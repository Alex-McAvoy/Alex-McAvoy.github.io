{"meta":{"title":"Alex_McAvoy","subtitle":"想要成为渔夫的猎手","description":"想要成为渔夫的猎手","author":"Alex_McAvoy","url":"https://alex-mcavoy.github.io","root":"/"},"pages":[{"title":"links","date":"2019-09-01T03:40:49.000Z","updated":"2021-08-19T12:07:46.115Z","comments":false,"path":"links/index.html","permalink":"https://alex-mcavoy.github.io/links/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-08-30T06:28:04.000Z","updated":"2021-08-19T12:05:14.257Z","comments":false,"path":"categories/index.html","permalink":"https://alex-mcavoy.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-27T07:54:18.000Z","updated":"2021-08-23T12:31:20.695Z","comments":false,"path":"tags/index.html","permalink":"https://alex-mcavoy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NVIDIA CUDA2023春训营（九）CUDA 原子操作","slug":"cuda-spring-bootcamp/09.NVIDIA CUDA2023春训营（九）CUDA 原子操作","date":"2023-02-07T13:02:47.000Z","updated":"2023-02-09T06:40:13.745Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/7acd409c.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/7acd409c.html","excerpt":"原子操作CUDA 编程的基本思想利用 GPU 来尽可能地并行执行相同的核函数，对于大多数并行任务，线程间不需要合作或使用其他线程的资源，只需要保证自己能够正常执行即可 但对于某些需要同步执行的操作，例如多个核函数需要对同一个变量进行读取-修改-写入，由于核函数之间是异步的，当试图同时执行时，就会导致出现问题","text":"原子操作CUDA 编程的基本思想利用 GPU 来尽可能地并行执行相同的核函数，对于大多数并行任务，线程间不需要合作或使用其他线程的资源，只需要保证自己能够正常执行即可 但对于某些需要同步执行的操作，例如多个核函数需要对同一个变量进行读取-修改-写入，由于核函数之间是异步的，当试图同时执行时，就会导致出现问题 CUDA 的原子操作是针对全局内存或共享内存中的变量，其是对全局变量或共享变量进行读取-修改-写入这三个操作的一个最小单位的执行过程，在这个执行过程中，不允许其他并行线程对该变量进行读取和写入 也就是说，原子操作实现了多个线程间共享的变量的互斥保护，每次只能有一个线程对全局变量或共享变量进行读写操作，能够确保任何一次对变量的操作的结果的正确性 常用函数原子操作的常用函数如下 12345678910111213141516171819202122// 加法：value = value + numatomicAdd(&amp;value, num);// 减法：value = value - numatomicSub(&amp;value, num);// 赋值：value = numatomicExch(&amp;value, num);// 求最大值：value = max(value, num)atomicMax(&amp;value, num);// 求最小值：value = min(value, num)atomicMin(&amp;value, num);// 向上计数：value = value &lt;= num ? value + 1 : 0atomicInc(&amp;value, num);// 向下计数：value = value &gt; num || value == 0 ? value - 1 : 0atomicDec(&amp;value, num);// 比较并交换：value = value == compare ? val : valueatomicCAS(&amp;value, compare, val);// 与运算：value = value &amp; numatomicAnd(&amp;value, compare, val);// 或运算：value = value | numatomicOr(&amp;value, compare, val);// 异或运算：value = value ^ numatomicXor(&amp;value, compare, val); 实例下面代码给出使用原子操作求和的实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#define N 10#define BLOCKS 32#define BLOCK_SIZE 256__global__ void sum_gpu(int *data, int *res) &#123; int index = blockDim.x * blockIdx.x + threadIdx.x; if (index &lt; N) &#123; atomicAdd(res, data[index]); &#125;&#125;int sum_cpu(int *data) &#123; int sum = 0; for (int i = 0; i &lt; N; i++) &#123; sum += data[i]; &#125; return sum;&#125;void check(int res_cpu, int res_gpu) &#123; printf(\"CPU 计算结果：%d\\n\", res_cpu); printf(\"GPU 计算结果：%d\\n\", res_gpu); printf(\"%s\\n\", res_cpu == res_gpu ? \"Pass\" : \"Error\");&#125;int main() &#123; // 申请统一内存 int *data, *res; cudaMallocManaged(&amp;data, sizeof(int) * N); cudaMallocManaged(&amp;res, sizeof(int)); // 初始化 res[0] = 0; for (int i = 0; i &lt; N; i++) &#123; data[i] = rand() % 10; &#125; // cpu计算 int res_cpu = sum_cpu(data); // gpu计算 sum_gpu&lt;&lt;&lt;BLOCKS, BLOCK_SIZE&gt;&gt;&gt;(data, res); cudaDeviceSynchronize(); int res_gpu = res[0]; // 检查结果 check(res_cpu, res_gpu); // 释放统一内存 cudaFree(data); cudaFree(res); return 0;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（八）CUDA 事件","slug":"cuda-spring-bootcamp/08.NVIDIA CUDA2023春训营（八）CUDA 事件","date":"2023-02-07T11:15:00.000Z","updated":"2023-02-07T12:59:34.450Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/196d4211.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/196d4211.html","excerpt":"Reference 【CUDA 基础】6.1 流和事件概述 CUDA 事件CUDA 事件（CUDA Event）是 CUDA 流中应用程序跟踪进度的一个方式，其本质是流执行过程中的一个标记，可以检查正在执行的流的操作是否到达该点","text":"Reference 【CUDA 基础】6.1 流和事件概述 CUDA 事件CUDA 事件（CUDA Event）是 CUDA 流中应用程序跟踪进度的一个方式，其本质是流执行过程中的一个标记，可以检查正在执行的流的操作是否到达该点 可以将事件当成一个操作插入到流的众多操作中，当执行到该操作时，所做的工作就是设置 host 端的一个 flag 来标记是否完成 事件通常执行以下两个基本事务： 同步流执行 监控设备的进展 举例来说，可使用 CUDA 事件来对算法计时，在算法开始前设置一个事件，在算法结束后设置一个事件，两个事件的时间差即为算法执行时间 事件的资源分配与回收CUDA 中封装了 CUDA 事件类型 cudaEvent_t，使用如下代码可声明一个事件 1cudaEvent_t event; 在声明一个事件后，该事件无法使用，需要使用 cudaEventCreate() 来为其分配资源，在使用完毕后，使用 cudaEventDestroy() 回收资源 12__host__ cudaError_t cudaEventCreate(cudaEvent_t* event)__host__ __device__ cudaError_t cudaEventDestroy(cudaEvent_t event) 需要注意的是，与 CUDA 流的资源释放相似，如果进行事件资源回收时，相关操作未完成，则在操作完成后会立刻释放资源 事件时间间隔cudaEventRecord() 用于将事件添加到流中，当不指定非空流时，默认添加进空流，函数原型如下： 1__host__ __device__ cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0) cudaEventElapsedTime() 用于记录两个事件间的时间间隔，单位为毫秒，函数原型如下： 1__host__ cudaError_t cudaEventElapsedTime(float* ms, cudaEvent_t start, cudaEvent_t end) 两个事件 start 和 stop 不必关联到同一个流上，但需要注意的是，由于 cudaEventRecord() 是异步发生的，如果二者任一关联到非空流上，是无法保证度量出的时间间隔恰好是这两个事件的时间间隔，得到的时间间隔可能比期望的要大 如果只是想要查看 GPU 工作的时间间隔，将 start 和 stop 事件都默认添加进空流即可 事件的同步函数在流中的事件主要是等待前面的操作完成后触发，与流同步函数类似，事件也具有阻塞和非阻塞两种同步函数 12__host__ cudaError_t cudaEventSynchronize(cudaEvent_t event);__host__ cudaError_t cudaEventQuery(cudaEvent_t event); cudaEventSynchronize() 会强制 host 端阻塞等待，直到事件前的所有操作执行完成；cudaStreamQuery() 会检查事件前的操作是否全部完成，不会阻塞 host 端，如果事件前的所有操作都执行完成，那么会返回 cudaSuccess，否则返回 cudaErrorNotReady 实例下述代码给出了记录事件时间间隔的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 5#define PI acos(-1.0)__global__ void kernel(double *x, int n) &#123; int index = threadIdx.x + blockIdx.x * blockDim.x; int stride = blockDim.x * gridDim.x; for (int i = index; i &lt; n; i += stride) &#123; x[i] = pow(PI,i); &#125;&#125;int main() &#123; // 声明事件 cudaEvent_t start, stop; // 分配事件资源 cudaEventCreate(&amp;start); cudaEventCreate(&amp;stop); // 申请host锁定内存 double *h_data; cudaMallocHost(&amp;h_data, sizeof(double) * N); // 申请device内存 double *d_data; cudaMalloc(&amp;d_data, sizeof(double) * N); // 将start事件插入空流 cudaEventRecord(start); // 执行核函数 kernel&lt;&lt;&lt;1, 64&gt;&gt;&gt;(d_data, N); // 将stop事件插入空流 cudaEventRecord(stop); // 阻塞host端直到事件完成 cudaEventSynchronize(stop); // device数据传输到host cudaMemcpy(h_data, d_data, sizeof(double) * N, cudaMemcpyDeviceToHost); // 计算事件时间间隔 float time; cudaEventElapsedTime(&amp;time, start, stop); for (int i = 0; i &lt; N; i++) &#123; printf(\"%lf \", h_data[i]); &#125; printf(\"\\nGPU执行时间:%g ms\\n\", time); // 回收事件资源 cudaEventDestroy(start); cudaEventDestroy(stop); // 释放host锁定内存 cudaFreeHost(h_data); // 释放device显存 cudaFree(d_data); return 0;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（七）CUDA 流","slug":"cuda-spring-bootcamp/07.NVIDIA CUDA2023春训营（七）CUDA 流","date":"2023-02-07T08:16:20.000Z","updated":"2023-02-09T02:56:31.321Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/903cd804.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/903cd804.html","excerpt":"Reference 【CUDA 基础】6.1 流和事件概述 CUDA —— Stream and Event CUDA 7 Stream流简化并发性 2.7.CUDA流 CUDA 官方文档 计算与传输重叠CPU 与 GPU 间交互时涉及两个引擎：内存复制引擎和核函数执行引擎，内存复制引擎负责 CPU 与 GPU 间的数据传输，核函数执行引擎负责 CPU 向 GPU 部署核函数任务","text":"Reference 【CUDA 基础】6.1 流和事件概述 CUDA —— Stream and Event CUDA 7 Stream流简化并发性 2.7.CUDA流 CUDA 官方文档 计算与传输重叠CPU 与 GPU 间交互时涉及两个引擎：内存复制引擎和核函数执行引擎，内存复制引擎负责 CPU 与 GPU 间的数据传输，核函数执行引擎负责 CPU 向 GPU 部署核函数任务 这两个引擎可以理解为两个独立的并发任务队列，CPU 将任务添加到不同的队列中，GPU 驱动程序负责执行队列中的任务 由于这两个队列是相互独立且并发的，因此在 GPU 执行核函数时，可以同时进行 CPU 与 GPU 之间的数据传输，即计算与传输重叠（Overlap） 使用 cudaGetDeviceProperties() 函数可以查看 GPU 的设备信息，包括 CUDA 版本号、内存大小、最大线程数目等，通过其中的 deviceOverlap 属性可以判断该 GPU 是否支持计算与传输重叠 123456789cudaDeviceProp prop;int whichDevice;cudaGetDevice(&amp;whichDevice);cudaGetDeviceProperties(&amp;prop, whichDevice);if (prop.deviceOverlap) &#123; printf(\"GPU 支持计算与传输重叠，可以使用流进行加速\\n\");&#125; else &#123; printf(\"GPU 不支持计算与传输重叠, 无法使用流进行加速\\n\" );&#125; CUDA 流在程序中实现计算与重叠功能，需要使用 CUDA 流（CUDA Stream），其可以理解为一系列异步 GPU 操作，这些操作的执行顺序是按照 host 端代码中的顺序在 GPU 上执行的 流能封装一系列的异步操作，且保持这些操作在流中排队，使得在前面所有操作启动之后再启动后续的操作 一个流中的不同操作有着严格的顺序，但不同流之间没有任何限制，多个流同时启动多个内核，就形成了网格级别的并行 如图所示，灰色部分代表进行内存复制，蓝色部分代表执行核函数，当流 stream0 执行核函数时，流 stream1 能够进行内存复制，当流 stream1 执行核函数时，流 stream 0 和流 stream2 能够进行内存复制，这就将内存复制的执行时间尽可能的压缩，从而提高了程序执行效率 流的类型CUDA 流可分为以下两种： 空流：隐式声明的流，即默认流 非空流：显式声明的流 如果没有声明一个流，那么所有 CUDA 操作都是在默认的空流中完成的，例如分配 device 端显存、host 端向 device 端传递数据、启动核函数等 但空流由于是隐式声明的，没有默认名，无法进行管理，因此若想控制流，就需要使用非空流 需要注意的是，在同一个流内不能实现计算与传输重叠，这是因为在同一个流中的计算需要的数据一般都是依赖于传输的数据，如果传输没有完成就开始计算，那么计算访问的数据就是错误的，所以 CUDA 中只能重叠不同流中的传输与计算 也就是说，如果没有显式声明非空流只使用空流的话，那么是无法实现计算与传输重叠的 流的使用基本思路利用流实现计算与传输重叠的基本思路为： 利用 cudaStreamCreate() 函数创建多个流 在每个流上利用 cudaMemcpyAsync() 函数将 host 端数据异步传输到 device 端中 在每个流上执行核函数 在每个流上利用 cudaMemcpyAsync() 函数将 device 端数据异步传输到 host 端中 利用 cudaStreamSynchronize() 流同步函数对多个流进行同步 利用 cudaStreamDestroy() 销毁创建的流 流的创建CUDA 中封装了非空流类型 cudaStream_t，使用如下代码可以声明一个流 1cudaStream_t stream; 在声明一个流后，这个流是无法使用的，需要使用 cudaStreamCreate() 来为其分配资源，函数原型如下： 1__host__ cudaError_t cudaStreamCreate(cudaStream_t* pStream) 在非空流中需要启动核函数时，可在 &lt;&lt;&lt;grid, block&gt;&gt;&gt; 中附加的非空流的启动设置 1kernel_fun&lt;&lt;&lt;grid, block, sharedMemSize, stream&gt;&gt;&gt;(...); 需要注意的是，host 端虚拟内存中分配的数据在物理内存中是随时可能被移动的，那么在执行异步数据传输时，必须要保证 host 端的内存是固定的，在整个生存周期中位置不变，否则如果操作系统移动了数据的物理地址，那么 device 可能会回到之前的物理地址取数据，导致出现未定义的错误 这就要求在 host 端分配内存时需要使用 cudaMallocHost() 来分配锁定内存 流的资源传递CUDA 中使用 cudaMemcpyAsync() 函数将流的资源内存异步的复制到目标内存中，前三个参数与 cudaMemcpy() 函数类似，第四个参数指定在哪个流中进行资源传递 1__host__ __device__ cudaError_t cudaMemcpyAsync(void* dst, const void* src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0) 流的同步由于 CUDA 流的执行是异步的，那么就需要同步函数在必要的时候执行同步操作 12__host__ cudaError_t cudaStreamSynchronize(cudaStream_t stream);__host__ cudaError_t cudaStreamQuery(cudaStream_t stream); cudaStreamSynchronize() 会强制 host 端阻塞等待，直到流中所有操作执行完成；cudaStreamQuery() 会检查流中的操作是否全部完成，不会阻塞 host 端，如果流中所有操作都执行完成，那么会返回 cudaSuccess，否则返回 cudaErrorNotReady 流的销毁cudaStreamDestroy() 用于回收非空流的资源，函数原型如下： 1__host__ __device__ cudaError_t cudaStreamDestroy(cudaStream_t stream) 由于流和主机端是异步的，在使用 cudaStreamDestroy() 回收非空流的资源的时，很有可能流还在执行，这时候，该函数会正常执行，但不会立刻停止流，而是等待流执行完成后，立刻回收该流中的资源 流同步同步流与异步流流分成阻塞流和非阻塞流，在非空流中所有操作都是非阻塞的，所以流启动以后，host 端还要完成自己的任务，这时就需要在某些时刻去同步 host 端与 device 端流之间的进度，或者同步流和流之间的进度 对于流的两种类型来说，有： 空流：同步流，其中部分操作会造成阻塞，令 host 端等待操作完成 非空流：异步流，通常不会阻塞 host 端 阻塞流与非阻塞流虽然非空流都是异步操作，不存在阻塞 host 端的情况，但有时可能会被空流中的操作阻塞，因此对于非空流，有： 阻塞流：当一个非空流被声明为阻塞流，会被空流阻塞 非阻塞流：当一个非空流被声明为非阻塞流时，对空流的阻塞行为失效 空流不需要任何显式声明，因此其是阻塞的，跟所有阻塞流同步，而使用 cudaStreamCreate() 创建流时，创建出来的流是阻塞流 使用 cudaStreamCreateWithFlags() 可以显式的创建阻塞流或非阻塞流，函数原型如下： 1__host__ __device__ cudaError_t cudaStreamCreateWithFlags(cudaStream_t* pStream, unsigned int flags) 其中，第二个参数就是选择要创建的流是阻塞的还是非阻塞的 1234// 默认为阻塞流flags = cudaStreamDefault// 非阻塞流，对空流的阻塞行为失效flags = cudaStreamNonBlocking 实例下述代码给出了多个非空流中调度 CUDA 操作的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define N 5#define STREAM_N 5#define PI acos(-1.0)__global__ void kernel(double *x, int n) &#123; int index = threadIdx.x + blockIdx.x * blockDim.x; int stride = blockDim.x * gridDim.x; for (int i = index; i &lt; n; i += stride) &#123; x[i] = pow(PI,i); &#125;&#125;int main() &#123; cudaDeviceProp prop; int whichDevice; cudaGetDevice(&amp;whichDevice); cudaGetDeviceProperties(&amp;prop, whichDevice); if (prop.deviceOverlap) &#123; printf(\"GPU 支持计算与传输重叠，可以使用流进行加速\\n\"); &#125; else &#123; printf(\"GPU 不支持计算与传输重叠, 无法使用流进行加速\\n\" ); &#125; // 声明非空流 cudaStream_t streams[STREAM_N]; double *h_data[STREAM_N]; double *d_data[STREAM_N]; for (int i = 0; i &lt; STREAM_N; i++) &#123; // 为非空流分配资源 cudaStreamCreate(&amp;streams[i]); // 申请host锁定内存 cudaMallocHost(&amp;h_data[i], sizeof(double) * N); // 申请device内存 cudaMalloc(&amp;d_data[i], sizeof(double) * N); &#125; for (int i = 0; i &lt; STREAM_N; i++) &#123; cudaMemcpyAsync(d_data[i], h_data[i], sizeof(double) * N, cudaMemcpyHostToDevice, streams[i]); kernel&lt;&lt;&lt;1, 64, 0, streams[i]&gt;&gt;&gt;(d_data[i], N); cudaMemcpyAsync(h_data[i], d_data[i], sizeof(double) * N, cudaMemcpyDeviceToHost, streams[i]); &#125; // 流同步函数 for (int i = 0; i &lt; STREAM_N; i++) &#123; cudaStreamSynchronize(streams[i]); &#125; for (int i = 0; i &lt; STREAM_N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; printf(\"%lf \", h_data[i][j]); &#125; printf(\"\\n\"); &#125; for (int i = 0; i &lt; STREAM_N; i++) &#123; // 释放host锁定内存 cudaFreeHost(h_data[i]); // 释放device显存 cudaFree(d_data[i]); &#125; return 0;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（六）CUDA 错误检测","slug":"cuda-spring-bootcamp/06.NVIDIA CUDA2023春训营（六）CUDA 错误检测","date":"2023-02-07T06:45:02.000Z","updated":"2023-02-07T13:47:36.861Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/5a90deb2.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/5a90deb2.html","excerpt":"Reference CUDA 官方文档 cudaGetErrorName和cudaGetErrorString的区别 【CUDA教程】四、异常处理与编程技巧 cudaGetErrorString与cudaGetLastError组合运用 错误类型CUDA 的 Runtime API 都带有 cudaError_t 类型的返回值，其是一个封装了各错误码的枚举类，常见的取值如下：","text":"Reference CUDA 官方文档 cudaGetErrorName和cudaGetErrorString的区别 【CUDA教程】四、异常处理与编程技巧 cudaGetErrorString与cudaGetLastError组合运用 错误类型CUDA 的 Runtime API 都带有 cudaError_t 类型的返回值，其是一个封装了各错误码的枚举类，常见的取值如下： cudaSuccess：函数执行成功，没有错误 cudaErrorInvalidValue：传递给 API 调用的一个或多个参数不在可接受的范围内 cudaErrorMemoryAllocation：无法分配足够的内存来执行请求的操作 cudaErrorInitializationError：无法初始化 CUDA 驱动程序 cudaErrorCudartUnloading：无法检测到 CUDA 驱动 更多的取值信息详见 CUDA 官方文档 错误检测CUDA 提供了相应的错误信息函数，常用的有以下两个： cudaGetErrorName(cudaError_t error)：返回错误代码 error 对应的错误类型名 cudaGetErrorString(cudaError_t error)：返回错误代码 error 对应的具体信息 在 CUDA 运行时，每个线程都会维护一个初始值为 cudaSuccess 的错误变量，并在每次发生错误时被错误代码覆盖，使用如下两个函数可以检测出现错误时的错误代码： cudaGetLastError()：返回维护的错误变量值 cudaPeekAtLastError()：返回维护的错误变量值并将其重置为 cudaSuccess 利用上述的函数，即可组合使用来检测 runtime API 是否运行成功，例如： 12cudaMalloc(...)printf(\"cudaMalloc function : %s\\n\",cudaGetErrorString(cudaGetLastError())); 封装实例下面给出一个将 cudaGetErrorString() 封装成 error.cuh 中的一个宏的实例 12345678910111213141516#pragma once#include &lt;stdio.h&gt;#define CHECK(call) \\do &#123; \\ const cudaError_t error_code = call; \\ if (error_code != cudaSuccess) &#123; \\ printf(\"CUDA Error:\\n\"); \\ printf(\" File: %s\\n\", __FILE__); \\ printf(\" Line: %d\\n\", __LINE__); \\ printf(\" Error code: %d\\n\", error_code); \\ printf(\" Error text: %s\\n\", \\ cudaGetErrorString(error_code)); \\ exit(1); \\ &#125; \\&#125; while (0) 那么就可以在代码中这么使用： 1234567#include \"error.cuh\"int main() &#123; int *a; CHECK(cudaMallocHost((void **) &amp;a, sizeof(int)*100)); return 0;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（五）CUDA 向量加法与矩阵乘法","slug":"cuda-spring-bootcamp/05.NVIDIA CUDA2023春训营（五）CUDA 向量加法与矩阵乘法","date":"2023-02-07T01:13:13.000Z","updated":"2023-02-08T13:51:05.395Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/84df80c7.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/84df80c7.html","excerpt":"1D Grid, 1D Block 向量加法普通实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define N 100const double EPS = 1E-6;void __global__ add(const double *x, const double *y, double *z, int n) &#123; // 获取全局索引 const int index = blockDim.x * blockIdx.x + threadIdx.x; // 步长 int stride = blockDim.x * gridDim.x; for (int i = index; i &lt; n; i += stride) &#123; z[i] = x[i] + y[i]; &#125;&#125;// 误差检测void check(const double *z, const int n) &#123; bool error = false; double maxError = 0; for (int i = 0; i &lt; n; i++) &#123; maxError = fmax(maxError, fabs(z[i]-70)); if (fabs(z[i] - 70) &gt; EPS) &#123; error = true; &#125; &#125; printf(\"%s\\n\", error ? \"Errors\" : \"Pass\"); printf(\"最大误差: %lf\\n\", maxError);&#125;int main() &#123; const int arraySize = sizeof(double) * N; // 申请host锁定内存 double *h_x, *h_y, *h_z; cudaMallocHost(&amp;h_x, arraySize); cudaMallocHost(&amp;h_y, arraySize); cudaMallocHost(&amp;h_z, arraySize); // 初始化数据 for (int i = 0; i &lt; N; i++) &#123; h_x[i] = 50; h_y[i] = 20; &#125; // 申请device显存 double *d_x, *d_y, *d_z; cudaMalloc((void **)&amp;d_x, arraySize); cudaMalloc((void **)&amp;d_y, arraySize); cudaMalloc((void **)&amp;d_z, arraySize); // host数据传输到device cudaMemcpy(d_x, h_x, arraySize, cudaMemcpyHostToDevice); cudaMemcpy(d_y, h_y, arraySize, cudaMemcpyHostToDevice); // 核函数执行配置 dim3 blockSize(128); dim3 gridSize((N + blockSize.x - 1) / blockSize.x); // 执行核函数 add&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(d_x, d_y, d_z, N); // 将device得到的结果传输到host cudaMemcpy(h_z, d_z, arraySize, cudaMemcpyDeviceToHost); // 检查执行结果 check(h_z, N); // 释放host锁定内存 cudaFreeHost(h_x); cudaFreeHost(h_y); cudaFreeHost(h_z); // 释放device显存 cudaFree(d_x); cudaFree(d_y); cudaFree(d_z); return 0;&#125;","text":"1D Grid, 1D Block 向量加法普通实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define N 100const double EPS = 1E-6;void __global__ add(const double *x, const double *y, double *z, int n) &#123; // 获取全局索引 const int index = blockDim.x * blockIdx.x + threadIdx.x; // 步长 int stride = blockDim.x * gridDim.x; for (int i = index; i &lt; n; i += stride) &#123; z[i] = x[i] + y[i]; &#125;&#125;// 误差检测void check(const double *z, const int n) &#123; bool error = false; double maxError = 0; for (int i = 0; i &lt; n; i++) &#123; maxError = fmax(maxError, fabs(z[i]-70)); if (fabs(z[i] - 70) &gt; EPS) &#123; error = true; &#125; &#125; printf(\"%s\\n\", error ? \"Errors\" : \"Pass\"); printf(\"最大误差: %lf\\n\", maxError);&#125;int main() &#123; const int arraySize = sizeof(double) * N; // 申请host锁定内存 double *h_x, *h_y, *h_z; cudaMallocHost(&amp;h_x, arraySize); cudaMallocHost(&amp;h_y, arraySize); cudaMallocHost(&amp;h_z, arraySize); // 初始化数据 for (int i = 0; i &lt; N; i++) &#123; h_x[i] = 50; h_y[i] = 20; &#125; // 申请device显存 double *d_x, *d_y, *d_z; cudaMalloc((void **)&amp;d_x, arraySize); cudaMalloc((void **)&amp;d_y, arraySize); cudaMalloc((void **)&amp;d_z, arraySize); // host数据传输到device cudaMemcpy(d_x, h_x, arraySize, cudaMemcpyHostToDevice); cudaMemcpy(d_y, h_y, arraySize, cudaMemcpyHostToDevice); // 核函数执行配置 dim3 blockSize(128); dim3 gridSize((N + blockSize.x - 1) / blockSize.x); // 执行核函数 add&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(d_x, d_y, d_z, N); // 将device得到的结果传输到host cudaMemcpy(h_z, d_z, arraySize, cudaMemcpyDeviceToHost); // 检查执行结果 check(h_z, N); // 释放host锁定内存 cudaFreeHost(h_x); cudaFreeHost(h_y); cudaFreeHost(h_z); // 释放device显存 cudaFree(d_x); cudaFree(d_y); cudaFree(d_z); return 0;&#125; 统一内存实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define N 100const double EPS = 1E-6;__global__ void add(const double *x, const double *y, double *z, int n) &#123; // 获取全局索引 const int index = blockDim.x * blockIdx.x + threadIdx.x; // 步长 int stride = blockDim.x * gridDim.x; for (int i = index; i &lt; n; i += stride) &#123; z[i] = x[i] + y[i]; &#125;&#125;void check(const double *z, const int n) &#123; bool error = false; double maxError = 0; // 误差检测 for (int i = 0; i &lt; n; i++) &#123; maxError = fmax(maxError, fabs(z[i]-70)); if (fabs(z[i] - 70) &gt; EPS) &#123; error = true; &#125; &#125; printf(\"%s\\n\", error ? \"Errors\" : \"Pass\"); printf(\"最大误差: %lf\\n\", maxError);&#125;int main() &#123; // 申请统一内存 const int arraySize = sizeof(double) * N; double *x, *y, *z; cudaMallocManaged((void**)&amp;x, arraySize); cudaMallocManaged((void**)&amp;y, arraySize); cudaMallocManaged((void**)&amp;z, arraySize); // 初始化数据 for (int i = 0; i &lt; N; i++) &#123; x[i] = 50; y[i] = 20; &#125; // 核函数执行配置 dim3 blockSize(128); dim3 gridSize((N + blockSize.x - 1) / blockSize.x); // 执行核函数 add&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(x, y, z, N); // 同步函数 cudaDeviceSynchronize(); // 检查执行结果 check(z, N); // 释放统一内存 cudaFree(x); cudaFree(y); cudaFree(z); return 0;&#125; 2D Grid, 2D Block 矩阵乘法普通实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define BLOCK_SIZE 16const double EPS = 1E-6;// GPU 矩阵乘法__global__ void gpu_matrix_mult(int *a,int *b, int *c, int m, int n, int k) &#123; // 当前线程在所有线程中的索引坐标，即结果矩阵中的行与列 int row = blockIdx.y * blockDim.y + threadIdx.y; int col = blockIdx.x * blockDim.x + threadIdx.x; int sum = 0; if (row &lt; m &amp;&amp; col &lt; k) &#123; for(int i = 0; i &lt; n; i++) &#123; sum += a[row * n + i] * b[i * k + col]; &#125; c[row * k + col] = sum; &#125;&#125; // CPU 矩阵乘法void cpu_matrix_mult(int *h_a, int *h_b, int *h_result, int m, int n, int k) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int sum = 0; for (int h = 0; h &lt; n; h++) &#123; sum += h_a[i * n + h] * h_b[h * k + j]; &#125; h_result[i * k + j] = sum; &#125; &#125;&#125;// 检查执行结果void check(int *h_c_cpu, int *h_c_gpu, int m, int k) &#123; int error = false; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; if(fabs(h_c_gpu[i * k + j] - h_c_cpu[i * k + j]) &gt; EPS) &#123; error = true; &#125; &#125; &#125; printf(\"检查结果：%s\\n\", error ? \"Errors\" : \"Pass\");&#125;int main() &#123; int m = 5; int n = 5; int k = 5; // 申请统一内存 int *a, *b, *c_gpu, *c_cpu; cudaMallocManaged((void **) &amp;a, sizeof(int) * m * n); cudaMallocManaged((void **) &amp;b, sizeof(int) * n * k); cudaMallocManaged((void **) &amp;c_gpu, sizeof(int) * m * k); cudaMallocManaged((void **) &amp;c_cpu, sizeof(int) * m * k); // 初始化数据 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; a[i * n + j] = rand() % 1024; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; b[i * k + j] = rand() % 1024; &#125; &#125; // 核函数执行配置 unsigned int grid_rows = (m + BLOCK_SIZE - 1) / BLOCK_SIZE; unsigned int grid_cols = (k + BLOCK_SIZE - 1) / BLOCK_SIZE; dim3 grid(grid_cols, grid_rows); dim3 block(BLOCK_SIZE, BLOCK_SIZE); // 执行核函数 gpu_matrix_mult&lt;&lt;&lt;grid, block&gt;&gt;&gt;(a, b, c_gpu, m, n, k); // 同步函数 cudaDeviceSynchronize(); // 输出GPU结果 printf(\"GPU执行结果：\\n\"); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; printf(\"%d \", c_gpu[i * k + j]); &#125; printf(\"\\n\"); &#125; // cpu矩阵乘积 cpu_matrix_mult(a, b, c_cpu, m, n, k); // 输出CPU结果 printf(\"CPU执行结果：\\n\"); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; printf(\"%d \", c_cpu[i * k + j]); &#125; printf(\"\\n\"); &#125; // 检查执行结果 check(c_cpu, c_gpu, m, k); // 释放统一内存 cudaFree(a); cudaFree(b); cudaFree(c_cpu); cudaFree(c_gpu); return 0;&#125; 共享内存优化实现在处理矩阵乘法时，假设矩阵 $M$ 为 $mn$ 维，矩阵 $N$ 为 $nk$ 维，得到的矩阵 $P$ 为 $m*k$ 维 举例来说，当需要读取矩阵 $M$ 中的一个数值 $M(\\text{row}, \\text{col})$ 时，就要被 grid 中所有满足 row = blockIdx.y * blockDim.y + threadIdx.y 的线程从全局内存中读取一次，总共要读取 $n$ 次 那么，对于这么多次的重复读取，可以将这个变量存放在共享内存中，从而减少每次的读取时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define BLOCK_SIZE 16const double EPS = 1E-6;// GPU 矩阵乘法，使用 shared memory__global__ void gpu_matrix_mult_shared(int *a,int *b, int *c, int m, int n, int k) &#123; // 当前线程在所有线程中的索引坐标，即结果矩阵中的行与列 int row = blockIdx.y * blockDim.y + threadIdx.y; int col = blockIdx.x * blockDim.x + threadIdx.x; // 申请共享内存，存于每个block中 __shared__ int s_a[BLOCK_SIZE][BLOCK_SIZE]; __shared__ int s_b[BLOCK_SIZE][BLOCK_SIZE]; int sum = 0; // 枚举所有的grid，sub * BLOCK_SIZE为第sub个grid前的所有grid中的所有block所占空间 for (int sub = 0; sub &lt; gridDim.x; sub++) &#123; /** index_a：该线程要读取的数据在矩阵a中的索引 * - sub * BLOCK_SIZE + threadIdx.x：该线程要读取的数据所在行 * - row*n：该线程所在行之前的所有数据 **/ int index_a = (sub * BLOCK_SIZE + threadIdx.x) + row * n; if (row &lt; m &amp;&amp; (sub * BLOCK_SIZE + threadIdx.x) &lt; n) &#123; s_a[threadIdx.y][threadIdx.x] = a[index_a]; &#125; else &#123; s_a[threadIdx.y][threadIdx.x] = 0; &#125; /** index_b：该线程要读取的数据在矩阵b中的索引 * - col：该线程要读取的数据所在行 * - n * (sub * BLOCK_SIZE + threadIdx.y)：该线程所在行之前的所有数据 **/ int index_b = col + n * (sub * BLOCK_SIZE + threadIdx.y); if (col &lt; n &amp;&amp; (sub * BLOCK_SIZE + threadIdx.y) &lt; k) &#123; s_b[threadIdx.y][threadIdx.x] = b[index_b]; &#125; else &#123; s_b[threadIdx.y][threadIdx.x] = 0; &#125; // 控制线程同步，保证共享变量中的元素都被加载 __syncthreads(); // 从共享空间中取元素计算 for (int i = 0; i &lt; BLOCK_SIZE; i++) &#123; sum += s_a[threadIdx.y][i] * s_b[i][threadIdx.x]; &#125; __syncthreads(); if (row &lt; m &amp;&amp; col &lt; k) &#123; c[row * k + col] = sum; &#125; &#125;&#125; // CPU 矩阵乘法void cpu_matrix_mult(int *a, int *b, int *c, int m, int n, int k) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int sum = 0; for (int h = 0; h &lt; n; h++) &#123; sum += a[i * n + h] * b[h * k + j]; &#125; c[i * k + j] = sum; &#125; &#125;&#125;// 检查执行结果void check(int *c_cpu, int *c_gpu, int m, int k) &#123; int error = false; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; if(fabs(c_gpu[i * k + j] - c_cpu[i * k + j]) &gt; EPS) &#123; error = true; &#125; &#125; &#125; printf(\"检查结果：%s\\n\", error ? \"Errors\" : \"Pass\");&#125;int main() &#123; int m = 5; int n = 5; int k = 5; // 申请统一内存 int *a, *b, *c_gpu, *c_cpu; cudaMallocManaged((void **) &amp;a, sizeof(int) * m * n); cudaMallocManaged((void **) &amp;b, sizeof(int) * n * k); cudaMallocManaged((void **) &amp;c_gpu, sizeof(int) * m * k); cudaMallocManaged((void **) &amp;c_cpu, sizeof(int) * m * k); // 初始化数据 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; a[i * n + j] = rand() % 1024; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; b[i * k + j] = rand() % 1024; &#125; &#125; // 核函数执行配置 unsigned int grid_rows = (m + BLOCK_SIZE - 1) / BLOCK_SIZE; unsigned int grid_cols = (k + BLOCK_SIZE - 1) / BLOCK_SIZE; dim3 grid(grid_cols, grid_rows); dim3 block(BLOCK_SIZE, BLOCK_SIZE); // 执行核函数 gpu_matrix_mult_shared&lt;&lt;&lt;grid, block&gt;&gt;&gt;(a, b, c_gpu, m, n, k); // 同步函数 cudaDeviceSynchronize(); // 输出GPU结果 printf(\"GPU执行结果：\\n\"); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; printf(\"%d \", c_gpu[i * k + j]); &#125; printf(\"\\n\"); &#125; // cpu矩阵乘积 cpu_matrix_mult(a, b, c_cpu, m, n, k); // 输出CPU结果 printf(\"CPU执行结果：\\n\"); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; printf(\"%d \", c_cpu[i * k + j]); &#125; printf(\"\\n\"); &#125; // 检查执行结果 check(c_cpu, c_gpu, m, k); // 释放统一内存 cudaFree(a); cudaFree(b); cudaFree(c_cpu); cudaFree(c_gpu); return 0;&#125; 2D Grid，2D Block 方阵转置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define N 10#define BLOCK_SIZE 16const double EPS = 1E-6;// N*M矩阵a转置为M*N矩阵b__global__ void transposition(int *a, int *b) &#123; // 索引 int x = blockIdx.x * blockDim.x + threadIdx.x; int y = blockIdx.y * blockDim.y + threadIdx.y; if (x &lt; N &amp;&amp; y &lt; N) &#123; b[N * x + y] = a[N * y + x]; &#125;&#125;// N*M矩阵a转置为M*N矩阵b，共享内存实现__global__ void transposition_shared(int *a, int *b) &#123; // 共享变量 __shared__ int s[BLOCK_SIZE][BLOCK_SIZE]; // N*M矩阵a索引 int a_x = blockIdx.x * BLOCK_SIZE + threadIdx.x; int a_y = blockIdx.y * BLOCK_SIZE + threadIdx.y; if (a_x &lt; N &amp;&amp; a_y &lt; N) &#123; s[threadIdx.y][threadIdx.x] = a[N * a_y + a_x]; &#125; __syncthreads(); // M*a矩阵b索引 int b_x = blockIdx.x * BLOCK_SIZE + threadIdx.y; int b_y = blockIdx.y * BLOCK_SIZE + threadIdx.x; if (b_x &lt; N &amp;&amp; b_y &lt; N) &#123; b[N * b_x + b_y] = s[threadIdx.x][threadIdx.y]; &#125;&#125;void check(int *a, int *b) &#123; int error = false; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if(fabs(a[i * N + j] - b[i * N + j]) &gt; EPS) &#123; error = true; &#125; &#125; &#125; printf(\"检查结果：%s\\n\", error ? \"Errors\" : \"Pass\");&#125;void print(int *arr) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; printf(\"%d \", arr[i * N + j]); &#125; printf(\"\\n\"); &#125;&#125;int main() &#123; // 申请统一内存 int *a, *b, *b_shared; cudaMallocManaged(&amp;a, sizeof(int) * N * N); cudaMallocManaged(&amp;b, sizeof(int) * N * N); cudaMallocManaged(&amp;b_shared, sizeof(int) * N * N); // 初始化N*M矩阵a for (int i = 0; i &lt; N ; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; a[i * N + j] = rand() % 1024; &#125; &#125; // 声明事件并分配资源 float time, time_shared; cudaEvent_t start, stop; cudaEvent_t start_shared, stop_shared; cudaEventCreate(&amp;start); cudaEventCreate(&amp;stop); cudaEventCreate(&amp;start_shared); cudaEventCreate(&amp;stop_shared); // 核函数执行配置 unsigned int gird_size = (N + BLOCK_SIZE - 1) / BLOCK_SIZE; dim3 grid(gird_size, gird_size); dim3 block(BLOCK_SIZE, BLOCK_SIZE); // 不使用共享内存实现矩阵转置 cudaEventRecord(start); transposition&lt;&lt;&lt;grid, block&gt;&gt;&gt;(a, b); cudaEventRecord(stop); cudaEventSynchronize(stop); cudaEventElapsedTime(&amp;time, start, stop); printf(\"不使用共享内存实现矩阵转置 GPU 执行时间:%g ms\\n\", time); // 使用共享内存实现矩阵转置 cudaEventRecord(start_shared); transposition_shared&lt;&lt;&lt;grid, block&gt;&gt;&gt;(a, b_shared); cudaEventRecord(stop_shared); cudaEventSynchronize(stop_shared); cudaEventElapsedTime(&amp;time_shared, start_shared, stop_shared); printf(\"使用共享内存实现矩阵转置 GPU 执行时间:%g ms\\n\", time_shared); // 打印结果 printf(\"原矩阵：\\n\"); print(a); printf(\"不使用共享内存转置矩阵：\\n\"); print(b); printf(\"使用共享内存转置矩阵：\\n\"); print(b_shared); check(b, b_shared); // 回收事件资源 cudaEventDestroy(start); cudaEventDestroy(stop); cudaEventDestroy(start_shared); cudaEventDestroy(stop_shared); // 释放统一内存 cudaFree(a); cudaFree(b); cudaFree(b_shared); return 0;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（四）CUDA 存储单元","slug":"cuda-spring-bootcamp/04.NVIDIA CUDA2023春训营（四）CUDA 存储单元","date":"2023-02-06T12:39:05.000Z","updated":"2023-02-09T06:59:39.562Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/f99d6734.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/f99d6734.html","excerpt":"Reference CUDA 官方文档 【CUDA教程】二、主存与显存 CUDA共享内存操作(shared关键字) 【CUDA】学习记录（7）- Global Memory cudaMemcpyToSymbol使用 Unified Memory Programming CUDA 存储单元架构CUDA 各存储单元架构如下","text":"Reference CUDA 官方文档 【CUDA教程】二、主存与显存 CUDA共享内存操作(shared关键字) 【CUDA】学习记录（7）- Global Memory cudaMemcpyToSymbol使用 Unified Memory Programming CUDA 存储单元架构CUDA 各存储单元架构如下 CUDA 各存储单元的对比如下 CUDA 函数关系与 device 端变量访问权限如下 主存主存（Host Memory）是 host 端的内存，其可分为可分页内存（Pageable Memory）和锁定内存（Page-Locked Memory / Pinned Memory） 两种 可分页内存由 malloc()、new() 等操作系统 API 在 host 端分配与释放的，该内存是可以换页的，即内存页可以被置换到磁盘中，普通的 C/C++ 程序使用的内存就是该内存 锁定内存是由 CUDA 函数 cudaMallocHost()、cudaFree() 分配与释放的，其一大特点是操作系统不会对这块内存进行分页与交换操作，能够确保该内存始终驻留在物理内存中，不会被分配到低速的虚拟内存 同时，由于 GPU 知道锁定内存的物理地址，因此可以通过 DMA（Direct Memory Acess）技术直接在 host 端和 device 端进行通信，速率更快 cudaMallocHost() 和 cudaFree() 的函数原型如下： 12__host__ cudaError_t cudaMallocHost(void **ptr, size_t size)__host__ cudaError_t cudaFreeHost(void *ptr) 关键在于 cudaMallocHost() 函数第一个参数的二维指针，如下例 123double *host_data = NULL;size_t size = sizeof(double) * 1024;cudaMallocHost((void**) &amp;host_data, size); host_data 是存储在 host 端上的指针变量，其要存储的值是内存地址，现在想要利用 cudaMallocHost() 在 host 端申请了一个大小为 1024 的 double 型一维数组 由于该函数的无法返回在 host 申请的首地址，那么就需要利用参数来传递这个地址，也就是存储在 host 端中 host_data 这个指针变量的地址 &amp;host_data 当 cudaMallocHost() 执行完后，会向 host_data 这个指针变量中写入一个地址值，这个地址值就是在 host 端所申请的数组首地址 寄存器与本地内存寄存器寄存器（Registers）是速度最快的存储单元，位于 GPU 的计算单元（Streaming Multiprocessor，SM）上，当核函数启动后，这些位于计算单元上的寄存器会被分配给指定的线程使用 在核函数中，没有特殊声明的自动变量与数组都是存放在寄存器里，这些变量是每个线程私有的，一旦线程执行结束，寄存器变量就会失效 本地内存本地内存（Local Memory）在硬件中没有特定的存储单元，其是从全局内存上虚拟出来的地址空间，因此针对它的访问速度与全局内存是相近的 本地内存是为寄存器无法满足存储需求的情况而设计的，其与寄存器相似，是线程私有的，当寄存器不够用时，就会使用本地内存来代替这部分存储空间 此外，当出现以下几种情况时，编译器会将变量放到内存空间 编译期间无法确定值的本地数组 消耗太多寄存器的较大的结构体或数组 超过寄存器限制的变量 全局内存全局内存全局内存（Global Memory）是 GPU 中空间最大、最基础的内存，任意 SM 都可以在整个程序的生命周期中获取其状态 某种意义上，常说的 GPU 显存就是指全局内存，其是核函数输入数据和写入结果的唯一来源 在 CUDA 中，使用 cudaMalloc() 和 cudaFree() 函数可以申请和释放 GPU 显存，函数原型如下： 12__host__ __device__ cudaError_t cudaMalloc(void **devPtr, size_t size)__host__ __device__ cudaError_t cudaFree(void *devPtr) 其使用方法与 cudaMallocHost() 和 cudaFreeHost() 类似，例如： 123double *device_data = NULL;size_t size = sizeof(double) * 1024;cudaMalloc((void**) &amp;device_data, size); 使用 cudaMemset() 可以对 device 端申请的显存进行初始化，其类似于 memset() 函数，函数原型如下： 1__host__ cudaError_t cudaMemset (void* devPtr, int value, size_t count) 需要注意的是，与 memset() 类似，其是以字节为单位来进行赋值的，需要使用十六进制来进行赋值，因此一般使用该函数将申请的空间置为全 0 或全 -1 资源传递对于 CUDA 程序，除了 host 端和 device 端的内存申请、释放，以及核函数在 device 端的执行外，另一关键的步骤就是数据在 host 端和 device 端上的传输 CUDA 使用 cudaMemcpy() 函数将资源内存复制到目标内存中，类似于 C 语言中的 memcpy()，函数原型如下： 1__host__ cudaError_t cudaMemcpy(void *dst, const void *src, size_t count, cudaMemcpyKind kind) 其输入参数有四个： *dst：指向用于存储复制内容的目标数组 *src：指向要复制内容的数据源 conut：要复制的数据大小，以 Byte 为单位 kind：复制的方向，从 host 端复制到 device 端为 cudaMemcpyHostToDevice，从 device 端复制到 host 端为 cudaMemcpyDeviceToHost 下述代码给出了一个使用 cudaMemcpy() 传输资源的实例 1234567891011// 申请大小const int size = sizeof(double) * 100;// 申请host内存double *h_x = (double*) malloc(size);// 申请device显存double *d_x;cudaMalloc((void **)&amp;d_x, size);// host到devicecudaMemcpy(d_x, h_x, size, cudaMemcpyHostToDevice);// device到hostcudaMemcpy(h_x, d_x, size, cudaMemcpyDeviceToHost); 需要注意的是，该函数是一个同步函数，在未完成数据转移操作前会锁死并一直占有 CPU 控制权，因此无需再添加 cudaDeviceSynchronize() 同步函数 全局变量使用 __device__ 修饰符可以定义 device 端的全局变量，其与 C/C++ 的全局变量声明位置相同，只能在类和函数外声明 在 host 端无法直接访问 __device__ 修饰的变量，只能通过 cudaMemcpyToSymbol() 和 cudaMemcpyFromSymbol() 函数来传递或获取变量值，函数原型如下： 12__host__ cudaError_t cudaMemcpyToSymbol(const void* symbol, const void* src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice)__host__ cudaError_t cudaMemcpyFromSymbol(void* dst, const void* symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost) 下述代码给出了一个使用全局变量的实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#define N 5// 声明device端全局变量__device__ int constant_a[N];// 输出全局变量核函数__global__ void print_constant() &#123; int index = blockDim.x * blockIdx.x + threadIdx.x; if (index &gt;= N) return; printf(\"%d \",constant_a[index]);&#125;// 修改全局变量核函数__global__ void update_constant() &#123; int index = blockDim.x * blockIdx.x + threadIdx.x; if (index &gt;= N) return; constant_a[index] = 1024;&#125;int main() &#123; int h_a[N] = &#123;0,1,2,3,4&#125;; // 修改device端全局变量 cudaMemcpyToSymbol(constant_a, h_a, sizeof(h_a)); printf(\"修改前的全局变量：\"); print_constant&lt;&lt;&lt;1, 16&gt;&gt;&gt;(); cudaDeviceSynchronize(); // 获取全局变量 update_constant&lt;&lt;&lt;1, 16&gt;&gt;&gt;(); cudaMemcpyFromSymbol(h_a, constant_a, sizeof(h_a)); printf(\"\\n修改后的全局变量：\"); for (int i = 0; i &lt; N; i++) &#123; printf(\"%d \", h_a[i]); &#125; printf(\"\\n\"); cudaDeviceSynchronize(); return 0;&#125; 固定内存固定内存固定内存（Constant Memory）类似于本地内存，没有特定的存储单元的，只是全局内存的虚拟地址 与本地内存不同的是，其范围是全局的，所有核函数均可见，同时其是只读的，因此一定程度上简化了缓存管理，硬件无需管理复杂的回写策略 常量固定内存中的变量使用 __constant__ 来修饰，即 device 端的常量 由于其是只读的，因此必须在 host 端使用 cudaMemcpyToSymbol() 函数来进行初始化赋初值，且一经赋值后就无法再更改 当想要在 host 端读取常量值时，需要使用 cudaMemcpyFromSymbol() 来获取其值 下述代码给出了一个使用全局常量的实例 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#define N 5// 声明device端常量__device__ int constant_a[N];// 输出常量核函数__global__ void print_constant() &#123; int index = blockDim.x * blockIdx.x + threadIdx.x; if (index &gt;= N) return; printf(\"%d \",constant_a[index]);&#125;int main() &#123; int h_a[N] = &#123;0,1,2,3,4&#125;; // 初始化device端常量 cudaMemcpyToSymbol(constant_a, h_a, sizeof(h_a)); printf(\"通过核函数读取常量：\"); print_constant&lt;&lt;&lt;16, 1&gt;&gt;&gt;(); cudaDeviceSynchronize(); // 获取全局变量 printf(\"\\n通过host端读取常量：\"); cudaMemcpyFromSymbol(h_a, constant_a, sizeof(h_a)); for (int i = 0; i &lt; N; i++) &#123; printf(\"%d \", h_a[i]); &#125; printf(\"\\n\"); cudaDeviceSynchronize(); return 0;&#125; 共享内存共享内存共享内存（Shared Memory）的访问延迟仅次于寄存器，其可以被一个 block 中的所有线程访问，从而实现 block 内线程间的低开销通信 若线程频繁对某个数据进行读写操作，可以设置将该数据常驻共享内存，从而提高代码运行效率 块内共享变量共享内存中的变量使用 __shared__ 来修饰，其能被一个 block 中的所有线程访问，因为被称为块内共享变量 共享变量只能在 __device__ 函数或者 __global__ 函数内被声明，不能跨过一个 block，因此，某个 block 中的共享变量是无法被其他 block 所访问到的 此外，由于共享内存中的数据可以被一个 block 中的所有线程访问，那么当多个线程对同一个共享变量进行操作时，需要对线程进行同步操作，从而避免竞争的发生，常使用 __syncthreads() 来控制线程同步 共享变量的一个典型应用是用来优化矩阵乘法，详见：NVIDIA CUDA2023春训营（五）CUDA 向量加法与矩阵乘法 纹理内存纹理内存（Texture Memory）实际上也是全局内存的一部分，从读取性能的角度来说，其与固定内存类似 但与固定内存不同的是，它有自己专属的只读 Cache，这个 Cache 在进行浮点运算时十分有用 纹理内存实质上是针对 2D 空间局部性的优化策略，要获取 2D 数据时，就可以使用纹理内存来获取 统一内存统一内存统一内存（Unifled Memory）是 CUDA 6.0 引入的，其避免了编写程序时在 host 和 device 上进行内存分配与数据传输的麻烦 统一内存定义了一个托管内存（Managed Memory）来共同管理 host 和 device 中的内存，使得 host 端和 device 端都可以看到共同的地址空间，无需再使用 cudaMemcpy() 函数进行资源传递 在使用统一内存时，分配空间是在 host 端和 device 端的全局内存上各自申请了一块空间，只是可以使用一个变量来共同维护 统一内存资源分配统一内存中的变量使用 __managed__ 来修饰，需要在类和函数外声明 此外，CUDA 中还可使用 cudaMallocManaged() 函数在 host 端上分配统一内存，但使用完毕后需要使用 cudaFree() 进行资源释放，函数原型如下： 1__host__ cudaError_t cudaMallocManaged(void **devPtr, size_t size, unsigned int flags = cudaMemAttachGlobal) 其第三个参数是一个标志，默认值为 cudaMemAttachGlobal，代表内存可由任何设备上的任何流访问 两种统一内存分配方式的分配行为相同，不同的是由于 cudaMallocManaged() 函数第三个参数的限制，使用 cudaMallocManaged() 函数分配的统一内存可能会受到 cudaStreamAttachMemAsync() 的限制 如下给出了一个使用统一内存的实例 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#define N 64// 第一种分配方式__managed__ int arr_managed1[N];__global__ void add1(int a, int b) &#123; arr_managed1[threadIdx.x] = a + b;&#125;__global__ void add2(int *arr, int a, int b) &#123; arr[threadIdx.x] = a + b;&#125;int main() &#123; printf(\"第一种分配方式运行核函数：\\n\"); add1&lt;&lt;&lt; 1, N&gt;&gt;&gt;(100, 100); cudaDeviceSynchronize(); for(int i = 0; i &lt; N; i++) printf(\"%d \", arr_managed1[i]); printf(\"\\n\"); // 第二种分配方式 int *arr_managed2; cudaMallocManaged(&amp;arr_managed2, sizeof(int) * N); printf(\"第二种分配方式运行核函数：\\n\"); add2&lt;&lt;&lt; 1, N&gt;&gt;&gt;(arr_managed2, 200, 100); cudaDeviceSynchronize(); for(int i = 0; i &lt; N; i++) printf(\"%d \", arr_managed2[i]); printf(\"\\n\"); // 释放第二种分配方式申请的统一内存资源 cudaFree(arr_managed2); return 0;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（三）CUDA 线程层次结构与线程索引","slug":"cuda-spring-bootcamp/03.NVIDIA CUDA2023春训营（三）CUDA 线程层次结构与线程索引","date":"2023-02-06T11:03:41.000Z","updated":"2023-02-08T12:01:46.280Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/acc1b378.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/acc1b378.html","excerpt":"Reference 我的CUDA学习之旅——启程 CUDA线程索引计算 线程层次结构核函数在 device 端执行时，会启动若干线程，一个核函数所启动的所有线程被称为一个线程网格（Thread Grid），同一个线程网格上的线程共享相同的全局内存空间，每个线程网格又可分为若干线程块（Thread Block），每个线程块中又包含若干线程","text":"Reference 我的CUDA学习之旅——启程 CUDA线程索引计算 线程层次结构核函数在 device 端执行时，会启动若干线程，一个核函数所启动的所有线程被称为一个线程网格（Thread Grid），同一个线程网格上的线程共享相同的全局内存空间，每个线程网格又可分为若干线程块（Thread Block），每个线程块中又包含若干线程 通过如下语句，可以定义一个 3*2 的 grid，每个 block 中含有 5*3 的 thread 的二维线程组织，其中 gird 和 block 是定义为 dim3 类型的变量，在定义时，缺省值初始化为 1，可以灵活的定义 1-dim、2-dim、3-dim 结构 123dim3 grid(3, 2, 1);dim3 block(5, 3, 1);kernel_function&lt;&lt;&lt;grid, block&gt;&gt;&gt;(prams...); 需要注意的是，每个 grid 中最多含有 65535 个 block，而每个 block 中最多含有 1024 个线程 相应的线程层次如下图所示 线程坐标在 CUDA 中，一个线程需要两个内置的坐标变量 (blockIdx，threadIdx) 来标识，它们都是 dim3 类型变量，其中 blockIdx 指明线程所在的 block 在 grid 中的位置，而 threaIdx 指明线程在 block 中的位置 blockIdx 与 threadIdx 可通过内置变量来获得： threadIdx.[x y z]：执行当前核函数的线程在 block 中的索引值 blockIdx.[x y z]：执行当前核函数的线程所在的 block 在 grid 中的索引值 例如，threadIdx.x 是执行当前核函数的线程在 block 中的 x 方向的序号，blockIdx.x 是执行当前核函数的线程所在 block 在 grid 中的 x 方向的序号 12345678910111213#include &lt;stdio.h&gt;__global__ void hello_from_gpu() &#123; const int bx = blockIdx.x; const int tx = threadIdx.x; printf(\"block: %d, thread: %d\\n\", bx, tx);&#125;int main() &#123; hello_from_gpu&lt;&lt;&lt;4, 4&gt;&gt;&gt;(); cudaDeviceSynchronize(); return 0;&#125; 线程唯一索引唯一索引计算公式一个线程块上的线程是放在同一个流式多处理器（SM）上的，但是单个 SM 的资源有限，这就使得 block 中的线程数是有限制的，现代 GPUs 的 block 可支持的线程数可达 1024 个，这就使得有时若想要知道一个线程在所有线程中的全局 ID，就必须要知道相应的组织结构，通过以下两个内置变量，可获得相应的组织结构信息 blockDim.[x y z]：一个 block 中包含多少个线程 gridDim.[x y z]：一个 grid 中包含多少个 block 对于线程唯一索引，需要知道以下三个信息： blockIndex：block 在整个 grid 中的索引（1 维到 3 维） blockSize ：block 的大小，描述其中含有多少个线程 threadId ：线程在 block 中的索引（1 维到 3 维） 进而有唯一索引计算公式：index = blockIndex * blockSize + threadIndex 1D Grid, 1D Block对于 1-dim 的 grid 与 1-dim 的 block，有： 12345678// block在整个一维grid中的索引int blockIndex = blockIdx.x;// 一维block的大小int blockSize = blockDim.x;// 线程在一维block中的索引int threadIndex = threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 1D Grid, 2D Block对于 1-dim 的 grid 与 2-dim 的 block，有： 12345678// block在整个一维grid中的索引int blockIndex = blockIdx.x;// 二维block的大小int blockSize = blockDim.x * blockDim.y;// 线程在二维block中的索引int threadIndex = blockDim.x * threadIdx.y + threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 1D Grid, 3D Block对于 1-dim 的 grid 与 3-dim 的 block，有： 12345678// block在整个一维grid中的索引int blockIndex = blockIdx.x;// 三维block的大小int blockSize = blockDim.x * blockDim.y * blockDim.z;// 线程在三维block中的索引int threadIndex = blockDim.x * blockDim.y * threadIdx.z + blockDim.x * threadIdx.y + threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 2D Grid, 1D Block对于 2-dim 的 grid 与 1-dim 的 block，有： 12345678// block在整个二维grid中的索引int blockIndex = gridDim.x * blockIdx.y + blockIdx.x// 一维block的大小int blockSize = blockDim.x;// 线程在一维block中的索引int threadIndex = threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 2D Grid, 2D Block对于 2-dim 的 grid 与 2-dim 的 block，有： 12345678// block在整个二维grid中的索引int blockIndex = gridDim.x * blockIdx.y + blockIdx.x// 二维block的大小int blockSize = blockDim.x * blockDim.y;// 线程在二维block中的索引int threadIndex = blockDim.x * threadIdx.y + threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 2D Grid, 3D Block对于 2-dim 的 grid 与 3-dim 的 block，有： 12345678// block在整个二维grid中的索引int blockIndex = gridDim.x * blockIdx.y + blockIdx.x// 三维block的大小int blockSize = blockDim.x * blockDim.y * blockDim.z;// 线程在三维block中的索引int threadIndex = blockDim.x * blockDim.y * threadIdx.z + blockDim.x * threadIdx.y + threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 3D Grid, 1D Block对于 3-dim 的 grid 与 1-dim 的 block，有： 12345678// block在整个三维grid中的索引int blockIndex = gridDim.x * gridDim.y * blockIdx.z + gridDim.x * blockIdx.y + blockIdx.x// 一维block的大小int blockSize = blockDim.x;// 线程在一维block中的索引int threadIndex = threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 3D Grid, 2D Block对于 3-dim 的 grid 与 2-dim 的 block，有： 12345678// block在整个三维grid中的索引int blockIndex = gridDim.x * gridDim.y * blockIdx.z + gridDim.x * blockIdx.y + blockIdx.x// 二维block的大小int blockSize = blockDim.x * blockDim.y;// 线程在二维block中的索引int threadIndex = blockDim.x * threadIdx.y + threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex; 3D Grid, 3D Block对于 3-dim 的 grid 与 3-dim 的 block，有： 12345678// block在整个三维grid中的索引int blockIndex = gridDim.x * gridDim.y * blockIdx.z + gridDim.x * blockIdx.y + blockIdx.x// 三维block的大小int blockSize = blockDim.x * blockDim.y * blockDim.z;// 线程在三维block中的索引int threadIndex = blockDim.x * blockDim.y * threadIdx.z + blockDim.x * threadIdx.y + threadIdx.x;// 线程在整个grid中的索引int index = blockIndex * blockSize + threadIndex;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（二）CUDA 核函数","slug":"cuda-spring-bootcamp/02.NVIDIA CUDA2023春训营（二）CUDA 核函数","date":"2023-02-06T05:21:58.000Z","updated":"2023-02-08T03:33:33.562Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/f32d359e.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/f32d359e.html","excerpt":"Reference CUDA之同步函数详解 cuda同步编程 GPU与cuda 【CUDA教程】二、主存与显存 函数执行环境标识符由于 GPU 是异构模型，所以需要区分 host 端和 device 端上的代码，在 CUDA 中是通过函数类型限定词开区别 host 和 device 上的函数，主要的三个函数类型限定词如下：","text":"Reference CUDA之同步函数详解 cuda同步编程 GPU与cuda 【CUDA教程】二、主存与显存 函数执行环境标识符由于 GPU 是异构模型，所以需要区分 host 端和 device 端上的代码，在 CUDA 中是通过函数类型限定词开区别 host 和 device 上的函数，主要的三个函数类型限定词如下： __global__：在 device 端执行，host 端中调用（某些 GPU 允许从 device 端调用），返回类型必须是 void，不支持可变参数参数，不能成为类成员函数 __device__：在 device 端执行，device 端调用，不能与 __global__ 同时使用 __host__：在 host 端执行，host 端调用，一般省略不写，不能与 __global__ 同时使用，但可与 __device__ 同时使用（此时会在 device 端和 host 端都编译） 三个标识符标识的函数执行位置与调用位置如下表所示 标识符 执行位置 调用位置 __global__ device host &amp; device(arch&gt;3.2) __device__ device device __host__ host host 用拓扑结构图来表示有： 核函数使用 __global__ 修饰的函数被称为核函数（Kernel Function），在调用时需要用 &lt;&lt;&lt;grid, block&gt;&gt;&gt; 来分配 block 数与线程数，在核函数加载后，会按如下步骤执行： 将 grid 分配到一个 device 根据 &lt;&lt;&lt;grid, block&gt;&gt;&gt; 内的执行设置的 grid，将 block 分配到流式多处理器（SM）上，一个 block 内的线程一定会在同一个 SM 内，一个 SM 内可有多个 block 根据 &lt;&lt;&lt;grid, block&gt;&gt;&gt; 内的执行设置的 block，Wrap 调度器会调用线程，其会将 32 个线程分为一组，称为一个 Wrap 每个 Wrap 会被分配到 32 个 core 上运行 同时，核函数是异步的，即 host 端不会等待核函数执行完就执行下一步 如下给出了一个简单的 CUDA 程序 1234567891011121314#include &lt;stdio.h&gt;//定义核函数__global__ void hello_from_gpu() &#123; printf(\"Hello World from the GPU!\\n\");&#125;int main() &#123; //调用核函数 hello_from_gpu&lt;&lt;&lt;1, 1&gt;&gt;&gt;(); //同步函数 cudaDeviceSynchronize(); return 0;&#125; 对于 grid 和 block 的大小设置并没有统一标准，通常根据实际需要自行配置，对于 dim-1 的 grid 和 dim-1 的 block，推荐设置如下 12dim3 blockSize(128);dim3 gridSize((N + blockSize.x - 1) / blockSize.x); 同步函数当某个线程执行到同步函数时，会进入等待状态，直到同一 block 中所有线程都执行到这个函数为止，相当于一个线程同步点，确保一个 block 中所有线程都达到同步，然后线程进入运行状态 在 CUDA 中，由于核函数是异步的，host 端不会等待核函数执行完就执行下一步，为避免核函数未执行完出现错误，可以使用以下三种同步函数来停住 host 端线程，等待 CUDA 中的操作完成 cudaDeviceSynchronize()：停止 host 端执行，直到 device 端完成 CUDA 的任务，包括核函数、数据拷贝等 cudaThreadSynchronize()：与 cudaDeviceSynchronize() 作用类似，但其不能被核函数调用","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA CUDA2023春训营（一）GPU 与 CUDA 简介","slug":"cuda-spring-bootcamp/01.NVIDIA CUDA2023春训营（一）GPU 与 CUDA 简介","date":"2023-02-06T01:34:00.000Z","updated":"2023-02-06T11:05:26.601Z","comments":true,"path":"nvidia/cuda-spring-bootcamp/1c5747fe.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/cuda-spring-bootcamp/1c5747fe.html","excerpt":"GPU在 GPU 出现之前，对于各种绘制计算机图形所需的运算，包括顶点设置、光影、像素操作等，都是由 CPU 配合特定软件实现的 图形处理器（Graphic Processing Unit，GPU）本质上是一组图形函数的集合，专门用于处理绘制计算机图形所需的运算，而这些函数由硬件实现，因此，GPU 从某种意义上讲就是为了在图形处理过程中充当主角而出现的","text":"GPU在 GPU 出现之前，对于各种绘制计算机图形所需的运算，包括顶点设置、光影、像素操作等，都是由 CPU 配合特定软件实现的 图形处理器（Graphic Processing Unit，GPU）本质上是一组图形函数的集合，专门用于处理绘制计算机图形所需的运算，而这些函数由硬件实现，因此，GPU 从某种意义上讲就是为了在图形处理过程中充当主角而出现的 近年来，GPU 最成功的一个应用就是深度学习领域，基于 GPU 的并行计算已经成为训练深度学习模型的标配 GPU 的运算类型适合 GPU 运算的运算类型有以下六种： 大量的轻量级运算：大量数据或同一数据多次调用同一公式或计算过程，公式本身并不复杂，只是执行的次数较多 高度并行：各数据间运算互不影响，耦合度较低 计算密集型：少量的 IO 读取与大量的计算 控制简单：逻辑简单的运算 多阶段执行：运算程序可分解为多个小程序或者同一程序可分多个阶段执行 浮点型运算：浮点数参与的运算 异构计算架构GPU 并不是一个独立运行的计算平台，其需要与 CPU 协同工作，可以看成是 CPU 的协处理器，因此当在谈及 GPU 并行计算时，其实是指基于 CPU+GPU 的异构计算架构，GPU 与 CPU 通过 PCIe 总线连接在一起来协同工作，CPU 所在位置称为为主机（host）端，而 GPU 所在位置称为设备（device）端 CPU 上的线程是重量级的，上下文切换开销大，但是 GPU 由于的核心远多于 CPU，其线程是轻量级的，因此，基于 CPU+GPU 的异构计算平台可以优势互补，CPU 负责处理逻辑复杂的串行程序，而 GPU 重点处理数据密集型的并行计算程序，从而发挥最大功效 CUDA统一计算设备架构（Compute Unified Device Architecture，CUDA）是一种由 NVIDIA 推出的通用并行计算架构，该架构使 GPU 能够解决复杂的计算问题，其包含 CUDA 指令集架构以及 GPU 内部的并行计算引擎 同时，CUDA 提供了 GPU 编程的简易接口，基于 CUDA 编程可以构建基于 GPU 计算的应用程序，支持 C/C++，Python，Fortran 等编程语言 简单来说，CUDA 是建立在 NVIDIA 的 GPUs 上的一个通用并行计算平台和编程模型，基于 CUDA 编程可以利用 GPUs 的并行计算引擎来更加高效地解决比较复杂的计算难题 CUDA 编程模型CUDA 编程模型是一个异构模型，需要 CPU 和 GPU 协同工作 在 CUDA 中，host 端和 device 端是两个极为重要的概念，host 端指代 CPU 及其内存，device 端指代 GPU 及其显存，一个 CUDA 程序中既包含 host 程序，又包含 device 程序，它们分别在 CPU 和 GPU 上运行 同时，host 端与 device 端之间可以进行通信，从而实现两者间的数据拷贝 对于 CUDA 程序，其在 host 端与 device 端的执行流程如下： 分配 host 端内存，并进行数据初始化 分配 device 端内存，并从 host 端将数据拷贝到 device 端上 调用 CUDA 的核函数在 device 端上完成指定的运算 将 device 端上的运算结果拷贝到 host 端上 释放 device 端和 host 端上分配的内存","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"CUDA春训营","slug":"nvidia/cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/categories/nvidia/cuda-spring-bootcamp/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"CUDA春训营","slug":"cuda-spring-bootcamp","permalink":"https://alex-mcavoy.github.io/tags/cuda-spring-bootcamp/"}],"author":"Alex_McAvoy"},{"title":"更新过程","slug":"stochastic-process/20.更新过程","date":"2022-12-26T09:16:00.000Z","updated":"2023-02-24T08:03:40.021Z","comments":true,"path":"mathematics/stochastic-process/83765294.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/83765294.html","excerpt":"【更新过程】Poisson 过程的到达时间间隔是相互独立同服从指数分布的随机变量序列，那么一种自然的推广是考虑到达时间间隔相互独立同分布，但分布函数任意的计数随机过程，这样的计数过程即更新过程 设 $\\{T_n,n=1,2,\\cdots\\}$ 是一列相互独立同分布的非负随机变量，令","text":"【更新过程】Poisson 过程的到达时间间隔是相互独立同服从指数分布的随机变量序列，那么一种自然的推广是考虑到达时间间隔相互独立同分布，但分布函数任意的计数随机过程，这样的计数过程即更新过程 设 $\\{T_n,n=1,2,\\cdots\\}$ 是一列相互独立同分布的非负随机变量，令 \\begin{array}{c} \\tau_n=\\sum_{k=1}^n T_k,\\quad \\tau_0=0\\\\ N(t)=\\sup{\\{n|\\tau_n\\leq t\\}},\\quad t\\geq 0 \\end{array}则称 $\\{N(t),t\\geq 0\\}$ 为一更新过程，其状态空间 $S=\\{0,1,2,\\cdots\\}$，称 \\tau_n,\\quad n=0,1,2,\\cdots为第 $n$ 个更新时刻，称 T_n,\\quad n=1,2,\\cdots为第 $n$ 个更新间距 设 $T_1,T_2,\\cdots,T_n,\\cdots$ 的分布函数为 $F(t)$，概率密度函数为 $f(t)$，那么随机变量 $\\tau_n$ 的概率密度函数为 $f(t)$ 的 $n$ 重卷积，设 $\\mu=ET_n,n=1,2,\\cdots$，由 $T_n$ 为非负随机变量且不恒为零，有 F(0)=P(T_n=0)","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"Poisson 过程","slug":"stochastic-process/19.Poisson过程","date":"2022-12-26T02:24:00.000Z","updated":"2023-02-24T08:03:46.888Z","comments":true,"path":"mathematics/stochastic-process/5489b5.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/5489b5.html","excerpt":"【引入】泊松（Poisson）过程是一类直观意义很强且极为重要的计数过程，其应用范围遍布各个领域 考虑一个来到某服务点要求服务的顾客流，顾客到达服务点的到达过程，即可认为是一个 Poisson 过程，当抽象的服务点和顾客流有着不同含义时，即可得到不同的 Poisson 过程","text":"【引入】泊松（Poisson）过程是一类直观意义很强且极为重要的计数过程，其应用范围遍布各个领域 考虑一个来到某服务点要求服务的顾客流，顾客到达服务点的到达过程，即可认为是一个 Poisson 过程，当抽象的服务点和顾客流有着不同含义时，即可得到不同的 Poisson 过程 在介绍 Poisson 过程前，首先给出计数过程和独立增量过程的定义 计数过程对于实随机过程 $\\{N(t),t\\geq 0\\}$，若 $N(t)$ 代表到时刻 $t$ 随机事件发生的次数，这称该随机过程为计数过程，其满足以下条件： $N(t)\\geq 0$ $N(t)$ 是非负整数 对 $\\forall 0\\leq s &lt;t$，有 $N(t)\\geq N(s)$ 对 $\\forall 0\\leq s &lt;t$，$N(t)-N(s)$ 代表时间间隔 $t-s$ 内随机事件发生的次数 独立增量过程设 $\\{X(t),t\\in T\\}$ 是一随机过程，若对 $\\forall n\\geq 3, \\forall t_1&lt;t_2&lt;\\cdots&lt;t_n\\in T$，有随机变量 X(t_2)-X(t_1),X(t_3)-X(t_2),\\cdots,X(t_n)-X(t_{n-1})相互独立，则称 $\\{X(t),t\\in T\\}$ 是独立增量过程 设 $\\{X(t),t\\in T\\}$ 是一随机过程，若对 $\\forall s&lt;t\\in T$，$X(t)-X(s)$ 分布仅依赖于 $t-s$，与 $t,s$ 本身取值无关，则称 $\\{X(t),t\\in T\\}$ 是平稳增量过程 那么，如果一个随机过程 $\\{X(t),t\\in T\\}$ 既是独立增量过程，又是平稳增量过程，那么该随机过程被称为平稳的独立增量过程 【Poisson 过程】定义对于计数过程 $\\{ N(t),t\\geq 0\\}$，若满足： $N(0)=0$ $\\{N(t),t\\geq 0\\}$ 是平稳的独立增量过程 对 $\\forall t&gt;0$，$N(t)$ 服从参数为 $\\lambda t$ 的 Poisson 分布，即 P(N(t)=k)=\\frac{(\\lambda t)^k}{k!} e^{-\\lambda t},\\quad k=0,1,2,\\cdots则称 $\\{N(t),t\\geq 0\\}$ 是参数为 $\\lambda&gt;0$ 的 Poisson 过程 进一步，对 $\\forall 0\\leq s &lt;t$，$N(t)-N(s)$ 服从参数为 $\\lambda(t-s)$ 的 Poisson 分布 在实际应用中，Poisson 过程常采用如下等价定义 对于计数过程 $\\{N(t),t\\geq 0\\}$，若满足： $N(0)=0$ $\\{N(t),t\\geq 0\\}$ 是平稳的独立增量过程 当 $\\Delta t$ 充分小时，在 $(t,t+\\Delta t)$ 内事件出现一次的概率为 $\\lambda\\Delta t+o(\\Delta t)$，出现两次及以上的概率为 $o(\\Delta t)$，即 \\begin{array}{c} P(N(t+\\Delta t)-N(t)=1)=\\lambda \\Delta t+ o(\\Delta t) \\\\ P(N(t+\\Delta t)-N(t)\\geq 2)=o(\\Delta t) \\end{array}则称 $\\{N(t),t\\geq 0\\}$ 是参数为 $\\lambda&gt;0$ 的 Poisson 过程 数字特征若随机过程 $\\{N(t),t\\geq 0\\}$ 是 Poisson 过程，则有： 均值函数：$\\mu_N(t)=\\lambda t,t\\geq 0$ 方差函数：$\\sigma_N(t)=\\lambda t,t\\geq 0$ 协方差函数：$C_N(s,t)=\\lambda \\min(s,t),s,t\\geq 0$ 相关函数：$R_N(s,t)=\\lambda^2st+\\lambda \\min(s,t),\\:s,t\\geq0$ 【到达时间与到达时间间隔】到达时间设 $N(t)$ 表示直到 $t$ 时刻到达的随机点数，则 $\\{N(t),t\\geq 0\\}$ 是参数为 $\\lambda$ 的 Poisson 过程 令 $\\tau_1,\\tau_2,\\cdots,\\tau_n,\\cdots$ 分别表示第 $i$ 个随机点的到达时间，则称随机变量序列 $\\{\\tau_n,n=1,2,\\cdots\\}$ 为 Poisson 过程的到达时间序列 对于到达时间序列 $\\{\\tau_n,n=1,2,\\cdots\\}$ 中的随机变量 $\\tau_n,n=1,2,\\cdots$，其服从参数为 $n,\\lambda$ 的伽马分布，即 $\\tau_n\\sim \\Gamma(n,\\lambda)$，有 f_{\\tau_n}(t)=\\left\\{\\begin{array}{c} \\lambda e^{-\\lambda t}\\frac{(\\lambda t)^{(n-1)}}{(n-1)!}, &t\\geq 0\\\\ 0, &t","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"齐次马尔科夫链的状态空间分解","slug":"stochastic-process/18.齐次马尔科夫链的状态空间分解","date":"2022-12-19T15:18:00.000Z","updated":"2023-02-24T08:04:00.707Z","comments":true,"path":"mathematics/stochastic-process/9cda3c67.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/9cda3c67.html","excerpt":"【等价类】对于齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，根据互通这一等价关系，可以将状态空间 $S$ 划分为有限个或可列无限个互不相交的子集 $S_1,S_2,\\cdots$ 的并，即 S=\\bigcup_{n}S_n,\\quad S_m\\bigcap S_n=\\varnothing,\\quad m\\neq n,n=1,2,\\cdots显然，同一子集 $S_n$ 中的所有状态都互通，不同子集 $S_m$ 和 $S_n$ 中的状态不互通","text":"【等价类】对于齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，根据互通这一等价关系，可以将状态空间 $S$ 划分为有限个或可列无限个互不相交的子集 $S_1,S_2,\\cdots$ 的并，即 S=\\bigcup_{n}S_n,\\quad S_m\\bigcap S_n=\\varnothing,\\quad m\\neq n,n=1,2,\\cdots显然，同一子集 $S_n$ 中的所有状态都互通，不同子集 $S_m$ 和 $S_n$ 中的状态不互通 称 $S_n$ 是一个等价类，包含 $i$ 的等价类 $S_n$ 常记为 $S(i)$，于是有 \\begin{align*} S(i)&= \\{i\\} \\bigcup \\{j|j\\leftrightarrow i\\} \\\\ S(i)&= S(j) \\Leftrightarrow i\\leftrightarrow j\\\\ S(i)&=S_n \\Leftrightarrow i\\in S_n \\end{align*}【闭集与吸收状态】对于齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，设 $C$ 是 $S$ 的子集，若对任意 $i\\in C,j\\notin C,n\\geq 0$，有 p_{ij}^{(n)}=0则称 $C$ 是一个闭集，而对 $i\\in S$，若状态子集 $\\{i\\}$ 是闭集，那么状态 $i$ 被称为吸收状态 那么，$i\\in S$ 是吸收状态的充要条件是 p_{ii}=1 对于 $S$ 的子集 $C$，其是闭集的充要条件是下列三个等价条件之一成立 \\begin{array}{c} p_{ij}=0，\\forall i\\in C,j\\notin j \\\\ \\sum\\limits_{j\\in C}p_{ij}=1,\\forall i\\in C \\\\ \\sum\\limits_{j\\in C}p_{ij}^{(n)}=1,\\forall i\\in C,n\\geq 0 \\end{array}【可约与不可约】设 $C$ 是一个闭集，若 $C$ 中不再包含任何非空真闭子集，则称 $C$ 是不可约闭集，否则，称 $C$ 是可约闭集 根据闭集的定义，显然对于齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，状态空间 $S$ 是一个闭集，那么如果 $S$ 是不可约的，就称该齐次马尔科夫链不可约，否则，称其可约 于是，可以给出如下定理： 若等价类 $S(i)$ 为闭集，那么 $S(i)$ 是不可约的 若 $C$ 是闭集，当且仅当 $C$ 中的任何两个状态都互通时，$C$ 是不可约的 齐次马尔科夫链不可约的充要条件是：其任意两个状态都互通 在实际应用中，常遇到有限状态的齐次马尔科夫链，关于有限齐次马尔科夫链有如下定理： 有限齐次马尔科夫链的所有非常返状态的集合 $D$ 不可能是闭集 有限齐次马尔科夫链不可能存在零常返状态 不可约的有限齐次马尔科夫链的所有状态都是正常返状态 也就是说，无论有限齐次马尔科夫链从什么状态出发，迟早要进入常返状态的闭集中，即在有限个非常返状态中的转移步数是有限的，从而不可约的有限齐次马尔科夫链的所有状态都是正常返状态 【状态空间分解定理】对于齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，其状态空间 $S$ 可唯一分解为有限个或可列无限个互不相交的状态子集 $D,C_1,C_2,\\cdots$ 的并，即 S=D\\cup C_1\\cup C_2 \\cup \\cdots其中，$D$ 是所有非常返状态构成的状态子集，$C_n$ 是由常返状态构成的不可约闭集，每个状态子集中的状态有着相同的状态类型，且对任意 $i,j\\in S$，有 $f_{ij}=1$ 例如：设状态空间 $S=\\{0,1,2\\}$ 的齐次马尔科夫链的一步转移概率为 P=\\begin{bmatrix} \\frac{1}{2} & \\frac{1}{2} & 0 \\\\ \\frac{1}{2} & \\frac{1}{4} & \\frac{1}{4} \\\\ 0 & \\frac{1}{3} & \\frac{2}{3} \\\\ \\end{bmatrix}首先根据一步转移概率画出状态转移图 由于 $p_{00}=\\frac{1}{2}$，根据周期的定义可知，状态 $0$ 是非周期状态，而从状态转移图可以看出，三个状态是互通的，故状态 $1$ 和状态 $2$ 也是非周期状态 根据状态空间分解定理可知，该齐次马尔科夫链是不可约的，且三个状态都是正常返状态 进而三个状态都是遍历状态","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"齐次马尔科夫链的状态判定","slug":"stochastic-process/17.齐次马尔科夫链的状态判定","date":"2022-12-19T07:53:00.000Z","updated":"2023-02-24T08:04:05.335Z","comments":true,"path":"mathematics/stochastic-process/1ec493ae.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/1ec493ae.html","excerpt":"【Doeblin 公式】设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，对任意 $i,j\\in S$，有 f_{ij}=\\lim_{N\\rightarrow \\infty} \\frac{\\sum\\limits_{n=1}^{N} p_{ij}^{(n)}}{1+\\sum\\limits_{n=1}^{N}p_{jj}^{(n)}}进一步，可推得","text":"【Doeblin 公式】设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，对任意 $i,j\\in S$，有 f_{ij}=\\lim_{N\\rightarrow \\infty} \\frac{\\sum\\limits_{n=1}^{N} p_{ij}^{(n)}}{1+\\sum\\limits_{n=1}^{N}p_{jj}^{(n)}}进一步，可推得 f_{ii}=1-\\lim_{N\\rightarrow \\infty} \\frac{1}{1+\\sum\\limits_{n=1}^{N}p_{ii}^{(n)}}那么，有 \\begin{align*} \\sum_{n=1}^{\\infty} p_{ii}^{(n)} = +\\infty \\Leftrightarrow f_{ii}=1 \\\\ \\sum_{n=1}^{\\infty} p_{ii}^{(n)} < +\\infty \\Leftrightarrow f_{ii}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"齐次马尔科夫链的状态","slug":"stochastic-process/16.齐次马尔科夫链的状态","date":"2022-12-19T07:23:00.000Z","updated":"2023-02-24T08:04:10.831Z","comments":true,"path":"mathematics/stochastic-process/9e146555.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/9e146555.html","excerpt":"【状态的基本属性】首达概率与迟早概率设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $i,j\\in S$，称","text":"【状态的基本属性】首达概率与迟早概率设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $i,j\\in S$，称 f_{ij}^{(n)}=P(X_n=j,X_k\\neq j,k=1,2,\\cdots,n-1|X_0=i)为 $\\{X_n,n\\geq0\\}$ 在 $0$ 时从状态 $i$ 出发，经过 $n$ 步转移后，首次达到状态 $j$ 的概率，简称为首达概率，称 f_{ij}=\\sum_{n=1}^{\\infty} f_{ij}^{(n)}=P\\Big(\\bigcup_{n=1}^{\\infty}(X_n=j,X_k\\neq j,k=1,2,\\cdots,n-1)|X_0=i\\Big)为 $\\{X_n,n\\geq0\\}$ 在 $0$ 时从状态 $i$ 出发，经过有限步转移后，迟早要达到状态 $j$ 的概率，简称为迟早概率，称 f_{ij}^{(+\\infty)}=P(X_n\\neq j,n=1,2,\\cdots,n-1)|X_0=i\\Big)为 $\\{X_n,n\\geq0\\}$ 在 $0$ 时从状态 $i$ 出发，永远也无法达到状态 $j$ 的概率 对于首达概率和迟早概率，其与齐次马尔科夫链的转移概率有如下关系： \\begin{align*} 0\\leq& f_{ij}^{(n)} \\leq p_{ij}^{(n)} \\leq f_{ij} \\leq 1 \\\\ p_{ij}^{(n)}&=\\sum_{l=1}^n f_{ij}^{(l)}p_{jj}^{(n-l)} \\\\ f_{ij}^{(n)}&=\\sum_{i_1\\neq j}\\sum_{i_2\\neq j}\\cdots\\sum_{i_{n-1}\\neq j} p_{ii_1}p_{i_1i_2}\\cdots p_{i_{n-1}j} \\end{align*}首达时设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $j\\in S$，称 T_j=\\min \\{n|n\\geq 1,X_n=j\\}为 $\\{X_n,n\\geq0\\}$ 首次到达状态 $j$ 的时间，简称首达时，显然，$T_j$ 是一个随机变量 当 $\\{n|n\\geq 1,X_n=j\\}=\\varnothing$，即 $\\forall n\\geq 1,X_n\\neq j$ 时，定义 T_j=+\\infty即系统在有限时间内，不可到达状态 $j$ 首达时与首达概率和迟早概率有如下关系： \\begin{align*} f_{ij}^{(n)}&=P(T_j=n|X_0=i)\\\\ f_{ij}&=P(T_j< +\\infty|X_0=0) \\end{align*}平均转移步数设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $j\\in S$ 时，其首达时为 $T_j$，称 \\mu_{ij}=E(T_j|X_0=i)=\\sum_{n=1}^{\\infty}n f_{ij}^{(n)}为从状态 $i$ 出发，首次到达状态 $j$ 的平均转移步数，称 \\mu_{jj}=E(T_j|X_0=j)=\\sum_{n=1}^{\\infty}n f_{jj}^{(n)}为从状态 $i$ 出发，首次返回状态 $j$ 的平均返回时间 状态的周期设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $i\\in S$，若 $\\{n|n\\geq 1,p_{ii}^{(n)}&gt;0\\}\\neq \\varnothing$，则称 d_i=\\text{GCD}\\{n|n\\geq 1,p_{ii}^{(n)}>0\\}为状态 $i$ 的周期，若 $\\{n|n\\geq 1,f_{ii}^{(n)}&gt;0\\}\\neq \\varnothing$，则有 h_i=\\text{GCD}\\{n|n\\geq 1,f_{ii}^{(n)}>0\\} 对于 $d_i$ 和 $h_i$，有如下性质： 1）若 $p_{ij}^{(n)}&gt;0$，则存在 $m\\geq 1$，使得 n=md_i2）若 $f_{ij}^{(n)}&gt; 0$，则存在 $m’\\geq 1$，使得 n=m'h_i3）若 $d_i$ 和 $h_i$ 中一个存在，则另一个也存在，且 d_i=h_i【状态】对于齐次马尔科夫链，可以根据常返性、平均返回时间、周期性上的各种不同的表现进行区分 设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $i\\in S$，有： 1）若 $f_{ii}=1$，则称状态 $i$ 为常返状态，或返回状态 2）若 $f_{ii}&lt;1$，则称状态 $i$ 为非常返状态，或滑过状态 3）若 $i$ 为常返状态，且 $\\mu_{ii}&lt;+\\infty$，则称状态 $i$ 为正常返状态 4）若 $i$ 为常返状态，且 $\\mu_{ii}=+\\infty$，则称状态 $i$ 为零常返状态，或消极常返状态 5）若 $d_i&gt;1$，则称状态 $i$ 为周期为 $d_i$ 的周期状态 6）若 $d_i=1$，则称状态 $i$ 为非周期状态 7）若状态 $i$ 为正常返状态，且是非周期状态，则称状态 $i$ 为遍历状态 7）若状态 $i$ 为正常返状态，且是周期状态，则称状态 $i$ 为正常返周期状态 【状态的可达与互通】设齐次马尔科夫链 $\\{X_n,n\\geq0\\}$，当 $i,j\\in S$，若存在 $n\\geq 1$，使得 p_{ij}^{(n)}>0则称状态 $i$ 可达状态 $j$，记为 $i\\rightarrow j$ 若状态 $i$ 可达状态 $j$，且状态 $j$ 可达状态 $i$，即 i\\rightarrow j,j\\rightarrow i则称状态 $i$ 与状态 $j$ 互通，记为 $i\\leftrightarrow j$ 对于状态的可达与互通，有： 可达的传递性：若 $i\\rightarrow j,j\\rightarrow k$，则 $i\\rightarrow k$ 互通的传递性：若 $i\\leftrightarrow j,j\\leftrightarrow k$，则 $i\\leftrightarrow k$ 互通的对称性：若 $i\\leftrightarrow j$，则 $j\\leftrightarrow i$ 此外，对于互通的两个状态 $i,j\\in S$，他们有相同的类型，即设 $i,j\\in S$，且 $i\\leftrightarrow j$，则 $i,j$ 有： 两者同为非常返状态 两者同为零常返状态 两者同为正常返非周期状态 两者同为正常返周期状态且周期相同","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"马尔科夫链的转移概率与概率分布","slug":"stochastic-process/15.马尔科夫链的转移概率与概率分布","date":"2022-12-19T06:36:00.000Z","updated":"2023-02-24T08:04:19.995Z","comments":true,"path":"mathematics/stochastic-process/4cdefd51.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/4cdefd51.html","excerpt":"【转移概率】设 $\\{X(n),n\\geq 0\\}$ 为马尔科夫链，若在 $n$ 时刻处于状态 $i$ 的条件下，经过 $k$ 步转移，于 $n+k$ 时刻到达状态 $j$，此时的条件概率 p_{ij}^{(k)}(n)=P(X_{n+k}=j|X_n=i),\\quad i,j\\in S称为 $\\{X(n),n\\geq 0\\}$ 在 $n$ 时的 $k$ 步转移概率","text":"【转移概率】设 $\\{X(n),n\\geq 0\\}$ 为马尔科夫链，若在 $n$ 时刻处于状态 $i$ 的条件下，经过 $k$ 步转移，于 $n+k$ 时刻到达状态 $j$，此时的条件概率 p_{ij}^{(k)}(n)=P(X_{n+k}=j|X_n=i),\\quad i,j\\in S称为 $\\{X(n),n\\geq 0\\}$ 在 $n$ 时的 $k$ 步转移概率 特别地，当 $k=1$ 时，$p_{ij}^{(1)}(n)$ 被称为一步转移概率，简记为 $p_{ij}(n)$ 【转移概率矩阵】将以 $p_{ij}^{(k)}(n)$ 为第 $i$ 行第 $j$ 列元素组成的矩阵 P^{(k)}(n)=\\begin{bmatrix} p_{11}^{(k)}(n) & p_{12}^{(k)}(n) & \\cdots & p_{1n}^{(k)}(n)\\\\ p_{21}^{(k)}(n) & p_{22}^{(k)}(n) & \\cdots & p_{2n}^{(k)}(n)\\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ p_{n1}^{(k)}(n) & p_{n2}^{(k)}(n) & \\cdots & p_{nn}^{(k)}(n)\\\\ \\end{bmatrix}称为 $\\{X(n),n\\geq 0\\}$ 在 $n$ 时的 $k$ 步转移概率矩阵，其是一个随机矩阵，即每一列的和为 $1$ 特别地，当 $k=1$ 时，$P^{(1)}(n)$ 被称为一步转移概率矩阵，简记为 $P(n)$ 【C-K 方程】设 $\\{X(n),n\\geq 0\\}$ 为马尔科夫链，在 $n$ 时刻处于状态 $i$ 的条件下，经过 $k+m$ 步转移，于 $n+k+m$ 时刻到达状态 $j$，可以先在 $n$ 时从状态 $i$ 出发，经过 $k$ 步于 $n+k$ 时到达某种中间状态 $l$，再在 $n+k$ 时刻从中间状态 $l$ 出发，经过 $m$ 步转移于 $n+k+m$ 时刻到达最终状态 $j$，要求中间状态 $l$ 要取遍整个状态空间，即 p_{ij}^{(k+m)}(n)=\\sum_lp_{il}^{(k)}(n)p_{lj}^{(m)}(n+k)其矩阵形式为 P^{(k+m)}(n)=P^{(k)}(n)P^{(m)}(n+k) 当取 $m=1$ 时，有 P^{(k+1)}(n)=P^{(k)}(n)P(n+k)一直推下去，有 P^{(k+1)}(n)=P(n)P(n+1)\\cdots P(n+k)写成分量形式，即 p_{ij}^{(k+1)}(n)=\\sum_{j_1}\\sum_{j_2}\\cdots\\sum_{j_k} p_{ij_1}(n) p_{j_1j_2}(n+1)\\cdots p_{j_kj_1}(n)在上式中将 $k+1$ 换为 $k$，可得结论：马尔科夫链的 $k$ 步转移概率，由一步转移概率所完全确定 【概率分布】设 $\\{X(n),n\\geq 0\\}$ 为马尔科夫链，称 q_i^{(0)}=P(X_0=i),\\quad i\\in S为 $\\{X(n),n\\geq 0\\}$ 的初始分布，称 \\mathbf{q}^{(0)}=(q_1^{(0)},q_2^{(0)},\\cdots,q_n^{(0)})为 $\\{X(n),n\\geq 0\\}$ 的初始分布向量，称 q_j^{(n)}=P(X_n=j),\\quad j\\in S为 $\\{X(n),n\\geq 0\\}$ 的绝对分布，称 \\mathbf{q}^{(n)}=(q_1^{(n)},q_2^{(n)},\\cdots,q_n^{(n)})为 $\\{X(n),n\\geq 0\\}$ 的绝对分布向量 显然，初始分布、绝对分布、$n$ 步转移概率有如下关系： \\begin{align*} q_j^{(n)}&=\\sum_i q_i^{(0)}p_{ij}^{(n)}(0) \\\\ \\mathbf{q}^{(n)}&=\\mathbf{q}^{(0)}P^{(n)}(0) \\end{align*}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"马尔科夫过程的基本概念","slug":"stochastic-process/14.马尔科夫过程的基本概念","date":"2022-12-19T05:49:00.000Z","updated":"2023-02-24T08:04:27.987Z","comments":true,"path":"mathematics/stochastic-process/d5309d93.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/d5309d93.html","excerpt":"【马尔科夫性】设 $\\{X(t),t\\in T\\}$ 是一随机过程，当 $\\{X(t),t\\in T\\}$ 在 $t_0$ 时刻所处的状态已知时，若其在 $t&gt;t_0$ 时刻所处状态的条件分布与其在 $t_0$ 之前所处的状态无关，则称 $\\{X(t),t\\in T\\}$ 具有马尔科夫性 简单来说，马尔科夫性是指：在已知过程现在条件下，其将来的条件分布不依赖于过去的条件分布","text":"【马尔科夫性】设 $\\{X(t),t\\in T\\}$ 是一随机过程，当 $\\{X(t),t\\in T\\}$ 在 $t_0$ 时刻所处的状态已知时，若其在 $t&gt;t_0$ 时刻所处状态的条件分布与其在 $t_0$ 之前所处的状态无关，则称 $\\{X(t),t\\in T\\}$ 具有马尔科夫性 简单来说，马尔科夫性是指：在已知过程现在条件下，其将来的条件分布不依赖于过去的条件分布 【马尔科夫过程】设 $\\{X(t),t\\in T\\}$ 的状态空间为 $S$，若对 $\\forall n\\geq 2,\\forall t_1&lt;t_2&lt;\\cdots&lt;t_n\\in T$，在条件 $X(t_i)=x_i,x_i\\in S,i=1,2,\\cdots,n-1$ 下，$X(t_n)$ 的条件分布恰好等于在条件 $X(t_{n-1})=x_{n-1}$ 下的条件分布函数，即 \\begin{align*} &P(X(t_n)\\leq x_n|X(t_1)=x_1,X(t_2)=x_2,\\cdots,X(t_{n-1})=x_{n-1})\\\\ =&P(X(t_n)\\leq x_n|X(t_{n-1})=x_{n-1}),\\quad x_n\\in \\mathbb{R} \\end{align*}则称 $\\{X(t),t\\in T\\}$ 为马尔科夫过程 【马尔科夫链】对于马尔科夫过程 $\\{X(t),t\\in T\\}$，参数集 $T$ 和状态空间 $S$ 都是离散时，称 $\\{X(t),t\\in T\\}$ 为马尔科夫链，此时马尔科夫性可表示为： 对 $\\forall n\\geq 2,\\forall t_1&lt;t_2&lt;\\cdots&lt;t_n\\in T,i_1,i_2,\\cdots,i_n\\in S$，有 \\begin{align*} &P(X(t_n)= i_n|X(t_1)=i_1,X(t_2)=i_2,\\cdots,X(t_{n-1})=i_{n-1})\\\\ =&P(X(t_n)= i_n|X(t_{n-1})=i_{n-1}) \\end{align*}特别地，当取 $T=\\{0,1,2,\\cdots\\}$ 时，马尔科夫链常记为 $\\{X(n),n\\geq 0\\}$，简称为系统，此时马尔科夫性可表示为： 对 $\\forall n\\geq 1,i_0,i_1,i_2,\\cdots,i_n\\in S$，有 \\begin{align*} &P(X(n)= i_n|X(0)=i_1,X(1)=i_1,\\cdots,X(n-1)=i_{n-1})\\\\ =&P(X(n)= i_n|X(n-1)=i_{n-1}) \\end{align*}其中，$X(i)$ 可简写为 $X_i$ 【齐次马尔科夫链】设 $\\{X(n),n\\geq 0\\}$ 为马尔科夫链，若其一步转移概率 $p_{ij}(n)$ 恒与起始时刻 $n$ 无关，则称 $\\{X(n),n\\geq 0\\}$ 为齐次马尔科夫链 对于齐次马尔科夫链 $\\{X(n),n\\geq 0\\}$，其一步转移概率简记为 $p_{ij}$，其 $k$ 步转移概率 $p_{ij}^{(k)}(n)$ 也恒与起始时刻 $n$ 无关，可记为 $p_{ij}^{(k)}$，因此在进行具体讨论时，总可假设时间起点为零，即 p_{ij}^{(k)}=P(X_k=j|X_0=i),\\quad i,j\\in S进而其 $k$ 步转移概率矩阵 $P^{(k)}(n)$ 和一步转移概率矩阵 $P(n)$ 也恒与起始时刻 $n$ 无关，简记为 $P^{(k)}$ 和 $P$","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"平稳过程的谱分解","slug":"stochastic-process/13.平稳过程的谱分解","date":"2022-12-12T12:05:00.000Z","updated":"2023-02-24T08:04:36.495Z","comments":true,"path":"mathematics/stochastic-process/ea17b667.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/ea17b667.html","excerpt":"【复平稳过程的谱分解】设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是零均值均方连续的平稳过程，其谱函数为 $F_X(\\omega)$，则 X(t)=\\int_{-\\infty}^{+\\infty} e^{j\\omega t}dZ(\\omega),\\quad -\\infty","text":"【复平稳过程的谱分解】设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是零均值均方连续的平稳过程，其谱函数为 $F_X(\\omega)$，则 X(t)=\\int_{-\\infty}^{+\\infty} e^{j\\omega t}dZ(\\omega),\\quad -\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"平稳过程的谱密度","slug":"stochastic-process/12.平稳过程的谱密度","date":"2022-12-12T09:36:00.000Z","updated":"2023-02-24T08:05:02.042Z","comments":true,"path":"mathematics/stochastic-process/1e284eb3.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/1e284eb3.html","excerpt":"【相关函数的谱密度】平稳过程的相关函数可视为一表示位移的时间函数，在时域上描述了随机过程的统计特征，因此，对于平稳过程的相关函数，利用 Fourier 分析的方法进行研究，便可在频域上描述平稳过程的统计特征，进而得到平稳过程谱密度这一概念 设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是均方连续的平稳过程，则其相关函数","text":"【相关函数的谱密度】平稳过程的相关函数可视为一表示位移的时间函数，在时域上描述了随机过程的统计特征，因此，对于平稳过程的相关函数，利用 Fourier 分析的方法进行研究，便可在频域上描述平稳过程的统计特征，进而得到平稳过程谱密度这一概念 设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是均方连续的平稳过程，则其相关函数 R_X(\\tau)=\\frac{1}{2\\pi} \\int_{-\\infty}^{+\\infty} e^{j\\omega\\pi}dF_X(\\omega),\\quad -\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"平稳过程的各态历经性","slug":"stochastic-process/11.平稳过程的各态历经性","date":"2022-12-12T07:46:00.000Z","updated":"2023-02-24T08:10:36.472Z","comments":true,"path":"mathematics/stochastic-process/db731bd0.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/db731bd0.html","excerpt":"【时间平均与时间相关函数】设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是平稳过程，若下列均方极限存在 =\\underset{T\\rightarrow +\\infty}{\\text{l.i.m }} \\frac{1}{2T} \\int_{-T}^T X(t)dt则称该均方极限是平稳过程在 $(-\\infty,+\\infty)$ 上的时间平均","text":"【时间平均与时间相关函数】设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是平稳过程，若下列均方极限存在 =\\underset{T\\rightarrow +\\infty}{\\text{l.i.m }} \\frac{1}{2T} \\int_{-T}^T X(t)dt则称该均方极限是平稳过程在 $(-\\infty,+\\infty)$ 上的时间平均 若对于固定的 $\\tau$，下列均方极限存在 =\\underset{T\\rightarrow +\\infty}{\\text{l.i.m }} \\frac{1}{2T} \\int_{-T}^T \\overline{X(t)}X(t+\\tau)dt则称 $&lt;\\overline{X(t)}X(t+\\tau)&gt;$ 是 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 在在 $(-\\infty,+\\infty)$ 上的时间相关函数 从定义上来看，平稳过程的时间平均是随机变量，时间相关函数是一族随机变量 在实际应用中，通常只考虑定义在 $[0,+\\infty)$ 上的平稳过程，那么平稳过程的时间平均和时间相关函数有相应的下述形式 设 $\\{X(t),t\\geq 0\\}$ 是平稳过程，则其时间平均为： =\\underset{T\\rightarrow +\\infty}{\\text{l.i.m }} \\frac{1}{T} \\int_{0}^T X(t)dt对于固定的 $\\tau$，时间相关函数为： =\\underset{T\\rightarrow +\\infty}{\\text{l.i.m }} \\frac{1}{T} \\int_{0}^T \\overline{X(t)}X(t+\\tau)dt【各态历经性】在实际应用中，确定随机过程的均值函数和相关函数是十分重要的，但要确定随机过程的数字特征，一般需要知道过程的一、二维分布，而这需要对一个过程进行大量的重复试验，有时这难以做到 由于平稳过程的统计特性不随时间的推移而变化，那么一个自然而然的问题就是：能否从一个时间范围内观察到的一个样本函数，或一个样本函数在某些时刻的取值来提取过程的数字特征？ 如果能从随机过程的一个样本函数中获得其各种统计特性，那么称该特性为各态历经性，具有各态历经性的随机过程只需要一个样本函数，即可表示出它的数字特征 下面给出相关的定义： 1）设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是平稳过程，若时间平均 =\\mu_X以概率 $1$ 成立，则称 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 的均值具有各态历经性 2）设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是平稳过程，若对任意实数 $\\tau$，时间相关函数 =R_X(\\tau)以概率 $1$ 成立，则称 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 的相关函数具有各态历经性 3）若平稳过程 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 的均值和相关函数都具有各态历经性，则称 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 具有各态历经性，或称 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 为各态历经过程 【均值各态历经性的判定】设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是平稳过程，则其均值具有各态历经性的充要条件是： \\lim_{T\\rightarrow +\\infty} \\frac{1}{2T} \\int_{-2T}^{2T}(1-\\frac{|\\tau|}{2T})C_X(\\tau)d\\tau =0进一步，若 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是实平稳过程，则其均值具有各态历经性的充要条件是： \\lim_{T\\rightarrow +\\infty} \\frac{1}{T} \\int_{0}^{2T}(1-\\frac{\\tau}{2T})C_X(\\tau)d\\tau =0 对于定义在 $[0,+\\infty)$ 上的平稳过程 $\\{X(t),t\\geq 0\\}$，其均值具有各态历经性的充要条件是： \\lim_{T\\rightarrow +\\infty} \\frac{1}{T} \\int_{0}^{T}(1-\\frac{|\\tau|}{T})C_X(\\tau)d\\tau =0进一步，若 $\\{X(t),t\\geq 0\\}$ 是实平稳过程，则其均值具有各态历经性的充要条件是： \\lim_{T\\rightarrow +\\infty} \\frac{2}{T} \\int_{0}^{T}(1-\\frac{\\tau}{T})C_X(\\tau)d\\tau =0【相关函数各态历经性的判定】设 $\\{X(t),-\\infty&lt;t&lt;+\\infty\\}$ 是平稳过程，令 Y(t)=\\overline{X(t)}X(t+\\tau),\\quad -\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"平稳过程的基本概念","slug":"stochastic-process/10.平稳过程的基本概念","date":"2022-12-12T05:01:00.000Z","updated":"2023-02-24T08:05:49.673Z","comments":true,"path":"mathematics/stochastic-process/32940bce.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/32940bce.html","excerpt":"【严平稳过程】设 $\\{X(t),t\\in T\\}$ 是一随机过程，若对任意的 $n\\geq 1$ 和任意的 $t_1,t_2,\\cdots,t_n\\in T$ 以及使 $t_1+\\tau,t_2+\\tau,\\cdots,t_n+\\tau\\in T$ 的任意实数 $\\tau$，$n$ 维随机向量 $(X(t_1),X(t_2),\\cdots,X(t_n))$ 和 $(X(t_1+\\tau),X(t_2+\\tau),\\cdots,X(t_n+\\tau))$ 有相同的联合分布函数，即 F(t_1,\\cdots,t_n;x_1,\\cdots,x_n)=F(t_1+\\tau,\\cdots,t_n+\\tau;x_1,\\cdots,x_n),\\quad t_i\\in T,x_i,\\tau\\in \\mathbb{R}则称 $\\{X(t),t\\in T\\}$ 是严平稳过程，或称 $\\{X(t),t\\in T\\}$ 具严平稳性","text":"【严平稳过程】设 $\\{X(t),t\\in T\\}$ 是一随机过程，若对任意的 $n\\geq 1$ 和任意的 $t_1,t_2,\\cdots,t_n\\in T$ 以及使 $t_1+\\tau,t_2+\\tau,\\cdots,t_n+\\tau\\in T$ 的任意实数 $\\tau$，$n$ 维随机向量 $(X(t_1),X(t_2),\\cdots,X(t_n))$ 和 $(X(t_1+\\tau),X(t_2+\\tau),\\cdots,X(t_n+\\tau))$ 有相同的联合分布函数，即 F(t_1,\\cdots,t_n;x_1,\\cdots,x_n)=F(t_1+\\tau,\\cdots,t_n+\\tau;x_1,\\cdots,x_n),\\quad t_i\\in T,x_i,\\tau\\in \\mathbb{R}则称 $\\{X(t),t\\in T\\}$ 是严平稳过程，或称 $\\{X(t),t\\in T\\}$ 具严平稳性 根据定义可以看出，严平稳过程的有限维分布不随时间的推移而发生改变 其所有的一维分布函数与 $t$ 无关，即 F(t;x)=F(x)所有的二维分布函数仅是时间间隔的函数，与两个时刻本身无关 F(t_1,t_2;x_1,x_2)=F(t_1+\\tau,t_2+\\tau;x_1,x_2)=F(0,t_2-t_1;x_1,x_2) 那么，若 $\\{X(t),t\\in T\\}$ 是一个二阶矩过程，且是一个严平稳过程，其均值函数有 \\mu_X(t)=\\int_{-\\infty}^{+\\infty} x dF(t;x)=\\int_{-\\infty}^{+\\infty} x dF(x)\\triangleq \\mu_X(c),\\quad c\\in \\mathbb{R}其相关函数有 \\begin{align*} R_X(s,t) &= \\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty} x_1x_2 dF(s,t;x_1,x_2) \\\\ &= \\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty} x_1x_2 dF(0,t-s;x_1,x_2) \\\\ &\\triangleq R_X(t-s) \\end{align*}即一、二阶矩存在的严平稳过程的均值函数是常数，相关函数是时间间隔的函数，与时间起点无关 【宽平稳过程】设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，若 对 $\\forall t\\in T$，有 $\\mu_X(t)=\\mu_X(c),c\\in\\mathbb{R}$ 对 $\\forall s,t\\in T$，有 $R_X(s,t)=R_X(t-s)$ 或 $\\forall \\tau\\in \\mathbb{R}, t,t+\\tau\\in T,R_X(t,t+\\tau)=R_X(\\tau)$ 则称 $\\{X(t),t\\in T\\}$ 为宽平稳过程，简称平稳过程 一般来说，严平稳过程不一定是宽平稳过程，这是因为严平稳过程的定义只涉及有限维分布，而并不要求一、二阶矩存在，但对二阶矩过程，严平稳过程必定是宽平稳过程 反过来，宽平稳过程不一定是严平稳过程，这是因为宽平稳过程的定义只要求均值函数与时间无关，且相关函数仅依赖于时间间隔，而与时间的起点无关，推导不出随机过程的有限维分布不随时间的推移而发生改变 但若 $\\{X(t),t\\in T\\}$ 是正态过程，则 $\\{X(t),t\\in T\\}$ 是严平稳过程的充要条件是：$\\{X(t),t\\in T\\}$ 为宽平稳过程 【周期平稳过程】若平稳过程 $\\{X(t),t\\in T\\}$ 满足： X(t+T_0)=X(t),\\quad t\\in T,t_0\\in \\mathbb{R}则称 $\\{X(t),t\\in T\\}$ 是周期为 $T_0$ 的周期平稳过程 其相关函数也是周期函数，且周期与 $\\{X(t),t\\in T\\}$ 周期相同，即 R_X(\\tau+T_0)=E[\\overline{X(t)}X(t+\\tau+T_0)]=E[\\overline{X(t)}X(t+\\tau)]=R_X(\\tau)【平稳过程的相关函数】设 $\\{X(t),t\\in T\\}$ 是平稳过程，则其相关函数有如下性质： 1）$R_X(0)=E[|X(t)|^2] \\geq |\\mu_X|^2\\geq 0$ 2）$\\overline{R_X(\\tau)}=R_X(-\\tau)$ 3）$|R_X(\\tau)|\\leq R_X(0)$ 4）$R_X(\\tau)=R_X(t-s)$ 具非负定性，即对 $\\forall n\\geq 1$，$t_1,t_2,\\cdots,t_n\\in T$，与复数 $a_1,a_2,\\cdots,a_n$ 有 \\sum_{k=1}^n\\sum_{l=1}^n R_X(t_l-t_k)\\overline{a_k}a_l\\geq 0此外，若 $\\{X(t),t\\in T\\}$ 是实平稳过程，则其相关函数为偶函数，即 R_X(-\\tau)=R_X(\\tau)【平稳过程的随机分析】均方连续若 $\\{X(t),t\\in T\\}$ 是平稳过程，则 $\\{X(t),t\\in T\\}$ 均方连续的充要条件是：$R_X(\\tau)$ 在 $\\tau$ 处连续 均方可导若 $\\{X(t),t\\in T\\}$ 是平稳过程，则以下命题成立： 1）$\\{X(t),t\\in T\\}$ 均方可导的充要条件是：相关函数 $R_X(\\tau)$ 在 $\\tau=0$ 处一阶导数存在，二阶导数存在且连续 2）$\\{X(t),t\\in T\\}$ 均方可导的必要条件是：相关函数 $R_X(\\tau)$ 在 $\\tau=0$ 处一阶导数存在，二阶导数存在且连续 3）若 $\\{X(t),t\\in T\\}$ 均方可导，则其导数过程 $\\{X’(t),t\\in T\\}$ 仍为平稳过程，且 \\begin{align*} \\mu_{X'}(t)&=0 \\\\ R_{X'}(\\tau)&=-R''_X(\\tau) \\end{align*}均方可积若 $\\{X(t),-\\infty&lt;t&lt;+\\infty \\}$ 是均方连续的平稳过程，$f(t)$ 为分段连续函数，则在任何有限区间 $[a,b]$ 上，下列积分在均方意义下存在 \\int_{a}^bf(t)X(t)dt且对任一分段连续函数 $g(t)$，有 E\\Big[ \\int_a^b g(s)X(s)ds \\int_a^b f(t)X(t)dt \\Big]=\\int_a^b \\int_a^b \\overline{g(s)}f(t)R_X(t-s) ds dt【联合平稳的平稳过程】设 $\\{X(t),t\\in T\\}$ 和 $\\{Y(t),t\\in T\\}$ 是两个平稳过程，若 $\\forall s,t\\in T$，有 R_{XY}(s,t)=R_{XY}(t-s)则称 $\\{X(t),t\\in T\\}$ 和 $\\{Y(t),t\\in T\\}$ 是联合平稳的平稳过程 其相关函数有如下性质： \\begin{array}{c} \\overline{R_{XY}(\\tau)}=R_{YX}(-\\tau) \\\\ |R_{XY}(\\tau)|^2\\leq R_X(0)R_Y(0)\\\\ |R_{YX}(\\tau)|^2\\leq R_X(0)R_Y(0)\\\\ \\end{array}进一步，若 $\\{X(t),t\\in T\\}$ 和 $\\{Y(t),t\\in T\\}$ 都是实平稳过程，则其相关函数满足 R_{XY}(-\\tau)=R_{YX}(\\tau)","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"矩阵的直积与拉直运算","slug":"matrix-theory/15.矩阵的直积与拉直运算","date":"2022-12-09T05:26:00.000Z","updated":"2022-12-21T17:05:01.886Z","comments":true,"path":"mathematics/matrix-theory/11c3efbc.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/11c3efbc.html","excerpt":"【矩阵直积】定义设 $A=[a_{ij}]\\in C^{m\\times n},B\\in C^{p\\times q}$，则对于矩阵 $A$ 与矩阵 $B$，称","text":"【矩阵直积】定义设 $A=[a_{ij}]\\in C^{m\\times n},B\\in C^{p\\times q}$，则对于矩阵 $A$ 与矩阵 $B$，称 A\\otimes B = \\begin{bmatrix} a_{11}B & a_{12}B & \\cdots & a_{1n}B\\\\ a_{21}B & a_{22}B & \\cdots & a_{2n}B\\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m1}B & a_{m2}B & \\cdots & a_{mn}B \\end{bmatrix}为矩阵 $A$ 与矩阵 $B$ 的直积，或克罗内克（Kronecker）积 性质矩阵的直积具有如下性质： 设 $A\\in C^{m\\times n},B\\in C^{p\\times q},C\\in C^{r\\times s}$，则： 1）$\\lambda(A\\otimes B)=(\\lambda A)\\otimes B=A\\otimes (\\lambda B)$ 2）$A\\otimes (B\\otimes C)=(A\\otimes B)\\otimes C=A\\otimes B\\otimes C$ 3）$(A\\otimes B)^T=A^T\\otimes B^T$，$(A\\otimes B)^H=A^H\\otimes B^H$ 4）当 $D\\in C^{k\\times k}$ 且 $nq=rk$ 时，$(A\\otimes B)(C\\otimes D)$ 有意义，且当 $n=r,q=k$ 时，有 (A\\otimes B)(C\\otimes D)=(AC)\\otimes (BD)5）当 $p=m,q=n$ 时，有 \\begin{array}{c} (A+B)\\otimes C= A\\otimes C+ B \\otimes C \\\\ C\\otimes (A+B)= C \\otimes A+ C\\otimes B \\end{array}6）当 $p=m,q=n,E\\in C^{r\\times s}$ 时，有 (A+B)\\otimes(C+E)=A\\otimes C+ A\\otimes E+B\\otimes C+ B\\otimes E7）当 $m=n,p=q$ 且 $A^{-1},B^{-1}$ 存在时，有 (A\\otimes B)^{-1}=A^{-1}\\otimes B^{-1}8）当 $p=m,q=n$ 时，有 \\text{tr} (A\\otimes B)=\\text{tr} A\\cdot \\text{tr}B9）设 $A\\in C^{m\\times m},B\\in C^{n\\times n}$，$\\lambda,\\mu$ 分别是 $A,B$ 的特征值，相应的特征向量为 $\\mathbf{u},\\mathbf{v}$，则 $\\lambda\\mu$ 是 $A\\otimes B$ 的特征值，相应的特征向量为 $\\mathbf{u}\\otimes\\mathbf{v}$ 10）设 $A\\in C^{m\\times m},B\\in C^{n\\times n}$，则 |A\\otimes B|=|A|^n\\cdot |B|^m【拉直运算】定义设 $A=[a_{ij}]\\in C^{m\\times n}$，则向量 \\overrightarrow{A}=[a_{11},a_{12},\\cdots,a_{1n},\\cdots,a_{m1},a_{m2},\\cdots,a_{mn}] \\in C^{mn}称为矩阵 $A$ 的拉直运算 可以发现，矩阵的拉直运算是一种线性运算，即对 $\\forall A,B\\in C^{m\\times n}$，有 \\overrightarrow{aA+bB} = a\\overrightarrow{A}+b\\overrightarrow{B},\\quad \\forall a,b\\in C与直积关系设 $A\\in C^{m\\times n},X\\in C^{p \\times q},B\\in C^{q\\times n}$，则有 \\overrightarrow{AXB}=(A\\otimes B)\\overrightarrow{X}该关系可用于求解矩阵方程问题，即将矩阵方程组 A_1XB_1^T+A_2XB_2^T+\\cdots+A_sXB_s^T=F化为线性方程组 (A_1\\otimes B_1^T+ A_2\\otimes B_2^T+\\cdots+A_s\\otimes B_s^T)\\overrightarrow{X}=\\overrightarrow{F}其中，$A_i\\in C^{m\\times p},B_i \\in C^{q\\times n},X\\in C^{p\\times q},F\\in C^{m\\times n}$ 当 $p=m,q=n$ 时，上述线性方程组有唯一解的充要条件是 |A_1\\otimes B_1^T+ A_2\\otimes B_2^T+\\cdots+A_s\\otimes B_s^T|\\neq 0 例如：求解矩阵方程 $AX+XB=F$，其中 A=\\begin{bmatrix}1&1\\\\0&-1\\end{bmatrix}, B=\\begin{bmatrix}5&1\\\\2&-1\\end{bmatrix}, F=\\begin{bmatrix}13&2\\\\6&-1\\end{bmatrix}, X=\\begin{bmatrix}x_1&x_2\\\\x_3&x_4\\end{bmatrix}利用拉直运算，将 $AX+XB=F$ 化为线性方程组 (A\\otimes I_2+I_2\\otimes B)\\overrightarrow{X}=\\overrightarrow{F}则有 \\begin{array}{cc} A\\otimes I_2+I_2\\otimes B = \\begin{bmatrix} 6&2&1&0\\\\ 1&0&0&1\\\\ 0&0&4&2\\\\ 0&0&1&-2 \\end{bmatrix},\\\\ \\overrightarrow{X}=\\begin{bmatrix} x_1\\\\x_2\\\\x_3\\\\x_4 \\end{bmatrix}, \\overrightarrow{F}=\\begin{bmatrix} 13\\\\2\\\\6\\\\-1 \\end{bmatrix} \\end{array}而 |A\\otimes I_2+I_2\\otimes B|=20\\neq0故线性方程组有唯一解，解得 \\overrightarrow{X}=\\begin{bmatrix} 2&0&1&1 \\end{bmatrix}^T故原矩阵方程的解为 X=\\begin{bmatrix} 2&0 \\\\ 1&1 \\end{bmatrix}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"矩阵 M-P 广义逆","slug":"matrix-theory/14.矩阵M-P广义逆","date":"2022-12-09T03:11:00.000Z","updated":"2022-12-21T15:08:14.881Z","comments":true,"path":"mathematics/matrix-theory/7984179d.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/7984179d.html","excerpt":"【引入】对于任意一个方阵，其不一定可逆，但将矩阵逆的概念进行推广，使得任何一个矩阵在某种意义下均可逆，这就是矩阵广义逆的概念 矩阵广义逆有多种定义，其中最广泛应用的一种是 Moore-Penrose 广义逆","text":"【引入】对于任意一个方阵，其不一定可逆，但将矩阵逆的概念进行推广，使得任何一个矩阵在某种意义下均可逆，这就是矩阵广义逆的概念 矩阵广义逆有多种定义，其中最广泛应用的一种是 Moore-Penrose 广义逆 【M-P 广义逆的定义】设 $A\\in C^{m\\times n}$，若存在 $G\\in C^{n\\times m}$，使得 \\begin{array}{c} AGA=A\\\\ GAG=G\\\\ (AG)^H=AG\\\\ (GA)^H=GA \\end{array}则称 $G$ 为 $A$ 的 Moore-Penrose 广义逆，简称为 M-P 广义逆，记为 $A^+$ 对于任意 $A\\in C^{m\\times n}$，一定有 M-P 广义逆 $A^+$ 存在且唯一 【M-P 广义逆的性质】M-P 广义逆 $A^+$ 具有许多与普通逆矩阵 $A^{-1}$ 相似的性质： $(A^+)^+=A$ $(A^+)^H=(A^H)^+$ $(\\lambda A^+)=\\frac{1}{\\lambda}A^+,\\lambda\\neq0\\in C$ $A^H=A^HAA^+=A^+AA^H$ $A^+=(A^HA)^+A^H=A^H(AA^H)^+$ 若 $F$ 为列满秩矩阵，$G$ 为行满秩矩阵，则 $(FG)^+=G^+F^+$ 若 $U^HU=I_m$，$V^HV=I_n$，则 $(UAV)^+=V^HA^+U^H$ $\\text{rank }A=\\text{rank }A^+=\\text{rank }A^+A=\\text{rank }AA^+$ $\\text{rank }A=m-\\text{rank }(I_m-AA^+)=n-\\text{rank }(I_n-A^+A)$ 【M-P 广义逆的求法】对于矩阵 $A\\in C^{m\\times n}$，若想求其广义逆，需对 $A$ 作满秩分解 A=FG则有 A^+=G^+F^+=G^H(GG^H)^{-1}(F^HF)^{-1}F^H 例如 A=\\begin{bmatrix} 1 & 1 & 2 & 4 \\\\ -1 & -1 & -1 & -2 \\\\ 3 & 3 & 2 & 4 \\end{bmatrix}对 $A$ 作满秩分解，有 A=\\begin{bmatrix} 1 & 2 \\\\ -1 & -1 \\\\ 3 & 2 \\end{bmatrix}\\begin{bmatrix} 1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 2 \\end{bmatrix}= FG可得 \\begin{array}{c} G^T(GG^T)^{-1}=\\frac{1}{10}\\begin{bmatrix} 5 & 0 \\\\ 5 & 0 \\\\ 0 & 2 \\\\ 0 & 4 \\end{bmatrix} \\\\ (F^TF)^{-1}F^T=\\frac{1}{18}\\begin{bmatrix} -9 & 0 & 9 \\\\ 13 & -2 & -5 \\end{bmatrix} \\end{array}故 A^+=G^T(GG^T)^{-1}(F^TF)^{-1}F^T=\\frac{1}{180}\\begin{bmatrix} -45 & 0 & 45 \\\\ -45 & 0 & 45 \\\\ 26 & -4 & -10 \\\\ 52 & -8 & -20 \\end{bmatrix}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"随机分析中的均方积分","slug":"stochastic-process/09.随机分析中的均方积分","date":"2022-12-05T13:42:00.000Z","updated":"2023-02-24T08:05:58.538Z","comments":true,"path":"mathematics/stochastic-process/5b957935.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/5b957935.html","excerpt":"【均方积分的定义】均方积分设 $\\{X(t),t\\in [a,b]\\}$ 是二阶矩过程，$f(t,u)$ 是 $[a,b]\\times U$ 上的普通函数，$a=t_0&lt;t_1&lt;\\cdots&lt;t_n=b$ 是区间 $[a,b]$ 上的任一划分，取 $\\Delta t_k=t_k-t_{k-1}$，令 $\\Delta=\\max\\limits_{1\\leq k\\leq n} \\Delta_k$，则对 $\\forall t_k^*\\in[t_{k-1},t_k]$，作和式","text":"【均方积分的定义】均方积分设 $\\{X(t),t\\in [a,b]\\}$ 是二阶矩过程，$f(t,u)$ 是 $[a,b]\\times U$ 上的普通函数，$a=t_0&lt;t_1&lt;\\cdots&lt;t_n=b$ 是区间 $[a,b]$ 上的任一划分，取 $\\Delta t_k=t_k-t_{k-1}$，令 $\\Delta=\\max\\limits_{1\\leq k\\leq n} \\Delta_k$，则对 $\\forall t_k^*\\in[t_{k-1},t_k]$，作和式 \\sum_{k=1}^n f(t_k^*,u)X(t_k^*)\\Delta t_k\\in H若均方极限 Y(u)=\\underset{\\Delta \\rightarrow 0}{\\text{l.i.m }} \\sum_{k=1}^n f(t_k^*,u)X(t_k^*)\\Delta t_k存在，且该极限不依赖于对 $[a,b]$ 的分法以及 $t_k^$ 的取法，则称 $\\{f(t,u)X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方可积，其均方极限 $Y(u)$ 称为 $\\{f(t,u)X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上的*均方积分，即有 Y(u)=\\int_{a}^b f(t,u)X(t)dt,\\quad u\\in U此时，称 $\\{Y(u),u\\in U\\}$ 为 $\\{f(t,u)X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上的均方积分过程 特别地，当 $f(t,u)=1$ 时，$\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上的均方积分为一二阶矩变量，即 Y=\\int_a^b X(t)dt广义均方积分设 $\\{X(t),t\\in [a,+\\infty]\\}$ 是二阶矩过程，$f(t,u)$ 是 $[a,+\\infty]\\times U$ 上的普通函数，若对 $\\forall b&gt;a$，有 $\\{f(t,u)X(t),t\\in [a,+\\infty]\\}$ 在 $[a,b]$ 上均方可积，且均方极限 \\underset{b \\rightarrow +\\infty}{\\text{l.i.m }}\\int_{a}^b f(t,u)X(t)dt存在，则称 $\\{f(t,u)X(t),t\\in [a,+\\infty]\\}$ 在 $[a,+\\infty]$ 上广义均方可积，该均方极限称为 $\\{f(t,u)X(t),t\\in [a,+\\infty]\\}$ 在 $[a,+\\infty]$ 上的广义均方积分，即有 \\int_{a}^{+\\infty} f(t,u)X(t)dt=\\underset{b \\rightarrow +\\infty}{\\text{l.i.m }}\\int_{a}^b f(t,u)X(t)dt类似地，可定义 \\begin{align*} \\int_{-\\infty}^{b} f(t,u)X(t)dt=\\underset{a \\rightarrow -\\infty}{\\text{l.i.m }}\\int_{a}^b f(t,u)X(t)dt \\\\ \\int_{-\\infty}^{+\\infty} f(t,u)X(t)dt=\\underset{ \\begin{align*}a \\rightarrow -\\infty\\\\b\\rightarrow +\\infty\\end{align*}}{\\text{l.i.m }}\\int_{a}^b f(t,u)X(t)dt \\\\ \\end{align*}【均方可积准则】设 $\\{X(t),t\\in [a,b]\\}$ 是二阶矩过程，$f(t,u)$ 是 $[a,b]\\times U$ 上的普通函数，则 $\\{f(t,u)X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方可积的充要条件是：下列二重积分存在 \\int_a^b\\int_a^b\\overline{f(s,u)}f(t,u)R_X(s,t)dsdt设 $\\{X(t),t\\in [a,+\\infty]\\}$ 是二阶矩过程，$f(t,u)$ 是 $[a,+\\infty]\\times U$ 上的普通函数，称 $\\{f(t,u)X(t),t\\in [a,+\\infty]\\}$ 在 $[a,+\\infty]$ 上广义均方可积的充要条件是：下列二重积分存在 \\int_a^{+\\infty}\\int_a^{+\\infty}\\overline{f(s,u)}f(t,u)R_X(s,t)dsdt【均方积分的性质】对于二阶矩过程 $\\{X(t),t\\in [a,b]\\}$，其有如下性质： 1）若二阶矩过程 $\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方连续，则 $\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方可积 2）若二阶矩过程 $\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方可积，则其均方积分在概率 $1$ 下是唯一的 3）若二阶矩过程 $\\{f(t,u)X(t),t\\in [a,b]\\}$ 和 $\\{g(t,u)Y(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上都均方可积，则对任意常数 $\\alpha,\\beta$，$\\{\\alpha f(t,u)X(t)+\\beta g(t,u)Y(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上也均方可积，且 \\int_{a}^b (\\alpha f(t,u)X(t)+\\beta g(t,u)Y(t))dt=\\alpha\\int_{a}^b f(t,u)X(t)dt+\\beta\\int_{a}^b g(t,u)Y(t)dt4）若二阶矩过程 $\\{f(t,u)X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方可积，对 $\\forall c,a&lt;c&lt;b$， $\\{f(t,u)X(t),t\\in [a,b]\\}$ 在 $[a,c]$ 和 $[c,b]$ 上也均方可积，且 \\int_{a}^b f(t,u)X(t)dt=\\int_{a}^c f(t,u)X(t)dt+\\int_{c}^b f(t,u)X(t)dt【均方积分过程的数字特征】对于均方积分过程 $\\{Y(u),u\\in U\\}$，二重积分 \\int_a^b\\int_a^b\\overline{f(s,u)}f(t,u)R_X(s,t)dsdt存在，那么 $\\{Y(u),u\\in U\\}$ 的数字特征为： 1）均值函数 \\mu_Y(u)=\\int_a^bf(t,u)\\mu_X(t)dt,\\quad u\\in U2）方差函数 \\sigma_Y(u)=\\int_a^b\\int_a^b\\overline{f(s,u)}f(t,u)C_X(s,t)dsdt,\\quad u\\in U3）协方差函数 C_Y(u,v)=\\int_a^b\\int_a^b\\overline{f(s,u)}f(t,v)C_X(s,t)dsdt,\\quad u,v\\in U4）相关函数 R_Y(u,v)=\\int_a^b\\int_a^b\\overline{f(s,u)}f(t,v)R_X(s,t)dsdt,\\quad u,v\\in U5）均方值函数 \\Phi_Y(u)=\\int_a^b\\int_a^b\\overline{f(s,u)}f(t,u)R_X(s,t)dsdt,\\quad u\\in U【均方不定积分】设二阶矩过程 $\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方连续，令 Y(t)=\\int_{a}^t X(s)ds,\\quad t\\in [a,b]则称 $\\{Y(t),t\\in [a,b]\\}$ 为 $\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上的均方不定积分 进一步，若 $\\{X(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方连续，则其均方不定积分 $\\{Y(t),t\\in [a,b]\\}$ 在 $[a,b]$ 上均方可导，且 \\begin{align*} &P(Y'(t)=X(t)) = 1\\\\ \\mu_Y(t)=&\\int_a^t \\mu_X(s) ds,\\quad t\\in [a,b] \\\\ R_Y(s,t)=&\\int_a^s \\int_a^t R_X(u,v)dudv,\\quad s,t\\in[a,b] \\end{align*}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"随机分析中的均方导数","slug":"stochastic-process/08.随机分析中的均方导数","date":"2022-12-05T13:02:00.000Z","updated":"2023-02-24T08:06:14.546Z","comments":true,"path":"mathematics/stochastic-process/56112c52.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/56112c52.html","excerpt":"【均方导数的定义】设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，$t_0\\in T$，若均方极限 \\underset{\\Delta t\\rightarrow 0}{\\text{l.i.m }} \\frac{X(t_0+\\Delta t)-X(t_0)}{\\Delta t}存在，则称该极限为 $\\{X(t),t\\in T\\}$ 在 $t_0$ 点上的均方导数，记为 $X’(t_0)$ 或 $\\frac{dX(t)}{dt}\\Big|_{t=t_0}$，此时称 $\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方可导","text":"【均方导数的定义】设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，$t_0\\in T$，若均方极限 \\underset{\\Delta t\\rightarrow 0}{\\text{l.i.m }} \\frac{X(t_0+\\Delta t)-X(t_0)}{\\Delta t}存在，则称该极限为 $\\{X(t),t\\in T\\}$ 在 $t_0$ 点上的均方导数，记为 $X’(t_0)$ 或 $\\frac{dX(t)}{dt}\\Big|_{t=t_0}$，此时称 $\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方可导 进一步，若 $\\{X(t),t\\in T\\}$ 在 $T$ 上的每一点 $t$ 处均可导，则称 $\\{X(t),t\\in T\\}$ 在 $T$ 上均方可导，或称 $\\{X(t),t\\in T\\}$ 是均方可导的，此时 $\\{X(t),t\\in T\\}$ 的均方导数是一个新的二阶矩过程，记为 $\\{X’(t),t\\in T\\}$，其是 $\\{X(t),t\\in T\\}$ 的导数过程 若 $\\{X(t),t\\in T\\}$ 的导数过程 $\\{X’(t),t\\in T\\}$ 均方可导，则称 $\\{X(t),t\\in T\\}$ 二阶均方可导，进而 $\\{X(t),t\\in T\\}$ 的二阶均方导数仍为一个新的二阶矩过程，记为 $\\{X’’(t),t\\in T\\}$ 类似地，可定义 $\\{X(t),t\\in T\\}$ 的高阶导数过程 $\\{X^{(n)}(t),t\\in T\\}$ 此外，若 $\\{W(t),t\\in T\\}$ 是参数为 $\\sigma^2$ 的 Wiener 过程，若其均方可导，则其导数过程为 \\{W'(t),t\\in T\\}也被称为参数为 $\\sigma^2$ 的白噪声过程 【均方可导准则】广义二阶可导设 $f(s,t)$ 是普通二元函数，若下列极限存在 \\lim_{\\begin{align*}h\\rightarrow 0\\\\k\\rightarrow 0\\end{align*}}\\frac{f(s+h,t+k)-f(s+h,t)-f(s,t+k)+f(s,t)}{hk}则称 $f(s,t)$ 在 $(s,t)$ 处广义二阶可导，并称该极限为 $f(s,t)$ 在 $(s,t)$ 处的广义二阶导数 根据普通二元函数广义二阶可导的定义，对于二阶矩过程 $\\{X(t),t\\in T\\}$ 的相关函数 $R_X(s,t)$ 广义二阶可导的条件为： 充分条件：$R_X(s,t)$ 关于 $s$ 和 $t$ 的一阶偏导数存在，二阶混合偏导数存在且连续 必要条件：$R_X(s,t)$ 关于 $s$ 和 $t$ 的一阶偏导数存在，二阶混合偏导数存在且相等 二阶矩过程均方可导的条件根据均方可导的定义与均方收敛准则，二阶矩过程 $\\{X(t),t\\in T\\}$ ，在 $t_0\\in T$ 处可导的充要条件是：$R_X(s,t)$ 在 $(t_0,t_0)$ 处广义二阶可导 进一步，有：二阶矩过程 $\\{X(t),t\\in T\\}$ 均方可导的充要条件为 $\\forall t\\in T$，$R_X(s,t)$ 在 $(t,t)$ 处广义二阶可导 结合二阶矩过程 $\\{X(t),t\\in T\\}$ 的相关函数 $R_X(s,t)$ 广义二阶可导的条件，有以下推论： 设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，$t_0\\in T$，则 1）$\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方可导的充分条件是：$R_X(s,t)$ 关于 $s$ 和 $t$ 的一阶偏导数在 $(t_0,t_0)$ 处存在，二阶混合偏导数在 $(t_0,t_0)$ 处存在且连续 2）$\\{X(t),t\\in T\\}$ 均方可导的充分条件是：对 $\\forall t\\in T$，$R_X(s,t)$ 关于 $s$ 和 $t$ 的一阶偏导数在 $(t,t)$ 处存在，二阶混合偏导数在 $(t,t)$ 处存在且连续 3）$\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方可导的必要条件是：$R_X(s,t)$ 关于 $s$ 和 $t$ 的一阶偏导数在 $(t_0,t_0)$ 处存在，二阶混合偏导数在 $(t_0,t_0)$ 处存在且相等 4）$\\{X(t),t\\in T\\}$ 均方可导的必要条件是：对 $\\forall t\\in T$，$R_X(s,t)$ 关于 $s$ 和 $t$ 的一阶偏导数在 $(t,t)$ 处存在，二阶混合偏导数在 $(t,t)$ 处存在且相等 原过程与导数过程设二阶矩过程 $\\{X(t),t\\in T\\}$ 均方可导，则： 1）导数过程 $\\{X’(t),t\\in T\\}$ 的均值函数等于原过程 $\\{X(t),t\\in T\\}$ 均值函数的导数，即 \\mu_X(t)=\\mu_X'(t),\\quad t\\in T2）导数过程 $\\{X’(t),t\\in T\\}$ 和原过程的互相关函数 $R_{X’X}(s,t)$ 等于原过程 $\\{X(t),t\\in T\\}$ 的相关函数 $R_{X}(s,t)$ 关于 $s$ 的偏导数，即 R_{X'X}(s,t)=\\frac{\\partial}{\\partial s}R_X(s,t),\\quad s,t\\in T3）原过程 $\\{X(t),t\\in T\\}$ 和导数过程 $\\{X’(t),t\\in T\\}$ 的互相关函数 $R_{XX’}(s,t)$ 等于原过程 $\\{X(t),t\\in T\\}$ 的相关函数 $R_{X}(s,t)$ 关于 $s$ 的偏导数，即 R_{XX'}(s,t)=\\frac{\\partial}{\\partial s}R_X(s,t),\\quad s,t\\in T4）导数过程 $\\{X’(t),t\\in T\\}$ 的相关函数 $R_{X’}(s,t)$ 等于原过程 $\\{X(t),t\\in T\\}$ 的相关函数 $R_{X}(s,t)$ 的二阶混合偏导数，即 R_{X'}(s,t)=\\frac{\\partial^2}{\\partial s\\partial t} R_X(s,t)= \\frac{\\partial^2}{\\partial t\\partial s} R_X(s,t),\\quad s,t\\in T 若二阶矩过程 $\\{X(t),t\\in T\\}$ $n$ 阶均方可导，则 $n$ 阶导数过程 $\\{X^{(n)}(t),t\\in T\\}$ 的均值函数等于原过程 $\\{X(t),t\\in T\\}$ 的 $n$ 阶导数，即 \\mu_{X^{(n)}}(t)=\\mu_X^{(n)}(t),\\quad t\\in T【均方导数的性质】对于二阶矩过程 $\\{X(t),t\\in T\\}$，其有如下性质： 1）若二阶矩过程 $\\{X(t),t\\in T\\}$ 均方可导，则 $\\{X(t),t\\in T\\}$ 均方连续 2）若二阶矩过程 $\\{X(t),t\\in T\\}$ 均方可导，则其均方导数在概率 $1$ 下是唯一的 3）若二阶矩过程 $\\{X(t),t\\in T\\}$ 和 $\\{Y(t),t\\in T\\}$ 都均方可导，对于任意常数 $a,b$，$\\{aX(t)+bY(t),t\\in T\\}$ 也均方可导，即 (aX(t)+bY(t))'=aX'(t)+bY'(t)4）若二阶矩过程 $\\{X(t),t\\in T\\}$ 均方可导，$f(t)$ 是 $T$ 上普通可导函数，则 $\\{f(t)X(t),t\\in T\\}$ 均方可导，且 (f(t)X(t))'=f'(t)X(t)+f(t)X'(t)5）若二阶矩过程 $\\{X(t),t\\in T\\}$ 均方可导，且 $\\forall t\\in T,X’(t)=0$，则 $X(t)$ 以概率 $1$ 为常值随机变量","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"随机分析中的均方连续","slug":"stochastic-process/07.随机分析中的均方连续","date":"2022-12-05T08:46:00.000Z","updated":"2023-02-24T08:06:24.027Z","comments":true,"path":"mathematics/stochastic-process/e0c519d.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/e0c519d.html","excerpt":"【均方连续的定义】设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，$t_0\\in T$，若 \\underset{t\\rightarrow t_0}{\\text{l.i.m }} X(t) = X(t_0)则称 $\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方连续","text":"【均方连续的定义】设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，$t_0\\in T$，若 \\underset{t\\rightarrow t_0}{\\text{l.i.m }} X(t) = X(t_0)则称 $\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方连续 对 $\\forall t\\in T$，若 $\\{X(t),t\\in T\\}$ 在 $t$ 处都均方连续，则称 $\\{X(t),t\\in T\\}$ 在 $T$ 上均方连续，或称 $\\{X(t),t\\in T\\}$ 是均方连续的 【均方连续准则】设 $\\{X(t),t\\in T\\}$ 是二阶矩过程，$t_0\\in T$，其相关函数为 $R_X(s,t)$，则 $\\{X(t),t\\in T\\}$ 在 $t_0$ 处均方连续的充要条件是：$R_X(s,t)$ 在 $(t_0,t_0)$ 处连续，即 \\lim_{\\begin{align*}s\\rightarrow t_0\\\\t\\rightarrow t_0\\end{align*}} R_X(s,t)=R_X(t_0,t_0)进一步，二阶矩过程 $\\{X(t),t\\in T\\}$ 在 $T$ 上均方连续的充要条件是：对 $\\forall t\\in T$，$R_X(s,t)$ 在 $(t,t)$ 处连续 【均值函数与方差函数】若二阶矩过程 $\\{X(t),t\\in T\\}$ 是均方连续的，则其均值函数与方差函数也是连续函数，即 \\begin{array}{c} \\lim\\limits_{t\\rightarrow t_0} \\mu_X(t)=\\mu_X(t_0) \\\\ \\lim\\limits_{t\\rightarrow t_0} \\sigma_X(t)=\\sigma_X(t_0) \\end{array}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"随机分析中的均方极限","slug":"stochastic-process/06.随机分析中的均方极限","date":"2022-12-05T08:17:00.000Z","updated":"2023-02-24T08:06:34.678Z","comments":true,"path":"mathematics/stochastic-process/2dcd04d3.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/2dcd04d3.html","excerpt":"【二阶矩变量】对于概率空间 $(\\Omega,\\mathscr{F},P)$ 上，具有二阶矩的随机变量称为二阶矩变量，其全体记为 $H$ 设 $X_1,X_2\\in H$，$a,b$ 为任意常数，则","text":"【二阶矩变量】对于概率空间 $(\\Omega,\\mathscr{F},P)$ 上，具有二阶矩的随机变量称为二阶矩变量，其全体记为 $H$ 设 $X_1,X_2\\in H$，$a,b$ 为任意常数，则 aX_1+bX_2\\in H可得 $H$ 为一线性空间 【均方极限的定义】设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，若有二阶矩变量 $X\\in H$，使得 \\lim_{n\\rightarrow \\infty} E|X_n-X|^2=0则称二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}$ 均方收敛于 $X$，或称二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}$ 的均方极限为 $X$，记为 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n = X【均方极限的性质】唯一性设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，有二阶矩变量 $X\\in H$，且 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n = X则 $X$ 在概率 $1$ 下是唯一的 期望与方差设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，有二阶矩变量 $X\\in H$，且 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n = X则 \\begin{array}{c} \\lim\\limits_{n\\rightarrow\\infty} EX_n=E[\\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n]=EX \\\\ \\lim\\limits_{n\\rightarrow\\infty} E|X_n|^2=E[|\\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n|^2]=E|X|^2 \\\\ \\lim\\limits_{n\\rightarrow\\infty} DX_n=D[\\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n]=DX \\\\ \\end{array}运算法则设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\},\\{Y_n,n=1,2,\\cdots\\}\\subset H$，有二阶矩变量 $X,Y\\in H$，且 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n = X, \\quad \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} Y_n = Y则有： \\begin{array}{c} \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} (aX_n+bY_n) = aX+bY \\\\ \\underset{\\begin{align*}n\\rightarrow \\infty \\\\ m\\rightarrow \\infty\\end{align*}}{\\text{l.i.m }} E[\\overline{X_m}Y_n] = E[\\overline{X}Y] \\end{array}二阶矩变量函数设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，有二阶矩变量 $X\\in H$，且 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n = X若 $f(u)$ 是一确定性函数，且满足李普西兹（Lipschitz）条件，即 |f(u)-f(v)|\\leq M|u-v|,\\quad M>0则对二阶矩变量函数序列 $\\{f(X_n),n=1,2,\\cdots\\}\\subset H$，有二阶矩变量函数 $f(X)\\in H$，使得 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} f(X_n) = f(X)特征函数设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，有二阶矩变量 $X\\in H$，且 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} X_n = X则对任意有限的 $t$，有 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} e^{jtX_n} = e^{jtX},\\quad j=\\sqrt{-1}从而使得 \\lim_{n\\rightarrow\\infty}\\varphi_{X_n}(t)=\\varphi_{X}(t)即二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}$ 的特征函数序列收敛于 $X$ 的特征函数 均方大数定律若 $\\{X_n,n=1,2,\\cdots\\}\\subset H$ 是相互独立同分布的随机变量序列，且 $EX_k=\\mu$，则 \\underset{n\\rightarrow \\infty}{\\text{l.i.m }} \\frac{1}{n}\\sum_{k=1}^n X_k = \\mu【均方收敛判定准则】对于已知的二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}$，若想判定该序列是否均方收敛，由于不知道 $X$ 的存在，因此利用均方收敛的定义 E[|X_n-X|^2]\\rightarrow 0来判定序列收敛是极为困难的，为此，给出如下两个收敛判定准则： 1）Cauchy 准则 设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，则该序列均方收敛的充要条件为 \\lim_{\\begin{align*}m\\rightarrow\\infty\\\\n\\rightarrow\\infty\\end{align*}} E|X_m-X_n|^2=02）Loeve 准则 设二阶矩变量序列 $\\{X_n,n=1,2,\\cdots\\}\\subset H$，则该序列均方收敛的充要条件为 \\lim_{\\begin{align*}m\\rightarrow\\infty\\\\n\\rightarrow\\infty\\end{align*}} E[\\overline{X_m}X_n]=c,\\quad |c|","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"二阶矩过程与随机分析","slug":"stochastic-process/05.二阶矩过程与随机分析","date":"2022-12-05T07:49:00.000Z","updated":"2023-02-24T08:06:57.112Z","comments":true,"path":"mathematics/stochastic-process/8060fc86.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/8060fc86.html","excerpt":"【二阶矩过程】若随机过程 $\\{X(t),t\\in T\\}$ 的一、二阶矩存在，则称 $\\{X(t),t\\in T\\}$ 是二阶矩过程 将普通分析的结果推广到二阶矩过程的场合，即研究二阶矩过程 $\\{X(t),t\\in T\\}$ 的连续性、可导性、可积性等，被称为随机分析","text":"【二阶矩过程】若随机过程 $\\{X(t),t\\in T\\}$ 的一、二阶矩存在，则称 $\\{X(t),t\\in T\\}$ 是二阶矩过程 将普通分析的结果推广到二阶矩过程的场合，即研究二阶矩过程 $\\{X(t),t\\in T\\}$ 的连续性、可导性、可积性等，被称为随机分析 由二阶矩过程 $\\{X(t),t\\in T\\}$ 的定义可知，其均值函数、相关函数总是存在的，进而它的其他数字特征也都存在，其相关函数具有如下性质： 共轭对称性：$\\overline{R_X(s,t)}=R_X(t,s),\\:s,t\\in T$ 非负定性：对 $\\forall n\\geq 1$，以及 $\\forall t_1,t_2,\\cdots,t_n\\in T$ 和任意的复数 $\\lambda_1,\\lambda_2,\\cdots,\\lambda_n$，有 \\sum_{k=1}^n\\sum_{l=1}^n R_X(t_k,t_l)\\overline{\\lambda_k}\\lambda_l\\geq 0【正态过程】设 $\\{X(t),t\\in T\\}$ 是一随机过程，若对 $\\forall n\\geq 1$ 以及 $\\forall t_1,t_2,\\cdots,t_n\\in T$，$(X(t_1),X(t_2),\\cdots,X(t_n))$ 是 $n$ 维正态随机向量，则称 $\\{X(t),t\\in T\\}$ 为正态过程，或高斯过程 显然，正态过程是一种二阶矩过程，其有限维分布函数由其均值函数和协方差函数确定 在实际应用中，有时要考虑正态过程的均方导数和均方不定积分的分布，这部分的研究被称为正态过程的随机分析 【Wiener 过程】Wiener 过程来源于物理学中对布朗运动的一种描述，常被用于电路中热噪声的研究 对于实随机过程 $\\{W(t),t\\in T\\}$，若 $W(0)=0$ $\\{W(t),t\\in T\\}$ 是平稳的独立增量过程 $\\forall 0\\leq s&lt;t$，有 $W(t)-W(s)\\sim N(0,\\sigma^2(t-s))$ 则称 $\\{W(t),t\\in T\\}$ 是参数为 $\\sigma^2$ 的 Wiener 过程，显然，Wiener 过程是一种正态过程 对于参数为 $\\sigma^2$ 的 Wiener 过程 $\\{W(t),t\\in T\\}$，有： 服从正态分布：$\\forall t&gt;0$，$W(t)\\sim N(0,\\sigma^2t)$ 均值函数：$\\mu_W(t)=0,\\:t\\geq0$ 方差函数：$\\sigma_{W}(t)=\\sigma^2t,\\: t\\geq0$ 协方差函数与相关函数：$R_W(s,t)=C_W(s,t)=\\sigma^2\\min(s,t),\\:s,t\\geq0$","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"矩阵的奇异值分解","slug":"matrix-theory/13.矩阵的奇异值分解","date":"2022-12-02T04:16:00.000Z","updated":"2022-12-21T13:09:36.908Z","comments":true,"path":"mathematics/matrix-theory/4ceb95bd.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/4ceb95bd.html","excerpt":"【奇异值】设 $A\\in C^{m\\times n}$，记非负定 Hermite 阵 $A^HA$ 的 $n$ 个特征值为 \\lambda_1,\\lambda_2,\\cdots,\\lambda_n称","text":"【奇异值】设 $A\\in C^{m\\times n}$，记非负定 Hermite 阵 $A^HA$ 的 $n$ 个特征值为 \\lambda_1,\\lambda_2,\\cdots,\\lambda_n称 \\sigma_1=\\sqrt{\\lambda_1},\\sigma_2=\\sqrt{\\lambda_2},\\cdots,\\sigma_n=\\sqrt{\\lambda_n}为 $A$ 的奇异值 若 $\\text{rank } A=r$，则 $A^HA$ 具有 $r$ 个正的特征值，通常设 \\sigma_1\\geq \\sigma_2\\geq \\cdots \\geq \\sigma_r> \\sigma_{r+1}=\\sigma_{r+1}=\\cdots=\\sigma_{n}=0称 $\\sigma_1,\\sigma_2,\\cdots,\\sigma_r$ 为 $A$ 的正奇异值 【奇异值分解】设 $A\\in C^{m\\times n},\\text{rank } A=r&gt;0$，则有奇异值分解： U^HAV=\\begin{bmatrix} \\Sigma & O \\\\ O & O \\end{bmatrix}其中，$U$ 为 $m$ 阶酉矩阵，$V$ 为 $n$ 阶酉矩阵，$\\Sigma=\\text{diag }(\\sigma_1,\\sigma_2,\\cdots,\\sigma_r)$，$\\sigma_1\\geq \\sigma_2\\geq \\cdots \\geq \\sigma_r&gt;0$ 为 $A$ 的 $r$ 个正奇异值 【奇异值分解方法】根据奇异值分解的定义可推得： \\begin{align*} AA^HU &= UU^HAVV^HA^HU \\\\ &= U(U^HAV)(U^HAV)^H \\\\ &= U\\begin{bmatrix} \\Sigma^2 & O \\\\ O & O \\end{bmatrix} \\in C^{m\\times m}\\\\ AA^HV &= VV^HAUU^HA^HV \\\\ &= V(U^HAV)^H(U^HAV) \\\\ &= V\\begin{bmatrix} \\Sigma^2 & O \\\\ O & O \\end{bmatrix} \\in C^{n\\times n}\\\\ \\end{align*}这说明酉矩阵 $U$ 的各列是 $AA^H$ 的标准正交特征向量，称为 $A$ 的左奇异向量，酉矩阵 $V$ 的各列是 $A^HA$ 的标准正交特征向量，称为 $A$ 的右奇异值向量 由此，可得求矩阵的奇异值分解的一种方法，即分别求出 $AA^H$ 和 $A^HA$ 的标准正交特征向量，然后构造酉矩阵 $U$ 和酉矩阵 $V$ 需要注意的是，此时需要验证 U^HAV=\\begin{bmatrix} \\Sigma & O \\\\ O & O \\end{bmatrix}是否成立，若成立，则得到 $A$ 的奇异值分解 例如： A=\\begin{bmatrix} 1 & 0 & 0 & -1\\\\ 0 & 1 & 0 & 1\\\\ 0 & 0 & 0 & 0 \\end{bmatrix}由于 A^HA=\\begin{bmatrix} 1 & 0 & 0 & -1\\\\ 0 & 1 & 0 & 1\\\\ 0 & 0 & 0 & 0 \\\\ -1 & 1 & 0 & 2 \\end{bmatrix}的四个特征值分别为 $\\lambda_1=1,\\lambda_2=3,\\lambda_3=\\lambda_4=0$，对应的特征向量分别为 \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\begin{bmatrix} -1 \\\\ 1 \\\\ 0 \\\\ 2 \\end{bmatrix},\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix},\\begin{bmatrix} 1 \\\\ -1 \\\\ 0 \\\\ 1 \\end{bmatrix},由于这些特征向量均已正交，无需再进行 Schmidt 正交化，将它们单位化后即可得正交阵 V=\\begin{bmatrix} \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{6}} & 0 & \\frac{1}{\\sqrt{3}}\\\\ \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} & 0 & -\\frac{1}{\\sqrt{3}}\\\\ 0 & 0 & 1 & 0 \\\\ 0 & \\frac{2}{\\sqrt{6}} & 0 & \\frac{1}{\\sqrt{3}} \\end{bmatrix}又 AA^H=\\begin{bmatrix} 2 & -1 & 0 \\\\ -1 & 2 & 0\\\\ 0 & 0 & 0 \\end{bmatrix}的三个特征值为 $\\mu_1=1,\\mu_2=3,\\mu_3=0$，对应的特征向量分别为 \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix},\\begin{bmatrix} -1 \\\\ 1 \\\\ 0 \\end{bmatrix},\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}由于这些特征向量均已正交，无需再进行 Schmidt 正交化，将它们单位化后即可得正交阵 U=\\begin{bmatrix} \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0\\\\ \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0\\\\ 0 & 0 & 1 \\end{bmatrix}经验证，可得 $A$ 的奇异值分解为 A=U\\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & \\sqrt{3} & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ \\end{bmatrix}V^T","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"矩阵的 Hermite 标准形与满秩分解","slug":"matrix-theory/12.矩阵的Hermite标准形与满秩分解","date":"2022-12-02T02:32:00.000Z","updated":"2022-12-21T12:26:11.980Z","comments":true,"path":"mathematics/matrix-theory/12211cd5.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/12211cd5.html","excerpt":"【Hermite 标准形】定义设 $H\\in C^{m\\times n}$，$\\text{rank } H=r&gt;0$，若 $H$ 满足：","text":"【Hermite 标准形】定义设 $H\\in C^{m\\times n}$，$\\text{rank } H=r&gt;0$，若 $H$ 满足： $H$ 的前 $r$ 行都是非零行，后 $m-r$ 行全为 $0$ $H$ 中包含一个 $r$ 阶子单位矩阵 $I_r$，且 $I_r$ 中的元 $1$ 是所在行的首个非零元 则称 $H$ 为 Hermite 标准形 变换矩阵对于矩阵 $A\\in C^{m\\times n}$，进行一系列行初等变换，那么可将 $A$ 化为 Hermite 标准形 $H$ 由于对 $A$ 进行的行初等变换相当于对 $A$ 左乘一系列初等矩阵，故存在可逆阵 $P$，使得 $PA=H$，即 P\\left[\\begin{array}{c:c} A & I_m \\end{array}\\right] = \\left[\\begin{array}{c:c} PA & P \\end{array}\\right] = \\left[\\begin{array}{c:c} H & P \\end{array}\\right]因此，可采用如下方法来求 $A$ 的 Hermite 标准形与变换矩阵 $P$ \\left[\\begin{array}{c:c} A & I_m \\end{array}\\right] \\xrightarrow{行初等变换} \\left[\\begin{array}{c:c} H & P \\end{array}\\right]等价标准形上述 Hermite 标准形和变换矩阵是针对矩阵的行进行定义的，对称地，也可对矩阵的列定义 Hermite 标准形 对于矩阵 $A\\in C^{m\\times n}$，若 $\\text{rank }A=r&gt;0$，则存在可逆阵 $P$ 将 $A$ 化为 Hermite 标准形 PA=\\begin{bmatrix} H\\\\ O \\end{bmatrix}其中，$H\\in C^{n\\times n}$，且包含一个 $r$ 阶单位矩阵 $I_r$ 对 $PA$ 进行一系列列初等变换后，则存在可逆阵 $Q$，使得 PAQ=\\begin{bmatrix} H\\\\ O \\end{bmatrix}Q =\\begin{bmatrix} HQ\\\\ O \\end{bmatrix}=\\begin{bmatrix} I_r & O\\\\ O &O \\end{bmatrix}若存在可逆阵 $P,Q$，使得 $A=PBQ$，则称矩阵 $A$ 与 $B$ 是等价的，此时，称上式为 $A$ 的等价标准形 可采用如下方法求变换矩阵 $P,Q$ 以及等价标准形 \\left[\\begin{array}{c:c} A & I_m\\\\ \\hdashline I_n & \\end{array}\\right] \\xrightarrow{行、列初等变换} \\left[\\begin{array}{c:c} \\begin{bmatrix} I_r & O\\\\ O &O \\end{bmatrix} & P \\\\ \\hdashline Q \\end{array}\\right]即对 $A$ 进行行初等变换时，单位阵 $I_m$ 记录了变换矩阵 $P$；对 $A$ 进行列初等变换时，单位阵 $I_n$ 记录了变换矩阵 $Q$ 【满秩分解】满秩矩阵设 $A\\in C^{m\\times n}$，若 $\\text{rank }A=m$，则称 $A$ 为行满秩矩阵 $\\text{rank }A=n$，则称 $A$ 为列满秩矩阵 显然，$A$ 为满秩矩阵的充要条件是：$A$ 既行满秩又列满秩 若 $A$ 是行（列）满秩矩阵，其具有如下性质： $A^HA$ 的特征值大于 $0$ $A^HA$ 是正定 Hermite 矩阵 $A^HA$ 是 $r$ 阶可逆矩阵 满秩分解设 $A\\in C^{m\\times n}$，若存在列满秩矩阵 $F$ 与行满秩矩阵 $G$，使得 A=FG则称 $A$ 有满秩分解 需要注意的是，$A$ 的满秩分解不是唯一的 满秩分解方法对于 $A\\in C^{m\\times n}$，若 $\\text{rank }A=r&gt;0$，则 $A$ 必有满秩分解，具体分解步骤如下： 1）对 $A$ 进行行初等变换，求出 $A$ 的 Hermite 标准形 $H$ 2）设 $H$ 中单位子矩阵 $I$，所在列为 $i_1,i_2,\\cdots,i_r$，由于对 $A$ 进行初等行变换不会影响 $A$ 列向量间的线性组合关系，易得 $A$ 的最大无关列为 A_{i_1},A_{i_2},\\cdots,A_{i_r}故列满秩矩阵可取为 F=\\begin{bmatrix} A_{i_1} & A_{i_2} & \\cdots & A_{i_r} \\end{bmatrix}3）由于 $Q^{-1}$ 是 $Q$ 的逆置换，故 G=\\begin{bmatrix} I_r & S \\end{bmatrix} Q^{-1}恰好为 $A$ 的 Hermite 标准形 $H$ 的前 $r$ 行构成的矩阵 例如： A=\\begin{bmatrix} 7 & 14 & 0 & 0 & 35\\\\ 1 & 2 & 4 & 12 & 13\\\\ 3 & 6 & 0 & 0 & 15\\\\ 2 & 4 & 5 & 15 & 20 \\end{bmatrix}对 $A$ 进行初等变换，将 $A$ 化为 Hermite 标准形 $H$ A=\\begin{bmatrix} 7 & 14 & 0 & 0 & 35\\\\ 1 & 2 & 4 & 12 & 13\\\\ 3 & 6 & 0 & 0 & 15\\\\ 2 & 4 & 5 & 15 & 20 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 1 & 2 & 0 & 0 & 5\\\\ 0 & 0 & 1 & 3 & 2\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 \\end{bmatrix} =H由于 $i_1=1,i_2=3$，故取 $A$ 的一、三列构成列满秩矩阵 $F$，再取 $H$ 的第一、二行构成行满秩矩阵 $G$，故 A= FG=\\begin{bmatrix} 7 & 0 \\\\ 1 & 4 \\\\ 3 & 0 \\\\ 2 & 5 \\end{bmatrix}\\begin{bmatrix} 1 & 2 & 0 & 0 & 5\\\\ 0 & 0 & 1 & 3 & 2 \\end{bmatrix}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"矩阵的正交三角分解","slug":"matrix-theory/11.矩阵的正交三角分解","date":"2022-12-02T01:54:00.000Z","updated":"2023-02-24T08:00:30.994Z","comments":true,"path":"mathematics/matrix-theory/30c67d9b.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/30c67d9b.html","excerpt":"【QR 分解】设 $A\\in C^{n\\times n}$，若 $A$ 可分解为 A=QR其中，$Q$ 为 $n$ 阶酉矩阵，$R$ 为上三角阵，则称 $A$ 可 QR 分解","text":"【QR 分解】设 $A\\in C^{n\\times n}$，若 $A$ 可分解为 A=QR其中，$Q$ 为 $n$ 阶酉矩阵，$R$ 为上三角阵，则称 $A$ 可 QR 分解 当 $A$ 为可逆实数矩阵时，QR 分解又称为正交三角分解，此时，$Q$ 为正交阵，$R$ 为实上三角阵 当 $A$ 为可逆复数矩阵时，QR 分解又称为酉三角分解，此时，$Q$ 为酉矩阵，$R$ 为复上三角阵 【QR 分解具体方法】Householde 矩阵由于 $A$ 不一定可逆，因此使用 Schmidt 标准正交化方法对 $A$ 进行 QR 分解不一定能进行 在实际应用中，常采用镜像变换 H=I_n-2\\omega\\omega^H,\\quad \\omega\\in C^n,||\\omega||_2=1变换矩阵 $H$ 被称为 Householde 矩阵，其具有如下性质： 变换矩阵为酉矩阵：$H^HH=I_n$ 变换矩阵为 Hermite 阵：$H^H=H$ 变换矩阵为对合阵：$H^2=I_n$ 对于给定 $C^n$ 中的单位向量 $\\mathbf{e}$，有 $\\forall \\mathbf{x}\\in C^n$，存在复数 $a$ 与 $n$ 阶复 Householde 矩阵 $H$，使得 H\\mathbf{x}=a\\mathbf{e}其中，复数 $a$ 满足条件 |a|=||\\mathbf{x}||_2且 $a\\mathbf{x}^H\\mathbf{e}$ 为实数 Householde 进行 QR 分解设 $A=[B_1,B_2,\\cdots,B_n],B_i\\in C^{n}$，则存在复数 $a_1$ 与 $n$ 阶 Householde 矩阵 $H_1$，使得 H_1B_1=a_1\\mathbf{e}_1,\\quad \\mathbf{e}_1=[1,0,\\cdots,0]^T\\in C^n从而有 H_1A=\\begin{bmatrix} a_1 & a_{12}^{(1)} & \\cdots & a_{1n}^{(1)} \\\\ 0 & a_{22}^{(1)} & \\cdots & a_{2n}^{(1)} \\\\ \\vdots & \\vdots& \\ddots & \\vdots \\\\ 0 & a_{n2}^{(1)} & \\cdots & a_{nn}^{(1)} \\\\ \\end{bmatrix} \\triangleq \\left[ \\begin{array}{c:ccc} a_1 & a_{12}^{(1)} &\\cdots & a_{1n}^{(1)} \\\\ \\hdashline 0 & && \\\\ \\vdots &&A_1& \\\\ 0 &&& \\end{array} \\right]设 $A_1=[B_1^{(1)},B_2^{(1)},\\cdots,B_{n-1}^{(1)}],B_i^{(1)}\\in C^{n-1}$，则存在复数 $a_2$ 与 $n-1$ 阶 Householde 矩阵 $H_{21}$，使得 H_{21}B_1^{(1)}=a_2\\mathbf{\\tilde{e}}_1,\\quad \\mathbf{\\tilde{e}}_1=[1,0,\\cdots,0]^T\\in C^{n-1}令 $H_2=\\begin{bmatrix}1&amp;\\\\&amp;H_{21}\\end{bmatrix}$，则 $H_2$ 仍为酉矩阵，且有 H_2H_1A= \\left[ \\begin{array}{c:ccc} a_1 & a_{12}^{(1)} &\\cdots & a_{1n}^{(1)} \\\\ \\hdashline 0 & && \\\\ \\vdots &&H_{21}A_1& \\\\ 0 &&& \\end{array} \\right] \\triangleq \\left[ \\begin{array}{cc:ccc} a_1 & a_{12}^{(1)}&a_{13}^{(1)} &\\cdots & a_{1n}^{(1)} \\\\ 0 & a_{2} & a_{23}^{(2)} & \\cdots & a_{2n}^{(1)} \\\\ \\hdashline 0 & 0 &&& \\\\ \\vdots&\\vdots &&A_2& \\\\ 0 &0 &&& \\end{array} \\right]重复以上步骤，即存在一系列酉矩阵 $H_1,H_2,\\cdots,H_{n-1}$，使得 H_{n-1}\\cdots H_1 A=\\begin{bmatrix} a_1 & * & \\cdots & \\cdots & * \\\\ & a_2 & \\ddots & & \\vdots \\\\ & & \\ddots & \\ddots & \\vdots \\\\ & & &a_{n-1} & * \\\\ & & & & a_{nn}^{(n-1)} \\end{bmatrix} \\triangleq R即矩阵 $A$ 有 QR 分解 A=H_1\\cdots H_{n-1}R\\triangleq QR其中，$Q=H_1\\cdots H_{n-1}$ 为酉矩阵，$R$ 为上三角阵","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"二维随机过程与复随机过程","slug":"stochastic-process/04.二维随机过程与复随机过程","date":"2022-11-28T13:45:00.000Z","updated":"2023-02-24T08:07:02.737Z","comments":true,"path":"mathematics/stochastic-process/4c9cefe5.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/4c9cefe5.html","excerpt":"【联合分布函数】在实际应用中，有时需要同时考虑两个或两个以上随机过程的统计特征 例如，某个线性系统的输入是一个随机过程 $\\{X(t),t\\in T\\}$，其输出也是一个随机过程 $\\{Y(t),t\\in T\\}$，那么，此时就要考虑这两个随机过程的联合统计特性","text":"【联合分布函数】在实际应用中，有时需要同时考虑两个或两个以上随机过程的统计特征 例如，某个线性系统的输入是一个随机过程 $\\{X(t),t\\in T\\}$，其输出也是一个随机过程 $\\{Y(t),t\\in T\\}$，那么，此时就要考虑这两个随机过程的联合统计特性 此外，与概率论中的复随机变量类似，随机过程中也有复随机过程，其是由二维随机过程给出的 【二维随机过程】联合分布函数设 $\\{X(t),t\\in T\\}$ 和 $\\{Y(t),t\\in T\\}$ 是定义在同一概率空间上的两个随机过程，则称 \\{(X(t),Y(t)),t\\in T\\}为二维随机过程 那么，对任意的 $m\\geq 1,n\\geq 1$，$t_1,\\cdots,t_m\\in T$，$t_1’,\\cdots,t_n’\\in T$，有 (X_1(t),\\cdots,X_m(t),Y_1(t_1'),\\cdots,Y(t_n'))是 $m+n$ 维随机变量，称 \\begin{align*} &F(t_1,\\cdots,t_m;x_1,\\cdots,x_m;t_1',\\cdots,t_n';y_1,\\cdots,y_n) \\\\ =& P(X(t_1)\\leq x_1,\\cdots,X(t_m)\\leq x_m,Y(t_1')\\leq y_1,\\cdots,Y(t_n')\\leq y_n) \\end{align*}为二维随机过程 $\\{(X(t),Y(t)),t\\in T\\}$ 的 $m+n$ 维联合分布函数 边缘分布函数二维随机过程 $\\{(X(t),Y(t)),t\\in T\\}$ 作为一个整体，具有 $m+n$ 维分布函数，而随机过程 $\\{X(t),t\\in T\\}$ 具有 $m$ 维分布函数，随机过程 $\\{Y(t),t\\in T\\}$ 具有 $n$ 维分布函数，将他们分别记为 \\begin{array}{cc} F_X(t_1,t_2,\\cdots,t_m;x_1,x_2,\\cdots,x_m) \\\\ F_Y(t_1',t_2',\\cdots,t_n';y_1,y_2,\\cdots,y_n) \\end{array}那么，对于二维随机过程 $\\{(X(t),Y(t)),t\\in T\\}$，分别称两者为 $\\{(X(t),Y(t)),t\\in T\\}$ 关于 $\\{X(t),t\\in T\\}$ 和关于 $\\{Y(t),t\\in T\\}$ 的 $m$ 维边缘分布函数和 $n$ 维边缘分布函数 此外，若有 \\begin{align*} &F(t_1,\\cdots,t_m;x_1,\\cdots,x_m;t_1',\\cdots,t_n';y_1,\\cdots,y_n) \\\\ =& F_X(t_1,\\cdots,t_m;x_1,\\cdots,x_m) F_Y(t_1,\\cdots,t_n';y_1,\\cdots,y_n) \\end{align*}则称 $\\{X(t),t\\in T\\}$ 和 $\\{Y(t),t\\in T\\}$ 相互独立 数字特征设 $\\{(X(t),Y(t)),t\\in T\\}$ 是二维随机过程，$\\forall s,t\\in T$，$X(s),Y(t)$ 是两个随机变量 若 $E[X(s)Y(t)]$ 存在，记为 $R_{XY}(s,t)$，称其为随机过程 $\\{(X(t),Y(t)),t\\in T\\}$ 的互相关函数 若 $Cov(X(s),Y(t))$ 存在，记为 $C_{XY}(s,t)$，称其为随机过程 $\\{(X(t),Y(t)),t\\in T\\}$ 的互协方差函数 显然，有 C_{XY}(s,t)=R_{XY}(s,t)-\\mu_X(s)\\mu_Y(t)此外，若 $C_{XY}(s,t)=0$ 或 $R_{XY}(s,t)=\\mu_X(s)\\mu_Y(t)$，则称 $\\{X(t),t\\in T\\}$ 与 $\\{Y(t),t\\in T\\}$ 不相关 进一步，可知，若 $\\{X(t),t\\in T\\}$ 与 $\\{Y(t),t\\in T\\}$ 相互独立，则 $\\{X(t),t\\in T\\}$ 与 $\\{Y(t),t\\in T\\}$ 不相关 【复随机过程】设 $\\{X(t),t\\in T\\}$ 与 $\\{Y(t),t\\in T\\}$ 是定义在同一概率空间上的两个实随机过程，令 Z(t)=X(t)+jY(t),\\quad t\\in T,j=\\sqrt{-1}则称 $\\{Z(t),t\\in T\\}$ 是复随机过程 复随机过程的任意有限维可由二维随机过程 $\\{(X(t),Y(t)),t\\in T\\}$ 的所有 $n+m$ 维联合分布函数给出 其数字特征的定义如下： 均值函数：$\\mu_Z(t)=E[Z(t)]$ 方差函数：$\\sigma_Z(t)=D[Z(t)]=E|Z(t)-\\mu_Z(t)|^2$ 协方差函数：$C_Z(s,t)=Cov(Z(s),Z(t))=E[\\overline{(Z(s)-\\mu_Z(s))}(Z(t)-\\mu_Z(t))]$ 相关函数：$R_Z(s,t)=E[\\overline{Z(s)}Z(t)])$ 均方值函数：$\\Phi_Z(t)=E|Z(t)|^2$ 易知，复随机过程的数字特征间有如下关系： \\begin{array}{c} \\mu_Z(t)= \\mu_X(t)+j\\mu_Y(t) \\\\ \\sigma_Z(t)= \\sigma_X(t)+\\sigma_Y(t)\\\\ \\sigma_Z(t)= C_Z(t,t)\\\\ C_Z(s,t)= R_Z(s,t)-\\overline{\\mu_Z(s)}\\mu_Z(t)\\\\ \\Phi_Z(t)= R_Z(t,t) \\end{array}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"随机过程的数字特征","slug":"stochastic-process/03.随机过程的数字特征","date":"2022-11-28T10:36:00.000Z","updated":"2023-02-24T08:07:05.321Z","comments":true,"path":"mathematics/stochastic-process/300a0201.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/300a0201.html","excerpt":"【引入】随机过程的有限维分布函数族虽然是对随机过程的概率特征的完整描述，但在实际应用中却难以求得 同时，对于某些随机过程，为表征其概率特征，不一定要求出它的有限维分布函数族，只需要求出随机过程的几个表征值即可","text":"【引入】随机过程的有限维分布函数族虽然是对随机过程的概率特征的完整描述，但在实际应用中却难以求得 同时，对于某些随机过程，为表征其概率特征，不一定要求出它的有限维分布函数族，只需要求出随机过程的几个表征值即可 为此，像概率论中研究随机变量的数字特征一样，给出随机过程的数字特征，其是利用随机变量的数字特征来定义的 【均值函数】设 $\\{X(t),t\\in T\\}$ 为一随机过程，$X(t)$ 为随机变量，若 $E[X(t)]$ 存在，记为 $\\mu_X(t)$，称其为随机过程 $\\{X(t),t\\in T\\}$ 的均值函数 若 $\\{X(t),t\\in T\\}$ 的一维分布函数为 $F(t;x)$，那么 \\mu_X(t)=E[X(t)]=\\int_{-\\infty}^{+\\infty} x dF(x),\\quad t\\in T随机过程的均值函数 $\\mu_X(t)$ 在 $t$ 时刻的值表示随机过程在 $t$ 时刻所处状态取值的理论平均值，当 $t\\in T$ 时，$\\mu_X(t)$ 在几何上表示一条固定的曲线 【方差函数】设 $\\{X(t),t\\in T\\}$ 为一随机过程，$X(t)$ 为随机变量，若 $D[X(t)]$ 存在，记为 $\\sigma_X(t)$，称其为随机过程 $\\{X(t),t\\in T\\}$ 的方差函数，有 \\sigma_X(t)=D[X(t)]=E[X(t)-\\mu_X(t)]^2,\\quad t\\in T随机过程的方差函数 $\\sigma_X(t)$ 在 $t$ 时刻的值表示随机过程在 $t$ 时刻所处状态取值偏离均值的偏差程度 将随机过程的若干样本函数、均值函数、方差函数画到同一坐标系中，可以看到，均值函数刻画了随机过程在各时刻的摆动中心，方差函数刻画了随机过程在各时刻对均值的偏离程度 【协方差函数】设 $\\{X(t),t\\in T\\}$ 为一随机过程，对于 $\\forall s,t \\in T$，$X(t),X(s)$ 为两个随机变量，若 $Cov(X(s),X(t))$ 存在，记为 $C_X(s,t)$，称其为随机过程 $\\{X(t),t\\in T\\}$ 的协方差函数，有 \\begin{align*} C_X(s,t) &=Cov(X(s),X(t)) \\\\ &=E\\big[(X(s)-\\mu_X(s))(X(t)-\\mu_X(t))\\big] \\\\ &=E[X(s)X(t)]-\\mu_X(s)\\mu_X(t)\\\\ \\end{align*}随机过程的协方差函数 $C_X(s,t)$ 在 $s,t\\in T$ 时刻的值表示随机过程在 $s,t$ 时刻所处状态的线性联系的密切程度 若 $C_X(s,t)$ 的绝对值较大，说明在两个时刻 $s,t$ 的状态 $X(s)$ 和 $X(t)$ 的线性联系较为密切；若 $C_X(s,t)$ 的绝对值较小，说明在两个时刻 $s,t$ 的状态 $X(s)$ 和 $X(t)$ 的线性联系不密切 【相关函数】设 $\\{X(t),t\\in T\\}$ 为一随机过程，对于 $\\forall s,t \\in T$，$X(t),X(s)$ 为两个随机变量，若 $E[X(s)X(t)]$ 存在，记为 $R_X(s,t)$，称其为随机过程 $\\{X(t),t\\in T\\}$ 的相关函数，有 R_X(s,t)=E[X(s)X(t)]随机过程的相关函数 $R_X(s,t)$ 在 $s,t\\in T$ 时刻的值表示随机过程在 $s,t$ 时刻所处状态的线性相关关系 【均方值函数】设 $\\{X(t),t\\in T\\}$ 为一随机过程，$X(t)$ 为随机变量，若 $E[X(t)]^2$ 存在，记为 $\\Phi_X(t)$，称其为随机过程 $\\{X(t),t\\in T\\}$ 的均方值函数 若 $\\{X(t),t\\in T\\}$ 的一维分布函数为 $F(t;x)$，那么 \\Phi_X(t)=E[X(t)]^2=\\int_{-\\infty}^{+\\infty} x^2 dF(x),\\quad t\\in T【各数字特征间的关系】随机过程 $\\{X(t),t\\in T\\}$ 的协方差函数、相关函数、均值函数的关系为 C_X(s,t)=R_X(s,t)-\\mu_X(s)\\mu_X(t),\\quad s,t\\in T在协方差函数的定义式中，取 $s=t$，则随机过程的方差函数和协方差函数的关系为 D_X(t)=C_X(t,t),\\quad t\\in T类似地，均方值函数和相关函数的关系为 \\Phi_X(t)=R_X(t,t),\\quad t\\in T从上述关系可看出，均值函数和相关函数是随机过程的两个本质数字特征，其他的数字特征可以通过这个两个本质数字特征获得 此外，随机过程的均值函数也被称为随机过程的一阶矩，均方值函数也被随机过程的二阶矩","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"随机过程的分布函数与特征函数","slug":"stochastic-process/02.随机过程的分布函数与特征函数","date":"2022-11-28T09:21:00.000Z","updated":"2023-02-24T08:02:47.660Z","comments":true,"path":"mathematics/stochastic-process/ec97b9f8.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/ec97b9f8.html","excerpt":"【分布函数】无论随机过程属于哪一类，均需要找出它的统计特性，才能讨论它的性质，研究统计特性的一种方法，就是求该随机过程的有限维分布函数族，在引入有限维分布函数族前，首先给出随机分布随机函数的定义 设 $\\{X(t),t\\in T\\}$ 是随机过程，对于任意固定的 $t\\in T$，$X(t)$ 是一随机变量，称","text":"【分布函数】无论随机过程属于哪一类，均需要找出它的统计特性，才能讨论它的性质，研究统计特性的一种方法，就是求该随机过程的有限维分布函数族，在引入有限维分布函数族前，首先给出随机分布随机函数的定义 设 $\\{X(t),t\\in T\\}$ 是随机过程，对于任意固定的 $t\\in T$，$X(t)$ 是一随机变量，称 F(t;x)=P(X(t)\\leq x),\\quad x\\in R,t\\in T为随机过程 $\\{X(t),t\\in T\\}$ 的一维分布函数 对于任意固定的 $t_1,t_2\\in T$，$X(t_1),X(t_2)$ 是两个随机变量，称 F(t_1,t_2;x_1,x_2)=P(X(t_1)\\leq x_1,X(t_2)\\leq x_2),\\quad x_1,x_2\\in R,t_1,t_2\\in T为随机过程 $\\{X(t),t\\in T\\}$ 的二维分布函数 推广到 $n$ 维，对于任意固定的 $t_1,\\cdots,t_n\\in T$，$X(t_1),\\cdots,X(t_n)$ 是 $n$ 个随机变量，称 F(t_1,\\cdots,t_n;x_1,\\cdots,x_n)=P(X(t_1)\\leq x_1,\\cdots,X(t_n)\\leq x_n),\\quad x_i\\in R,t_i\\in T为随机过程 $\\{X(t),t\\in T\\}$ 的 $n$ 维分布函数 【有限维分布函数族】在有了随机过程分布函数的概念后，即可给出随机过程有限维分布函数族的概念 设 $\\{X(t),t\\in T\\}$ 为一随机过程，其是一维分布函数、二维分布函数、$\\cdots$、$n$ 维分布函数的全体，即 F=\\{F(t_1,\\cdots,t_n;x_1,\\cdots,x_n),x_i\\in R,t_i\\in T,i=1,2,\\cdots,n\\}称为随机过程 $\\{X(t),t\\in T\\}$ 的有限维分布函数族 那么，如果知道了随机过程 $\\{X(t),t\\in T\\}$ 的 $n$ 维分布函数全体，即可知道随机过程 $\\{X(t),t\\in T\\}$ 中任意 $n$ 个随机变量的联合分布 进一步，如果知道了随机过程 $\\{X(t),t\\in T\\}$ 的有限维分布函数族，即可知道随机过程 $\\{X(t),t\\in T\\}$ 中任意有限个随机变量的联合分布，从而确定它们间的相互关系 随机过程的有限维分布函数族具有以下两性质 1）对称性：设 $i_1i_2\\cdots i_n$ 是 $1,2,\\cdots,n$ 的任一排列，则 F(t_{i_1},t_{i_2},\\cdots,t_{i_n};x_{i_1},x_{i_2},\\cdots,x_{i_n}) = F(t_1,t_2,\\cdots,t_n;x_1,x_2,\\cdots,x_n)2）相容性：设 $m&lt;n$，则 F(t_1,\\cdots,t_m;x_1,\\cdots,x_m) = F(t_1,\\cdots,t_m,t_{m+1},\\cdots,t_n;x_1,\\cdots,x_m,+\\infty,\\cdots,+\\infty)【特征函数】在概率论中，研究随机变量的统计特性除使用分布函数外，另一重要的方法就是通过特征函数，且随机变量的分布函数与特征函数有意义对应的关系 那么，在随机过程中，也可通过随机过程的有限维特征函数来研究随机过程的统计特性 设 $\\{X(t),t\\in T\\}$ 是一随机过程，对任意固定的 $t_1,\\cdots,t_n\\in T$，$X(t_1),\\cdots,X(t_n)$ 是 $n$ 个随机变量，称 \\begin{align*} & \\varphi(t_1,\\cdots,t_n;u_1,\\cdots,u_n) \\\\ =& E\\big\\{ \\exp\\big[ j(u_1X(t_1)+\\cdots+u_nX(t_n)) \\big]\\big\\} \\\\ =& \\int_{-\\infty}^{+\\infty}\\cdots\\int_{-\\infty}^{+\\infty} \\exp\\big[ j(u_1X(t_1)+\\cdots+u_nX(t_n)) dF(t_1,\\cdots,t_n;x_1,\\cdots,x_n) \\\\ & u_i\\in \\mathbb{R},\\quad t_i\\in T,\\quad i=1,2,\\cdots,n,\\quad j=\\sqrt{-1} \\end{align*}为随机过程 $\\{X(t),t\\in T\\}$ 的 $n$ 维特征函数，称 \\Phi=\\{ \\varphi(t_1,\\cdots,t_n;u_1,\\cdots,u_n),u_i\\in\\mathbb{R},t_i\\in T,i=1,2,\\cdots,n,n\\in N \\}为随机过程 $\\{X(t),t\\in T\\}$ 的 有限维特征函数族","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"随机过程的基本概念","slug":"stochastic-process/01.随机过程的基本概念","date":"2022-11-28T08:09:00.000Z","updated":"2023-02-24T08:03:33.912Z","comments":true,"path":"mathematics/stochastic-process/ffdf5716.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/stochastic-process/ffdf5716.html","excerpt":"【随机过程的定义】随机过程是概率论的继续与发展，其研究对象是随时间演变的随机现象 从数学的角度来说，就是事物的变化过程无法用一个或几个由时间 $t$ 来确定的函数进行描绘，也就是说，对事物变化的过程进行一次观察，得到的结果是一个关于时间 $t$ 的函数，但对同一事物的变化过程独立地进行多次观察，得到的结果是不同的","text":"【随机过程的定义】随机过程是概率论的继续与发展，其研究对象是随时间演变的随机现象 从数学的角度来说，就是事物的变化过程无法用一个或几个由时间 $t$ 来确定的函数进行描绘，也就是说，对事物变化的过程进行一次观察，得到的结果是一个关于时间 $t$ 的函数，但对同一事物的变化过程独立地进行多次观察，得到的结果是不同的 随机过程被定义为一族二元函数，设 $(\\Omega,\\mathscr{F},P)$ 是一概率空间，$T$ 是一个实参数集，对于定义在 $\\Omega$ 与 $T$ 上的二元函数 $X(\\omega,t)$，若对任意固定的 $t\\in T$，$X(\\omega,t)$ 是 $(\\Omega,\\mathscr{F},P)$ 上的随机变量，则称 \\{X(\\omega,t),\\omega\\in\\Omega,t\\in T\\}为概率空间 $(\\Omega,\\mathscr{F},P)$ 上的随机过程，记为 $\\{X(t),t\\in T\\}$ 固定 $\\omega=\\omega_0\\in\\Omega$，此时，$X(t)$ 是定义在 $T$ 上的一个不再具有随机性的普通函数，记为 $x(t)$，称为随机过程的一个样本函数，其图像是随机过程的一条样本曲线 固定 $t=t_0\\in T$，此时 $X(t)$ 在 $t_0$ 的数值为 $X(t_0)$，第一次试验值为 $x_1(t_0)$，第二次试验值为 $x_2(t_0)$，以此类推，显然 $X(t)$ 是一个随机变量，由此，存在如下定义： 设 $\\{X(t),t\\in T\\}$ 是随机过程，则当 $t$ 固定时，$X(t)$ 是一个随机变量，其是随机过程 $\\{X(t),t\\in T\\}$ 在 $t$ 时刻的状态 随机变量 $X(t)$（$t$ 固定且 $t\\in T$）所有可能的取值构成的集合被称为随机过程的状态空间，记为 $S$ 【随机过程的类型】根据参数集 $T$ 和状态空间 $S$ 是离散集还是连续集，可分为以下四类 1）离散参数、离散状态 参数集 $T$ 是离散的，对于固定的 $t\\in T$，$X(t)$ 是离散型随机变量 考虑投掷一颗骰子的试验，设 $X_n$ 是第 $n$ 次投掷的点数，对于 $n=1,2,\\cdots$ 的不同值，$X_n$ 是不同的随机变量 因而 $\\{X_n,n\\geq 1\\}$ 构成一随机过程，称为伯努利过程，其参数集为 $T=\\{1,2,\\cdots\\}$，状态空间为 $S=\\{1,2,\\cdots,6\\}$ 2）离散参数、连续状态 参数集 $T$ 是离散的，对于固定的 $t\\in T$，$X(t)$ 是连续型随机变量 设 $X_n,n=\\cdots,-2,-1,0,1,2,\\cdots$ 是相互独立且同分布服从标准正态分布的随机变量，则 $\\{X_n,n=\\cdots,-2,-1,0,1,2,\\cdots\\}$ 为一随机过程，其参数集为 $T=\\{\\cdots,-2,-1,0,1,2,\\cdots\\}$，状态空间为 $S=(-\\infty,+\\infty)$ 3）连续参数、离散状态 参数集 $T$ 是连续的，对于固定的 $t\\in T$，$X(t)$ 是离散型随机变量 设 $X(t)$ 为在 $[0,t]$ 期间内到达服务点的顾客数，对于 $t\\in [0,+\\infty)$ 的不同值，$X(t)$ 是不同的随机变量，则 $\\{X(t),t\\geq 0\\}$ 构成一随机过程，其参数集为 $T=[0,+\\infty)$，状态空间为 $S=\\{0,1,2,\\cdots\\}$ 4）连续参数、连续状态 参数集 $T$ 是连续的，同时对于固定的 $t\\in T$，$X(t)$ 是连续型随机变量 设 $X(t)=A\\cos (\\omega t+\\varphi),-\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"随机过程","slug":"mathematics/stochastic-process","permalink":"https://alex-mcavoy.github.io/categories/mathematics/stochastic-process/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"随机过程","slug":"stochastic-process","permalink":"https://alex-mcavoy.github.io/tags/stochastic-process/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（八）使用 Flask 与 Vue 开发 Web","slug":"skyhackathon/08.NVIDIA 7th SkyHackathon（八）使用 Flask 与 Vue 开发 Web","date":"2022-11-25T12:39:00.000Z","updated":"2023-02-06T03:25:45.801Z","comments":true,"path":"nvidia/skyhackathon/fb177d1b.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/fb177d1b.html","excerpt":"页面效果Web 采用 flask+vue 开发，效果图如下","text":"页面效果Web 采用 flask+vue 开发，效果图如下 后端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import sysimport subprocessimport osfrom PIL import Imagefrom datetime import datetimefrom ASR_metrics import utils as metricsfrom werkzeug.wrappers import Request, Responsefrom flask import Flask, render_template, request, jsonifysys.path.append('/home/nvidia/7th_CV')sys.path.append('/home/nvidia/7th_ASR')# ASR 路径pathASR = \"/home/nvidia/7th_ASR\"# 项目路径pathSky = '/home/nvidia'app = Flask(__name__, static_folder='')# 上传路径uploadPath = 'uploads/'try_model_1 = None# 主页@app.route('/')def index(): return render_template('sky7.html', template_folder='templates')# ------------------ASR------------------# ASR 模型加载@app.route('/asr/load')def asrLoad(): global try_model_1 if try_model_1 == None: import nemo.collections.asr as nemo_asr print('Loading Nemo') # 加载模型 try_model_1 = nemo_asr.models.EncDecCTCModel.restore_from(\"/home/nvidia/7th_ASR/7th_asr_model.nemo\") print('Done loading Nemo') return 'ok'# POST 请求上传音频@app.route('/asr/upload', methods=['POST'])def asrUpload(): if request.method == 'POST': f = request.files['file'] if(f.headers.get('Content-Type') != 'audio/wav'): return '音频格式有错误', 400 else: fileName = f'&#123;uploadPath&#125;audio.wav' f.save(fileName) dt = datetime.now() ts = str(int(datetime.timestamp(dt))) return jsonify(f'/&#123;uploadPath&#125;audio.wav?t=&#123;ts&#125;')# 识别上传的音频@app.route('/asr/identify', methods=['GET', 'POST'])def asrIdentify(): global try_model_1 if try_model_1 == None: return '模型无效，请重新加载', 500 try: asr_result = try_model_1.transcribe(paths2audio_files=[\"uploads/audio.wav\"]) s1 = request.form.get('defaultText') s2 = \" \".join(asr_result)#识别结果 result = &#123; \"asr_result\": asr_result, \"word_error_rate\": metrics.calculate_cer(s1,s2), \"word_accuracy_rate\":1-metrics.calculate_cer(s1,s2) &#125; return jsonify(result) except Exception as e: return '无法识别', 400# ------------------CV------------------# POST 请求上传图片@app.route(\"/cv/upload\", methods=['POST'])def cvUpload(): if request.method == 'POST': f = request.files['file'] print('image', f, f.filename) if not 'image' in f.headers.get('Content-Type'): return '图片有错误', 400 original = f'&#123;uploadPath&#125;original.jpg' try: # Convert image to jpeg im = Image.open(f) rgb_im = im.convert('RGB') rgb_im.save(original) # Add timestamp dt = datetime.now() ts = str(int(datetime.timestamp(dt))) return jsonify(original+'?t='+ts) except Exception as e: return '有错误', 400# 检测图片@app.route(\"/api/detect/image\")def detectImage(): cv_results = subprocess.Popen('python3 /home/nvidia/7th_CV/detection_image.py /home/nvidia/uploads/original.jpg', shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE) print('code', cv_results.returncode) cv_results = str(cv_results.stdout.read()).split('\\\\n')[-2] dt = datetime.now() ts = str(int(datetime.timestamp(dt))) result = &#123; \"detection_result_image_path\": f'/uploads/result.jpg?t=&#123;ts&#125;' &#125; return jsonify(result)# 获取 FPS，以 Json 格式返回前端@app.route(\"/api/detect/fps\")def detectFPS(): # Code here fps_results = subprocess.Popen('python3 /home/nvidia/7th_CV/cv_fps.py', shell = True, stdout = subprocess.PIPE, stderr = subprocess.STDOUT) fps_results = str(fps_results.stdout.read()).split('\\\\n')[-2] fps_results = fps_results.split(\" \")[-1] result = &#123; \"detection_FPS\": fps_results, &#125; return jsonify(result)# 获取 mAP@app.route(\"/api/detect/map\")def detectMAP(): # Code here map_results = subprocess.Popen('python3 /home/nvidia/7th_CV/cv_map.py', shell = True, stdout = subprocess.PIPE, stderr = subprocess.STDOUT) map_results = str(map_results.stdout.read()) bytes(map_results, encoding=\"utf-8\").decode() map_results = map_results[-9:-3] result = &#123; \"detection_mAP\": map_results, &#125; return jsonify(result)if __name__ == \"__main__\": app.run(debug=True) 前端html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409&lt;html&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"&gt; &lt;head&gt; &lt;script src=\"https://unpkg.com/vue@3\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.8/dist/css/layui.css\"&gt; &lt;script src=\"//unpkg.com/layui@2.6.8/dist/layui.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\"&gt; &lt;/head&gt; &lt;body id=\"app\"&gt; &lt;!-- 模型加载中 --&gt; &lt;div class=\"loading\" v-if=\"loading!=''\"&gt; &lt;div class=\"pad\"&gt;%%loading%%&lt;/div&gt; &lt;/div&gt; &lt;h1&gt;7th Sky Hackathon&lt;/h1&gt; &lt;h5&gt;team：早八睡不醒&lt;/h5&gt; &lt;div class=\"content\"&gt; &lt;div class=\"layui-tab layui-tab-brief\" lay-filter=\"docDemoTabBrief\"&gt; &lt;ul class=\"layui-tab-title\"&gt; &lt;li class=\"layui-this\"&gt;&lt;i class=\"layui-icon panel-title layui-icon\"&gt;&amp;#xe6dc;&amp;nbsp;ASR&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=\"layui-icon panel-title layui-icon\"&gt;&amp;#xe660;&amp;nbsp;CV&lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"layui-tab-content\"&gt; &lt;!-- ASR 开始--&gt; &lt;div class=\"layui-tab-item layui-show\"&gt; &lt;div class=\"layui-anim layui-anim-up\"&gt; &lt;fieldset class=\"asr\"&gt; &lt;legend&gt;&lt;span class=\"panel-title\"&gt;ASR&lt;/span&gt;&lt;/legend&gt; &lt;div class=\"layui-container\"&gt; &lt;!-- 1 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt; 1.请加载语音识别模型 &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;button class=\"layui-btn\" @click=\"loadModel()\" v-if=\"!modelLoaded\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe601;&amp;nbsp;加载&lt;/i&gt;&lt;/button&gt; &lt;div v-if=\"modelLoaded\" class=\"modelLoaded\"&gt;模型加载成功&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 1 结束 --&gt; &lt;!-- 2、3 开始 --&gt; &lt;div class=\"field file\"&gt; &lt;div class=\"newFileUpload\"&gt; &lt;!-- 2 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;label for=\"file\"&gt;2.请选择音频文件&lt;/label&gt; &lt;div class=\"note\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅支持 .wav 和单声道格式&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;div class=\"userdefined-file\"&gt; &lt;input type=\"text\" name=\"userdefinedFile\" id=\"userdefinedFileAudio\" value=\"未选择任何文件\" /&gt; &lt;button type=\"button\"&gt;选择&lt;/button&gt; &lt;/div&gt; &lt;input type=\"file\" name=\"file\" id=\"fileAudio\" @change=\"handleFileUploadAudio($event)\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 2 结束 --&gt; &lt;/div&gt; &lt;!-- 3 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt; 3.请上传音频文件&lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;button class=\"layui-btn\" @click=\"submitFile('asr')\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe67c;&amp;nbsp;上传&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3 结束 --&gt; &lt;/div&gt; &lt;!-- 2、3 结束 --&gt; &lt;!-- 4 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"field\"&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;label&gt;4.请试听上传语音并输入正确答案&lt;/label&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;input id=\"answer\" type=\"text\" name=\"defaultText\" v-model=\"defaultText\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4 结束 --&gt; &lt;div class=\"field\" v-if=\"asrStatus=='uploaded' || asrStatus=='identified'\"&gt; &lt;!-- 试听 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"audio\"&gt; &lt;div class=\"layui-col-md4\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 试听 &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;audio controls :src=\"audioOriginal\"&gt;&lt;/audio&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 试听 结束 --&gt; &lt;!-- 5 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt;5.识别语音&lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;div class=\"action\"&gt; &lt;button class=\"layui-btn\" @click=\"identifyAudio()\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe615;&amp;nbsp;识别&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 5 结束 --&gt; &lt;/div&gt; &lt;!-- 6 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"field result asr\" v-if=\"asrStatus=='identified'\"&gt; &lt;div class=\"layui-col-md4\"&gt;6.指标&lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in asrResult\"&gt;%%key%%: %%value%%&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 6 结束 --&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ASR 结束 --&gt; &lt;!-- CV 开始 --&gt; &lt;div class=\"layui-tab-item\"&gt; &lt;div class=\"layui-anim layui-anim-up\"&gt; &lt;fieldset class=\"cv\"&gt; &lt;legend&gt;&lt;span class=\"panel-title\"&gt;CV&lt;/span&gt;&lt;/legend&gt; &lt;div class=\"layui-container\"&gt; &lt;!-- 1 开始 --&gt; &lt;div class=\"field\"&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;p&gt;1. 获取 FPS&lt;/p&gt; &lt;div class=\"item result\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; FPS: %%cvFps%%&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;div class=\"item action\"&gt; &lt;button @click=\"getFps()\" class=\"inline layui-btn\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe601;&amp;nbsp;获取&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 1 结束 --&gt; &lt;!-- 2 开始 --&gt; &lt;div class=\"field\"&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;p&gt;2. 获取 mAP&lt;/p&gt; &lt;div class=\"item result\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; mAP: %%cvMap%%&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;div class=\"item\"&gt; &lt;button @click=\"getMap()\" class=\"inline layui-btn\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe601;&amp;nbsp;获取&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 2 结束 --&gt; &lt;!-- 3、4 开始 --&gt; &lt;div class=\"field file\"&gt; &lt;!-- 3 开始 --&gt; &lt;div class=\"newFileUpload\"&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;label for=\"file\"&gt;3.请选择图像文件 &lt;/label&gt; &lt;div class=\"note\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;div class=\"userdefined-file\"&gt; &lt;input type=\"text\" name=\"userdefinedFile\" id=\"userdefinedFileImage\" value=\"未选择任何文件\" /&gt; &lt;button type=\"button\"&gt;选择&lt;/button&gt; &lt;/div&gt; &lt;input type=\"file\" name=\"file\" ref=\"file\" id=\"fileImage\" @change=\"handleFileUploadImage($event)\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3 结束 --&gt; &lt;!-- 4 开始 --&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt;4.请上传图像文件 &lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;button @click=\"submitFile('cv')\" class=\"layui-btn\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe67c;&amp;nbsp;上传&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4 结束 --&gt; &lt;/div&gt; &lt;!-- 3、4 结束 --&gt; &lt;div class=\"action\" v-if=\"imageOriginal!=''\"&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"layui-col-md4\"&gt;5.识别图片&lt;/div&gt; &lt;div class=\"layui-col-md4\"&gt; &lt;button class=\"layui-btn\" @click=\"identifyImage()\"&gt;&lt;i class=\"layui-icon\"&gt;&amp;#xe615;&amp;nbsp;识别&lt;/i&gt;&lt;/button&gt;&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;div class=\"layui-row\"&gt; &lt;div class=\"image original\" v-if=\"imageOriginal!=''\"&gt; &lt;div class=\"layui-col-md1\"&gt; &lt;div class=\"label\"&gt;原图&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md3\"&gt; &lt;image :src=\"imageOriginal\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"image result cv\" v-if=\"imageResult!=''\"&gt; &lt;div class=\"layui-col-md1\"&gt; &lt;div class=\"label\"&gt;结果图&lt;/div&gt; &lt;/div&gt; &lt;div class=\"layui-col-md3\"&gt; &lt;image :src=\"imageResult\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- CV 结束 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; const &#123; createApp &#125; = Vue createApp(&#123; data() &#123; return &#123; file: '', defaultText: '请检测出纸箱、瓶子和果皮', modelLoaded: false, imageOriginal: '', imageResult: '', audioOriginal: '', error: '', asrResult: &#123;&#125;, cvMap: '', cvFps: '', loading: '', asrStatus: 'pending', cvStatus: 'pending' &#125; &#125;, // Avoid conflict with Flask delimiters compilerOptions: &#123; delimiters: [\"%%\", \"%%\"] &#125;, methods: &#123; async loadModel() &#123; if (this.loading != '') return showError('在运行中，无法执行') this.loading = '加载模型中，请耐心等待...' this.modelLoaded = false try &#123; var &#123; data, status &#125; = await axios.get('/asr/load') if (status == 200) &#123; this.modelLoaded = true &#125; &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = '' &#125;, async submitFile(fileType) &#123; let formData = new FormData() formData.append('file', this.file) if (this.file == \"\") &#123; showError(\"请选择文件\"); return false; &#125; statusType = fileType + 'Status' this.loading = '上传中...' try &#123; var &#123; data, status &#125; = await axios.post('/' + fileType + '/upload', formData, &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125;) if (status == 200) &#123; this[statusType] = 'uploaded' if (fileType == 'cv') &#123; this.imageOriginal = data &#125; else &#123; this.audioOriginal = data &#125; &#125; &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = '' &#125;, handleFileUploadAudio(event) &#123; document.getElementById(\"userdefinedFileAudio\").value = document.getElementById(\"fileAudio\").value; this.file = event.target.files[0]; &#125;, handleFileUploadImage(event) &#123; document.getElementById(\"userdefinedFileImage\").value = document.getElementById(\"fileImage\").value; this.file = event.target.files[0]; &#125;, async identifyAudio(event) &#123; // if (this.loading != '') return showError('在运行中，无法执行') this.loading = '识别中...' try &#123; let formData = new FormData() formData.append('defaultText', this.defaultText) console.log('t', this.defaultText) var result = await axios.post('/asr/identify', formData) this['asrStatus'] = 'identified' this.asrResult = result.data &#125; catch (err) &#123; if (err.response.status == 500) this.modelLoaded = false showError(err.response.data) &#125; this.loading = '' &#125;, async identifyImage(event) &#123; if (this.loading != '') return showError('在运行中，无法执行') this.loading = '识别中...' this.cvStatus = 'pending' try &#123; var &#123; data &#125; = await axios.get('/api/detect/image') this.imageResult = data['detection_result_image_path'] &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = '' &#125;, async getFps(event) &#123; if (this.loading != '') return showError('在运行中，无法执行') this.loading = '获取 FPS...' try &#123; var &#123; data &#125; = await axios.get('/api/detect/fps') this.cvFps = data['detection_FPS'] &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = '' &#125;, async getMap(event) &#123; // 接口路径: /api/detect/map // 方式: GET if (this.loading != '') return showError('在运行中，无法执行') this.loading = '获取 mAP...' try &#123; var &#123; data &#125; = await axios.get('/api/detect/map') this.cvMap = data['detection_mAP'] &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = '' &#125; &#125; &#125;).mount('#app') function showError(msg) &#123; layer.msg(msg || '错误') &#125; &lt;/script&gt;&lt;/html&gt; CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154body &#123; font-size: 20px; margin: 0;&#125;.content &#123; padding: 10px; margin: 40px;&#125;fieldset &#123; border: 1px solid #ccc; padding: 10px;&#125;.modelLoaded &#123; color: green;&#125;.note &#123; color: #999; margin: 5px 0; font-size: 12px;&#125;.field &#123; margin: 10px 0;&#125;.action &#123; margin-top: 10px;&#125;.loading &#123; position: fixed; top: 0; background: #E8F9D9; text-align: center; width: 100%;&#125;.pad &#123; padding: 5px;&#125;.inline &#123; display: inline-block;&#125;.field .item &#123; margin: 5px 0;&#125;.image &#123; display: inline-block; margin-right: 10px;&#125;.image img &#123; max-height: 600px;&#125;/* 标题 */h1,h5 &#123; margin: 40px;&#125;/* 队名 */h5 &#123; margin-left: 210px;&#125;/* 面板title */.panel-title &#123; font-size: 25px;&#125;/* 答案输入框 */#answer &#123; height: 40px; width: 200px; font-size: 14px; display: inline-block; vertical-align: middle; padding-right: 14px; padding-left: 14px;&#125;/* 音频文件选择 */.newFileUpload &#123; position: relative; height: 40px; line-height: 40px;&#125;.newFileUpload label &#123; display: inline-block;&#125;.userdefined-file &#123; position: absolute; top: 0; /* left: 200px; */ z-index: 2; width: 300px; height: 40px; line-height: 40px; font-size: 0; /*应对子元素为 inline-block 引起的外边距*/&#125;.userdefined-file input[type=\"text\"] &#123; display: inline-block; vertical-align: middle; padding-right: 14px; padding-left: 14px; width: 220px; box-sizing: border-box; border: 1px solid #ccc; height: 40px; line-height: 40px; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.userdefined-file button &#123; display: inline-block; vertical-align: middle; width: 80px; text-align: center; height: 40px; line-height: 40px; font-size: 14px; background-color: #009688; /* background-color: #f54; */ border: none; color: #fff; cursor: pointer;&#125;.newFileUpload input[type=\"file\"] &#123; position: absolute; top: 0; /* left: 200px; */ z-index: 3; opacity: 0; width: 300px; height: 40px; line-height: 40px; cursor: pointer;&#125;","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"矩阵的三角分解","slug":"matrix-theory/10.矩阵的三角分解","date":"2022-11-25T11:48:00.000Z","updated":"2023-02-24T07:55:48.325Z","comments":true,"path":"mathematics/matrix-theory/eaf75200.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/eaf75200.html","excerpt":"【LU 分解】若方阵 $A$ 可分解为 A=LU其中，$L$ 为单位下三角阵，$U$ 为上三角阵，则称 $A$ 可三角分解，或称 $A$ 可 LU 分解、Doolittle 分解","text":"【LU 分解】若方阵 $A$ 可分解为 A=LU其中，$L$ 为单位下三角阵，$U$ 为上三角阵，则称 $A$ 可三角分解，或称 $A$ 可 LU 分解、Doolittle 分解 对于 $n$ 阶方阵 $A=[a_{ij}]$ 有唯一的 LU 分解的充要条件是：$A$ 的前 $n-1$ 个顺序主子式 $\\Delta_k\\neq 0,1\\leq k\\leq n-1$，其中 \\Delta_k=\\left|\\begin{array}{c} a_{11} & a_{12} & \\cdots & a_{1k} \\\\ a_{21} & a_{22} & \\cdots & a_{2k} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{k1} & a_{k2} & \\cdots & a_{kk} \\\\ \\end{array}\\right| LU 分解的一个具体方法是：对 $A$ 的增广矩阵 $\\left[ \\begin{array}{c:c}A&amp;I\\end{array}\\right]$ 进行初等变换，变换成一个上三角阵和单位下三角阵的格式 $\\left[ \\begin{array}{c:c}U&amp;L^{-1}\\end{array}\\right]$，此时即可得 $A=LU$ 例： A=\\begin{bmatrix} 2&1&4\\\\ 4&3&13\\\\ 2&2&20 \\end{bmatrix}对 $A$ 的增广矩阵进行初等变换 \\left[ \\begin{array}{c:c}A&I\\end{array}\\right] \\rightarrow \\left[ \\begin{array}{c:c} \\begin{matrix} 2&1&4\\\\ &1&5\\\\ &&1 \\end{matrix} & \\begin{matrix} 1&&\\\\ -2&1&\\\\ 1&-1&1 \\end{matrix} \\end{array}\\right] \\triangleq \\left[ \\begin{array}{c:c}U&L^{-1}\\end{array}\\right]可得 L=\\begin{bmatrix} 1&&\\\\ 2&1&\\\\ 1&1&1 \\end{bmatrix}故有 A=LU=\\begin{bmatrix} 1&&\\\\ 2&1&\\\\ 1&1&1 \\end{bmatrix}\\begin{bmatrix} 2&1&4\\\\ &1&5\\\\ &&1 \\end{bmatrix}【带行交换的 LU 分解】对于 $n$ 阶方阵 $A$，若其前 $n-1$ 个顺序主子式 $\\exists \\Delta_k=0$，则 $A$ 无法进行 LU 分解 但若 $A$ 为满秩矩阵，那么存在置换矩阵 $P$，使得 $PA$ 有 LU 分解，此时称为带行交换的 LU 分解 设 $A$ 是带有行交换的三角分解 $PA=LU$，由于 $A$ 满秩，故 $U$ 可逆，记 $Q=U^{-1}$，则 $Q$ 亦为上三角阵，于是有 $PAQ=L$，而上三角阵可逆 $Q$ 右乘 $A$，相当于对 $A$ 进行行初等变换，故分解过程如下： \\left[ \\begin{array}{c:c} A&I\\\\ \\hdashline I \\end{array}\\right] \\stackrel{行置换}{\\longrightarrow} \\left[ \\begin{array}{c:c} PA&P\\\\ \\hdashline I \\end{array}\\right] \\stackrel{向右列变换}{\\longrightarrow} \\left[ \\begin{array}{c:c} PAQ&P\\\\ \\hdashline Q \\end{array}\\right] \\triangleq \\left[ \\begin{array}{c:c} L&P\\\\ \\hdashline Q \\end{array}\\right]则有 $PAQ=L$，从而 PA=LQ^{-1}=LU【LDU 分解】设方阵 $A$ 有 LU 分解 A=LU_1若 $A$ 可逆，则上三角阵 $U_1$ 也可逆，其主对角线元素均不为 $0$ 因此，$U_1$ 必可分解为对角阵 $D$ 和单位上三角阵 $U$ 的乘积，即有 A=LDU称为方阵 $A$ 的 LDU 分解，其中，$L$ 为单位下三角阵，$D$ 为对角阵，$U$ 为单位上三角阵 例： A=\\begin{bmatrix} 2&1&4\\\\ 4&3&13\\\\ 2&2&20 \\end{bmatrix}由前例可知，$A$ 有 LU 分解，且 $A$ 可逆，故 \\begin{align*} A=&\\begin{bmatrix} 1&&\\\\ 2&1&\\\\ 1&1&1 \\end{bmatrix}\\begin{bmatrix} 2&1&4\\\\ &1&5\\\\ &&1 \\end{bmatrix} \\\\ =& \\begin{bmatrix} 1&&\\\\ 2&1&\\\\ 1&1&1 \\end{bmatrix}\\begin{bmatrix} 2&&\\\\ &1&\\\\ &&11 \\end{bmatrix}\\begin{bmatrix} 1&\\frac{1}{2}&2\\\\ &1&5\\\\ &&1 \\end{bmatrix} \\end{align*}【Cholesky 分解】当 $A$ 是对称正定矩阵时，其顺序主子式 $\\Delta_k&gt;0(0\\leq k\\leq n)$，故 $A$ 有唯一的 LDU 分解 $A=LDU$，记 D=\\text{diag} (d_1,d_2,\\cdots,d_n),\\quad d_i>0,1\\leq i\\leq n由于 $A=A^T$，故有 LDU=(LDU)^T=U^TDL^T由 LDU 分解的唯一性，可知 $L=U^T$，令 D^{\\frac{1}{2}}=\\text{diag} (\\sqrt{d_1},\\sqrt{d_2},\\cdots,\\sqrt{d_n})则有 A=LDU=LD^{\\frac{1}{2}}D^{\\frac{1}{2}}L^T=(D^{\\frac{1}{2}}L^T)(LD^{\\frac{1}{2}})^T\\triangleq GG^T称为对称正定矩阵的 Cholesky 分解或平方根分解，其中，$G=LD^{\\frac{1}{2}}$ 为下三角阵，其主对角元素均大于 $0$","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"矩阵微分与矩阵积分","slug":"matrix-theory/09.矩阵微分与矩阵积分","date":"2022-11-25T03:31:00.000Z","updated":"2023-02-24T07:55:23.339Z","comments":true,"path":"mathematics/matrix-theory/ba6b7932.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/ba6b7932.html","excerpt":"【矩阵微分】引入根据下表，微分可分为标量对标量 $\\frac{\\partial y}{\\partial x}$、向量对标量 $\\frac{\\partial \\mathbf{y}}{\\partial x}$、标量对向量 $\\frac{\\partial y}{\\partial \\mathbf{x}}$、矩阵对标量 $\\frac{\\partial Y}{\\partial x}$、标量对矩阵 $\\frac{\\partial y}{\\partial X}$、向量对向量 $\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{x}}$ 六种形式","text":"【矩阵微分】引入根据下表，微分可分为标量对标量 $\\frac{\\partial y}{\\partial x}$、向量对标量 $\\frac{\\partial \\mathbf{y}}{\\partial x}$、标量对向量 $\\frac{\\partial y}{\\partial \\mathbf{x}}$、矩阵对标量 $\\frac{\\partial Y}{\\partial x}$、标量对矩阵 $\\frac{\\partial y}{\\partial X}$、向量对向量 $\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{x}}$ 六种形式 标量 向量 矩阵 标量 $\\frac{\\partial y}{\\partial x}$ $\\frac{\\partial \\mathbf{y}}{\\partial x}$ $\\frac{\\partial Y}{\\partial x}$ 向量 $\\frac{\\partial y}{\\partial \\mathbf{x}}$ $\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{x}}$ \\ 矩阵 $\\frac{\\partial y}{\\partial X}$ \\ \\ 其中，$x,y$ 为标量，$\\mathbf{x},\\mathbf{y}$ 是向量，$X,Y$ 是矩阵 标量对标量形式 $\\frac{\\partial y}{\\partial x}$ 即微积分中的一元函数微分，例如 y=x^2\\Rightarrow \\frac{\\partial y}{\\partial x}=2x向量对标量形式 $\\frac{\\partial \\mathbf{y}}{\\partial x}$ 即对向量元素逐项微分，例如 \\mathbf{y}=\\begin{bmatrix}2x\\\\3x\\\\x^2\\end{bmatrix} \\Rightarrow \\frac{\\partial \\mathbf{y}}{\\partial x}= \\begin{bmatrix} 2 \\\\ 3 \\\\ 2x \\end{bmatrix}标量对向量形式 $\\frac{\\partial y}{\\partial \\mathbf{x}}$ 即微积分中的多元函数偏导，即函数 $y$ 对向量 $\\mathbf{x}$ 的梯度 $\\text{grad }y$，例如 \\left\\{\\begin{array}{l} y=2x_1+x_2^3+5x_3 \\\\ \\mathbf{x}=[x_1,x_2,x_3]^T \\end{array}\\right. \\Rightarrow \\frac{\\partial y}{\\partial \\mathbf{x}}=\\triangledown y=\\begin{bmatrix} 2 \\\\ 3x_2^2\\\\ 10x_3 \\end{bmatrix}下面，逐一介绍剩余的矩阵对标量 $\\frac{\\partial Y}{\\partial x}$、标量对矩阵 $\\frac{\\partial y}{\\partial X}$、向量对向量 $\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{x}}$ 三种形式 矩阵对标量设 $m\\times n$ 阶函数矩阵 $A(t)=[a_{ij}(t)]$，定义函数矩阵 $A(t)$ 关于标量 $t$ 的微分为 \\frac{dA(t)}{dt}=\\Big[\\frac{da_{ij}(t)}{dt}\\Big]简记为 A'(t)=[a_{ij}'(t)]其有如下的求导法则： 1）若 $A(t),B(t)$ 是同阶可微矩阵，则 (A(t)+B(t))'=A'(t)+B'(t)2）若 $A(t),B(t)$ 分别是 $m\\times n$ 阶、$n\\times l$ 阶可微矩阵，则 (A(t)B(t))'=A'(t)B(t)+A(t)B'(t)3）若 $A(u)$ 可微且 $u=f(t)$ 关于 $t$ 可微，则 \\frac{d}{dt} A(f(t))=f'(t)\\frac{d}{du}A(u)4）若 $A(t),A^{-1}(t)$ 均可微，则 \\frac{d}{dt}A^{-1}(t)=-A^{-1}(t)A'(t)A^{-1}(t) 可以发现，矩阵对标量形式的微分，本质就是对矩阵内的元素逐一求导，例如 A(t)=\\begin{bmatrix} \\sin t & \\cos t & t \\\\ t\\sin t & e^t & t^2 \\\\ 1 & 0 & t^3 \\end{bmatrix} \\Rightarrow \\frac{dA(t)}{dt}=\\begin{bmatrix} \\cos t & -\\sin t & 1 \\\\ \\sin t+t\\cos t & e^t & 2t \\\\ 0 & 0 & 3t^2 \\end{bmatrix}标量对矩阵设 $X=[x_{ij}]$ 是 $m\\times n$ 阶的标量矩阵，且 f(X)=f(x_{11},\\cdots,x_{1n},x_{21},\\cdots,x_{2n},\\cdots,x_{m1},\\cdots,x_{mn})是 $mn$ 元可微的标量函数，那么函数 $f(X)$ 关于矩阵 $X$ 的导数为 \\frac{df}{dX} =\\Big[\\frac{\\partial f}{\\partial x_{ij}}\\Big] =\\begin{bmatrix} \\frac{\\partial f}{\\partial x_{11}} & \\frac{\\partial f}{\\partial x_{12}} & \\cdots & \\frac{\\partial f}{\\partial x_{1n}} \\\\ \\frac{\\partial f}{\\partial x_{21}} & \\frac{\\partial f}{\\partial x_{22}} & \\cdots & \\frac{\\partial f}{\\partial x_{2n}} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial f}{\\partial x_{m1}} & \\frac{\\partial f}{\\partial x_{m2}} & \\cdots & \\frac{\\partial f}{\\partial x_{mn}} \\\\ \\end{bmatrix}特别地，当 $X$ 是 $m\\times 1$ 阶矩阵，即 $m$ 维向量时，此时标量对矩阵形式即为标量对向量形式，函数 $f(X)$ 关于 $X$ 的微分，即 $f$ 对 $X$ 的梯度 \\text{grad }f=\\triangledown f=\\begin{bmatrix} \\frac{\\partial f}{\\partial x_1} \\\\ \\frac{\\partial f}{\\partial x_2} \\\\ \\vdots\\\\ \\frac{\\partial f}{\\partial x_m} \\end{bmatrix}标量对矩阵形式有如下的求导法则： \\begin{align*} &\\frac{d}{dX}(f(X)+g(X))=\\frac{d}{dX}f(X)+\\frac{d}{dX}g(X) \\\\ &\\frac{d}{dX}(f(X)g(X))=f(X)\\frac{d}{dX}g(X)+g(X)\\frac{d}{dX}f(X) \\end{align*}向量对向量设 $\\mathbf{x}=[x_1,x_2,\\cdots,x_n]^T$ 为 $n$ 维列向量，$a_1(\\mathbf{x}),a_2(\\mathbf{x}),\\cdots,a_m(\\mathbf{x})$ 是 $m$ 个 $n$ 元可微函数，记向量函数 \\mathbf{a}^T(\\mathbf{x})=[a_1(\\mathbf{x}),a_2(\\mathbf{x}),\\cdots,a_m(\\mathbf{x})]则向量函数 $\\mathbf{a}^T(\\mathbf{x})$ 关于向量 $\\mathbf{x}$ 的微分为 \\frac{d\\mathbf{a}^T(\\mathbf{x})}{d\\mathbf{x}} =\\begin{bmatrix} \\frac{\\partial a_1(\\mathbf{x})}{\\partial x_1} & \\frac{\\partial a_2(\\mathbf{x})}{\\partial x_1} & \\cdots & \\frac{\\partial a_m(\\mathbf{x})}{\\partial x_1} \\\\ \\frac{\\partial a_1(\\mathbf{x})}{\\partial x_2} & \\frac{\\partial a_2(\\mathbf{x})}{\\partial x_2} & \\cdots & \\frac{\\partial a_m(\\mathbf{x})}{\\partial x_2} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial a_1(\\mathbf{x})}{\\partial x_n} & \\frac{\\partial a_2(\\mathbf{x})}{\\partial x_n} & \\cdots & \\frac{\\partial a_m(\\mathbf{x})}{\\partial x_n} \\end{bmatrix}_{n\\times m}同理，定义向量函数 $\\mathbf{a}(\\mathbf{x})$ 关于向量 $\\mathbf{x}^T$ 的导数为 \\frac{d\\mathbf{a}(\\mathbf{x})}{d\\mathbf{x}^T} =\\begin{bmatrix} \\frac{\\partial a_1(\\mathbf{x})}{\\partial x_1} & \\frac{\\partial a_1(\\mathbf{x})}{\\partial x_2} & \\cdots & \\frac{\\partial a_1(\\mathbf{x})}{\\partial x_n} \\\\ \\frac{\\partial a_2(\\mathbf{x})}{\\partial x_1} & \\frac{\\partial a_2(\\mathbf{x})}{\\partial x_2} & \\cdots & \\frac{\\partial a_2(\\mathbf{x})}{\\partial x_n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial a_m(\\mathbf{x})}{\\partial x_1} & \\frac{\\partial a_m(\\mathbf{x})}{\\partial x_2} & \\cdots & \\frac{\\partial a_m(\\mathbf{x})}{\\partial x_n} \\end{bmatrix}_{m\\times n}显然有 \\frac{d\\mathbf{a}^T(\\mathbf{x})}{d\\mathbf{x}}=\\Big( \\frac{d\\mathbf{a}(\\mathbf{x})}{d\\mathbf{x}^T} \\Big)^T,\\quad \\frac{d\\mathbf{x}}{d\\mathbf{x}^T}=\\frac{d\\mathbf{x}^T}{d\\mathbf{x}}=I标量对矩阵形式有如下的求导法则： \\begin{align*} \\frac{d}{d\\mathbf{x}}(\\mathbf{a}^T(\\mathbf{x})+\\mathbf{b}^T(\\mathbf{x})) &= \\frac{d}{d\\mathbf{x}}\\mathbf{a}^T(\\mathbf{x}) + \\frac{d}{d\\mathbf{x}}\\mathbf{b}^T(\\mathbf{x})\\\\ \\frac{d}{d\\mathbf{x}}(f(\\mathbf{x})\\mathbf{a}^T(\\mathbf{x})) &= \\frac{df(\\mathbf{x})}{d\\mathbf{x}}\\mathbf{a}^T(\\mathbf{x})+f(\\mathbf{x})\\frac{d\\mathbf{a}^T(\\mathbf{x})}{d\\mathbf{x}}\\\\ \\frac{d}{d\\mathbf{x}}\\big(A\\mathbf{a}(\\mathbf{x})\\big) &= A\\frac{d}{d\\mathbf{x}^T}\\mathbf{a}(\\mathbf{x})\\\\ \\frac{d}{d\\mathbf{x}}\\big(\\mathbf{a}^T(\\mathbf{x})\\mathbf{b}(\\mathbf{x})\\big) &= \\frac{d\\mathbf{a}^T(\\mathbf{x})}{d\\mathbf{x}}\\mathbf{b}(\\mathbf{x})+\\frac{d\\mathbf{b}^T(\\mathbf{x})}{d\\mathbf{x}}\\mathbf{a}(\\mathbf{x})\\\\ \\end{align*}其中，$A$ 为常数矩阵，$f(\\mathbf{x})$ 为向量 $\\mathbf{x}$ 的数量函数，$\\mathbf{a}(\\mathbf{x}),\\mathbf{b}(\\mathbf{x})$ 为向量 $\\mathbf{x}$ 的向量函数 【矩阵积分】设 $m\\times n$ 阶函数矩阵 $A(t)=[a_{ij}(t)]$ 中的每个元素 $a_{ij}(t)$ 在 $[a,b]$ 上可积，则称 $A(t)$ 在 $[a,b]$ 上是可积的，且定义 \\int_{a}^bA(t)dt=\\Big[\\int_a^b a_{ij}(t)dt\\Big]_{m\\times n}根据矩阵积分定义与微积分的知识，易知矩阵积分有如下性质： 1）若 $A(t)$ 在 $[a,b]$ 上连续，则 $\\forall t\\in(a,b)$，$\\int_a^t A(s)ds$ 可微，且 \\frac{d}{dt}\\int_a^tA(s)ds=A(t)2）若 $A(t)$ 在 $[a,b]$ 上连续可微，则 \\int_{a}^b \\frac{dA(t)}{dt}dt=A(b)-A(a)","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（七）Tao 目标检测模型可视化推理与导出","slug":"skyhackathon/07.NVIDIA 7th SkyHackathon（七）Tao 目标检测模型可视化推理与导出","date":"2022-11-23T12:15:00.000Z","updated":"2023-02-06T03:14:50.496Z","comments":true,"path":"nvidia/skyhackathon/17a9b161.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/17a9b161.html","excerpt":"可视化推理结果对于训练好的模型，使用 tao 套件可进行推理，各参数如下： -o：输出文件目录，即检测过的图片保存位置 -e：训练配置文件 -m：要测试的模型 -l：推理结果的标注文件目录 -k：秘钥","text":"可视化推理结果对于训练好的模型，使用 tao 套件可进行推理，各参数如下： -o：输出文件目录，即检测过的图片保存位置 -e：训练配置文件 -m：要测试的模型 -l：推理结果的标注文件目录 -k：秘钥 1tao ssd inference --gpu_index=$GPU_INDEX -i $LOCAL_DATA_DIR/test_samples -o $USER_EXPERIMENT_DIR/ssd_infer_images -e $SPECS_DIR/ssd_retrain_resnet18_kitti.txt -m $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/ssd_resnet18_epoch_$EPOCH.tlt -l $USER_EXPERIMENT_DIR/ssd_infer_labels -k $KEY 之后，使用 matplotlib 进行可视化 1234567891011121314151617import matplotlib.pyplot as pltimport osfrom math import ceilvalid_image_ext = ['.jpg', '.png', '.jpeg', '.ppm']def visualize_images(image_dir, num_cols=4, num_images=10): output_path = os.path.join(os.environ['LOCAL_EXPERIMENT_DIR'], image_dir) num_rows = int(ceil(float(num_images) / float(num_cols))) f, axarr = plt.subplots(num_rows, num_cols, figsize=[80,30]) f.tight_layout() a = [os.path.join(output_path, image) for image in os.listdir(output_path) if os.path.splitext(image)[1].lower() in valid_image_ext] for idx, img_path in enumerate(a[:num_images]): col_id = idx % num_cols row_id = idx // num_cols img = plt.imread(img_path) axarr[row_id, col_id].imshow(img) 效果图： 模型导出首先在 $USER_EXPERIMENT_DIR 下创建模型导出的目录 export，然后使用 tao 套件导出训练的模型，导出的模型即可利用 NVIDIA TensorRT 进行推理 其参数如下： -m：要导出的模型 -o：导出模型的存放位置 -e：训练配置文件 -k：秘钥 —batch_size：模型的输入 batchsize —data_type：导出模型的数据类型 1tao ssd export --gpu_index=$GPU_INDEX -m $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/ssd_resnet18_epoch_$EPOCH.tlt -k $KEY -o $USER_EXPERIMENT_DIR/export/ssd_resnet18_epoch_$EPOCH.etlt -e $SPECS_DIR/ssd_train_resnet18_kitti.txt --batch_size 1 --data_type fp32 最后，使用 tao-coverter 工具，将导出的模型转为 TensorRT 可直接使用的推理引擎即可 1tao converter -k $KEY -d 3,300,300 -o NMS -e $USER_EXPERIMENT_DIR/export/trt.engine -m 1 -t fp32 -i nchw $USER_EXPERIMENT_DIR/export/ssd_resnet18_epoch_$EPOCH.etlt","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"中心极限定理","slug":"probability-theory/10.中心极限定理","date":"2022-11-21T11:38:00.000Z","updated":"2023-02-24T07:13:14.615Z","comments":true,"path":"mathematics/probability-theory/b092a00e.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/b092a00e.html","excerpt":"Reference 概率论——大数定律与中心极限定理 什么是中心极限定理？这里有一份可视化解释 中心极限定理通俗介绍 【引入】大数定律研究的是一系列随机变量 $\\{X_n\\}$ 的均值 $\\overline{X_n}$ 是否会依概率或几乎处处收敛于期望 $E\\overline{X_n}$，而中心极限定理，是进一步研究 $\\overline{X_n}$ 服从什么分布","text":"Reference 概率论——大数定律与中心极限定理 什么是中心极限定理？这里有一份可视化解释 中心极限定理通俗介绍 【引入】大数定律研究的是一系列随机变量 $\\{X_n\\}$ 的均值 $\\overline{X_n}$ 是否会依概率或几乎处处收敛于期望 $E\\overline{X_n}$，而中心极限定理，是进一步研究 $\\overline{X_n}$ 服从什么分布 若 $\\{X_n\\}$ 满足一定条件时，当 $n$ 足够大时，$\\overline{X_n}$ 近似服从正态分布，这就是中心极限定理的主要思想 其在理论上保证了可以只抽样一部分，而推测研究对象统计参数的目的 【林德贝格-勒维中心极限定理】林德贝格-勒维中心极限定理又称独立同分布中心极限定理，其说明了当 $n$ 足够大时，随机变量序列 $\\{X_n\\}$ 在独立同分布条件下，$\\overline{X_n}$ 近似服从正态分布 若 $\\{X_n\\}$ 是独立同分布的随机变量序列，且数学期望 $EX_i=\\mu$，方差 $DX_i=\\sigma^2$，那么当 $n$ 足够大时，$\\overline{X_n}$ 近似服从正态分布 $N(\\mu,\\frac{\\sigma^2}{n})$，即 \\lim_{n\\rightarrow\\infty} P(\\frac{\\overline{X_n}-\\mu}{\\sigma/\\sqrt{n}}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"大数定律","slug":"probability-theory/09.大数定律","date":"2022-11-21T08:17:00.000Z","updated":"2023-02-24T07:22:01.690Z","comments":true,"path":"mathematics/probability-theory/9fdbb2c9.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/9fdbb2c9.html","excerpt":"Reference 中心极限定理与大数定律 概率论——大数定律与中心极限定理 【马尔科夫不等式】设 $X$ 为一随机变量，若 $E|X|^r&lt;+\\infty,r&gt;0$，则称 $EX^r$ 为随机变量 $X$ 的 $r$ 阶矩","text":"Reference 中心极限定理与大数定律 概率论——大数定律与中心极限定理 【马尔科夫不等式】设 $X$ 为一随机变量，若 $E|X|^r&lt;+\\infty,r&gt;0$，则称 $EX^r$ 为随机变量 $X$ 的 $r$ 阶矩 设 $X$ 的 $r$ 阶矩存在，则对 $\\forall \\varepsilon&gt;0$，有： P(|X|\\geq \\varepsilon) \\leq \\frac{E|X|^r}{\\varepsilon^r}称为马尔科夫（Markov）不等式 需要注意的是，Markov 不等式是一个很宽松的不等式，在大多数情况下，Markov 不等式得出的概率的上界通常都与真实的概率相去甚远，但其需要的条件非常之少 特别地，令 $X=X-EX,r=2$，即可得到切比雪夫（Chebyshev）不等式 P(|X-EX|\\geq \\varepsilon) \\leq \\frac{DX}{\\varepsilon^2}切比雪夫不等式可以对随机变量偏离期望值的概率做出估计，这是大数定律的推理基础 【大数定律的引入】大数定律，是关于大量随机现象平均结果稳定性的定理 对于随机变量序列 $\\{X_n,n=1,2,\\cdots\\}$，设每个随机变量都有期望，由于随机变量之和 $\\sum\\limits_{i=1}^nX_i$ 很有可能发散到无穷大 因此转而考虑随机变量的均值 $\\overline{X_n}=\\frac{1}{n}\\sum\\limits_{i=1}^nX_i$ 和其期望 $E(\\overline{X_n})$ 之间的距离 若 $\\{X_n\\}$ 满足一定条件，当 $n$ 足够大时，这个距离会以非常大的概率接近 $0$ 任取 $\\varepsilon&gt;0$，若恒有 \\lim_{n\\rightarrow\\infty} P(|\\overline{X_n}-E\\overline{X_n}|","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"随机变量序列的收敛性","slug":"probability-theory/08.随机变量序列的收敛性","date":"2022-11-21T04:35:00.000Z","updated":"2023-02-24T07:23:59.953Z","comments":true,"path":"mathematics/probability-theory/b5e57c2c.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/b5e57c2c.html","excerpt":"Reference 依分布收敛、依概率收敛、均方收敛、几乎处处收敛 概率论四大收敛与三个大数定律 【概率论】随机变量的收敛模式 【分布函数的弱收敛性】概率法则是对大量随机现象的考察中显现出来的，而对于大量随机现象的描述，就要使用极限的方法","text":"Reference 依分布收敛、依概率收敛、均方收敛、几乎处处收敛 概率论四大收敛与三个大数定律 【概率论】随机变量的收敛模式 【分布函数的弱收敛性】概率法则是对大量随机现象的考察中显现出来的，而对于大量随机现象的描述，就要使用极限的方法 对于分布函数列 $\\{F_{n}(x),n=1,2,\\cdots\\}$，若存在一个非降函数 $F(x)$，使 \\lim_{n\\rightarrow \\infty} F_n(x)=F(x)在 $F(x)$ 的每一连续点上都成立，则称分布函数列 $\\{F_{n}(x),n=1,2,\\cdots\\}$ 弱收敛于 $F(x)$，并记为 F_{n}(x) \\xrightarrow{W} F(x)在弱收敛性的基础上，针对特征函数，有连续性定理： 设分布函数列 $\\{F_{n}(x),n=1,2,\\cdots\\}$ 弱收敛于某一分布函数 $F(x)$，则相应特征函数列 $\\{\\varphi_{n}(x),n=1,2,\\cdots\\}$ 弱收敛于特征函数 $\\varphi(t)$，且在 $t$ 的任一有限区间内收敛是一致的 设特征函数列 $\\{\\varphi_{n}(x),n=1,2,\\cdots\\}$ 弱收敛于某一函数 $\\varphi(t)$，且 $\\varphi(t)$ 在 $t=0$ 处连续，则相应的分布函数列 $\\{F_{n}(x),n=1,2,\\cdots\\}$ 弱收敛于某一分布函数 $F(x)$，且 $\\varphi(t)$ 为 $F(x)$ 的特征函数 【随机变量的收敛性】概率论中的极限定理研究的是随机变量序列的某种收敛性，对随机变量收敛性的不同定义将导致不同的极限定理 对于概率空间 $(\\Omega,\\mathscr{F},P)$ 上的随机变量 $X$ 和随机变量序列 $\\{X_n,n=1,2,\\cdots\\}$，设它们的分布函数分别为 $\\{F_{n}(x),n=1,2,\\cdots\\}$ 和 $F(x)$，可给出如下四大收敛的定义 依分布收敛若分布函数列 $\\{F_{n}(x)\\}$ 弱收敛于分布函数 $F(x)$，则有 $\\{X_n\\}$ 依分布收敛于 $X$，记为 $X_n\\xrightarrow{L}X$ 即： F_{n}(x) \\xrightarrow{W} F(x)\\Rightarrow X_n\\xrightarrow{L}X依分布收敛是收敛性中最弱的收敛，只能保证分布函数序列收敛 依概率收敛若对任意 $\\varepsilon&gt;0$，有 \\lim_{n\\rightarrow \\infty} P(|X_n-X|\\geq \\varepsilon)=0则称 $\\{X_n\\}$ 依概率收敛于 $X$，记为 $X_n\\xrightarrow{P}X$ 或 $\\lim\\limits_{n\\rightarrow\\infty} X_n=X$ 依概率收敛强于依分布收敛，其先给定 $\\varepsilon&gt;0$，保证 $|X_n-X|\\geq\\varepsilon$ 随着 $n$ 增大，概率趋于 $0$，可见 $\\varepsilon$ 越小收敛性越好 此外，若 $\\{X_n\\}$ 依概率收敛于 $X$，则必有 $\\{X_n\\}$ 依分布收敛于 $X$，即： X_n\\xrightarrow{P}X \\Rightarrow X_n\\xrightarrow{L}X$r$ 阶收敛若 $E|X_n|^r\\leq +\\infty$ 且 $E|X|^r&lt;+\\infty$，有 \\lim_{n\\rightarrow\\infty}E|X_n-X|^r=0则称 $\\{X_n\\}$ $r$ 阶收敛于 $X$，记为 $X_n\\xrightarrow{r}X$ $r$ 阶收敛强于依概率收敛，其说明了随着 $n$ 的增大，$r$ 阶的 $|X_n-X|$ 的期望为 $0$ 此外，若 $\\{X_n\\}$ $r$ 阶收敛于 $X$，则必有 $\\{X_n\\}$ 依概率收敛于 $X$，即： X_n\\xrightarrow{r}X \\Rightarrow X_n\\xrightarrow{P}X进一步，可推得 X_n\\xrightarrow{r}X \\Rightarrow X_n\\xrightarrow{P}X\\Rightarrow X_n\\xrightarrow{L}X几乎处处收敛若下式成立 P(\\lim_{n\\rightarrow\\infty}X_n=X)=1则称 $\\{X_n\\}$ 几乎处处收敛于 $X$，又称 $\\{X_n\\}$ 依概率 $1$ 收敛于 $X$，记为 $X_n\\xrightarrow{a.s.}X$ 几乎处处收敛强于依概率收敛，和依概率收敛比较，可以看成取定 $\\varepsilon=0$ 的依概率收敛，所以也叫依概率 $1$ 收敛 事实上，几乎处处收敛是不收敛点的集合，只构成勒贝格零集 此外，若 $\\{X_n\\}$ 几乎处处收敛于 $X$，则必有 $\\{X_n\\}$ 依概率收敛于 $X$，即： X_n\\xrightarrow{a.s.}X \\Rightarrow X_n\\xrightarrow{P}X进一步，可推得 X_n\\xrightarrow{a.s.}X \\Rightarrow X_n\\xrightarrow{P}X\\Rightarrow X_n\\xrightarrow{L}X","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"条件数学期望","slug":"probability-theory/07.条件数学期望","date":"2022-11-20T16:35:00.000Z","updated":"2023-02-24T07:30:59.614Z","comments":true,"path":"mathematics/probability-theory/5ea2bcdd.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/5ea2bcdd.html","excerpt":"Reference 概率论学习笔记（四） 概率论 —— 条件数学期望 【概率论】4-7:条件期望(Conditional Expectation) 【条件分布律】设离散型二维随机变量 $(X,Y)$ 的联合分布律为 $P(X=x_i,Y=y_j)=p_{ij}$，若 $P(Y=y_j)=p_{\\cdot j}&gt;0$，则称","text":"Reference 概率论学习笔记（四） 概率论 —— 条件数学期望 【概率论】4-7:条件期望(Conditional Expectation) 【条件分布律】设离散型二维随机变量 $(X,Y)$ 的联合分布律为 $P(X=x_i,Y=y_j)=p_{ij}$，若 $P(Y=y_j)=p_{\\cdot j}&gt;0$，则称 p_{i|j} = P(X=x_i|Y=y_j)=\\frac{p_{ij}}{p_{\\cdot j}}为 $(X,Y)$ 关于 $X$ 在 $Y=y_j$ 条件下的条件分布律，称 F_{X|Y}(x|y)=P(X\\leq x| Y=y_j) =\\sum_{x_i\\leq x} \\frac{p_{ij}}{p_{\\cdot j}},\\quad -\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（六）Tao 目标检测模型训练与评估","slug":"skyhackathon/06.NVIDIA 7th SkyHackathon（六）Tao 目标检测模型训练与评估","date":"2022-11-19T10:40:00.000Z","updated":"2023-02-06T01:28:08.360Z","comments":true,"path":"nvidia/skyhackathon/16e68227.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/16e68227.html","excerpt":"模型准备安装 NGC CLI使用 NGC CLI 来获得预训练模型，关于 NGC 的详细信息可访问 官网 中的 SETUP 了解","text":"模型准备安装 NGC CLI使用 NGC CLI 来获得预训练模型，关于 NGC 的详细信息可访问 官网 中的 SETUP 了解 1234567891011121314# 创建 NGC CLI 目录%env CLI=ngccli_cat_linux.zipmkdir -p $LOCAL_PROJECT_DIR/ngccli# 移除之前安装的 NGC CLIrm -rf $LOCAL_PROJECT_DIR/ngccli/*# 下载并解压 NGC CLIwget \"https://ngc.nvidia.com/downloads/$CLI\" -P $LOCAL_PROJECT_DIR/ngccliunzip -u \"$LOCAL_PROJECT_DIR/ngccli/$CLI\" -d $LOCAL_PROJECT_DIR/ngccli/rm $LOCAL_PROJECT_DIR/ngccli/*.zip # 添加 NGC CLI 到环境变量中os.environ[\"PATH\"]=\"&#123;&#125;/ngccli:&#123;&#125;\".format(os.getenv(\"LOCAL_PROJECT_DIR\", \"\"), os.getenv(\"PATH\", \"\")) 安装预训练模型1234567891011# 查看目前 NGC 上可下载的关于目标检测的预训练模型ngc registry model list nvidia/tao/pretrained_object_detection:*# 创建保存预训练模型的目录mkdir -p $LOCAL_EXPERIMENT_DIR/pretrained_resnet18/# 下载选择的预训练模型ngc registry model download-version nvidia/tao/pretrained_object_detection:resnet18 --dest $LOCAL_EXPERIMENT_DIR/pretrained_resnet18#查看预训练模型是否下载成功ls -l $LOCAL_EXPERIMENT_DIR/pretrained_resnet18/pretrained_object_detection_vresnet18 设置模型参数打开 $LOCAL_SPECS_DIR/ssd_train_resnet18_kitti.txt，根据实际需要，修改模型参数，其中： batch_size_per_gpu：定义 batch_size 大小，（若 GPU 显存不大，可以调小一点，以免出现 out of memory） num_epochs：定义会训练多少轮，第一次训练建议不小于 80 validation_period_during_training：定义训练验证轮次，可直观看出训练的效果变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667random_seed: 42ssd_config &#123; aspect_ratios_global: \"[1.0, 2.0, 0.5, 3.0, 1.0/3.0]\" scales: \"[0.05, 0.1, 0.25, 0.4, 0.55, 0.7, 0.85]\" two_boxes_for_ar1: true clip_boxes: false variances: \"[0.1, 0.1, 0.2, 0.2]\" arch: \"resnet\" nlayers: 18 freeze_bn: false freeze_blocks: 0&#125;training_config &#123; batch_size_per_gpu: 32 num_epochs: 80 enable_qat: false learning_rate &#123; soft_start_annealing_schedule &#123; min_learning_rate: 5e-5 max_learning_rate: 2e-2 soft_start: 0.15 annealing: 0.8 &#125; &#125; regularizer &#123; type: L1 weight: 3e-5 &#125;&#125;eval_config &#123; validation_period_during_training: 5 average_precision_mode: SAMPLE batch_size: 16 matching_iou_threshold: 0.5&#125;nms_config &#123; confidence_threshold: 0.01 clustering_iou_threshold: 0.6 top_k: 200&#125;augmentation_config &#123; output_width: 300 output_height: 300 output_channel: 3&#125;dataset_config &#123; data_sources: &#123; tfrecords_path: \"/home/alex/7th_sky_hackathon/data/tfrecords/kitti_train*\" &#125; include_difficult_in_training: true target_class_mapping &#123; key: \"cardboard\" value: \"cardboard\" &#125; target_class_mapping &#123; key: \"bottle\" value: \"bottle\" &#125; target_class_mapping &#123; key: \"banane\" value: \"banane\" &#125; validation_data_sources: &#123; label_directory_path: \"/home/alex/7th_sky_hackathon/data/val/label\" image_directory_path: \"/home/alex/7th_sky_hackathon/data/val/image\" &#125;&#125; 模型训练首先在 $LOCAL_EXPERIMENT_DIR 中创建模型输出文件夹 experiment_dir_unpruned_final，保存训练结果 之后，使用 tao 套件进行训练，各参数如下： —gpus：几个 GPU —gup_index：使用哪个 GPU -e：训练的设置文件 -r：训练模型输出文件夹 -k：秘钥 -m：预训练模型 1tao ssd train --gpus 1 -- gpu_index=$GPU_INDEX -e $SPECS_DIR/ssd_train_resnet18_kitti.txt -r $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final -k $KEY -m $USER_EXPERIMENT_DIR/7th/pretrained_resnet18/pretrained_object_detection_vresnet18/resnet_18.hdf5 训练完成后，可在 $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/weights 目录下，查看每轮训练出的模型 文件 ssd_training_log_resnet18.csv 中，记录了所有模型的精度，文件具体内容如下： 12345epoch,AP_banane,AP_bottle,AP_cardboard,loss,lr,mAP,validation_loss1,nan,nan,nan,27.146854,8.2377446e-05,nan,nan2,nan,nan,nan,17.637777,0.00013572087,nan,nan3,nan,nan,nan,15.214624,0.00022360678,nan,nan4,nan,nan,nan,13.826463,0.00036840313,nan,nan 选择 mAP 最大的模型作为最好的模型 1%set_env EPOCH=080 模型评估选择好模型后，使用 tao 套件，可对模型进行评估 1tao ssd evaluate --gpu_index=$GPU_INDEX -e $SPECS_DIR/ssd_train_resnet18_kitti.txt -m $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/weights/ssd_resnet18_epoch_$EPOCH.tlt -k $KEY 模型剪枝首先在目录 $USER_EXPERIMENT_DIR 下建立存储剪枝模型的目录 experiment_dir_pruned 之后使用 tao 工具套件对模型进行剪枝，各参数如下： -m：要剪枝的模型 -o：剪枝后的输出 -ep：剪枝的方式 -pth：剪枝的阈值 -k：秘钥 1tao ssd prune --gpu_index=$GPU_INDEX -m $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/weights/ssd_resnet18_epoch_$EPOCH.tlt -o $USER_EXPERIMENT_DIR/experiment_dir_pruned/ssd_resnet18_pruned.tlt -eq intersection -pth 0.6 -k $KEY 在经过剪枝后，需要对模型重新训练、评估，步骤同上","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"方阵函数及其计算","slug":"matrix-theory/08.方阵函数及其计算","date":"2022-11-18T04:14:00.000Z","updated":"2023-02-24T07:55:08.584Z","comments":true,"path":"mathematics/matrix-theory/6915a6bd.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/6915a6bd.html","excerpt":"【方阵函数】定义以往定义的函数 $y=f(x)$ 通常是指自变量 $x$ 为实数，因变量 $y$ 为实数的单值映射，将函数的概念进行拓广，定义方阵函数，即自变量与函数值都是方阵的一种特殊函数","text":"【方阵函数】定义以往定义的函数 $y=f(x)$ 通常是指自变量 $x$ 为实数，因变量 $y$ 为实数的单值映射，将函数的概念进行拓广，定义方阵函数，即自变量与函数值都是方阵的一种特殊函数 设幂级数 $\\sum\\limits_{k=0}^{\\infty}c_kz^k$ 的收敛半径为 $R$，其和函数为 $f(z)$，即 f(z)=\\sum\\limits_{k=0}^{\\infty}c_kz^k,\\quad |z|","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"矩阵序列与矩阵级数","slug":"matrix-theory/07.矩阵序列与矩阵级数","date":"2022-11-18T02:30:00.000Z","updated":"2023-02-24T07:53:46.311Z","comments":true,"path":"mathematics/matrix-theory/22fbf728.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/22fbf728.html","excerpt":"【向量序列的极限】定义设存在向量序列 $\\{\\mathbf{x}_1,\\mathbf{x}_2,\\cdots,\\mathbf{x}_k,\\cdots\\}\\subset V^n$，若 $\\exists \\mathbf{x} \\in V^n$，使得","text":"【向量序列的极限】定义设存在向量序列 $\\{\\mathbf{x}_1,\\mathbf{x}_2,\\cdots,\\mathbf{x}_k,\\cdots\\}\\subset V^n$，若 $\\exists \\mathbf{x} \\in V^n$，使得 \\lim_{k\\rightarrow +\\infty} ||\\mathbf{x}_k-\\mathbf{x}||_a=0则称向量序列 $\\{\\mathbf{x}_k\\}$ 按 a 范数收敛于 $\\mathbf{x}$ 等价性根据不同向量范数的等价性，可以得出如下结论： 在 $V^n$ 中，序列 $\\{\\mathbf{x}_k\\}$ 按某种范数收敛于 $\\mathbf{x}$，则 $\\{\\mathbf{x}_k\\}$ 按任何范数都收敛于 $\\mathbf{x}$ 在 $V^n$ 中，序列 $\\{\\mathbf{x}_k\\}$ 按某种范数收敛于 $\\mathbf{x}$，等价于 $\\{\\mathbf{x}_k\\}$ 按坐标收敛于 $\\mathbf{x}$，即设 $\\{\\mathbf{e}_1,\\mathbf{e}_2,\\cdots,\\mathbf{e}_n\\}$ 是 $V^n$ 的一个基，令 \\mathbf{x}=\\sum_{i=1}^nx_i\\mathbf{e}_i,\\quad\\mathbf{x}_k=\\sum_{i=1}^n x_i^{(k)}\\mathbf{e}_i则 \\begin{align*} &\\lim_{k\\rightarrow +\\infty} ||\\mathbf{x}_k-\\mathbf{x}||_a=0 \\\\ \\Leftrightarrow& \\lim_{k\\rightarrow +\\infty} ||\\mathbf{x}_k-\\mathbf{x}||_2=0 \\\\ \\Leftrightarrow& \\lim_{k\\rightarrow +\\infty} (\\sum_{i=1}^n|x_i^{(k)}-x_i|^2)^{\\frac{1}{2}}=0 \\\\ \\Leftrightarrow& \\lim_{k\\rightarrow +\\infty} |x_i^{(k)}-x_i|=0 \\\\ \\end{align*}【矩阵序列的极限】定义设 $\\{A_k\\}\\subset C^{m\\times n}$ 为一矩阵序列，$A_k$ 的 $(i,j)$ 处的元记为 $(A_k)_{ij}$，若极限 \\lim_{k\\rightarrow +\\infty} (A_k)_{ij}=(A)_{ij}均存在，则称矩阵序列 $\\{A_k\\}$ 收敛于矩阵 $A$，记为 $\\lim\\limits_{k\\rightarrow +\\infty}A_k=A$ 或 $A_k\\rightarrow A(k\\rightarrow +\\infty)$，否则，称矩阵序列 $\\{A_k\\}$ 是发散的 从定义可知，一个 $m\\times n$ 阶的矩阵序列 $\\{A_k\\}$ 收敛等价于 $mn$ 个数列极限收敛，故若 $\\lim\\limits_{k\\rightarrow +\\infty} A_k=A$，$\\lim\\limits_{k\\rightarrow +\\infty}B_k=B$，则 \\begin{array}{c} \\lim\\limits_{k\\rightarrow +\\infty}(\\lambda A_k+\\mu B_k)=\\lambda A+\\mu B,\\quad \\forall \\lambda,\\mu\\in C \\\\ \\lim\\limits_{k\\rightarrow +\\infty}(A_kB_k)=AB \\\\ \\lim\\limits_{k\\rightarrow +\\infty} A_k^{-1}=A^{-1} \\end{array}等价性根据不同矩阵范数的等价性，可以得出如下结论： 1）设 $A=[a_{ij}],A_k=[a_{ij}^{(k)}]\\in C^{m\\times n},k=1,2,\\cdots$，则 \\begin{align*} &\\lim_{k\\rightarrow +\\infty} A_k = A\\\\ \\Leftrightarrow& \\lim_{k\\rightarrow +\\infty} a_{ij}^{(k)}=a_{ij} \\\\ \\Leftrightarrow& \\lim_{k\\rightarrow +\\infty} \\max_{1\\leq j\\leq n} \\sum_{i=1}^m |a_{ij}^{(k)}-a_{ij}|\\rightarrow0 ,\\quad k\\rightarrow +\\infty \\\\ \\Leftrightarrow& ||A_k-A||_1\\rightarrow 0,\\quad k\\rightarrow +\\infty \\\\ \\Leftrightarrow& ||A_k-A||\\rightarrow 0,\\quad k\\rightarrow +\\infty\\quad (对任一矩阵范数) \\\\ \\end{align*}2）设 $A\\in C^{m\\times n}$，若 $||A||&lt;1$，则 \\lim_{k\\rightarrow +\\infty} A^k=O3）设 $A\\in C^{m\\times n}$，有 \\lim_{k\\rightarrow +\\infty} A^k=O \\Leftrightarrow \\rho(A)","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（五）图像数据集的处理","slug":"skyhackathon/05.NVIDIA 7th SkyHackathon（五）图像数据集的处理","date":"2022-11-17T08:58:00.000Z","updated":"2023-02-06T01:28:15.346Z","comments":true,"path":"nvidia/skyhackathon/5b50c09e.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/5b50c09e.html","excerpt":"训练环境设置文件地址在使用 Tao 训练模型时，需要设置两套文件地址：","text":"训练环境设置文件地址在使用 Tao 训练模型时，需要设置两套文件地址： USER_EXPERIMENT_DIR：docker 中的实验文档存放地址 LOCAL_PROJECT_DIR：系统中的实验文档存放地址 12345678910111213141516171819202122232425262728import os%env KEY=\"之前在 NGC 官网申请的秘钥\"%env GPU_INDEX=0# --------------docker地址设置--------------# docker 地址%env USER_EXPERIMENT_DIR=/home/alex/7th_sky_hackathon# docker 数据存放地址%env DATA_DOWNLOAD_DIR=/home/alex/7th_sky_hackathon/data# docker 规格说明存放地址%env SPECS_DIR=/home/alex/7th_sky_hackathon/7th/specs# --------------本地地址设置--------------# 本地项目地址%env LOCAL_PROJECT_DIR=/home/alex/7th_sky_hackathon# 本地数据集存放地址 $LOCAL_DATA_DIR=$LOCAL_PROJECT_DIR/dataos.environ[\"LOCAL_DATA_DIR\"] = os.path.join(os.getenv(\"LOCAL_PROJECT_DIR\", os.getcwd()), \"data\")# 本地步骤结果地址 $LOCAL_EXPERIMENT_DIR=$LOCAL_PROJECT_DIR/7thos.environ[\"LOCAL_EXPERIMENT_DIR\"] = os.path.join(os.getenv(\"LOCAL_PROJECT_DIR\", os.getcwd()), \"7th\")# 本地规格说明文件目录 $LOCAL_SPECS_DIR=$NOTEBOOK_ROOT/specs# 若未使用 notebook 环境，需定义执行下述命令，以定义 $NOTEBOOK_ROOT# %env NOTEBOOK_ROOT=/data/tlt-experiments/ssdos.environ[\"LOCAL_SPECS_DIR\"] = os.path.join(os.getenv(\"NOTEBOOK_ROOT\", os.getcwd()), \"specs\") 设置映射关系将两套文件地址设置好映射后，只需对系统地址进行管理，docker 系统中的地址将会自动进行管理 123456789101112131415161718import jsonmounts_file = os.path.expanduser(\"~/.tao_mounts.json\")# 定义映射字典drive_map = &#123; \"Mounts\": [ &#123; \"source\": os.environ[\"LOCAL_PROJECT_DIR\"], \"destination\": \"/home/alex/7th_sky_hackathon/\" &#125;, &#123; \"source\": os.environ[\"LOCAL_SPECS_DIR\"], \"destination\": os.environ[\"SPECS_DIR\"] &#125; ]&#125;with open(mounts_file, \"w\") as mfile: json.dump(drive_map, mfile, indent=4) 数据集处理数据集简介本次比赛，官方给出了 Pascal VOC 数据集，一共提供了三个压缩包，具体信息如下表 压缩包名 包含数据 数据来源 CARDBOARD.v1-cardboard.voc.zip 纸箱 https://universe.roboflow.com/object-detection/cardboard-1hdgz Food Project.v3-fruits-v3.voc.zip 果皮 https://universe.roboflow.com/object-detection/food-project trash.v1i.voc.zip 瓶子 https://universe.roboflow.com/object-detection/trash-5xwft 每个压缩包中包含相应图片和每张图片打完标签所对应的 XML 文件，每个样例以及相应标签的解释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;annotation&gt; &lt;folder&gt;&lt;/folder&gt; &lt;!-- 文件名 --&gt; &lt;filename&gt;cardboard1_jpg.rf.751f28e0ab21477466e5b0620fb70dde.jpg&lt;/filename&gt; &lt;path&gt;cardboard1_jpg.rf.751f28e0ab21477466e5b0620fb70dde.jpg&lt;/path&gt; &lt;!-- 图片来源信息 --&gt; &lt;source&gt; &lt;database&gt;roboflow.ai&lt;/database&gt; &lt;/source&gt; &lt;!-- 图片尺寸 --&gt; &lt;size&gt; &lt;width&gt;416&lt;/width&gt; &lt;height&gt;416&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;!-- 是否有分割label --&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;!-- 物体类别 --&gt; &lt;name&gt;CARDBOARD&lt;/name&gt; &lt;!-- 物体姿态 --&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;!-- 物体是否出现部分遮挡 &gt;15% 的情况 --&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;!-- 物体是否难以辨识，即需要结合背景才能辨识 --&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;!-- 物体的重要部分是否被遮挡 --&gt; &lt;occluded&gt;0&lt;/occluded&gt; &lt;!-- 物体的 bound box --&gt; &lt;bndbox&gt; &lt;!-- 左 --&gt; &lt;xmin&gt;29&lt;/xmin&gt; &lt;!-- 上 --&gt; &lt;xmax&gt;387&lt;/xmax&gt; &lt;!-- 右 --&gt; &lt;ymin&gt;8&lt;/ymin&gt; &lt;!-- 下 --&gt; &lt;ymax&gt;338&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; 需要注意的是，除官方所提供的数据集外，还可以使用自己的数据集，同时，由于官方给出的数据集中部分数据样本有问题，需要进行数据清洗与重复标注，重复标注阶段使用的工具是 labelimg 数据集要求比赛要求将 VOC 标注格式转为 Kitti 标注格式，标注样例如下： 1banane 0.00 0 0.0 56.00 5.00 338.00 415.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0 VOC 标注格式转 Kitti 标注格式VOC 标注格式转为 Kitti 标注格式转换脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport xml.etree.ElementTree as ETfrom tqdm import tqdmdef convert(xml_dir, kitti_dir, filename): # 打开xml文件 file = open(xml_dir + filename, \"rb\") # 获取xml的root结点 root = ET.parse(file).getroot() # 对 object 进行枚举 for obj in root.iter(\"object\"): # 物体类别 clazz = obj.find(\"name\").text if clazz == \"bottle\": clazz = \"bottle\" elif clazz == \"CARDBOARD\": clazz = \"cardboard\" elif clazz == \"banane\" or clazz == \"0\": clazz = \"banane\" else: clazz = \"\" # 物体的 bound box bndbox = obj.find(\"bndbox\") xmin = int(bndbox.find(\"xmin\").text) xmax = int(bndbox.find(\"xmax\").text) ymin = int(bndbox.find(\"ymin\").text) ymax = int(bndbox.find(\"ymax\").text) # 写入 if clazz == \"bottle\" or clazz == \"cardboard\" or clazz == \"banane\": clazz = clazz + \" 0.00 0 0.0 \" + str(xmin) + \" \" + str(ymin) + \" \" + str(xmax) + \" \" + str(ymax) + \" 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n\" with open(kitti_dir + filename + \".txt\", \"w\") as f: f.write(clazz)if __name__ == \"__main__\": # xml路径 xml_dir = \"/home/alex/7th_sky_hackathon/data/xml\" # kitti路径 kitti_dir = \"/home/alex/7th_sky_hackathon/data/kitti\" # 对xml路径中的每个文件进行转换 xml_list = os.listdir(xml_dir) for i in tqdm(range(len(xml_list))): convert(xml_dir, kitti_dir, xml_list[i]) 生成验证集使用官方提供的脚本 generate_val_dataset.py 来生成验证集 1python3.6 generate_val_dataset.py -- input_image_dir=$LOCAL_DATA_DIR/images --input_label_dir=$LOCAL_DATA_DIR/labels --output_dir=$LOCAL_DATA_DIR/val 脚本内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Copyright (c) 2017-2020, NVIDIA CORPORATION. All rights reserved.from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport argparseimport osdef parse_args(args=None): # 参数解析 parser = argparse.ArgumentParser(description='生成验证数据集') parser.add_argument( \"--input_image_dir\", type=str, required=True, help=\"Kitti 训练集图像的输入目录\" ) parser.add_argument( \"--input_label_dir\", type=str, required=True, help=\"Kitti 训练集标注的输入目录\" ) parser.add_argument( \"--output_dir\", type=str, required=True, help=\"验证集输出目录\" ) parser.add_argument( \"--val_split\", type=int, required=False, default=10, help=\"验证集占训练集的百分比\" ) return parser.parse_args(args)def main(args=None): # 参数处理 args = parse_args(args) # 图像文件 img_files = [] for file_name in os.listdir(args.input_image_dir): if file_name.split(\".\")[-1] == \"jpg\": img_files.append(file_name) total_cnt = len(img_files) # 划分验证集 val_ratio = float(args.val_split) / 100.0 val_cnt = int(total_cnt * val_ratio) train_cnt = total_cnt - val_cnt val_img_list = img_files[0:val_cnt] # 输出目录 target_img_path = os.path.join(args.output_dir, \"image\") target_label_path = os.path.join(args.output_dir, \"label\") if not os.path.exists(target_img_path): os.makedirs(target_img_path) else: print(\"图像输出路径已存在\") return if not os.path.exists(target_label_path): os.makedirs(target_label_path) else: print(\"标注输出路径已存在\") return # 输出 print(\"总计 &#123;&#125; 个 Kitti 样本\".format(total_cnt)) print(\"划分出 &#123;&#125; 个训练样本，以及 &#123;&#125; 个验证样本\".format(train_cnt, val_cnt)) for img_name in val_img_list: label_name = img_name.split(\".jpg\")[0] + \".txt\" os.rename(os.path.join(args.input_image_dir, img_name), os.path.join(target_img_path, img_name)) os.rename(os.path.join(args.input_label_dir, label_name), os.path.join(target_label_path, label_name))if __name__ == \"__main__\": main() 将 Kitti 格式数据集转为 TFRecords 格式根据实际目录配置，修改 specs/ssd_tfrecords_kitti_train.txt 中的内容，其中需要修改的内容如下： 字段 含义 root_directory_path docker 环境中的地址 image_dir_name 保存图片数据的文件夹 label_dir_name 保存标注文件的文件夹 target_class_mapping 标注的类别，key 为标注文件中写的类别，value 为 Tao 训练时使用的类别 修改后的内容如下： 1234567891011121314151617181920212223kitti_config &#123; root_directory_path: \"/home/alex/7th_sky_hackathon/data\" image_dir_name: \"images\" label_dir_name: \"labels\" image_extension: \".jpg\" partition_mode: \"random\" num_partitions: 2 val_split: 0 num_shards: 10&#125;image_directory_path: \"/home/alex/7th_sky_hackathon/data\"target_class_mapping &#123; key: \"cardboard\" value: \"cardboard\"&#125;target_class_mapping &#123; key: \"bottle\" value: \"bottle\"&#125;target_class_mapping &#123; key: \"banane\" value: \"banane\"&#125; 之后，在 $LOCAL_DATA_DIR 目录下，创建用于保存 tfrecord 格式数据的文件夹 tfrecords，再利用 tao 自带的工具转换数据，将训练集转为 tfrecord 格式 12$LOCAL_DATA_DIR/tfrecords/*!tao ssd dataset_convert -d home/alex/7th_sky_hackathon/7th/specs/ssd_tfrecords_kitti_train.txt -o /home/alex/7th_sky_hackathon/data/tfrecords/kitti_train","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（四）Nemo ASR 模型训练与评估","slug":"skyhackathon/04.NVIDIA 7th SkyHackathon（四）Nemo ASR 模型训练与评估","date":"2022-11-15T03:30:00.000Z","updated":"2023-02-06T01:27:21.027Z","comments":true,"path":"nvidia/skyhackathon/8359dd7a.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/8359dd7a.html","excerpt":"模型加载导入 NeMo123456789101112import nemoimport nemo.collection.asr as nemo_asrimport torch# 检查 nemo 版本 '1.4.0'print(nemo.__version__)# 检查 torch 版本 '1.12.1+cu113'print(torch.__version__) # 检查 GPU 是否被 torch 调用 Trueprint(torch.cuda.is_available())","text":"模型加载导入 NeMo123456789101112import nemoimport nemo.collection.asr as nemo_asrimport torch# 检查 nemo 版本 '1.4.0'print(nemo.__version__)# 检查 torch 版本 '1.12.1+cu113'print(torch.__version__) # 检查 GPU 是否被 torch 调用 Trueprint(torch.cuda.is_available()) 加载自动语音识别模型NeMo 的每个集合 ASR、NLP、TTS 中，都提供了许多预训练模型，使用 list_available_models() 可以查看 ASR 所提供的所有预训练模型 123456789nemo_asr.models.EncDecCTCModel.list_available_models()'''[PretrainedModelInfo( pretrained_model_name=QuartzNet15x5Base-En, description=QuartzNet15x5 model trained on six datasets: LibriSpeech, Mozilla Common Voice (validated clips from en_1488h_2019-12-10), WSJ, Fisher, Switchboard, and NSC Singapore English. It was trained with Apex/Amp optimization level O1 for 600 epochs. The model achieves a WER of 3.79% on LibriSpeech dev-clean, and a WER of 10.05% on dev-other. Please visit https://ngc.nvidia.com/catalog/models/nvidia:nemospeechmodels for further details., location=https://api.ngc.nvidia.com/v2/models/nvidia/nemospeechmodels/versions/1.0.0a5/files/QuartzNet15x5Base-En.nemo ), ...]''' 本次比赛 NVIDIA 在相关资料中提供了中文预训练模型 stt_zh_quartznet15x5.nemo，使用 restore_form() 进行加载 12# 加载中文预训练模型并实例化quartznet = nemo_asr.models.EncDecCTCModel.restore_from(\"stt_zh_quartznet15x5.nemo\") 加载 quartznet 配置文件使用 YAML 读取 quartznet 模型配置文件 1234567891011try: from ruamel.yaml import YAMLexcept ModuleNotFoundError: from ruamel_yaml import YAMLconfig_path =\"quartznet_15x5_zh.yaml\"yaml = YAML(typ='safe')with open(config_path) as f: params = yaml.load(f) print(params) 加载数据清单并传给配置文件将之前所制作的数据清单进行加载，并传给配置文件 1234567# 加载数据清单train_manifest = \"/root/data/train.json\"test_manifest = \"/root/data/val.json\"# 传递给配置文件params['model']['train_ds']['manifest_filepath']=train_manifestparams['model']['validation_ds']['manifest_filepath']=test_manifest 模型训练训练使用迁移学习的方法训练模型 123456789# 设置训练集quartznet.setup_training_data(train_data_config=params['model']['train_ds'])# 设置测试集quartznet.setup_validation_data(val_data_config=params['model']['validation_ds'])# 开始训练import pytorch_lightning as pltrainer = pl.Trainer(gpus=1,max_epochs=200)trainer.fit(quartznet) 保存并重载12345# 将训练好的模型保存为.nemo格式quartznet.save_to(\"7th_asr_model_1.nemo\")# 重新加载模型try_model_1 = nemo_asr.models.EncDecCTCModel.restore_from(\"7th_asr_model_1.nemo\") 模型评估123456789101112131415from ASR_metrics import utils as metrics# 加载测试数据asr_result = try_model_1.transcribe(paths2audio_files=[\"/root/data/test/1/1.wav\"])print(asr_result)#指定正确答案s1 = \"请检测出果皮\"#识别结果s2 = \" \".join(asr_result)#计算字错率cerprint(\"字错率:&#123;&#125;\".format(metrics.calculate_cer(s1,s2)))#计算准确率print(\"准确率:&#123;&#125;\".format(1-metrics.calculate_cer(s1,s2)))","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（三）语音数据集的制作","slug":"skyhackathon/03.NVIDIA 7th SkyHackathon（三）语音数据集的制作","date":"2022-11-14T13:51:00.000Z","updated":"2023-02-06T01:28:01.762Z","comments":true,"path":"nvidia/skyhackathon/754e609e.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/754e609e.html","excerpt":"数据采集为制作数据集，寻找了 65 个人单独采集样本，每人录制一个采样率为 44100HZ 的 wav 单声道语音文件 录制内容为下述的 15 句话，在对每个文件进行分割、数据清洗后，按类别存放在 15 个文件夹中，具体数据情况如下：","text":"数据采集为制作数据集，寻找了 65 个人单独采集样本，每人录制一个采样率为 44100HZ 的 wav 单声道语音文件 录制内容为下述的 15 句话，在对每个文件进行分割、数据清洗后，按类别存放在 15 个文件夹中，具体数据情况如下： 编号 内容 数据量 1 请检测出果皮 62 2 请检测出瓶子 61 3 请检测出纸箱 61 4 请检测出果皮和瓶子 60 5 请检测出果皮和纸箱 61 6 请检测出瓶子和果皮 61 7 请检测出瓶子和纸箱 59 8 请检测出纸箱和果皮 61 9 请检测出纸箱和瓶子 60 10 请检测出果皮、瓶子和纸箱 60 11 请检测出果皮、纸箱和瓶子 61 12 请检测出瓶子、果皮和纸箱 60 13 请检测出瓶子、纸箱和果皮 60 14 请检测出纸箱、果皮和瓶子 61 15 请检测出纸箱、瓶子和果皮 60 数据清单要求本次比赛数据清单格式要求如下例： 12345&#123; \"audio_filepath\": \"/root/traindata/hi1.wav\", \"duration\": 3.1463038548752835, \"text\": \"你好请让我进入小区\"&#125; NVIDIA 官方建议使用 librosa 音频工具包获取音频时长 12import librosa time = librosa.get_duration(filename=\"raw_data/请检测出果皮/10.wav\") 数据清单制作采用随机交叉验证，将清洗后的数据划分为训练集、测试集，并制作出 json 格式的数据清单：train.json、val.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time: 2022/11/12 16:25# @Author: FangXinimport librosaimport osimport jsonimport randomraw_root = 'raw_data/'save_root = 'data/'sentences = os.listdir(raw_root)print(sentences)train_cnt = 0train = []val_cnt = 0val = []for s in sentences: path = raw_root + s + '/' files = os.listdir(path) for f in files: file_path = os.path.join(path, f) if not os.path.isfile(file_path): continue # 每个句子的时长 time = librosa.get_duration(filename=file_path) dic = &#123;\"audio_filepath\": file_path, \"duration\": time, \"text\": s&#125; # 交叉验证 if random.random() &lt; 0.8: out_file = open(f\"&#123;save_root&#125;\" + 'train/' + f\"&#123;f.split('.')[0] + '_' + s&#125;.json\", \"w\") json.dump(dic, out_file) out_file.close() train_cnt += 1 train.append(dic) else: out_file = open(f\"&#123;save_root&#125;\" + 'val/' + f\"&#123;f.split('.')[0] + '_' + s&#125;.json\", \"w\") json.dump(dic, out_file) out_file.close() val_cnt += 1 val.append(dic)print(f\"train 中数据数量：&#123;train_cnt&#125;\")print(f\"val 中数据数量：&#123;val_cnt&#125;\")# 生成train.json文件with open(save_root+'train.json', 'w') as json_file: for each_dict in train: json_file.write(json.dumps(each_dict) + '\\n')# 生成val.json文件with open(save_root+'val.json', 'w') as json_file: for each_dict in train: json_file.write(json.dumps(each_dict) + '\\n')","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"特征函数、矩母函数与母函数","slug":"probability-theory/06.特征函数、矩母函数与母函数","date":"2022-11-14T13:21:00.000Z","updated":"2023-02-24T07:32:27.566Z","comments":true,"path":"mathematics/probability-theory/70829920.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/70829920.html","excerpt":"Reference 概率论与随机过程8——特征函数，矩母函数与母函数 概率论学习笔记（五） 概率论学习笔记（六） 公式墙(1)——Laplace Transform(拉普拉斯变换) 拉普拉斯变换简介 从另一个角度看拉普拉斯变换 【复随机变量】设 $(\\Omega,\\mathscr{F},P)$ 为一概率空间，$X,Y$ 为 $\\mathscr{F}$ 的实值随机变量，则称","text":"Reference 概率论与随机过程8——特征函数，矩母函数与母函数 概率论学习笔记（五） 概率论学习笔记（六） 公式墙(1)——Laplace Transform(拉普拉斯变换) 拉普拉斯变换简介 从另一个角度看拉普拉斯变换 【复随机变量】设 $(\\Omega,\\mathscr{F},P)$ 为一概率空间，$X,Y$ 为 $\\mathscr{F}$ 的实值随机变量，则称 Z\\triangleq X+jY,\\quad j=\\sqrt{-1}为复随机变量 复随机变量 $Z$ 是取复数值的随机变量，其数学期望被定义为 EZ\\triangleq EX+jEY【随机变量的特征函数】特征函数设 $X$ 为实值随机变量，其分布函数为 $F(x)$，则称 \\varphi(t)\\triangleq E[e^{jtX}]=\\int_{-\\infty}^{+\\infty}e^{jtx}dF(x),\\quad -\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"随机变量的数字特征","slug":"probability-theory/05.随机变量的数字特征","date":"2022-11-14T05:30:00.000Z","updated":"2023-02-24T07:09:15.621Z","comments":true,"path":"mathematics/probability-theory/17018599.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/17018599.html","excerpt":"Reference 概率论学习笔记（四） 可测函数与积分、Stieltjes积分 在Stieltjes观点下看“级数”与“积分” 初识斯蒂尔杰斯积分（Stieltjes integral） 【引入】Stieltjes 积分","text":"Reference 概率论学习笔记（四） 可测函数与积分、Stieltjes积分 在Stieltjes观点下看“级数”与“积分” 初识斯蒂尔杰斯积分（Stieltjes integral） 【引入】Stieltjes 积分设 $f(x),g(x)$ 是定义在 $[a,b]$ 上的有界函数，$a=x_0&lt;x_1&lt;\\cdots&lt;x_n=b$ 为区间 $[a,b]$ 的任一划分，取 $\\Delta x_k=x_k-x_{k-1}$，$\\Delta=\\max\\limits_{1\\leq k\\leq n} \\Delta_k$，在每一子区间 $[x_{k-1},x_k]$ 上任取一点 $\\xi_k$ 作和式 S = \\sum_{k=1}^n f(\\xi_k)[g(x_k)-g(x_{k-1})]若极限 \\lim_{\\Delta\\rightarrow0} S = \\lim_{\\Delta\\rightarrow0} \\sum_{k=1}^n f(\\xi_k)[g(x_k)-g(x_{k-1})]存在，且与 $[a,b]$ 的划分方法和 $\\xi_k$ 的取法无关，则称该极限为函数 $f(x)$ 对函数 $g(x)$ 在区间 $[a,b]$ 的 Stieltjes 积分，简称 S 积分，也称 $f(x)$ 对 $g(x)$ 在 $[a,b]$ 上可积，记为 $\\int_a^bf(x)dg(x)$ 进一步，若 $f(x),g(x)$ 是定义在 $(-\\infty,+\\infty)$ 上的函数，在任意有限区间 $[a,b]$ 上，$f(x)$ 对 $g(x)$ 在 $[a,b]$ 上可积，且极限 \\lim_{\\begin{align*}a\\rightarrow -\\infty\\\\b\\rightarrow+\\infty\\end{align*}} \\int_b^a f(x) dg(x)存在，则称该极限为 $f(x)$ 对 $g(x)$ 在无穷区间 $(-\\infty,+\\infty)$ 上的 Stieltjes 积分，记为 $\\int_{-\\infty}^{+\\infty}f(x)dg(x)$ S 积分的转化在 S 积分中，当 $g(x)$ 取一些特殊形式时，其可化为级数或黎曼积分 当 $g(x)=x$ 时，S 积分即黎曼积分，有 \\int_{-\\infty}^{+\\infty} f(x) dg(x)=\\int_{-\\infty}^{+\\infty} f(x) dx当 $g(x)$ 为可微函数，且其导数为 $g’(x)$ 时，有 \\int_{-\\infty}^{+\\infty} f(x) dg(x)=\\int_{-\\infty}^{+\\infty} f(x) g'(x)dx当 $g(x)$ 为阶梯函数，且其跳跃点为有限个或无穷可列个时，积分问题转为判别级数是否收敛问题，有 \\int_{-\\infty}^{+\\infty} f(x) dg(x)=\\sum_kf(x_k)\\big[g(x_k+0)-g(x_k-0)\\big]Fourier-Stieltjes 积分当 $f(x)=e^{itx}$ 时，根据欧拉公式，有： e^{itx}=\\cos tx+i\\sin tx若积分 \\int_{-\\infty}^{+\\infty} e^{itx} dg(x)=\\int_{-\\infty}^{+\\infty}\\cos tx dg(x) + i\\int_{-\\infty}^{+\\infty}\\sin tx dg(x)存在，则称该积分为 $g(x)$ 的 Fourier-Stieltjes 积分，简称 F-S 积分 【数学期望】随机变量设 $X$ 为一随机变量，$F(x)$ 为其分布函数，若 $\\int_{-\\infty}^{+\\infty} |x| dF(x) &lt; +\\infty$，则称 EX\\triangleq \\int_{-\\infty}^{+\\infty} x dF(x)为随机变量 $X$ 的数学期望，描述了 $X$ 平均取值状况特征 当 $X$ 为离散型随机变量时，其分布律为 $P(X=x_i)=p_i$，则： EX=\\sum_{i}x_ip_i当 $X$ 为连续型随机变量时，其概率密度函数为 $f(x)$，则： EX=\\int_{-\\infty}^{+\\infty}xf(x) dx随机向量若 $y=g(x)$ 为一连续函数，$\\int_{-\\infty}^{+\\infty} g(x) dF(x)$ 存在，则 EY=E[g(X)]=\\int_{-\\infty}^{+\\infty} g(x) dF(x)推广到 $n$ 维随机向量，设 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$，其联合分布函数为 $F(x_1,x_2,\\cdots,x_n)$，$g(x_1,x_2,\\cdots,x_n)$ 是连续函数，若 $\\int_{-\\infty}^{+\\infty}\\cdots\\int_{-\\infty}^{+\\infty} g(x_1,\\cdots,x_n) dF(x_1,\\cdots,x_n)$ 存在，则 E[g(X_1,\\cdots,X_n)]=\\int_{-\\infty}^{+\\infty}\\cdots\\int_{-\\infty}^{+\\infty} g(x_1,\\cdots,x_n) dF(x_1,\\cdots,x_n)性质随机变量的数学期望具有如下性质： 设 $a,b$ 为任意常数，则 $E(aX+bY)=aEX+bEY$ 若 $X,Y$ 相互独立，则 $EXY=EXEY$ Schwarz 不等式：设 $E|X|^2&lt;+\\infty,E|Y|^2&lt;+\\infty$，则 $(EXY)^2\\leq EX^2EY^2$ 【方差】方差设 $X$ 为一随机变量，$F(x)$ 为其分布函数， $E|X|^2&lt;+\\infty$，则称 DX\\triangleq E(X-EX)^2=\\int_{-\\infty}^{+\\infty}(x-EX)^2 dF(x)为随机变量 $X$ 的方差，其描述了 $X$ 与其期望值偏离程度 当 $X$ 为离散型随机变量时，其分布律为 $P(X=x_i)=p_i$，则： DX=\\sum_{i}(x_i-EX)^2p_i若 $X$ 为连续型随机变量时，其概率密度函数为 $f(x)$，则： DX=\\int_{-\\infty}^{+\\infty}(x-EX)^2f(x) dx性质随机变量的方差具有如下性质： 设 $c$ 为任意常数，则 $D(c)=0$ 设 $a,b$ 为任意常数，则 $D(aX+b)=a^2DX$ $D(X\\pm Y)=DX+DY\\pm 2Cov(X,Y)$ 若 $X,Y$ 相互独立，则 $D(aX+bY)=a^2DX+b^2DY$ $DX=EX^2-(EX)^2$ 【协方差】协方差设 $X,Y$ 为随机变量，$F(x,y)$ 为联合分布函数， $E|X|^2&lt;+\\infty,E|X|^2&lt;+\\infty$，则称 cov(X,Y)\\triangleq E[(X-EX)(Y-EY)]=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}(x-EX)(y-EY) dF(x,y)为随机变量 $X,Y$ 的协方差，其描述了 $X,Y$ 间偏差的关联程度 当 $(X,Y)$ 为离散型随机变量时，其联合分布律为 $P(X=x_i,Y=y_j)=p_{ij}$，则： cov(X,Y)=\\sum_{i}\\sum_{j}(x_i-EX)(y_j-EY)p_{ij}若 $(X,Y)$ 为连续型随机变量时，其联合概率密度函数为 $f(x,y)$，则： DX=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}(x-EX)(y-EY)f(x,y) dxdy相关系数设 $X,Y$ 为随机变量，若 $DX&gt;0,DY&gt;0$，则称 \\rho_{XY}\\triangleq \\frac{cov(X,Y)}{\\sqrt{DX}\\sqrt{DY}}为随机变量 $X,Y$ 的相关系数 若 $\\rho_{XY}=0$，则称 $X,Y$ 不相关，若 $\\rho_{XY}\\neq 0$，则称 $X,Y$ 相关 此外，有： \\rho_{XY}=0 \\Leftrightarrow Cov(X,Y)=0 \\Leftrightarrow EXY=EXEY\\Leftrightarrow D(X\\pm Y)= DX+DY性质随机变量 $X,Y$ 的协方差具有如下性质： $Cov(X,Y)=Cov(Y,X)$ $Cov(X,X)=DX$ 设 $c$ 为任意常数，则 $Cov(X,c)=Cov(c,Y)=0$ 设 $a,b$ 为任意常数，则 $Cov(aX+b,Y)=aCov(X,Y)$ $Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$ 随机变量 $X,Y$ 的相关系数具有如下性质： $\\rho_{XX}=1$ $|\\rho_{XY}|\\leq 1$ 若 $Y=aX+b$，则 $a&gt;0$ 时，$\\rho_{XY}=1$，$a&lt;0$ 时，$\\rho_{XY}=-1$ 【均值向量与协方差矩阵】设 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$ 为一 $n$ 维随机向量，称 E\\mathbf{X}\\triangleq(EX_1,EX_2,\\cdots,EX_n)为 $n$ 维随机向量 $\\mathbf{X}$ 的均值向量，称 \\mathbf{B} \\triangleq \\begin{bmatrix} Cov(X_1,X_1) & Cov(X_1,X_2) & \\cdots & Cov(X_1,X_n) \\\\ Cov(X_2,X_1) & Cov(X_2,X_2) & \\cdots & Cov(X_2,X_n) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ Cov(X_n,X_1) & Cov(X_n,X_2) & \\cdots & Cov(X_n,X_n) \\\\ \\end{bmatrix}为 $n$ 维随机向量 $\\mathbf{X}$ 的协方差矩阵，其是一个非负定矩阵，且主对角线元素分别为 $X_1,X_2,\\cdots,X_n$ 的方差","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（二）开发套件的安装与测试","slug":"skyhackathon/02.NVIDIA 7th SkyHackathon（二）开发套件的安装与测试","date":"2022-11-11T13:37:00.000Z","updated":"2023-02-06T03:12:41.155Z","comments":true,"path":"nvidia/skyhackathon/dda5ea58.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/dda5ea58.html","excerpt":"NeMo 开源工具包关于 NeMoNeMo（Neural Modules）是 NVIDIA 发布的基于 PyTorch 的开源工具包，它允许开发者快速构建、训练和微调会话式人工智能模型","text":"NeMo 开源工具包关于 NeMoNeMo（Neural Modules）是 NVIDIA 发布的基于 PyTorch 的开源工具包，它允许开发者快速构建、训练和微调会话式人工智能模型 NeMo 由 NeMo Core 和 NeMo Collection 组成，NeMo Core 为所有模型和模块提供了一个通用的外观，NeMo Collection 则是特定领域模块和模型的组合 NeMo Collection 主要分为三个模块： Speech Collection（nemo_asr）：用于 ASR 任务的模型，如语音识别、命令识别等 NLP Collection（nemo_nlp）：用于 NLP 任务的模型，如问题回答、命名实体识别等 Speech Synthesis（nemo_tts）：用于 TTS 任务的模块，如谱图生成器、声码器等 关于 TAO 的详细介绍，见：NVIDIA NeMo NeMo 的应用栈如下图 安装 NeMo 语音工具包（NeMo Speech Collection）1234567root@Alex-McAvoy:~$ apt-get update &amp;&amp; sudo apt-get install -y libsndfile1 ffmpegroot@Alex-McAvoy:~$ pip install Cythonroot@Alex-McAvoy:~$ pip install --user pytest-runnerroot@Alex-McAvoy:~$ pip install rosa numpy==1.19.4root@Alex-McAvoy:~$ pip install torchmetrics==0.6.0root@Alex-McAvoy:~$ pip install nemo_toolkit[all]==1.4.0root@Alex-McAvoy:~$ pip install ASR-metrics NeMo 语音工具包检测若没有报错表示安装成功（Warning 无需理会） 123root@Alex-McAvoy:~$ python&gt;&gt;&gt; import nemo&gt;&gt;&gt; import nemo.collections.asr as nemo_asr TAO 模型训练工具套件关于 TAOTAO（Train, Adapt and Optimize）是 NVIDIA 基于TensorFlow 和 PyTorch 构建的工具套件，其利用迁移学习从现有的神经网络模型中已学习到的特征提取到新的自定义模型中，通过利用自己的数据对预训练 NVIDIA 模型进行微调，并针对推理进行优化 关于 TAO 的详细介绍，见：NVIDIA TAO 工具套件 TAO 的应用栈如下图 安装运行 TAO 的 Virtualenv 虚拟环境为确保 TAO 有独立的 Python 运行环境，需要安装 Virtualenv 虚拟环境 12root@Alex-McAvoy:~$ pip install virtualenv virtualenvwrapperroot@Alex-McAvoy:~$ mkdir $HOME/.virtualenvs 之后，利用 vim 在 ~/.bashrc 中，添加如下行： 123export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=$HOME/miniconda3/bin/python3source $HOME/miniconda3/bin/virtualenvwrapper.sh 保存退出后，执行 source ~/.bashrc 重新加载 bash 配置 最后，创建名为 tao 的虚拟环境 1root@Alex-McAvoy:~$ mkvirtualenv tao -p $HOME/miniconda3/bin/python3 安装 TAO 模型训练工具执行 workon tao 进入之前创建的名为 tao 的虚拟环境，然后在其中安装 TAO 123(tao)root@Alex-McAvoy:~$ pip3 install nvidia-pyindex(tao)root@Alex-McAvoy:~$ pip3 install nvidia-tao(tao)root@Alex-McAvoy:~$ tao info 当出现以下信息后，说明安装成功","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"向量范数与矩阵范数","slug":"matrix-theory/06.向量范数与矩阵范数","date":"2022-11-11T05:26:00.000Z","updated":"2023-02-24T07:51:20.251Z","comments":true,"path":"mathematics/matrix-theory/13c0cc0d.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/13c0cc0d.html","excerpt":"【向量范数】定义在内积空间中，可以通过向量的内积来定义向量的长度 $|\\alpha|=\\sqrt{&lt;\\alpha,\\alpha&gt;}$，那么对于一般的线性空间，也可以引入一个类似长度的概念，即范数","text":"【向量范数】定义在内积空间中，可以通过向量的内积来定义向量的长度 $|\\alpha|=\\sqrt{&lt;\\alpha,\\alpha&gt;}$，那么对于一般的线性空间，也可以引入一个类似长度的概念，即范数 设 $V$ 是数域 $F$ 上的线性空间，若 $\\forall \\alpha \\in V$，都有一个实数 $||\\alpha||$ 与之对应，且满足条件： 正定性：$||\\alpha||&gt;0$ 且 $||\\alpha||=0\\Leftrightarrow \\alpha=0$ 齐次性：$||k\\alpha||=|k|\\cdot||\\alpha||,k\\in F$ 三角不等式：$||\\alpha+\\beta||\\leq ||\\alpha||+||\\beta||$ 则称 $||\\alpha||$ 为线性空间 $V$ 中向量的范数，定义了范数的线性空间称为线性赋范数空间，记为 $(V,||\\cdot||)$ 根据范数的定义可知，线性空间中范数的定义不是唯一的，在 $C^n$ 上可以找到无穷多种范数 等价性设 $||\\cdot||_{a}$ 和 $||\\cdot||_b$ 是 $n$ 维线性空间 $V^n$ 中的任意两种范数，若存在常数 $M\\geq m&gt;0$，使得 $\\forall \\alpha\\in V$，有 m||\\alpha||_b\\leq ||\\alpha||_a\\leq M||\\alpha||_b则称范数 $||\\cdot||_a$ 与 $||\\cdot||_b$ 等价，记为 $||\\cdot||_a \\sim ||\\cdot||_b$ 易知 $\\sim$ 满足等价关系的三定律： 自反律：$||\\cdot||_a\\sim||\\cdot||_a$ 对称律：若 $||\\cdot||_a\\sim||\\cdot||_b$，则 $||\\cdot||_b\\sim||\\cdot||_a$ 传递律：若 $||\\cdot||_a\\sim||\\cdot||_b,||\\cdot||_a\\sim||\\cdot||_c$，则 $||\\cdot||_a\\sim||\\cdot||_c$ 常用范数向量范数 $||\\alpha||$ 可视为按照一定规律与向量 $\\alpha$ 对应的非负实值函数，对 $\\forall \\mathbf{x}=[x_1,x_2,\\cdots,x_n]^T\\in C^n$，有 1）p 范数：常用于导出其他范数，当 $p$ 分别取 $0,1,2,\\infty$ 时，有 0 范数、1 范数、2 范数、无穷范数 ||\\mathbf{x}||_p=\\big({\\sum_{i=1}^n|x_i|^p}\\big)^{\\frac{1}{p}} 2）0 范数：向量 $\\mathbf{x}$ 中非 $0$ 元素的个数，通常用于表示稀疏程度，$0$ 范数越小，表示 $0$ 元素就多，也就越稀疏 ||\\mathbf{x}||_0=\\lim_{p\\rightarrow0}\\sum_{i=1}^n |x_i|^p=\\#\\{i:x_i\\neq0\\}3）1 范数：表示向量 $\\mathbf{x}$ 中所有元素的绝对值的和 ||\\mathbf{x}||_1=\\sum_{i=1}^n|x_i|4）2 范数：表示向量 $\\mathbf{x}$ 中所有元素的均方根 ||\\mathbf{x}||_2=\\sqrt{\\sum_{i=1}^nx_i^2}当线性空间 $V$ 为欧氏空间时，2 范数即为向量的长度 $||\\mathbf{x}||=\\sqrt{&lt;\\mathbf{x},\\mathbf{x}&gt;}$，被称为欧氏范数 5）无穷范数：表示向量 $\\mathbf{x}$ 中各元素的绝对值的最大值 ||\\mathbf{x}||_\\infty=\\max{|x_i|}【矩阵范数】相容与协调矩阵 $A$ 可视为 $C^{n}\\rightarrow C^{m}$ 上的线性变换，那么矩阵范数 $||A||$ 与向量范数 $||\\mathbf{x}||_{\\alpha},||\\mathbf{y}||_{\\beta}$ 存在一定关系，为此给出如下定义 设 $||\\cdot||_{\\alpha}$，$||\\cdot||_{\\beta}$ 和 $||\\cdot||_{\\gamma}$ 是线性空间 $C^{m\\times n}$、$C^{n\\times p}$、$C^{m\\times p}$ 中满足范数公理的矩阵范数，若 $\\forall A\\in C^{m\\times n},B\\in C^{n\\times p}$ 有不等式 ||AB||_{\\gamma}\\leq ||A||_{\\alpha}\\cdot||B||_{\\beta}成立，则称这三种矩阵范数 $||\\cdot||_{\\alpha}$，$||\\cdot||_{\\beta}$ 和 $||\\cdot||_{\\gamma}$ 是相容的 当 $p=1$ 时，有 $\\forall \\mathbf{x}\\in C^n,A\\mathbf{x}\\in C^m$ ||A\\mathbf{x}||_{\\gamma}\\leq ||A||\\cdot||\\mathbf{x}||_{\\beta}此时称矩阵范数 $||\\cdot||$ 和向量范数 $||\\cdot||_{\\beta},||\\cdot||_{\\gamma}$ 是协调的 等价性与向量范数类似，对一般的矩阵范数，有如下性质： 1）设 $A=[a_{ij}]\\in C^{m\\times n}$，则 $A$ 的任一种矩阵范数 $||A||$ 都是 $A$ 的 $m\\times n$ 个元素的连续函数 2）矩阵空间 $C^{m\\times n}$ 上的任意两种矩阵范数 $||\\cdot||_a,||\\cdot||_b$ 都是等价的，即存在常数 $M\\geq m\\geq 0$，使得 $\\forall A\\in C^{m\\times n}$ 有 m||A||_b\\leq ||A||_a\\leq M||A||_bF 范数设 $||\\cdot||_{\\alpha}$，$||\\cdot||_{\\beta}$ 和 $||\\cdot||_{\\gamma}$ 是线性空间 $C^{m\\times n}$、$C^{n\\times p}$、$C^{m\\times p}$ 中满足范数公理的矩阵范数，当 $p=2$ 时，记由向量的 2 范数直接定义的矩阵范数为 $||A||_2$ 为 ||A||_F=||A||_2=(\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|^2)^{\\frac{1}{2}}=\\sqrt{tr(A^HA)}称 $||A||_F$ 为 Frobenius 范数，简称 F 范数 其具有如下性质： 1）酉变换不影响 F 范数的值：设 $A\\in C^{m\\times n}$，对酉矩阵 $U\\in C^{m\\times m},V\\in C^{n\\times n}$，恒有 ||A||_F=||UA||_F=||AV||_F=||UAV||_F2）F 范数相容性：对 $\\forall A\\in C^{m\\times n},B\\in C^{n\\times p}$，有 ||AB||_F\\leq ||A||_F\\cdot ||B||_F3）2 范数与 F 范数相容性：设 $A\\in C^{m\\times n}$，则 $||A||_F$ 与 $C^{m\\times n},C^{n}$ 上的 2 范数 $||\\cdot||_2$ 是相容的，即 $\\forall \\mathbf{x}\\in C^{n}$ 有 ||A\\mathbf{x}||_2\\leq ||A||_F\\cdot ||\\mathbf{x}||_2诱导范数与向量范数相容的最常用的矩阵范数是算子范数，其是利用向量范数是向量坐标的连续函数的性质诱导出来的，故也称为诱导范数 设 $A\\in C^{m\\times n}$，$\\mathbf{x}=[x_1,x_2,\\cdots,x_n]^T\\in C^{n}$，$||\\mathbf{x}||$ 和 $||A\\mathbf{x}||$ 分别是 $C^{n}$ 和 $C^m$ 中的范数，则 $||A\\mathbf{x}||$ 是 $(x_1,x_2,\\cdots,x_n)$ 的连续函数，从而 $||A\\mathbf{x}||$ 在有界闭集 $S=\\{\\mathbf{x}\\in C^n|\\:||\\mathbf{x}||=1\\}$ 上取极大值，则 ||A||=\\max_{||\\mathbf{x}||=1}||A\\mathbf{x}||=||A\\mathbf{x}_0||,\\quad x_0\\in C^{n}为一种相容的矩阵范数，其是由向量范数所诱导出来的一种矩阵范数，称为诱导范数 可以发现，求矩阵的诱导范数，相当于求函数 $||A\\mathbf{x}||$ 在约束 $||\\mathbf{x}||=1$ 下的条件极值 对于一般的向量范数而言，当向量范数分别取 1 范数、2 范数、无穷范数时，对应的矩阵的诱导范数分别称为矩阵的列范数、谱范数、行范数 设 $A=[a_{ij}]\\in C^{m\\times n}$，则 列范数：$||A||_1=\\max\\limits_{1\\leq j\\leq n} \\sum\\limits_{i=1}^m |a_{ij}|$ 行范数：$||A||_{\\infty}=\\max\\limits_{1\\leq i\\leq m} \\sum\\limits_{j=1}^n |a_{ij}|$ 谱范数：$||A||_2=\\sqrt{\\max \\lambda(A^HA)}$，其中 $\\lambda(A^HA)$ 代表 $A^HA$ 的特征值 谱半径设 $A\\in C^{n\\times n}$，称 S_p(A)=\\{\\lambda|\\lambda 为 A 的特征值\\}为 $A$ 的谱，称 \\rho(A)=\\max|S_p(A)|为 $A$ 的谱半径 按照定义，有 ||A||_2=\\sqrt{\\rho(A^HA)}特别地，当 $A$ 是 Hermite 矩阵时，有 ||A||_2=\\rho(A)当 $A\\in C^{n\\times n}$，$||A||$ 是 $A$ 的任意一种诱导范数时，有 \\rho(A)\\leq ||A||","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"凯莱-哈密顿定理与最小多项式","slug":"matrix-theory/05.凯莱-哈密顿定理与最小多项式","date":"2022-11-11T02:41:00.000Z","updated":"2022-12-18T10:42:02.559Z","comments":true,"path":"mathematics/matrix-theory/c480a3d8.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/c480a3d8.html","excerpt":"【方阵多项式】设复多项式 g(\\lambda)=a_0\\lambda^m+a_1\\lambda^{m-1}+\\cdots+a_{m-1}\\lambda+a_m为 $m$ 次多项式，其中，$\\lambda$ 为复变量，$m$ 为整数，$a_0\\neq0,a_1,\\cdots,a_m$ 均为复系数","text":"【方阵多项式】设复多项式 g(\\lambda)=a_0\\lambda^m+a_1\\lambda^{m-1}+\\cdots+a_{m-1}\\lambda+a_m为 $m$ 次多项式，其中，$\\lambda$ 为复变量，$m$ 为整数，$a_0\\neq0,a_1,\\cdots,a_m$ 均为复系数 对 $\\forall A\\in \\mathbb{C}^{n\\times n}$，将上式中的 $\\lambda$ 换为方阵 $A$，则 g(A)=a_0A^m+a_{1}A^{m-1}+\\cdots+a_{m-1}A+a_mI_n仍为一 $n$ 阶方阵，称上式为方阵多项式 相应地，对于一个方阵多项式，也可转为对应同次数的复多项式 【零化多项式】设 $A$ 为 $n$ 阶方阵，$g(\\lambda)$ 为 $m$ 次多项式，若 g(A)=O则称 $g(\\lambda)$ 为方阵 $A$ 的零化多项式 【凯莱-哈密顿定理】凯莱-哈密顿（Cayley-Hamilton）定理，简称 CH 定理，其提供了一个寻找任何方阵零化多项式的有效方法，即：$n$ 阶方阵 $A$ 的特征多项式 $f_A(\\lambda)$ 是 $A$ 的零化多项式 从形式上看，若 f_A(\\lambda)=|\\lambda I_n-A|=\\lambda^n+a_1\\lambda^{n-1}+\\cdots+a_{n-1}\\lambda+a_n则 f_A(A)=A^n+a_1A^{n-1}+\\cdots+a_{n-1}A+a_nI_n=OCH 定理的重要意义在于： 指出任何 $n$ 阶方阵 $A$ 都具有次数不超过 $n$ 的零化多项式 $f_A(\\lambda)$ 当 $m\\geq n$ 时，任何 $n$ 阶方阵 $A$ 的方幂 $A^m$，均可表为 $A^{n-1},\\cdots,A,A^0$ 的线性组合，从而 $A$ 的任何 $m$ 次方阵多项式都可表为次数不超过 $n-1$ 次的方阵多项式 例如： 设 A=\\begin{bmatrix} 1&2&0 \\\\ 0&-1&1 \\\\ 0&1&0 \\end{bmatrix}求：$g(A)=2A^8-3A^5+A^4+A^2-4I_3$ 易得，$A$ 的特征多项式为 f_A(\\lambda)=|\\lambda I_3-A|=\\lambda^3-2\\lambda+1取 $g(A)$ 对应的复多项式 g(\\lambda)=2\\lambda^8-3\\lambda^5+\\lambda^4+\\lambda^2-4用 $f_A(\\lambda)$ 去除 $g(\\lambda)$，得 g(\\lambda)=(2\\lambda^5+4\\lambda^3-5\\lambda^2+9\\lambda-14)f_A(\\lambda)+\\varphi(\\lambda)其中，余式 $\\varphi(\\lambda)=24\\lambda^2-37\\lambda+10$ 根据 CH 定理，$f_A(A)=0$，故 g(A)=\\varphi(A)=24A^2-37A+10I_3 =\\begin{bmatrix} -3&-74&48\\\\ 0&95&-61\\\\ 0&-61&34 \\end{bmatrix}【最小多项式】定义任何一个 $n$ 方阵 $A$，都有无穷多个零化多项式 $g(\\lambda)$，在这诸多的零化多项式中称 $A$ 的首项系数为 $1$ 且次数最小的零化多项式，为 $A$ 的最小多项式，记为 $m_A(\\lambda)$ 其具有如下性质： $A$ 的任何零化多项式 $g(\\lambda)$ 都能被 $m_A(\\lambda)$ 整除 $A$ 的最小多项式 $m_A(\\lambda)$ 是唯一的 $\\lambda_0$ 为 $A$ 的特征值的充要条件是 $m_A(\\lambda_0)=0$ 通过如上性质，可以得到一个推论：若 $A$ 的特征值都是单根，则 $A$ 的特征多项式就是最小多项式 最小多项式形式设 $n$ 阶方阵 $A$ 的特征多项式为 f_A(\\lambda)=(\\lambda-\\lambda_1)^{n_1}(\\lambda-\\lambda_2)^{n_2}\\cdots(\\lambda-\\lambda_s)^{n_s}其中，$\\lambda_1,\\lambda_2,\\cdots,\\lambda_s$ 是 $s$ 个全部互异的特征值，$n_1,n_2,\\cdots,n_s$ 是相应的代数重数 则 $A$ 的最小多项式必须具备如下形式 m_A(\\lambda)=(\\lambda-\\lambda_1)^{m_1}(\\lambda-\\lambda_2)^{m_2}\\cdots(\\lambda-\\lambda_s)^{m_s}其中，$1\\leq m_i\\leq n_i$ 例如： A=\\begin{bmatrix} 2&-1&-1 \\\\ 0&5&3 \\\\ 0&-4&-2 \\end{bmatrix}则 $A$ 的特征多项式为 f_A(\\lambda)=|\\lambda I_3-A|=(\\lambda-1)(\\lambda-2)^2根据最小多项式 $m_A(\\lambda)$ 的形式，$m_A(\\lambda)$ 只可能是 $(\\lambda-1)(\\lambda-2)$ 或 $(\\lambda-1)(\\lambda-2)^2$ 分别计算 (A-I_3)(A-2I_3)\\overset{?}=O \\quad (A-I_3)(A-2I_3)^2\\overset{?}=O解得 $(A-I_3)(A-2I_3)=O$，故最小多项式为 m_A(\\lambda)=(\\lambda-1)(\\lambda-2)分块对角阵的最小多项式设方阵 $A_1,A_2,\\cdots,A_s$ 的特征多项式分别为 $f_1(\\lambda),f_2(\\lambda),\\cdots,f_s(\\lambda)$，最小多项式分别为 $m_1(\\lambda),m_2(\\lambda),\\cdots,m_s(\\lambda)$ 那么对角阵 A=\\begin{bmatrix} A_1&&&\\\\ &A_2&&\\\\ &&\\ddots&\\\\ &&& A_s \\end{bmatrix}的特征多项式为 f_A(\\lambda)=f_1(\\lambda)f_2(\\lambda)\\cdots f_s(\\lambda)$A$ 的最小多项式 $m_A(\\lambda)$ 为$m_1(\\lambda),m_2(\\lambda),\\cdots,m_s(\\lambda)$ 的最小公倍式","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"NVIDIA 7th SkyHackathon（一）比赛开发环境部署","slug":"skyhackathon/01.NVIDIA 7th SkyHackathon（一）比赛开发环境部署","date":"2022-11-09T11:29:00.000Z","updated":"2023-02-06T03:11:40.829Z","comments":true,"path":"nvidia/skyhackathon/bbb8d9ae.html","link":"","permalink":"https://alex-mcavoy.github.io/nvidia/skyhackathon/bbb8d9ae.html","excerpt":"获取 NGC 秘钥1）登录 NGC | NVIDIA GPU Cloud 官网，创建 NGC 用户并登录 2）在右上角用户名的下拉界面点击 setup","text":"获取 NGC 秘钥1）登录 NGC | NVIDIA GPU Cloud 官网，创建 NGC 用户并登录 2）在右上角用户名的下拉界面点击 setup 3）进入 setup 页后生成 NGC 秘钥并做好记录，该秘钥在模型训练过程以及推理过程都会使用到，且只有在创建时可看到秘钥内容，无法后续进行查询 下载相关资料下载大赛网盘中相应的资料，资料目录结构说明如下： 配置 NVIDIA GPU 环境系统要求x86 CPU + NVIDIA GPU + Ubuntu 18.04 以上 安装 NVIDIA 驱动NVIDIA 驱动要求 460 以上版本，安装完成后需要重启，重启完后执行 nvidia-smi 检查驱动 1234root@Alex-McAvoy:~$ apt-get install software-properties-commonroot@Alex-McAvoy:~$ add-apt-repository ppa:graphics-drivers/pparoot@Alex-McAvoy:~$ apt-get install nvidia-driver-460root@Alex-McAvoy:~$ reboot 安装 docker关于 docker，详见：docker 手册，命令图解如下： 安装完毕后，使用 docker run hello-world 测试是否安装成功 123456root@Alex-McAvoy:~$ apt-get install -y ca-certificates curl gnupg lsb-releaseroot@Alex-McAvoy:~$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o/usr/share/keyrings/docker-archive-keyring.gpgroot@Alex-McAvoy:~$ echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs)stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullroot@Alex-McAvoy:~$ apt-get updateroot@Alex-McAvoy:~$ apt-get install -y docker-ce docker-ce-cli containerd.io 当出现以下信息后，说明 docker 安装成功 安装 nvidia-docker2安装完毕后，使用 docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi 测试是否安装成功 1234root@Alex-McAvoy:~$ curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | apt-key add -distribution=$(./etc/os-release;echo $ID$VERSION_ID)root@Alex-McAvoy:~$ curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | tee /etc/apt/sources.list.d/nvidia-docker.listroot@Alex-McAvoy:~$ apt-get update &amp;&amp; apt-get install -y nvidia-docker2root@Alex-McAvoy:~$ systemctl restart docker 当出现以下信息后，说明 nvidia-docker2 安装成功 登录 NGC1root@Alex-McAvoy:~$ docker login -u '$oauthtoken' --password-stdin nvcr.io &lt;&lt;&lt; '申请的密钥' 安装 GPU 版本 Pytorch使用 nvidia-smi 查看 GPU 详细信息，可以看到，已安装的 cuda 版本为 11.8，之后通过 pytorch 官网，根据 cuda 版本和操作系统版本等信息，选择对应版本的 pytorch 1root@Alex-McAvoy:~$ pip install torch==1.12.1+cu113 torchvision==0.13.1+cu113 torchaudio==0.12.1 --extra-index-url https://download.pytorch.org/whl/cu113 安装 MiniConda31234root@Alex-McAvoy:~$ export DL_SITE=https://mirrors.tuna.tsinghua.edu.cn/anaconda/minicondaroot@Alex-McAvoy:~$ wget -c $DL_SITE/Miniconda3-py38_4.10.3-Linux-x86_64.shroot@Alex-McAvoy:~$ bash Miniconda3-py38_4.10.3-Linux-x86_64.shroot@Alex-McAvoy:~$ source ~/.bashrc Jupyter Lab 开发环境安装123root@Alex-McAvoy:~$ pip install jupyter jupyterlabroot@Alex-McAvoy:~$ export PW='登录密码'root@Alex-McAvoy:~$ python3 -c \"from notebook.auth.security import set_password; set_password('$PW','$HOME/.jupyter/jupyter_notebook_config.json')\" 启动进入工作目录 7thSkyHackathon 后，执行下述命令启动 Jupyter 即可 1(tao)root@Alex-McAvoy:~/7thSkyHackathon$ jupyter lab --ip 0.0.0.0 --port 8888 --allow-root 此时，在浏览器输入 URL，并输入密码后，即可进入到 Jupyter Lab 界面","categories":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/categories/nvidia/"},{"name":"SkyHackathon","slug":"nvidia/skyhackathon","permalink":"https://alex-mcavoy.github.io/categories/nvidia/skyhackathon/"}],"tags":[{"name":"NVIDIA","slug":"nvidia","permalink":"https://alex-mcavoy.github.io/tags/nvidia/"},{"name":"SkyHackathon","slug":"skyhackathon","permalink":"https://alex-mcavoy.github.io/tags/skyhackathon/"}],"author":"Alex_McAvoy"},{"title":"常见分布","slug":"probability-theory/04.常见分布","date":"2022-11-07T10:05:00.000Z","updated":"2022-12-15T08:05:40.828Z","comments":true,"path":"mathematics/probability-theory/2424b658.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/2424b658.html","excerpt":"Reference 概率论学习笔记（二） 几种常见的数学分布 常用分布 几个常见的离散型概率分布 帕斯卡分布 负二项分布 机器学习：Multinoulli分布与多项式分布 【离散分布】伯努利试验","text":"Reference 概率论学习笔记（二） 几种常见的数学分布 常用分布 几个常见的离散型概率分布 帕斯卡分布 负二项分布 机器学习：Multinoulli分布与多项式分布 【离散分布】伯努利试验满足以下描述的试验，被称为伯努利试验（Bernoulli experiment） 试验只能有互斥的两种结果，发生或不发生，成功或失败 每次试验中，某种结果发生的概率是 $p$，另一种结果发生的概率是 $1-p$ 试验是互相独立的，且可重复进行 $n$ 次 伯努利试验，对应的现实场景是有放回抽样 伯努利分布伯努利分布（Bernoulli Distribution）又称 0-1 分布、两点分布，用于描述一次伯努利试验中是否成功 记 $X$ 为一次伯努利试验中事件 $A$ 成功的次数，则 $X=0,1$，假设事件 $A$ 发生的概率为 $p$，那么称 $X$ 服从参数为 $1,p$ 的伯努利分布，记作 $X\\sim B(1,p)$ $X$ 的概率分布为： P(X=x)=p^x(1-p)^{1-x},\\quad x=0,1即： P(X=1)=p \\quad P(X=0)=1-p 伯努利分布的数学期望和方差分别为： $EX=p$ $DX=p(1-p)$ 伯努利分布的特征函数为： \\varphi(t)=pe^{jt}+q二项分布二项分布（Binomial Distribution）又称 $n$ 重伯努利分布，用于描述 $n$ 次伯努利试验中成功的次数 记 $X$ 为 $n$ 重伯努利试验中事件 $A$ 成功的次数，则 $X=0,1,2,\\cdots,n$，假设事件 $A$ 发生的概率为 $p$，那么称 $X$ 服从参数为 $n,p$ 的伯努利分布，记作 $X\\sim B(n,p)$ $X$ 的概率分布为： P(X=k)= \\left(\\begin{array}{c}n\\\\k\\end{array}\\right) p^k(1-p)^{n-k},\\quad k=0,1,\\cdots,n在独立条件下，二项分布对于其中的参数 $n$ 具有可加性，即：$X_1\\sim B(n_1,p)$，$X_2\\sim B(n_2,p)$，且 $X_1,X_2$ 独立，有 $X_1+X_2\\sim B(n_1+n_2,p)$ 进一步，服从 $B(n,p)$ 的随机变量可以看作是 $n$ 个相互独立的服从伯努利分布 $B(1,p)$ 的随机变量之和 二项分布的数学期望和方差分别为： $EX=np$ $DX=np(1-p)$ 二项分布的特征函数为： \\varphi(t)=(pe^{jt}+q)^n几何分布几何分布（Geometric Distribution）用于描述伯努利试验序列中，事件 $A$ 首次出现的试验次数 重复进行伯努利试验，直到事件 $A$ 发生为止才停下，记 $X$ 为若干次伯努利试验中事件 $A$ 进行的次数，则 $X=1,2,\\cdots$，假设事件 $A$ 发生的概率为 $p$，那么称 $X$ 服从参数为 $p$ 的几何分布，记作 $X\\sim G(p)$ $X$ 的概率分布为： P(X=k)=(1-p)^{k-1}p,\\quad k=1,2,...几何分布具有无记忆性：若 $X\\sim G(p)$，对 $\\forall n,m\\in Z^+$，有 P(X>n+m|X>m)=P(X>n)该性质表明，在前 $m$ 次试验中 $A$ 没有出现的条件下，则在接下去的 $n$ 次试验中 $A$ 仍未出现的概率只与 $n$ 有关，而与以前的 $m$ 次试验无关，似乎忘记了前 $m$ 次试验结果 几何分布的数学期望和方差分别为： $EX=\\frac{1}{p}$ $DX=\\frac{1-p}{p^2}$ 几何分布的特征函数为： \\varphi(t)=\\frac{pe^{jt}}{1-qe^{jt}}负二项分布与帕斯卡分布负二项分布（Negative Binomial Distribution）用于描述伯努利试验序列中，事件 $A$ 第 $r$ 次出现时的试验次数 重复进行伯努利试验，直到事件 $A$ 发生第 $r$ 次时才停下，记 $X$ 为若干次伯努利试验中事件 $A$ 进行的次数，则 $X=r,r+1,\\cdots$，假设事件 $A$ 发生的概率为 $p$，那么称 $X$ 服从参数为 $r,p$ 的负二项分布，记作 $X\\sim NB(r,p)$ $X$ 的概率分布为： P(X=k)=\\left(\\begin{array}{c}k-1\\\\r-1\\end{array}\\right) (1-p)^{k-1}p,\\quad k=r,r+1,...当 $r$ 为整数时，称 $X$ 服从参数为 $r,p$ 的帕斯卡分布（Pascal Distribution），记作 $X\\sim Pas(r,p)$ 需要注意的是，尽管很难想象一个非整数的失败次数，但这个分布是通过概率密度函数在形式上严格定义的 可以发现，当 $r=1$ 时，帕斯卡分布即几何分布，即：$Pas(1,p)=G(p)$ 与二项分布类似，帕斯卡分布对于其中的参数 $r$ 具有可加性，即：$X_1\\sim Pas(r_1,p)$，$X_2\\sim Pas(r_2,p)$，且 $X_1,X_2$ 独立，有 $X_1+X_2\\sim Pas(r_1+r_2,p)$ 进一步，服从帕斯卡分布 $Pas(r,p)$ 的随机变量可以看作是 $r$ 个相互独立的服从几何分布 $G(p)$ 的随机变量之和 负二项分布的数学期望和方差分别为： $EX=\\frac{r}{p}$ $DX=\\frac{r(1-p)}{p^2}$ 负二项分布的特征函数为： \\varphi(t)=(\\frac{pe^{jt}}{1-qe^{jt}})^t泊松分布泊松分布（Poisson Distribution）常与单位时间、单位面积、单位体积上的计数过程相联系 记 $X$ 为某个随机事件 $A$ 发生的次数，则 $X=0,1,2,\\cdots,n$，假设每次事件 $A$ 是否发生相互独立，且事件 $A$ 平均发生 $\\lambda$ 次，那么 $X$ 服从参数为 $\\lambda$ 的泊松分布，记为 $X\\sim P(\\lambda)$ $X$ 的概率分布为： P(X=k)=\\frac{\\lambda^k}{k!}e^{-\\lambda},\\quad k=0,1,2,\\cdots与二项分布类似，泊松分布在独立条件下对于参数 $\\lambda$ 具有可加性，即：$X_1\\sim P(\\lambda_1)$，$X_2\\sim P(\\lambda_2)$，且 $X_1,X_2$ 独立，有 $X_1+X_2\\sim P(\\lambda_1+\\lambda_2)$ 事实上，泊松分布本质上是 $n\\rightarrow \\infty$ 时的二项分布，即若 $\\lim\\limits_{n\\rightarrow \\infty} np_n=\\lambda,0&lt;p_n&lt;1$，则有： \\lim\\limits_{n\\rightarrow \\infty} \\left(\\begin{array}{c}n\\\\k\\end{array}\\right) p_n^k(1-p_n)^{n-k} = \\frac{\\lambda^k}{k!}e^{-\\lambda}也就是说，当 $n$ 足够大，且此时平均发生的事件数趋于常数 $\\lambda$ 时，二项分布 $B(n,p_n)$ 实质上就是泊松分布 $P(\\lambda)$ 泊松分布的数学期望和方差分别为： $EX=\\lambda$ $DX=\\lambda$ 泊松分布的特征函数为： \\varphi(t)=e^{\\lambda(e^{jt}-1)}超几何分布超几何分布（Hypergeometric Distribution）用于描述 $N$ 个产品中不放回的随机抽取 $n$ 个的次品数 设有 $N$ 个产品，其中有 $M(M\\leq N)$ 个次品，从中不放回的随机抽取 $n(n\\leq N)$ 个，记 $X$ 为这 $n$ 个中的次品数，则 $X=0,1,\\cdots,\\min\\{M,n\\}$，称 $X$ 服从参数为 $n,N,M$ 的超几何分布，记作 $X\\sim H(n,M,N)$ $X$ 的概率分布为： P(X=k) = \\frac{ \\left(\\begin{array}{c}M\\\\k\\end{array}\\right) \\left(\\begin{array}{c}N-M\\\\n-k\\end{array}\\right) }{ \\left(\\begin{array}{c}N\\\\n\\end{array}\\right) },\\quad k=0,1,\\cdots,\\min\\{M,n\\}当次品数 $M$ 只与产品数 $N$ 相关时，且 $\\lim\\limits_{N\\rightarrow\\infty}\\frac{M}{N}=p\\in(0,1)$，则有： \\lim_{N\\rightarrow\\infty} \\frac{ \\left(\\begin{array}{c}M\\\\k\\end{array}\\right) \\left(\\begin{array}{c}N-M\\\\n-k\\end{array}\\right) }{ \\left(\\begin{array}{c}N\\\\n\\end{array}\\right) } = \\left(\\begin{array}{c}M\\\\k\\end{array}\\right) p^k(1-p)^{n-k}也就是说，当总量 $N$ 足够大时，若次品率 $\\frac{M}{N}$ 趋于一个常数 $p$，那么进行无放回抽取（超几何分布）可以近似为有放回抽取（二项分布） 超几何分布的数学期望和方差分别为： $EX=\\frac{nM}{N}$ $DX=\\frac{nM(N-m)(N-n)}{N^2(N-1)}$ 超几何分布的特征函数为： f(t) = \\sum_{k=0}^{\\infty} \\frac{t^k}{k!} \\binom{n}{k} p^k (1-p)^{n-k}【连续分布】正态分布若随机变量 $X$ 的概率密度函数为： f(x)=\\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},\\quad -\\infty","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"n 维随机向量","slug":"probability-theory/03.n维随机向量","date":"2022-11-07T06:59:00.000Z","updated":"2023-02-24T07:06:34.740Z","comments":true,"path":"mathematics/probability-theory/952f3930.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/952f3930.html","excerpt":"Reference 概率论学习笔记（三） §3.2 随机向量，随机变量的独立性 【$n$ 维随机向量】在随机变量的基础上扩展到 $n$ 维，就有了随机向量，从本质上来看，二者区别不大，只是处理的方式稍微复杂一些","text":"Reference 概率论学习笔记（三） §3.2 随机向量，随机变量的独立性 【$n$ 维随机向量】在随机变量的基础上扩展到 $n$ 维，就有了随机向量，从本质上来看，二者区别不大，只是处理的方式稍微复杂一些 在概率空间 $(\\Omega,\\mathscr{F},P)$ 上的 $n$ 元实函数 $\\mathbf{X}(\\cdot)=\\{X_1(\\cdot),X_2(\\cdot),\\cdots,X_n(\\cdot)\\}$，若 $\\forall \\mathbf{x} = (x_1,x_2,\\cdots,x_n)\\in\\mathbb{R}^n$，有： \\{\\omega|X_1(\\omega)\\leq x_1,X_2(\\omega)\\leq x_2,\\cdots,X_n(\\omega)\\leq x_n\\}\\in \\mathscr{F}则称 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$ 为 $n$ 维随机向量 【分布函数】联合分布函数对于 $n$ 维随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$， $\\forall \\mathbf{x} = (x_1,x_2,\\cdots,x_n)\\in\\mathbb{R}^n$，称： F(\\mathbf{x})=F(x_1,x_2,\\cdots,x_n)=P(X_1\\leq x_1,X_2\\leq x_2\\cdots,X_n\\leq x_n)为 $\\mathbf{X}$ 的联合分布函数 与一维情况下的分布函数类似，其具有如下性质： 单调不减：$F(x_1,x_2,\\cdots,x_n)$ 对任一 $x_i$，是单调不减函数 右连续：$F(x_1,x_2,\\cdots,x_n)$ 对任一 $x_i$，是右连续函数 有界：$F(x_1,\\cdots,x_{i-1},-\\infty,x_{i+1},\\cdots,x_n)=0,F(+\\infty,+\\infty,\\cdots,+\\infty)=1$ Jordan 公式：设 $x_i\\leq y_i,i=1,2,\\cdots,n$，有 \\begin{align*} & F(y_1,y_2,\\cdots,y_n)-\\sum_{i=1}^n F(y_1,y_2,\\cdots,y_{i-1},x_i,y_{i+1},\\cdots,y_n) \\\\ +& \\sum_{1\\leq i< j \\leq n}F(y_1,y_2,\\cdots,y_{i-1},x_i,y_{i+1},\\cdots,y_{j-1},x_j,y_{j+1},y_n) \\\\ -& +(-1)^n F(x_1,x_2,\\cdots,x_n) \\geq 0 \\end{align*}边缘分布函数联合分布描述的是多个随机变量混合纠缠在一起时的分布，将某一个或某几个随机变量分离出来，求他们的概率分布，即有了边缘分布函数 对于 $n$ 维随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$， $\\forall \\mathbf{x} = (x_1,x_2,\\cdots,x_n)\\in\\mathbb{R}^n$，保留 $k\\:(1\\leq k&lt;n)$ 个 $x_i$，比如 $x_1,x_2,\\cdots,x_k$，并令其他的 $x_i$ 均趋于 $+\\infty$，即： \\lim_{ \\begin{align*} x_{k+1} & \\rightarrow +\\infty \\\\ &\\cdots \\\\ x_{n} & \\rightarrow +\\infty \\end{align*} } F(x_1,\\cdots,x_k,x_{k+1},\\cdots,x_n) =F(x_1,\\cdots,x_k,+\\infty,\\cdots,+\\infty)此时称 $F(x_1,\\cdots,x_k)$ 为 $n$ 维随机向量 $\\mathbf{X}$ 关于 $(X_1,X_2,\\cdots,X_k)$ 的边缘分布函数 特别地，当 $k=1$ 时，即可得到 $n$ 维随机向量 $\\mathbf{X}$ 的 $n$ 个边缘分布函数： F_{X_1}(x_1),F_{X_2}(x_2),\\cdots,F_{X_n}(x_n)【随机向量分量独立性】有了边缘分布的概念后，即可得到关于随机向量各分量间独立性的定理，其描述的是随机向量内部的关系 设 $n$ 维随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$， 其联合分布函数为 $F(x_1,x_2,\\cdots,x_n)$，边缘分布函数为 $F_{X_1}(x_1),F_{X_2}(x_2),\\cdots,F_{X_n}(x_n)$ 若对 $\\forall \\mathbf{x} = (x_1,x_2,\\cdots,x_n)\\in\\mathbb{R}^n$，有： F(x_1,x_2,\\cdots,x_n)=F_{X_1}(x_1)F_{X_2}(x_2)\\cdots F_{X_n}(x_n)则称随机变量 $X_1,X_2,\\cdots,X_n$ 相互独立 【$n$ 维离散型随机向量】联合分布函数若 $n$ 维随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$ 的可能取值为有限对或可列无限对，则 $X$ 称为$n$ 维离散型随机向量 此时用联合分布律来描述随机变量的概率分布，即： P(X_1=x_1,X_2=x_2,\\cdots,X_n=x_n)此时 $X$ 的联合分布函数为： F(u_1,u_2,\\cdots,u_n)=\\sum_{x_1\\leq u_1}\\sum_{x_2\\leq u_2}\\cdots\\sum_{x_n\\leq u_n}P(X_1=x_1,X_2=x_2,\\cdots,X_n=x_n)边缘分布函数对于 $n$ 维随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$， $\\forall \\mathbf{x} = (x_1,x_2,\\cdots,x_n)\\in\\mathbb{R}^n$，保留 $k\\:(1\\leq k&lt;n)$ 个 $x_i$，比如 $x_1,x_2,\\cdots,x_k$，并令其他的 $x_i$ 均趋于 $+\\infty$，即可得到 $k$ 维边缘分布函数 $F(x_1,x_2,\\cdots,x_k,+\\infty,\\cdots,+\\infty)$ 特别地，当 $k=1$ 时，即可得到 $n$ 维随机向量 $\\mathbf{X}$ 的 $n$ 个边缘分布函数： F_{X_1}(x_1),F_{X_2}(x_2),\\cdots,F_{X_n}(x_n)分量独立性对于 $n$ 维离散型随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$，$X_1,X_2,\\cdots,X_n$ 相互独立的充要条件为： P(X_1=x_1,X_2=x_2,\\cdots,X_n=x_n)=P(X_1=x_1)P(X_2=x_2)\\cdots P(X_n=x_n)【$n$ 维连续型随机向量】联合概率密度函数若随机向量 $\\mathbf{X}$ 的可能取值为不可列对，则 $\\mathbf{X}$ 称为 $n$ 维连续型随机变量 若 $\\mathbb{R}^n$ 上的非负可积函数 $f(x_1,x_2,\\cdots,x_n)$，对 $\\forall D=\\{(x_1,\\cdots,x_n)|a_i&lt;x_i\\leq b_i,a_i,b_i\\in \\mathbb{R}\\}$，都有： P(\\mathbf{X}\\in D)=\\int\\cdots\\int_Df(x_1,\\cdots,x_n)dx_1\\cdots dx_n则称 $f(x_1,x_2,\\cdots,x_n)$ 为 $n$ 维连续随机向量 $\\mathbf{X}$ 的联合概率密度函数 边缘概率密度函数对于 $n$ 维连续型随机变量 $\\mathbf{X}$，其联合概率密度函数为 $f(x_1,x_2,\\cdots,x_n)$ 对 $\\forall 1\\leq k &lt; n$，设 $D_k=\\{(x_1,\\cdots,x_k)|a_i&lt;x_i\\leq b_i,a_i,b_i\\in \\mathbb{R},1\\leq i\\leq k\\}$，则有： P((X_1,\\cdots,X_k)\\in D_k) = \\int\\cdots\\int_{D_k \\times \\mathbb{R}^{n-k}}f(x_1,\\cdots,x_n)dx_1\\cdots dx_n根据 Fubini 定理：对于 $D\\subset \\mathbb{R}^n$ 上的绝对可积函数 $f$，其在 $D$ 上的任意 $n$ 重积分可以任意交换 $n$ 次积分的顺序 故原式为： \\int\\cdots \\int_{D_k} \\Big( \\int\\cdots \\int_{\\mathbb{R}^{n-k}} f(x_1,\\cdots,x_k,x_{k+1},\\cdots,x_n) dx_{k+1}\\cdots dx_n \\Big) dx_1\\cdots dx_k根据联合概率密度函数的定义，记： f(x_1,\\cdots,x_k)=\\int\\cdots \\int_{\\mathbb{R}^{n-k}} f(x_1,\\cdots,x_k,x_{k+1},\\cdots,x_n) dx_{k+1}\\cdots dx_n此时 $f(x_1,\\cdots,x_k)$ 为 $n$ 维随机向量 $\\mathbf{X}$ 关于 $(X_1,X_2,\\cdots,X_k)$ 的边缘概率密度函数 特别地，当 $k=1$ 时，即可得到 $n$ 维连续型随机向量 $\\mathbf{X}$ 的 $n$ 个边缘概率密度函数： f_{X_1}(x_1),f_{X_2}(x_2),\\cdots,f_{X_n}(x_n)分量独立性对于 $n$ 维连续型随机向量 $\\mathbf{X}=(X_1,X_2,\\cdots,X_n)$，$X_1,X_2,\\cdots,X_n$ 相互独立的充要条件为： f(x_1,x_2,\\cdots,x_n)=f_{X_1}(x_1)f_{X_2}(x_2)\\cdots f_{X_n}(x_n)","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"随机变量","slug":"probability-theory/02.随机变量","date":"2022-11-07T04:46:00.000Z","updated":"2023-02-24T07:05:26.320Z","comments":true,"path":"mathematics/probability-theory/95645250.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/95645250.html","excerpt":"Reference 概率论学习笔记（二） Borel 集 Borel 集的作用？意义？它为什么重要？ 【随机变量】示性函数","text":"Reference 概率论学习笔记（二） Borel 集 Borel 集的作用？意义？它为什么重要？ 【随机变量】示性函数对于样本空间 $\\Omega$，样本点 $\\omega$，设 $A$ 为事件，示性函数 $I_A$ 为 $\\Omega$ 上的函数，其被定义为： I_A(\\omega) = \\left\\{ \\begin{array}{rl} 0, \\omega\\in A\\\\ 1, \\omega\\notin A \\end{array} \\right.可以发现，对于 $\\forall x \\in \\mathbb{R}$，$\\{I_A \\leq x\\}$ 都是事件 详细地，有： \\{\\omega|I_A(\\omega)\\leq x\\} = \\left\\{ \\begin{array}{rl} \\varnothing,& x < 0 \\\\ \\bar{A},& x\\in [0,1) \\\\ \\Omega,& x\\geq 1 \\end{array} \\right.随机变量在示性函数的基础上，即可严格定义随机变量 对于概率空间 $(\\Omega,\\mathscr{F},P)$，若实函数 $X(\\cdot)$ 满足：$\\forall x \\in \\mathbb{R},\\{\\omega|X(\\omega)\\leq x\\}\\in\\mathscr{F}$，则称 $X(\\omega)$ 为可测空间 $(\\Omega,\\mathscr{F})$ 上的随机变量，通常省略样本点 $\\omega$ 记为 $X$ 【Borel 集】Borel 集接下来，要提出的一个自然的问题是：集合 $A$ 要满足什么条件，才能使得 $\\{x\\in A\\}\\in\\mathscr{F}$，即在实数域上，随机变量的所有可能取值的集合至少应该满足的条件是什么？ 根据随机变量的定义，若 $X$ 为随机变量，必有 $\\{a&lt;X\\leq b\\}\\in \\mathscr{F}$ 从这一点出发，假设 $C$ 为 $\\mathbb{R}$ 中所有左闭右开的集合组成的集合，设 $\\mathbb{B}$ 为 $C$ 中所有元素经过交、补、可列并运算及其反复运算得到的集合所组成的集合 容易验证 $\\mathbb{B}$ 满足事件域的定义，此时，称 $\\mathbb{B}$ 为 Borel 域，其中的元素为 Borel 集 进一步，可给出定理：设 $X$ 为随机变量，$A$ 为 Borel 集，则 $\\{x\\in A\\}\\in\\mathscr{F}$ 由此可知，随机变量的所有可能取值的集合至少要是一个 Borel 集，即对 Borel 集 $A$，$P(x\\in A)$ 才是可计算的 Borel 可测函数可以发现，二元组 $(\\mathbb{R},\\mathbb{B})$ 同样是一个可测空间 那么在可测空间 $(\\mathbb{R},\\mathbb{B})$ 上，若函数 $g(\\cdot)$ 满足：$\\forall a \\in \\mathbb{R},\\{x|g(x)\\leq a\\}\\in \\mathbb{B}$，则称函数 $g(\\cdot)$ 为 Borel 可测函数 事实上，目前接触到的几乎所有集合都是 Borel 集，几乎所有函数都是 Borel 可测函数 进一步，可给出定理：设 $X$ 为随机变量，$g(\\cdot)$ 为 Borel 可测函数，则 $g(X)$ 为随机变量 这正是利用已有的随机变量，构造出无穷无尽的随机变量的方法 随机变量独立性Borel 集可看作是事件与随机变量之间的桥梁，因此，根据事件独立性的定义，可以类似地定义随机变量的独立性 设 $X_1,X_2,\\cdots,X_n$ 为随机变量，对于 $\\forall x_1,x_2,\\cdots,x_n$，若有： P(X_1\\leq x_1,X_2\\leq x_2\\cdots,X_n\\leq x_n)=P(X_1\\leq x_1)P(X_2\\leq x_2)\\cdots P(X_n\\leq x_n)则称随机变量 $X_1,X_2,\\cdots,X_n$ 相互独立 对于 Borel 集在维系随机变量独立性中的作用 ，有以下定理： $X_1,X_2,\\cdots,X_n$ 为相互独立的随机变量，对任意 Borel 集 $A_1,A_2,\\cdots,A_n$，事件 $\\{X_1\\in A_1\\},\\{X_2\\in A_2\\},\\cdots,\\{X_n\\in A_n\\}$ 也相互独立 进一步，若 $g_1(\\cdot),g_2(\\cdot),\\cdots,g_n(\\cdot)$ 为 Borel 可测函数，则 $g_1(X_1),g_2(X_2),\\cdots,g_n(X_n)$ 也相互独立 【分布函数】对于随机变量 $X$，函数 $F(x)=P(X\\leq x),-\\infty&lt;x&lt;\\infty$ 称为随机变量 $X$ 的分布函数 其具有如下性质： 单调不减：若 $x_1&lt;x_2$，则 $F(x_1)\\leq F(x_2)$ 右连续：$\\forall x \\in \\mathbb{R}$，有 $F(x+0)=F(x)$ 有界：$F(-\\infty)=\\lim\\limits_{x\\rightarrow -\\infty}F(x)=0,F(+\\infty)=\\lim\\limits_{x\\rightarrow +\\infty}F(x)=1$ 【离散型随机变量】若随机变量 $X$ 的可能取值为有限个或可列无限个，则 $X$ 称为离散型随机变量 此时用概率分布列来描述随机变量的概率分布，即： P(X=x_i)=p_i,\\quad i=1,2,\\cdots此时 $X$ 的分布函数为： F(x)=\\sum_{x_i\\leq x}p_i,\\quad x\\in \\mathbb{R}【连续型随机变量】若随机变量 $X$ 的可能取值为不可列个，则 $X$ 称为连续型随机变量 若存在非负可积函数 $f(x)$，使得： F(x)=\\int_{-\\infty}^x f(t) dt,\\quad x\\in \\mathbb{R}则称 $f(x)$ 为连续随机变量 $X$ 的概率密度函数 对于 $\\forall a&lt;b$，连续随机变量 $X$ 的概率密度函数有： P(a","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"概率空间","slug":"probability-theory/01.概率空间","date":"2022-11-07T02:57:00.000Z","updated":"2023-02-24T07:04:25.853Z","comments":true,"path":"mathematics/probability-theory/22949ea2.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/probability-theory/22949ea2.html","excerpt":"Reference 概率论学习笔记（一） 概率的性质——连续性 §2.2 事件独立性 【事件域】基本概念","text":"Reference 概率论学习笔记（一） 概率的性质——连续性 §2.2 事件独立性 【事件域】基本概念 随机试验：结果不能事先确定且相同条件下可重复的试验 样本空间：一个试验所有可能出现的结果的全体，记为 $\\Omega$ 样本点：试验的一个结果，记为 $\\omega$，即 $\\Omega=\\{\\omega\\}$ 随机事件：简称事件，样本空间的某个子集 事件域根据实际情况，并不对 $\\Omega$ 的一切子集研究，只对某些事件类感兴趣，由此引入事件域 设 $\\Omega$ 是样本空间，$\\mathscr{F}$ 是 $\\Omega$ 的某些子集构成的集合，若： $\\omega$ 是域中的一个元素，即 $\\Omega\\in\\mathscr{F}$ 对于域 $\\mathscr{F}$ 中的任意事件 $A$，其对立事件 $\\bar{A}$ 也在域 $\\mathscr{F}$ 中，即 $A\\in\\mathscr{F}$，则 $\\bar{A}\\in\\mathscr{F}$ 对于域 $\\mathscr{F}$ 中的事件，其无穷交 $\\bigcup\\limits_{n=1}^{\\infty}A_n$ 也在域中，即 $A_n \\in \\mathscr{F} , n=1,2, \\cdots$，则 $\\bigcup\\limits^{\\infty}_{n=1}A_n \\in \\mathscr{F}$ 那么称 $\\mathscr{F}$ 为事件域，也称 $\\mathscr{F}$ 为 $\\sigma$ 域（满足补集运算封闭、可列并运算封闭），称 $(\\Omega,\\mathscr{F})$ 为可测空间 例如：$\\Omega=\\{1,2,3,4,5,6\\}$ $F=\\{\\Omega,\\varnothing,\\{1,3,5\\},\\{2,4,6\\}\\}$ 构成 $\\sigma$ 域 $F=\\{\\Omega,\\varnothing,\\{1,2\\},\\{3,4\\}\\}$ 不构成 $\\sigma$ 域 其具有以下性质： $\\varnothing\\in\\mathscr{F}$ 若 $A,B \\in \\mathscr{F}$，则 $A-B\\in\\mathscr{F}$ 若 $A_n\\in\\mathscr{F},n=1,2,\\cdots$，则 $\\bigcap\\limits^{\\infty}_{n=1}A_n\\in\\mathscr{F}$ 【概率空间】概率空间在可测空间 $(\\Omega,\\mathscr{F})$ 上，定义概率，作为一种测度存在 设 $\\Omega$是样本空间，$\\mathscr{F}$ 为事件域，定义在 $\\mathscr{F}$ 上的实值函数 $P(\\cdot)$ 若满足： 非负性：$\\forall A \\in\\mathscr{F}$，$P(A)\\geq 0$ 完全性：$P(\\Omega)=1$ 可列可加性：若 $A_n \\in \\mathscr{F},n=1,2,\\cdots$，且 $A_i A_j=\\varnothing , i\\neq j=1,2,\\cdots$，则 P(\\bigcup^{\\infty}_{n=1}A_n)=\\sum^{\\infty}_{n=1}P(A_n)那么，称 $P$ 是可测空间 $(\\Omega,\\mathscr{F})$ 上的概率，称 $P(A)$ 为事件 $A$ 的概率，称 $(\\Omega,\\mathscr{F},P)$ 为概率空间 概率性质事件的概率具有如下性质： $P(\\varnothing)=0$ 若 $A_i \\in \\mathscr{F},n=1,\\cdots,n$，且 $A_iA_j=\\varnothing,i\\neq j=1,\\cdots,n$，则： P(\\bigcup^n_{i=1}A_i)=\\sum^n_{i=1}P(A_i) 若 $A,B\\in\\mathscr{F},A\\subset B$，则 $P(B-A)=P(B)-P(A)$，$P(A)\\leq P(B)$ 若 $A\\in\\mathscr{F}$，则 $P(A)\\leq 1$，$P(\\bar{A})=1-P(A)$ 若 $A_n\\in\\mathscr{F},n=1,2,\\cdots$，则： P(\\bigcup^{\\infty}_{n=1}A_n)\\leq\\sum^{\\infty}_{n=1}P(A_n) Jordan 公式：若 $A_n\\in\\mathscr{F},n=1,2,\\cdots$，则： P(\\bigcup^n_{i=1}A_i)=\\sum^n_{i=1}P(A_i)-\\sum_{1\\leq i\\leq j \\leq n} P(A_iA_j)+\\cdots+(-1)^{n-1}P(A_1A_2\\cdots A_n)概率连续性定义单调事件列： 单调递增的事件列：事件列 $A_n\\in\\mathscr{F}$ ，满足 $A_n\\subset A_{n+1}$，其中 $n=1,2,\\cdots$ 单调递减的事件列：事件列 $A_n\\in\\mathscr{F}$ ，满足 $A_n\\supset A_{n+1}$，其中 $n=1,2,\\cdots$ 单调事件列必有极限： 1）若 $A_n$ 为单调递增的事件列，那么有：$A_1\\subset A_2\\subset \\cdots \\subset A_n \\cdots$，进而有： \\lim_{n\\rightarrow \\infty} P(A_n) = P(\\bigcup^{\\infty}_{n=1}A_n)2）若 $A_n$ 为单调递减的事件列，那么有：$A_1\\supset A_2\\supset \\cdots \\supset A_n \\cdots$，进而有： \\lim_{n\\rightarrow \\infty} P(A_n) = P(\\bigcap^{\\infty}_{n=1}A_n)【条件概率】以古典概型的掷骰子为例，设事件 $A$ 为掷出的点数为偶数，事件 $B$ 为掷出 $2$，那么概率 $P(B|A)$ 称为在条件 $A$ 下，$B$ 发生的条件概率 可以发现，在附加了 “掷出的点数为偶数” 的条件后，事件 “掷出 $2$” 没有发生变化，变化的是样本空间，其被缩小了 也就是说，条件概率的本质，是对样本空间的限制 于是，有： P(B|A)=P(AB|A)=\\frac{|AB|}{|A|}=\\frac{\\frac{|AB|}{|\\Omega|}}{\\frac{|AB|}{|\\Omega|}}=\\frac{P(AB)}{P(A)} 进一步，模仿概率测度的定义，可以定义条件概率测度 设 $(\\Omega,\\mathscr{F},P)$ 为一概率空间，$A,B\\in\\mathscr{F}$，且 $P(A)&gt;0$，则称 P(B|A)=\\frac{P(AB)}{P(A)}为事件 $A$ 发生的条件下，事件 $B$ 发生的条件概率 【概率公式】乘法公式若 $A_i\\in\\mathscr{F},i=1,2,\\cdots,n$，且 $P(A_1A_2\\cdots A_{n-1})&gt;0$，则： P(A_1A_2\\cdots A_n)=P(A_1)P(A_2|A_1)\\cdots P(A_n|A_1A_2\\cdots A_{n-1})全概率公式若 $A\\in\\mathscr{F},B_i\\in\\mathscr{F},P(B_i)&gt;0,i=1,2,\\cdots,n$，且 $B_iB_j=\\varnothing,i\\neq j,\\bigcup\\limits^{\\infty}_{i=1}B_i\\supset A$，则： P(A)=\\sum^{\\infty}_{i=1}P(B_i)P(A|B_i)贝叶斯公式（Bayes）若 $A\\in\\mathscr{F},P(A)&gt;0,B_i\\in\\mathscr{F},P(B_i)&gt;0,i=1,2,\\cdots,n$，且 $B_iB_j=\\varnothing,i\\neq j,\\bigcup\\limits^{\\infty}_{i=1}B_i\\supset A$，则： P(B_i|A)=\\frac{P(B_i)P(A|B_i)}{\\sum\\limits^{\\infty}_{j=1}P(B_j)P(A|B_j)},\\quad i=1,2,\\cdots$B_j$ 可以看作是诱发了事件 $A$ 的原因，$P(B_j)$ 就代表了每个原因可能发生的概率，为先验概率（Prior Probability） 当发生了事件 $A$ 后，会对引发其的原因产生了新的认识，即 $P(B_j|A)$，称为后验概率（Posterior Probability） 拿着先天的经验来进行实践，得到结果后又反过来去更新那些已经具有的经验，不断地重复这一过程，即可越来越接近最终的真理，因此贝叶斯公式描述的是一个学习与逆推的过程 【事件独立性】对于两个事件 $A,B$，若满足 $P(AB)=P(A)P(B)$，则称 $A$ 与 $B$ 独立 进一步，对于概率空间 $(\\Omega,\\mathscr{F},P)$ ，有 $A_i\\in\\mathscr{F},i=1,\\cdots,n$，若其中的任意两个事件 $A_i,A_j,i\\neq j$，有 $P(A_iA_j)=P(A_i)P(A_j)$ 则称事件两两独立 也就是说，一个随机事件无论是否发生，不会影响到另外一个随机事件发生的概率 再进一步，对于概率空间 $(\\Omega,\\mathscr{F},P)$ ，有 $A_i\\in\\mathscr{F},i=1,\\cdots,n$，若对 $\\forall k \\in(1,n]$ 以及 $1\\leq i_1 &lt; i_2 &lt; \\cdots&lt;i_k \\leq n$，有： P(A_{i_1},A_{i_2},\\cdots,A_{i_k})=P(A_{i_1})P(A_{i_2})\\cdots P(A_{i_k})则称 $A_1,A_2,\\cdots,A_n$ 相互独立 可以发现，若事件 $A_1,A_2,\\cdots,A_n$ 相互独立，则必有事件 $A_1,A_2,\\cdots,A_n$ 两两独立，反之则不成立","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"概率论","slug":"mathematics/probability-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/probability-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"概率论","slug":"probability-theory","permalink":"https://alex-mcavoy.github.io/tags/probability-theory/"}],"author":"Alex_McAvoy"},{"title":"Jordan 标准形","slug":"matrix-theory/04.Jordan标准形","date":"2022-11-04T03:43:00.000Z","updated":"2023-02-24T07:45:59.618Z","comments":true,"path":"mathematics/matrix-theory/4763d862.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/4763d862.html","excerpt":"【引入】对于 $n$ 阶方阵，如果没有 $n$ 个线性无关的特征向量，就无法进行对角化 那么，对于 $n$ 阶方阵，是否能相似于一个较为简单的上三角分块矩阵？答案是肯定的，这种具较为简单的上三角分块矩阵即 Jordan 标准形","text":"【引入】对于 $n$ 阶方阵，如果没有 $n$ 个线性无关的特征向量，就无法进行对角化 那么，对于 $n$ 阶方阵，是否能相似于一个较为简单的上三角分块矩阵？答案是肯定的，这种具较为简单的上三角分块矩阵即 Jordan 标准形 也就是说，任何 $n$ 阶方阵 $A$ 在复数域上都相似于一个 Jordan 标准形 【Jordan 矩阵】称形 \\begin{bmatrix} \\lambda & 1 & \\\\ & \\lambda & 1 & \\\\ & & \\ddots & 1 \\\\ & & & \\lambda \\end{bmatrix}\\in \\mathbb{C}^{r\\times r}的 $r$ 阶矩阵为基本 Jordan 块矩阵，简称为 Jordan 块 同一特征值的若干 Jordan 块组成的对角块矩阵称为子 Jordan 矩阵，而由若干子 Jordan 矩阵组成的对角矩阵称为 Jordan 矩阵 例如 \\begin{bmatrix} 2 & 1\\\\ & 2\\\\ \\end{bmatrix},\\begin{bmatrix} i+1 & 1 \\\\ & i+1 & 1 \\\\ & & i+1 \\end{bmatrix},\\begin{bmatrix} 0 & 1 & & \\\\ & 0 & 1 & \\\\ & & 0 & 1 \\\\ & & & 0 \\end{bmatrix}均为 Jordan 块， \\left[\\begin{array}{c:cc} i+1 & &\\\\ \\hdashline & i+1 & 1\\\\ & & i+1 \\end{array}\\right],\\left[\\begin{array}{cc:cc} 2 & 1 & \\\\ & 2 & & \\\\ \\hdashline & &0 &1 \\\\ & & & 0 \\end{array}\\right],\\left[\\begin{array}{cc:ccc} 3 & 1 & & & \\\\ & 3 & & &\\\\ \\hdashline & & -3 & &\\\\ & & & -3 & 1 \\\\ & & & & -3 \\end{array}\\right]均为 Jordan 矩阵，其中，第一个矩阵由两个 Jordan 块组成，第二、三个矩阵由两个子 Jordan 矩阵组成 【Jordan 标准形】如果 $n$ 阶方阵 $A$ 相似于 Jordan 矩阵，即存在 $n$ 阶可逆阵 $P$，使得 P^{-1}AP=J其中，$J$ 为 Jordan 矩阵，则称 $J$ 为 $A$ 的 Jordan 标准形 设 $n$ 阶方阵 $A$ 的全部互异的特征值为 $\\lambda_1,\\lambda_2,\\cdots,\\lambda_s$，其代数重数分别为 $n_1,n_2,\\cdots,n_s(n_1+n_2+\\cdots+n_s=n)$，几何重数分别为 $k_i=\\text{dim } \\varepsilon_{\\lambda_i}$，则 $A$ 相似于一个 Jordan 阵，即存在可逆阵 $P\\in \\mathbb{C}^{n\\times n}$，使得 P^{-1}AP=\\begin{bmatrix} J_1 & & &\\\\ & J_2 & &\\\\ & &\\ddots &\\\\ & & & J_s \\end{bmatrix}其中，$J_i$ 是主对角元为 $\\lambda_i$ 的 $n_i$ 阶子 Jordan 阵，且 $J_i$ 包含 $k_i$ 个 Jordan 块 【行列式因子与不变因子】行列式因子若一个矩阵都是关于 $\\lambda$ 的多项式，那么该矩阵称为 $\\lambda$ 阵，或多项式矩阵 设 $A\\in\\mathbb{C}^{n\\times n}$，记 $A(\\lambda)=\\lambda I_n-A$，称 $A(\\lambda)$ 为方阵 $A$ 的特征矩阵，显然 $A(\\lambda)$ 中的元均为 $\\lambda$ 的零次或一次多项式，故 $A(\\lambda)$ 是一个特殊的 $\\lambda$ 阵 对于 $n$ 阶方阵 $A$ 的特征矩阵 $A(\\lambda)$，其中所有非零的 $k$ 阶子式的首项系数为 $1$ 的最大公因式 $D_k(\\lambda)$，称为 $A(\\lambda)$ 的一个 $k$ 级行列式因子 由于多项式的首项是指多项式的最高次项，通常称首项系数为 $1$ 的多项式为首一多项式，因此 $A(\\lambda)$ 的各级行列式因子均为首一多项式 不变因子根据行列式因子的定义，有 D_n(\\lambda)=|\\lambda I_n-A|因为 $D_k(\\lambda)$ 可按一行或按一列展开为一系列 $k-1$ 级子式的代数和，又 $D_{k-1}(\\lambda)$ 能整除每个 $k-1$ 级子式，所以 $D_{k-1}(\\lambda)$ 能整除 $D_k(\\lambda)$，记为 $D_{k-1}(\\lambda)|D_k(\\lambda)$，故称下列 $n$ 个多项式 \\begin{align*} d_1(\\lambda) =& D_1(\\lambda)\\\\ d_2(\\lambda) =& \\frac{D_2(\\lambda)}{D_1(\\lambda)} \\\\ \\vdots \\\\ d_n(\\lambda) =& \\frac{D_n(\\lambda)}{D_{n-1}(\\lambda)} \\end{align*}为 $A(\\lambda)$ 的不变因子 由于特征矩阵 $A(\\lambda)$ 只与 $A$ 相关，因此 $A(\\lambda)$ 的行列式因子和不变因子也称为矩阵 $A$ 的行列式因子和不变因子 【Smith 标准形】直接使用定义去求 $A$ 的各级行列式因子和不变因子是十分繁琐的，为此可以采用初等变换的方式来求 称下列运算为多项式矩阵 $A(\\lambda)$ 的初等变换： 互换 $A(\\lambda)$ 的任意两行或两列 用非零常数 $c$ 乘 $A(\\lambda)$ 的某行或某列 用多项式 $\\varphi(\\lambda)$ 乘 $A(\\lambda)$ 的某行或某列，然后加到另一行或另一列 由行列式的性质可知，特征矩阵 $A(\\lambda)$ 的行列式因子在初等变换下是不变的，因此，可对 $A(\\lambda)$ 进行初等变换，将 $A(\\lambda)$ 变为如下对角形 \\begin{bmatrix} \\varphi_1(\\lambda) &&& \\\\ & \\varphi_2(\\lambda) &&\\\\ && \\ddots &\\\\ &&& \\varphi_n(\\lambda) \\end{bmatrix}其中，$\\varphi_i(\\lambda)$ 均为首一多项式，且满足 \\varphi_1(\\lambda)|\\varphi_2(\\lambda),\\quad \\varphi_2(\\lambda)|\\varphi_3(\\lambda),\\quad \\cdots,\\quad \\varphi_{n-1}(\\lambda)|\\varphi_n(\\lambda)称上式的对角形为特征矩阵 $A(\\lambda)$ 的 Smith 标准形，其主对角线上的各多项式即为 $A(\\lambda)$ 的不变因子 【初等因子】将 $A$ 的每个次数大于零的不变因子在复数域内分解为互不相同的一次因式的方幂的乘积，所有这些一次因式的方幂（相同的按出现次数计算）称为 $A$ 的初等因子 例如，若 $A$ 的不变因子为 \\begin{array}{c} d_1(\\lambda)=d_2(\\lambda)=\\cdots=d_6(\\lambda)=1 \\\\ d_7(\\lambda)=(\\lambda-1)^2 \\\\ d_8(\\lambda)=(\\lambda-2)(\\lambda-1)^2 \\\\ d_9(\\lambda)=(\\lambda-2)^2(\\lambda-1)^2 \\end{array}则次数大于零的不变因子有 $3$ 个，即 $d_7(\\lambda),d_8(\\lambda),d_9(\\lambda)$，这三个不变因子共有五个因子组成，故 $A$ 的全部初等因子为 (\\lambda-1)^2,\\quad (\\lambda-2),\\quad (\\lambda-1)^2,\\quad (\\lambda-2)^2,\\quad (\\lambda-1)^2【Jordan 标准形的构造】根据多项式矩阵理论，两根同阶方阵 $A,B$ 相似的充要条件是它们具有相同的不变因子或初等因子 从这一结论可以推出，若知道方阵 $A$ 的全部初等因子，那么只要能求出同样具有这些初等因子的 Jordan 阵，这个 Jordan 阵，即为 $A$ 的 Jordan 标准形 设方阵 $A\\in\\mathbb{C}^{n\\times n}$ 的全部初等因子为 (\\lambda-\\lambda_1)^{k_1},\\quad (\\lambda-\\lambda_2)^{k_2},\\quad\\cdots,\\quad (\\lambda-\\lambda_s)^{k_s}其中，$\\lambda_1,\\lambda_2,\\cdots,\\lambda_s$ 可能是相同的，指数 $k_1,k_2,\\cdots,k_s$ 也可能是相同的，对每个初等因子 $(\\lambda-\\lambda_i)^{k_i}$ 构造一个 Jordan 块 J_i=\\begin{bmatrix} \\lambda_i & 1 & &\\\\ & \\lambda_i & \\ddots &\\\\ & & \\ddots & 1 \\\\ & & & \\lambda_i \\end{bmatrix},\\quad i=1,2\\cdots,s则 $A$ 的 Jordan 标准形为 J=\\begin{bmatrix} J_1 &&& \\\\ & J_2 && \\\\ &&\\ddots& \\\\ &&& J_n \\end{bmatrix}易知，除去 Jordan 块的排列次序外，方阵 $A$ 的 Jordan 标准形是由 $A$ 唯一确定的 例如，若矩阵 $A$ 的全部初等因子为 (\\lambda-2),\\quad (\\lambda-2)^2,\\quad (\\lambda-4)故 $A$ 的 Jordan 标准形为 J=\\left[\\begin{array}{c:c:cc} 4 & & & \\\\ \\hdashline & 2 & &\\\\ \\hdashline & & 2 & 1 \\\\ & & & 2 \\end{array}\\right]即存在可逆阵 $P$，使得 P^{-1}AP=\\text{diag}([4],[2],\\begin{bmatrix}2&1\\\\&2\\end{bmatrix})","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"内积空间","slug":"matrix-theory/03.内积空间","date":"2022-10-28T03:39:00.000Z","updated":"2023-02-24T07:45:04.292Z","comments":true,"path":"mathematics/matrix-theory/2b21d67a.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/2b21d67a.html","excerpt":"【内积空间】欧式空间设 $V^n$ 是 $\\mathbb{R}$ 上的 $n$ 维实线性空间，若 $\\forall \\alpha,\\beta\\in V$，有一实数 $&lt;\\alpha,\\beta&gt;$ 与之对应，且满足","text":"【内积空间】欧式空间设 $V^n$ 是 $\\mathbb{R}$ 上的 $n$ 维实线性空间，若 $\\forall \\alpha,\\beta\\in V$，有一实数 $&lt;\\alpha,\\beta&gt;$ 与之对应，且满足 对称性：$&lt;\\alpha,\\beta&gt;=&lt;\\beta,\\alpha&gt;$ 可加性：$&lt;\\alpha+\\beta,\\gamma&gt;=&lt;\\alpha,\\gamma&gt;+&lt;\\beta,\\gamma&gt;$ 齐次性：$=k&lt;\\alpha,\\beta&gt;,k\\in \\mathbb{R}$ 正定性：$&lt;\\alpha,\\alpha&gt;\\geq 0$，当且仅当 $\\alpha=0$ 时 $&lt;\\alpha,\\alpha&gt;=0$ 则称 $&lt;\\alpha,\\beta&gt;$ 为 $\\alpha,\\beta$ 的内积，称定义有这样内积的 $n$ 维线性空间 $V$ 为 $n$ 维欧式空间 酉空间设 $V^n$ 是 $\\mathbb{R}$ 上的 $n$ 维复线性空间，若 $\\forall \\alpha,\\beta\\in V$，有一复数 $&lt;\\alpha,\\beta&gt;$ 与之对应，且满足 共轭对称性：$&lt;\\alpha,\\beta&gt;=\\overline{&lt;\\beta,\\alpha&gt;}$ 第一变元可加性：$&lt;\\alpha+\\beta,\\gamma&gt;=&lt;\\alpha,\\gamma&gt;+&lt;\\beta,\\gamma&gt;$ 第一变元齐次性：$=k&lt;\\alpha,\\beta&gt;,k\\in \\mathbb{C}$ 正定性：$&lt;\\alpha,\\alpha&gt;\\geq 0$，当且仅当 $\\alpha=0$ 时 $&lt;\\alpha,\\alpha&gt;=0$ 则称 $&lt;\\alpha,\\beta&gt;$ 为 $\\alpha,\\beta$ 的内积，称定义有这样内积的 $n$ 维复线性空间 $V$ 为 $n$ 维酉空间 【度量矩阵】设 $\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 为 $V^n$ 的一个基，对 $\\forall\\alpha=\\sum\\limits_{i=1}^nx_i\\alpha_i,\\forall\\beta=\\sum\\limits_{j=1}^ny_j\\alpha_j$，有 \\begin{align*} =& \\\\ =& \\sum_{i=1}^n\\sum_{j=1}^nx_iy_j \\end{align*}称 G(\\alpha_1,\\alpha_2,\\cdots,\\alpha_n)=\\begin{bmatrix} & & \\cdots & \\\\ & & \\cdots & \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ & & \\cdots & \\\\ \\end{bmatrix}为基 $\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 的度量矩阵 故有 =\\mathbf{x}^TG(\\alpha_1,\\alpha_2,\\cdots,\\alpha_n)\\mathbf{y}其中，$\\mathbf{x},\\mathbf{y}$ 分别为 $\\alpha,\\beta$ 的坐标向量 【向量运算】向量长度对向量 $\\alpha\\in V$ 称 $\\sqrt{&lt;\\alpha,\\alpha&gt;}$ 为 $\\alpha$ 的长度，记为 $|\\alpha|$，长度为 $1$ 的向量称为单位向量 向量长度具有如下性质： $|\\alpha|\\geq 0$，当且仅当 $\\alpha=0$ 时，$|\\alpha|=0$ 对 $\\forall k$，有 $|k\\alpha|=|k||\\alpha|$ 三角不等式：$|\\alpha+\\beta|\\leq |\\alpha| + |\\beta|$ Cauchy-Schwartz 不等式：$|&lt;\\alpha,\\beta&gt;|\\leq |\\alpha||\\beta|$ 向量的距离与夹角Cauchy-Schwartz 不等式在 $n$ 维欧氏空间 $\\mathbb{R}^n$ 中，变为 |\\sum_{i=1}^n x_iy_i|\\leq \\sqrt{\\sum_{i=1}^n x_i^2} \\sqrt{\\sum_{i=1}^n y_i^2}同时，在 $\\mathbb{R}^n$ 中，可定义两向量 $\\alpha$ 与 $\\beta$ 的距离 d(\\alpha,\\beta)=|\\alpha-\\beta|且两向量 $\\alpha$ 与 $\\beta$ 的夹角满足下式 \\cos(\\alpha,\\beta)=\\frac{}{|\\alpha||\\beta|}向量单位化对于 $\\forall \\alpha\\neq 0$，有 \\Big|\\frac{\\alpha}{|\\alpha|}\\Big| = \\frac{1}{|\\alpha|} |\\alpha|=1即 $\\frac{\\alpha}{|\\alpha|}$ 为单位向量，称这种方法为向量的单位化 Schmidt 标准正交化若 $&lt;\\alpha,\\beta&gt;=0$，则称向量 $\\alpha$ 和 $\\beta$ 正交，记为 $\\alpha\\perp\\beta$，进一步，若向量组 $\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 中的向量两两正交，则称该向量组为正交向量组，对于不含零向量的正交向量组，是线性无关的 称 $V^n$ 中有顺序的 $n$ 个非零向量所组成的正交向量组为正交基，称由单位向量组成的正交基为标准正交基，显然，$B=\\{\\varepsilon_1,\\varepsilon_2,\\cdots,\\varepsilon_n\\}$ 为 $V^n$ 的一个标准正交基的充要条件为 =\\delta_{ij} \\triangleq \\left\\{ \\begin{array}{c} 1,&i=j\\\\ 0,&i\\neq j \\end{array}\\right. \\quad i,j=1,2,\\cdots,n对于线性无关向量组来说，若想将其构造成一个标准正交基，可采用 Schmidt 标准正交化 设 $\\{ \\alpha_1,\\alpha_2,\\cdots,\\alpha_n \\}$ 是 $n$ 维内积空间中的线性无关向量组，那么正交向量组 $\\{\\beta_1,\\beta_2,\\cdots,\\beta_n\\}$ 为 \\begin{array}{l} \\beta_1= \\alpha_1 \\\\ \\beta_2= \\alpha_2-\\frac{}{}\\beta_1 \\\\ \\beta_3 = \\alpha_3-\\frac{}{}\\beta_1 - \\frac{}{}\\beta_2\\\\ \\cdots \\\\ \\beta_n = \\alpha_n - \\sum\\limits_{i=1}^{n-1}\\frac{}{}\\beta_i \\end{array}其中，$\\frac{&lt;\\alpha_n,\\beta_i&gt;}{&lt;\\beta_i,\\beta_i&gt;}\\beta_i$ 称为向量 $\\alpha_n$ 在向量 $\\beta_i$ 上的投影 将正交向量组 $\\{\\beta_1,\\beta_2,\\cdots,\\beta_n\\}$ 再进行标准化，即可得到一标准正交基 $\\{\\varepsilon_1,\\varepsilon_2,\\cdots,\\varepsilon_n\\}$，即 \\begin{align*} \\varepsilon_1 =& \\frac{\\beta_1}{|\\beta_1|} \\\\ \\varepsilon_2 =& \\frac{\\beta_2}{|\\beta_2|} \\\\ \\vdots \\\\ \\varepsilon_n =& \\frac{\\beta_n}{|\\beta_n|} \\end{align*}由于 $\\frac{&lt;\\alpha_n,\\beta_i&gt;}{&lt;\\beta_i,\\beta_i&gt;}\\beta_n=&lt;\\alpha_n,\\varepsilon_n&gt;$，故由标准正交基 $\\{\\varepsilon_1,\\varepsilon_2,\\cdots,\\varepsilon_n\\}$ 到线性无关向量组 $\\{ \\alpha_1,\\alpha_2,\\cdots,\\alpha_n \\}$ 的变换的矩阵表示为 [\\alpha_1,\\alpha_2,\\cdots,\\alpha_n] = [\\varepsilon_1,\\varepsilon_2,\\cdots,\\varepsilon_n] \\begin{bmatrix} |\\beta_1| & & \\cdots & \\\\ 0 & |\\beta_2| & \\cdots & \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & |\\beta_n| \\\\ \\end{bmatrix}【正交变换】定义首先，给出以下三种矩阵的定义： 正交矩阵：$A^TA=I$ 酉矩阵：$A^HA=I$，其中 $A^H=\\overline{A^T}$ Hermite 矩阵：$A^H=A$ 对于 $n$ 维欧氏空间（酉空间）$V^n$ 的线性变换 $T$，若 $\\forall \\alpha,\\beta\\in V^n$，有 =则线性变换 $T$ 称为正交变换（酉变换） 判别线性变换 $T$ 是正交变换（酉变换）的充要条件是下列条件之一成立： $T$ 保持向量长度不变，即 $\\forall \\alpha\\in V^{n}$，有 $|T\\alpha|=|\\alpha|$ $T$ 将标准正交基映射为标准正交基 $T$ 在任何标准正交基下的矩阵，均为正交阵或酉矩阵 初等旋转变换在二维平面上，绕原点逆时针旋转 $\\theta$ 角的线性变换 $T$ 在标准正交基 $\\{e_1,e_2\\}$ 下的矩阵为 \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}由于旋转不改变向量的长度，故 $T$ 为正交变换 一般地，在 $\\mathbb{R}^n$ 中取一个标准正交基 $\\{\\varepsilon_1,\\varepsilon_2,\\cdots,\\varepsilon_n\\}$ 后，在平面 $\\text{span}\\{\\varepsilon_i,\\varepsilon_j\\}$ 中逆时针旋转 $\\theta$ 角的线性变换 $T$ 是一正交变换，称为初等旋转变换，其在 $\\{\\varepsilon_1,\\varepsilon_2,\\cdots,\\varepsilon_n\\}$ 下的矩阵称为初等旋转矩阵，有 T_{ij}(\\theta)=\\left[\\begin{array}{ccc:ccccc:ccc} 1 & & & & & & & & & & \\\\ & \\ddots & & & & & & & & & \\\\ & & 1 & & & & & & & & \\\\ \\hdashline & & & \\cos\\theta & & & & -\\sin\\theta & & & \\\\ & & & & 1 & & & & & & \\\\ & & & & & \\ddots & & & & & \\\\ & & & & & & 1 & & & & \\\\ & & & \\sin\\theta & & & & \\cos\\theta & & & \\\\ \\hdashline & & & & & & & & 1 & & \\\\ & & & & & & & & & \\ddots & \\\\ & & & & & & & & & & 1 \\end{array}\\right]其中，$\\cos\\theta,-\\sin\\theta$ 所在行为第 $i$ 行，$\\sin\\theta,\\cos\\theta$ 所在行为第 $j$ 行 镜像变换在平面上给定以单位向量 $\\omega$ 以及它正交且过原点的直线 $l$，将任一向量 $\\alpha$ 映射为与 $l$ 对称的向量 $\\beta$ 的变换 $T$，称为关于 $l$ 的镜像变换，由于映射不改变向量的长度，故 $T$ 为正交变换 一般地，在 $\\mathbb{R}^n$ 中定义线性变换 $H_{\\omega}$ 为 H_{\\omega}\\alpha = (I-2\\omega\\omega^T)\\alpha称 $H_{\\omega}$ 为镜像变换，或 Householder 变换，其可将任何向量映射为任意方向的同长度向量 变换矩阵 $H$ 被称为 Householde 矩阵，其具有如下性质： 变换矩阵为酉矩阵：$H^HH=I_n$ 变换矩阵为 Hermite 阵：$H^H=H$ 变换矩阵为对合阵：$H^2=I_n$ 【对称变换】定义对于 $n$ 维欧氏空间（酉空间）$V^n$ 的线性变换 $T$，若 $\\forall \\alpha,\\beta\\in V^n$，有 =则线性变换 $T$ 称为对称变换（酉对称变换） 判别线性变换 $T$ 是对称变换（酉对称变换）的充要条件是：$T$ 在标准正交基下的矩阵，是对称矩阵（Hermite 矩阵） 对角化对于 $n$ 阶方阵 $A$，其不一定总能化成对角阵，但可以退而求其次，根据 Schur 定理，一定可化为三角阵，即： 设 $A$ 为 $n$ 阶方阵，$\\lambda_1,\\lambda_2,\\cdots,\\lambda_n$ 为其特征值，无论它们是实数还是复数，总存在相似酉矩阵 $U$，将 $A$ 化为三角阵，即 U^{-1}AU=B其中，$B$ 为三角阵，且对角线元素为 $\\lambda_1,\\lambda_2,\\cdots,\\lambda_n$ 进一步，若 $A$ 为 Hermite 矩阵，那么则存在酉矩阵 $U$，使得 U^HAU=\\text{diag}(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)若 $A$ 为实对称矩阵，那么则存在正交矩阵 $Q$，使得 Q^TAQ=\\text{diag}(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)综上，$n$ 维欧氏空间（酉空间）的对称变换（酉对称变换）一定可对角化","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"线性变换及其矩阵表示","slug":"matrix-theory/02.线性变换及其矩阵表示","date":"2022-10-21T12:55:00.000Z","updated":"2023-02-24T07:41:42.989Z","comments":true,"path":"mathematics/matrix-theory/b2f8c39a.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/b2f8c39a.html","excerpt":"【线性变换】设 $V_1,V_2$ 是数域 $F$ 上的两个线性空间，将 $V_1$ 到 $V_2$ 的映射称为变换，线性变换是其中最简单、最基本的一种变换，其与矩阵、线性空间等都有密切的联系 定义变换 $T:V_1\\rightarrow V_2$，若满足 $\\forall \\alpha_1,\\alpha_2\\in V_1,\\lambda\\in F$，有","text":"【线性变换】设 $V_1,V_2$ 是数域 $F$ 上的两个线性空间，将 $V_1$ 到 $V_2$ 的映射称为变换，线性变换是其中最简单、最基本的一种变换，其与矩阵、线性空间等都有密切的联系 定义变换 $T:V_1\\rightarrow V_2$，若满足 $\\forall \\alpha_1,\\alpha_2\\in V_1,\\lambda\\in F$，有 \\begin{align*} T(\\alpha_1+\\alpha_2) &= T\\alpha_1+T\\alpha_2 \\\\ T(\\lambda\\alpha_1) &=\\lambda T\\alpha_1 \\end{align*}则称 $T$ 是由 $V_1$ 到 $V_2$ 的线性变换，并称 $\\alpha_1$ 为 $T\\alpha_1$ 的原像，$T\\alpha_1$ 为 $\\alpha_1$ 的像 线性变换具有如下性质： $T\\mathbf{0}=\\mathbf{0}$ 对于 $\\forall k_i$，有 $T(\\sum\\limits_{i=1}^r k_i\\alpha_i)=\\sum\\limits_{i=1}^rk_iT\\alpha_i$ 设 $\\alpha_1,\\cdots,\\alpha_r\\in V_1$ 且 $\\alpha_1,\\cdots,\\alpha_r$ 线性相关，则 $T\\alpha_1,\\cdots,T\\alpha_r$ 也是线性相关的 【变换矩阵】设 $T:V_1\\rightarrow V_2$ 为线性变换，$B_{\\alpha}=\\{T\\alpha_1,\\cdots,T\\alpha_n\\}$ 是 $V_1$ 的一组基，$B_{\\beta}=\\{\\beta_1,\\cdots,\\beta_m\\}$ 是 $V_2$ 的一组基，则 T\\alpha_{j}=\\sum_{i=1}^ma_{ij}\\beta_i= \\begin{bmatrix} \\beta_1 & \\cdots &\\beta_m \\end{bmatrix}\\begin{bmatrix} a_{1j} \\\\ \\vdots \\\\ a_{mj} \\end{bmatrix}, \\quad j=1,2,\\cdots,n将这 $n$ 个关系式用矩阵记号来表示 T\\begin{bmatrix} \\alpha_1 &\\alpha_2 & \\cdots &\\alpha_m \\end{bmatrix}= \\begin{bmatrix} \\beta_1 &\\beta_2 & \\cdots &\\beta_m \\end{bmatrix}\\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m1} & a_{m2} & \\cdots & a_{mn} \\\\ \\end{bmatrix}称 $m\\times n$ 阶矩阵 A=\\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m1} & a_{m2} & \\cdots & a_{mn} \\\\ \\end{bmatrix}为线性变换 $T$ 在基偶 $(B_{\\alpha},B_{\\beta})$ 下的变换矩阵，其描述了 $n$ 维空间到 $m$ 维空间的线性变换的映射关系 故有 TB_{\\alpha}=B_{\\beta}A称为线性变换 $T$ 在基偶 $(B_{\\alpha},B_{\\beta})$ 下的矩阵表示 该式表明了，在给定基偶 $(B_{\\alpha},B_{\\beta})$ 的条件下，线性变换 $T$ 与变换矩阵 $A$ 一一对应，即对线性变换 $T$ 的研究，可转换为对矩阵 $A$ 的研究 【等价关系与相似关系】在给定基偶 $(B_{\\alpha},B_{\\beta})$ 的条件下，线性变换 $T$ 与变换矩阵 $A$ 一一对应，那么 $T$ 在不同的基偶下，矩阵表示间的关系有最基本的两种，即等价关系和相似关系 等价关系设 $(B_{\\alpha},B_{\\beta})$ 和 $(B_{\\alpha’},B_{\\beta’})$ 是 $V_1\\rightarrow V_2$ 的两对基偶，$T$ 在这两个基偶下的变换矩阵分别为 $A,B$，且 $P$ 为 $B_{\\alpha}$ 到 $B_{\\alpha’}$ 的过渡矩阵，$Q$ 为 $B_{\\beta}$ 到 $B_{\\beta’}$ 的过渡矩阵，即 \\begin{matrix} B_{\\alpha'}=B_{\\alpha}P & TB_{\\alpha}=B_{\\beta}A \\\\ B_{\\beta'}=B_{\\beta}Q & TB_{\\alpha'}=B_{\\beta'}B \\end{matrix}从而有 B_{\\beta}AP=TB_{\\alpha}P=TB_{\\alpha'}=B_{\\beta'}B=B_{\\beta}QB因此 B_{\\beta}(AP-QB)=O由于 $B_{\\beta}$ 是基，线性无关，故有 AP=QB \\Rightarrow B=Q^{-1}AP即 $T$ 在不同基偶下的矩阵 $A$ 和 $B$ 是等价关系，记为 $A\\cong B$ 等价关系可理解为：在 $n$ 维线性空间中选择基矩阵 $P$，在 $m$ 维线性空间中，选择基矩阵 $Q$，在 $P,Q$ 的作用下，通过线性变换 $T$ 的映射，由 $A$ 变为 $B$ 相似关系若线性变换 $T$ 是 $V_1\\rightarrow V_1$，那么在上述过程中，有 V_2=V_1,B_{\\beta}=B_{\\alpha},B_{\\beta'}=B_{\\alpha'},Q=P进而可得 AP=PB\\Rightarrow B=P^{-1}AP即 $T$ 在不同基偶下的矩阵 $A$ 和 $B$ 是相似关系，记为 $A\\sim B$ 相似关系可理解为：在 $n$ 维线性空间中选择基矩阵 $P$，在 $P$ 的作用下，通过线性变换 $T$ 的映射，由 $A$ 变为 $B$ 【不变子空间】进一步，讨论线性变换 $T:V\\rightarrow V$ 的矩阵表示的简化问题，即 $T$ 在什么样的基下的矩阵表示较简单，这个问题与不变子空间和特征值与特征向量密切相关 核空间与值域在给出不变子空间的定义前，首先给出核空间与值域的概念 设 $T:V_1\\rightarrow V_2$ 为线性变换，分别称 \\begin{align*} N(T) &\\triangleq \\{\\alpha\\in V_1 | T\\alpha = \\mathbf{0} \\} \\\\ R(T) &\\triangleq \\{\\beta\\in V_2 | \\beta=T\\alpha,\\alpha\\in V_1 \\} \\\\ \\end{align*}为 $T$ 的核空间与值域 并称 $\\text{dim}(N(T))$ 为 $T$ 的零度，记为 $\\text{null }T$，称 $\\text{dim}(R(T))$ 为 $T$ 的秩，记为 $\\text{rank }T$ 通过基的扩张方法，对于线性变换 $T:V_1\\rightarrow V_2$ ，记 $n=\\text{dim}V_1$，有 \\text{null }T+\\text{rank } T = n不变子空间设 $T:V\\rightarrow V$ 为线性变换，$W$ 是 $V$ 的子空间，若 $\\forall \\alpha\\in W$，有 $T\\alpha\\in W$，则称 $W$ 为 $V$ 的不变子空间 显然，核空间 $N(T)$ 和值域 $R(T)$ 都是 $T$ 的不变子空间 利用不变子空间，可以简化线性变换 $T$ 的矩阵表示 设 $\\text{dim} V=n$，$W\\subset V$ 是不变子空间，$\\text{dim}W=k&lt;n$，取 $W$ 的一组基 $\\{\\alpha_1,\\cdots,\\alpha_k\\}$，将其扩张为 $V$ 的基 $\\{\\alpha_1,\\cdots,\\alpha_k,\\alpha_{k+1},\\cdots,\\alpha_{n}\\}$ 由于 $T(W)\\subset W$，故 $T\\alpha_1,\\cdots,T\\alpha_k$ 是 $\\alpha_1,\\cdots,\\alpha_k$ 的线性组合，而 $T\\alpha_{k+1},\\cdots,T\\alpha_{n}$ 是 $\\alpha_1,\\cdots,\\alpha_n$ 的线性组合，即 \\begin{align*} T\\alpha_1 &= a_{11}\\alpha_{1} + a_{21}\\alpha_{2} + \\cdots + a_{k1}\\alpha_{k} \\\\ T\\alpha_2 &= a_{12}\\alpha_{1} + a_{22}\\alpha_{2} + \\cdots + a_{k2}\\alpha_{k} \\\\ &\\cdots\\cdots\\\\ T\\alpha_k &= a_{1k}\\alpha_{1} + a_{2k}\\alpha_{2} + \\cdots + a_{kk}\\alpha_{k} \\\\ T\\alpha_{k+1} &= a_{1k+1}\\alpha_{1} + a_{2k+1}\\alpha_{2} + \\cdots + a_{kk+1}\\alpha_{k}+a_{k+1k+1}\\alpha_{k+1}+\\cdots+a_{nk+1}\\alpha_{n} \\\\ &\\cdots\\cdots\\\\ T\\alpha_{n} &= a_{1n}\\alpha_{1} + a_{2n}\\alpha_{2} + \\cdots + a_{kn}\\alpha_{k}+a_{k+1n}\\alpha_{k+1}+\\cdots+a_{nn}\\alpha_{n} \\end{align*}故 $T:V\\rightarrow V$ 在由不变子空间 $W$ 的基 $\\{\\alpha_1,\\cdots,\\alpha_k\\}$ 所扩张成空间 $V$ 的基 $\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 下的矩阵表示为 A=\\left[\\begin{array}{cccc:cccc} a_{11} & a_{12} & \\cdots & a_{1k} & a_{1k+1} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2k} & a_{2k+1} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{k1} & a_{k2} & \\cdots & a_{kk} & a_{kk+1} & \\cdots & a_{kn} \\\\ \\hdashline 0 & 0 & \\cdots & 0 & a_{k+1k+1} & \\cdots & a_{k+1n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 0 & a_{nk+1} & \\cdots & a_{nn} \\\\ \\end{array}\\right] \\triangleq \\begin{bmatrix} A_{11} & A_{12} \\\\ O & A_{22} \\end{bmatrix}反之，若 $T:V\\rightarrow V$ 在某个基 $\\{\\alpha_1,\\cdots,\\alpha_k,\\alpha_{k+1},\\cdots,\\alpha_{n}\\}$ 下的矩阵具有以上形状，则 W\\triangleq \\text{span}\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_k\\}必是 $T:V\\rightarrow V$ 的不变子空间 更进一步，若 $W_1\\triangleq \\text{span}\\{\\alpha_{k+1},\\cdots,\\alpha_n\\}$ 也是 $T$ 的不变子空间，则此时 $T:V\\rightarrow V$ 在基 $\\{\\alpha_1,\\cdots,\\alpha_k,\\alpha_{k+1},\\cdots,\\alpha_{n}\\}$ 下的矩阵表示为对角块阵，即 A=\\begin{bmatrix} A_{11} & O \\\\ O & A_{22} \\end{bmatrix}其中，$A_{11}$ 为 $W$ 所对应的过渡矩阵，$A_{22}$ 为 $W_1$ 所对应的过渡矩阵 一般若 $V$ 为 $T$ 的若干个不变子空间的直和 V=W_1\\oplus W_2\\oplus\\cdots\\oplus W_s在每个 $W_i$ 中取基 $\\{\\alpha_{i1},\\cdots,\\alpha_{in_i}\\}$，再将这些基合起来构成 $V$ 的一组基，则 $T:V\\rightarrow V$ 在该基下的矩阵表示为对角块阵，即 A=\\begin{bmatrix} A_{11} & & &\\\\ & A_{22} & & \\\\ & & \\ddots & \\\\ & & & A_{ss} \\end{bmatrix} \\triangleq \\text{diag}\\{A_{11},A_{22},\\cdots,A_{ss}\\}其中，$A_{ii}$ 为 $W_i$ 所对应的过渡矩阵 【特征值与特征向量】引入通过利用不变子空间，将线性变换 $T:V\\rightarrow V$ 的矩阵表示简化为对角块阵 而对角阵又是对角块阵中最简单的一种，那么是否在一定条件下 $T:V\\rightarrow V$ 的矩阵表示可以简化为对角阵？ 由于 $T:V\\rightarrow V$ 在基 $B=\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$ 下的矩阵是对角阵，即 A=\\begin{bmatrix} \\lambda_1 & & & \\\\ & \\lambda_2 & & \\\\ & & \\ddots & \\\\ & & & \\lambda_n \\end{bmatrix}\\triangleq \\text{diag}\\{\\lambda_1,\\lambda_2,\\cdots,\\lambda_n\\}则 \\begin{bmatrix} T\\alpha_1 & T\\alpha_2 & \\cdots & T\\alpha_n \\end{bmatrix}=\\begin{bmatrix} \\alpha_1 & \\alpha_2 & \\cdots & \\alpha_n \\end{bmatrix}\\begin{bmatrix} \\lambda_1 & & & \\\\ & \\lambda_2 & & \\\\ & & \\ddots & \\\\ & & & \\lambda_n \\end{bmatrix}从而有 T\\alpha_i=\\lambda_i\\alpha_i,\\quad i=1,2,\\cdots,n为此，引入线性变换 $T$ 的特征值和特征向量的概念 特征值与特征向量设线性变换 $T:V\\rightarrow V$，若 $\\exists \\lambda_0\\in F$ 及非零向量 $\\alpha$，使得 T\\alpha=\\lambda_0\\alpha则称 $\\lambda_0$ 是 $T$ 的一个特征值，$\\alpha$ 是 $T$ 关于 $\\lambda_0$ 的特征向量 易见，若 $\\alpha$ 为 $\\lambda_0$ 的特征向量，则 $\\forall k\\in F$，$k\\alpha$ 亦为 $\\lambda_0$ 的特征向量，即特征向量不被特征值唯一确定，但特征值由特征向量决定 对于 $T$ 的任一特征值 $\\lambda_0$，$T$ 关于 $\\lambda_0$ 的所有特征向量，再加上零向量组成的集合 V_{\\lambda_0}\\triangleq \\{\\alpha \\in V^n|T\\alpha=\\lambda_0\\alpha\\}是 $V^n$ 的一个子空间，称 $V_{\\lambda_0}$ 是 $T$ 关于 $\\lambda_0$ 的特征子空间，$\\text{dim}V_{\\lambda_0}$ 是 $\\lambda_0$ 的几何重数 显然，$V_{\\lambda_0}$ 是 $T$ 的不变子空间，且 $\\lambda_0$ 的几何重数就是 $T$ 关于 $\\lambda_0$ 的线性无关特征向量的最大个数，其反映了特征向量的个数 特征多项式下面给出如何求 $T$ 的特征值 $\\lambda_0$ 和对应的特征向量 $\\alpha$ 的方法 设 $n$ 维线性空间 $V$ 的基为 $B=\\{\\alpha_1,\\alpha_2,\\cdots,\\alpha_n\\}$，$T$ 在 $B$ 下的变换矩阵为 $A$，向量 $\\alpha=\\sum\\limits_{i=1}^nx_i\\alpha_i=B\\mathbf{x}$，$\\mathbf{x}=[x_1,x_2,\\cdots,x_n]^T$，则 T\\alpha=T(B\\mathbf{x})=(TB)\\mathbf{x}=B(A\\mathbf{x})即 $T\\alpha$ 在基 $B$ 下的坐标为 $A\\mathbf{x}$ 又因 $T\\alpha=\\lambda_0\\alpha$，则 $B(A\\mathbf{x})=B(\\lambda_0\\mathbf{x})$，即 $B(\\lambda_0\\mathbf{x}-A\\mathbf{x})=\\mathbf{0}$，因为 $B$ 为基，故 A\\mathbf{x}=\\lambda_0\\mathbf{x}即 $\\lambda_0$ 是矩阵 $A$ 的特征值 反过来，若 $\\lambda_0$ 是矩阵 $A$ 的特征值，则方程组 (\\lambda_0I-A)\\mathbf{x}=0有非零解 $\\mathbf{x}=[x_1,x_2,\\cdots,x_n]^T$，从而 \\alpha=\\sum_{i=1}^n x_i\\alpha_i是 $\\lambda_0$ 的特征向量 由于相似阵具有相同的特征多项式，故将 $A$ 的特征多项式 f(\\lambda)\\triangleq |\\lambda I-A|=\\lambda^n+b_1\\lambda^{n-1}+\\cdots+b_n称为线性变换 $T$ 的特征多项式，$T$ 的特征值即该特征多项式的根 我们知道，如果 $\\lambda_1,\\lambda_2,\\cdots,\\lambda_s$ 是 $T$ 的所有不同的特征值，那么 $T$ 的特征多项式可写为 f(\\lambda)=(\\lambda-\\lambda_1)^{n_1}(\\lambda-\\lambda_2)^{n_2}\\cdots(\\lambda-\\lambda_s)^{n_s}且 $n_1+n_2+\\cdots+n_s=n$，称 $n_i$ 为特征值 $\\lambda_i$ 的代数重数，其反映了特征向量重复的次数 关于特征值 $\\lambda_i$ 的代数重数和几何重数有如下定理：设 $\\lambda_1,\\lambda_2,\\cdots,\\lambda_s$ 是 $T$ 的所有不同的特征值，则对任一 $\\lambda_i$ 都有 \\text{dim} V_{\\lambda_i}\\leq n_i即任何特征值的几何重数不大于其代数重数 【线性变换对角化】在有了特征值与特征向量、几何重数与代数重数的概念后，继续讨论线性变换 $T:V\\rightarrow V$ 的矩阵表示的简化问题，由于最简单的矩阵表示是对角矩阵，那么在什么条件下 $T:V\\rightarrow V$ 的矩阵表示为对角矩阵？ 给出线性变换可对角化的定义：若存在 $V$ 的基，使 $T:V\\rightarrow V$ 在 $B$ 下的矩阵是对角阵，则称线性变换 $T:V\\rightarrow V$ 是可对角化的 线性变换 $T:V\\rightarrow V$ 是可对角化的充要条件是下列等价条件之一成立： $T$ 有 $n$ 个线性无关的特征向量 $V^n$ 可直和分解为所有特征值 $\\lambda_i$ 对应的特征子空间，即 $V_{\\lambda_1}\\oplus V_{\\lambda_2}\\oplus\\cdots\\oplus V_{\\lambda_s}=V^n$ 任一特征值的几何重数等于代数重数，即 $\\text{dim}V_{\\lambda_i}=n_i$ 也就是说，当线性变换 $T:V\\rightarrow V$ 满足上述的条件之一时，其矩阵表示为对角矩阵","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"线性空间","slug":"matrix-theory/01.线性空间","date":"2022-10-21T08:16:00.000Z","updated":"2023-02-24T07:36:28.204Z","comments":true,"path":"mathematics/matrix-theory/4d9cb2a4.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/matrix-theory/4d9cb2a4.html","excerpt":"【线性空间】数域线性空间是近代数学最重要的基本概念之一，在引入线性空间的概念前，首先给出数域的概念","text":"【线性空间】数域线性空间是近代数学最重要的基本概念之一，在引入线性空间的概念前，首先给出数域的概念 设 $F$ 是一个包含 $0,1$ 的数集，且若 $F$ 中的任两个数的和、差、积、商仍在 $F$ 中，即 $F$ 对这些运算封闭，则称 $F$ 为一个数域 线性空间设集合 $V=\\varnothing$，$F$ 是一数域，在 $V$ 上定义加法运算，即 $\\forall \\alpha,\\beta\\in V$，存在唯一的 $\\boldsymbol{\\gamma}\\in V$ 与之对应，称为 $\\alpha$ 与 $\\beta$ 的和，并记为 $\\gamma=\\alpha+\\beta$，且这种加法运算满足以下四条法则： 向量加法交换律：$\\alpha+\\beta=\\beta+\\alpha$ 向量加法结合律：$(\\alpha+\\beta)+\\gamma=\\alpha+(\\beta+\\gamma)$ 向量加法单位元：$\\exists \\mathbf{0}\\in V$，使得 $\\forall \\alpha\\in V$，有 $\\alpha+\\mathbf{0}=\\alpha$ 向量加法逆元：$\\forall \\alpha\\in V$，存在负元 $\\beta\\in V$，使得 $\\alpha+\\beta=\\mathbf{0}$，记为 $\\beta=-\\alpha$ 在集合 $V$ 和数域 $F$ 间，还定义一种数乘运算，即 $\\forall k\\in F,\\alpha\\in V$，存在唯一的 $\\eta\\in V$ 与之对应，称为 $k$ 与 $\\alpha$ 的数乘，记为 $\\eta=k\\alpha$，且这种数乘运算满足以下四条法则： 标量乘法单位元：$1\\cdot \\alpha=\\alpha$ 标量乘法与域乘法兼容性：$k(l\\alpha)=(kl)\\alpha$ 标量乘法对向量加法分配律：$(k+l)\\alpha=k\\alpha+l\\alpha$ 标量乘法对域加法分配律：$k(\\alpha+\\beta)=k\\alpha+k\\beta$ 称定义加法运算合数乘运算且满足上述八条法则的集合 $V$ 为数域 $F$ 上的线性空间，称 $V$ 中的元为向量，且当 $F$ 为实数域时，称 $V$ 为实线性空间，当 $F$ 为复数域时，称 $V$ 为复线性空间 【线性相关与线性无关】为刻画线性空间中向量的关系，引入线性表出、线性相关、线性无关的概念 设 $\\{\\alpha_1,\\cdots,\\alpha_m\\}$ 为线性空间 $V$ 中的向量组，若向量 \\boldsymbol{\\beta}=k_1\\alpha_1+\\cdots+k_m\\alpha_m则称 $\\beta$ 为 $\\alpha_1,\\cdots,\\alpha_m$ 的线性组合，亦称 $\\beta$ 可由 $\\alpha_1,\\cdots,\\alpha_m$ 线性表出 若 $k_1,\\cdots,k_m$ 不全为 $0$，使得 \\sum_{i=1}^mk_i\\alpha_i=\\mathbf{0}则称向量组 $\\{\\alpha_1,\\cdots,\\alpha_m\\}$ 线性相关 若 \\sum_{i=1}^mk_i\\alpha_i=\\mathbf{0}\\Rightarrow k_1=\\cdots=k_m=0则称向量组 $\\{\\alpha_1,\\cdots,\\alpha_m\\}$ 线性无关 由上述定义可知，若线性空间 $V$ 中的向量组向量组 $\\{\\alpha_1,\\cdots,\\alpha_m\\}$ 线性无关，且向量组 $\\{\\beta,\\alpha_1,\\cdots,\\alpha_m\\}$ 线性相关，则 $\\beta$ 可由 $\\alpha_1,\\cdots,\\alpha_m$ 唯一地线性表出 【基与坐标】为了对线性空间中的向量进行描述，给出基、坐标、维数的定义 设在数域 $F$ 上线性空间 $V$ 有 $n$ 个线性无关的向量 $\\alpha_1,\\cdots,\\alpha_n$，且 $V$ 中 且 $V$ 中任一向量 $\\alpha$ 都可由 $\\alpha_1,\\cdots,\\alpha_n$ 线性表出 \\alpha=k_1\\alpha_1+\\cdots+k_n\\alpha_n则称 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 为 $V$ 的一组基，称 $\\mathbf{k}= [k_1,\\cdots,k_n]^T$ 为 $\\alpha$ 在基 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 下的坐标 此时，称 $V$ 为 $n$ 维线性空间，记维数 $\\text{dim}V=n$，若对任意正整数 $N$，$V$ 中都存在 $N$ 个线性无关向量，则称 $V$ 是无限维线性空间 由于线性空间 $V$ 中的向量组向量组 $\\{\\alpha_1,\\cdots,\\alpha_m\\}$ 线性无关，且向量组 $\\{\\beta,\\alpha_1,\\cdots,\\alpha_m\\}$ 线性相关，则 $\\beta$ 可由 $\\alpha_1,\\cdots,\\alpha_m$ 唯一地线性表出 易知，向量 $\\alpha$ 在基 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 下的坐标是唯一的 那么，在给定基的情况下，$n$ 维线性空间 $V^{n}$ 中的向量 $\\alpha$ 与 $n$ 维欧氏空间 $\\mathbb{R}^{n}$ 中的坐标向量 $\\mathbf{k}$ 是一一对应的，从而使得对 $V^{n}$ 中的向量的研究可转换为对 $\\mathbb{R}^{n}$ 中的坐标向量 $\\mathbf{k}$ 的研究 一般将 $\\alpha=k_1\\alpha_1+\\cdots+k_n\\alpha_n$ 写为 \\boldsymbol{\\alpha} = \\begin{bmatrix} \\alpha_1 & \\cdots & \\alpha_n \\end{bmatrix} \\begin{bmatrix} k_1 \\\\ \\vdots \\\\ k_n \\end{bmatrix} = \\begin{bmatrix} \\alpha_1 & \\cdots & \\alpha_n \\end{bmatrix} \\mathbf{k}【坐标变换公式】过渡矩阵同一向量在不同基下的坐标一般是不同的，考虑两个基之间的变换关系 设 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 和 $\\{\\beta_1,\\cdots,\\beta_n\\}$ 是 $V$ 中的两组基，则有 \\beta_i=p_{1i}\\alpha_1+p_{2i}\\alpha_2+\\cdots+p_{ni}\\alpha_n = \\begin{bmatrix} \\alpha_1 & \\alpha_2 & \\cdots & \\alpha_n \\end{bmatrix} \\begin{bmatrix} p_{1i} \\\\ p_{1i} \\\\ \\vdots \\\\ p_{ni} \\end{bmatrix},\\quad i=1,2,\\cdots,n将这 $n$ 个关系式用矩阵记号来表示 \\begin{bmatrix} \\beta_1 & \\beta_2 & \\cdots & \\beta_n \\end{bmatrix}=\\begin{bmatrix} \\alpha_1 & \\alpha_2 & \\cdots & \\alpha_n \\end{bmatrix} \\begin{bmatrix} p_{11} & p_{12} & \\cdots & p_{1n} \\\\ p_{21} & p_{22} & \\cdots & p_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ p_{n1} & p_{n2} & \\cdots & p_{nn} \\\\ \\end{bmatrix}称 $n$ 阶方阵 P=\\begin{bmatrix} p_{11} & p_{12} & \\cdots & p_{1n} \\\\ p_{21} & p_{22} & \\cdots & p_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ p_{n1} & p_{n2} & \\cdots & p_{nn} \\\\ \\end{bmatrix}为基 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 到基 $\\{\\beta_1,\\cdots,\\beta_n\\}$ 的过渡矩阵（基变换矩阵），即有 \\begin{bmatrix} \\beta_1 & \\beta_2 & \\cdots & \\beta_n \\end{bmatrix}=\\begin{bmatrix} \\alpha_1 & \\alpha_2 & \\cdots & \\alpha_n \\end{bmatrix}P过渡矩阵必是可逆阵，那么上式可写为 \\begin{bmatrix} \\alpha_1 & \\alpha_2 & \\cdots & \\alpha_n \\end{bmatrix} = \\begin{bmatrix} \\beta_1 & \\beta_2 & \\cdots & \\beta_n \\end{bmatrix}P^{-1}$P^{-1}$ 即为基 $\\{\\beta_1,\\cdots,\\beta_n\\}$ 到基 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 的过渡矩阵 坐标变换公式坐标变换公式用于将一个向量 $\\xi$ 在基 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 下的坐标 $\\mathbf{x}$，转换为在基 $\\{\\beta_1,\\cdots,\\beta_n\\}$ 下的坐标 $\\mathbf{y}$ 设向量 $\\xi$ 在基 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 下的坐标为 $\\mathbf{x}$，在基 $\\{\\beta_1,\\cdots,\\beta_n\\}$ 下的坐标为 $\\mathbf{y}$，即 \\xi = \\begin{bmatrix}\\alpha_1&\\alpha_2&\\cdots&\\alpha_n\\end{bmatrix} \\mathbf{x}= \\begin{bmatrix}\\beta_1&\\beta_2&\\cdots&\\beta_n\\end{bmatrix} \\mathbf{y}由于 $\\begin{bmatrix} \\beta_1 &amp; \\beta_2 &amp; \\cdots &amp; \\beta_n\\end{bmatrix}=\\begin{bmatrix} \\alpha_1 &amp; \\alpha_2 &amp; \\cdots &amp; \\alpha_n \\end{bmatrix}P$，故 \\xi = \\begin{bmatrix}\\alpha_1&\\alpha_2&\\cdots&\\alpha_n\\end{bmatrix} \\mathbf{x}= \\begin{bmatrix}\\beta_1&\\beta_2&\\cdots&\\beta_n\\end{bmatrix} \\mathbf{y}=\\begin{bmatrix}\\alpha_1&\\alpha_2&\\cdots&\\alpha_n\\end{bmatrix} P\\mathbf{y}从而有 \\begin{bmatrix}\\alpha_1&\\alpha_2&\\cdots&\\alpha_n\\end{bmatrix} (\\mathbf{x}-P\\mathbf{y})=\\mathbf{0}由于 $\\{\\alpha_1,\\cdots,\\alpha_n\\}$ 是一组基，线性无关，故有 \\begin{align*} \\mathbf{x}&=P\\mathbf{y} \\\\ \\mathbf{y}&=P^{-1}\\mathbf{x} \\end{align*}【线性子空间】子空间在三维欧氏空间 $\\mathbb{R}^3$ 中，过原点的共面向量集，按通常的向量加法和数乘运算可以构成一个向量空间，类似地，过原点的共线向量集也可构成一向量空间，这些向量空间都可以看作是 $\\mathbb{R}^3$ 的子空间，由此，在一般 $n$ 维线性空间中，也可引进子空间的概念 设 $W$ 为线性空间 $V$ 的一非空子集，如果 $W$ 中的元满足： 加法封闭性：$\\forall \\alpha,\\beta\\in W$，有 $\\alpha+\\beta\\in W$ 数乘封闭性：$\\forall \\alpha \\in W,k\\in F$，有 $k\\alpha\\in W$ 则 $W$ 为数域 $F$ 上的线性空间，称 $W$ 为 $V$ 的子空间，记为 $W\\subset V$ 由于子空间 $W$ 中不可能有比 $V$ 更多的线性无关的向量，所以子空间 $W$ 的维数不能超过 $V$ 的维数，即 $\\text{dim} W\\leq \\text{dim}V$ 若 $W$ 为线性空间 $V^n$ 的子空间，$\\{\\alpha_1,\\cdots,\\alpha_m\\}$ 为 $W$ 的一组基，则可将其扩充为 $V^n$ 的一组基 $\\{\\alpha_1,\\cdots,\\alpha_m,\\alpha_{m+1},\\cdots,\\alpha_n\\}$，这被称为基的扩张 交与和设 $W_1,W_2$ 是线性空间 $V$ 的两个子空间，则称 \\begin{align*} W_1\\cap W_2 &\\triangleq \\{\\alpha\\in V|\\alpha\\in W_1,\\alpha \\in W_2\\} \\\\ W_1+W_2 &\\triangleq \\{\\alpha\\in V|\\alpha=\\alpha_1+\\alpha_2,\\alpha\\in W_1,\\alpha \\in W_2\\} \\end{align*}为 $W_1$ 与 $W_2$ 的交与和 若 $W_1=\\text{span}\\{ \\alpha_1,\\cdots,\\alpha_r\\}$，$W_2=\\text{span}\\{\\beta_1,\\cdots,\\beta_s\\}$，则 W_1+W_2=\\text{span}\\{\\alpha_1,\\cdots,\\alpha_r,\\beta_1,\\cdots,\\beta_s\\}对于子空间 $W_1$ 和 $W_2$，有维数公式 \\text{dim}(W_1+W_2)+\\text{dim}(W_1\\cap W_2)=\\text{dim}W_1+\\text{dim}W_2直和若 $W_1+W_2$ 中的任一向量只能唯一地分解为 $W_1$ 中的一个向量与 $W_2$ 中的一个向量之和，则称 $W_1+W_2$ 为 $W_1$ 与 $W_2$ 的直和，记为 $W_1\\oplus W_2$ $W_1+W_2=W_1\\oplus W_2$ 的充要条件是下列等价条件之一成立： $W_1\\cap W_2=\\{\\mathbf{0}\\}$ 若 $\\xi_1+\\xi_2=\\mathbf{0},\\xi_i\\in W_i,i=1,2$，则 $\\xi_1=\\xi_2=\\mathbf{0}$ $\\text{dim}(W_1+W_2)=\\text{dim}W_1+\\text{dim}W_2$ 直和的概念可类似地推广到有限多个情形： W_1\\oplus W_2\\oplus\\cdots\\oplus W_s\\triangleq\\bigoplus\\limits_{i=1}^s W_i上述公式被称为空间的直和分解，通过将问题挪若干子空间研究，最后再进行合并","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"矩阵论","slug":"mathematics/matrix-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/matrix-theory/"}],"tags":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"矩阵论","slug":"matrix-theory","permalink":"https://alex-mcavoy.github.io/tags/matrix-theory/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 不蒜子站点访问计数","slug":"17.Next7.0+不蒜子站点访问计数","date":"2022-06-03T13:59:00.000Z","updated":"2022-06-03T14:30:10.360Z","comments":true,"path":"hexo/5db06912.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/5db06912.html","excerpt":"不蒜子是一款轻量级网页计数器，可将网站访问计数直接显示在网页上 NexT 中内置了不蒜子所提供的网页计数功能，只需要在 NexT 主题的配置文件 next/_config 中启用即可 12345678910# Show Views / Visitors of the website / page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true # 启用不蒜子 total_visitors: true # 网站总访客数 total_visitors_icon: fa fa-user total_views: true # 网站总浏览数 total_views_icon: fa fa-eye post_views: true # 文章浏览数 post_views_icon: fa fa-eye","text":"不蒜子是一款轻量级网页计数器，可将网站访问计数直接显示在网页上 NexT 中内置了不蒜子所提供的网页计数功能，只需要在 NexT 主题的配置文件 next/_config 中启用即可 12345678910# Show Views / Visitors of the website / page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true # 启用不蒜子 total_visitors: true # 网站总访客数 total_visitors_icon: fa fa-user total_views: true # 网站总浏览数 total_views_icon: fa fa-eye post_views: true # 文章浏览数 post_views_icon: fa fa-eye","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 多级分类目录展开折叠","slug":"16.Next7.0+多级分类目录展开折叠","date":"2021-09-23T09:04:00.000Z","updated":"2021-09-23T09:41:06.839Z","comments":true,"path":"hexo/41b257b8.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/41b257b8.html","excerpt":"在 Next 主题的分类页面中，没有提供多级目录展开的功能，为此，特意写了一个多级分类折叠展开的 js 将 Github 仓库 中的源码下载后，放入 /themes/next/source/js 中 之后打开 /themes/next/layout/_layout.swig 文件，在 &lt;body&gt; 中的最下方添加如下代码：","text":"在 Next 主题的分类页面中，没有提供多级目录展开的功能，为此，特意写了一个多级分类折叠展开的 js 将 Github 仓库 中的源码下载后，放入 /themes/next/source/js 中 之后打开 /themes/next/layout/_layout.swig 文件，在 &lt;body&gt; 中的最下方添加如下代码： 1234567&lt;body&gt; ... &lt;!-- 多级目录 --&gt; &lt;script type=\"text/javascript\" src=\"/js/category.js\"&gt;&lt;/script&gt;&lt;/body&gt; 最后，找到博客所在的根目录下的 /source/_data/styles.styl 文件，在文件中添加如下代码 123456789//分类样式.category-all-page .category-list-item &#123; margin: 15px 10px 10px 10px; list-style: none; font-size: 20px;&#125;.category-all-page .category-list-child &#123; list-style: none;&#125; 需要注意的是，在导入该功能前，要先导入 JQuery，具体方法见：Next 7.0+ JQuery 的导入","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ TagCanvas 标签云","slug":"15.Next7.0+TagCanvas标签云","date":"2021-08-19T15:40:00.000Z","updated":"2021-08-20T11:41:19.798Z","comments":true,"path":"hexo/7be258c0.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/7be258c0.html","excerpt":"Next 7.0+ 可以对标签进行自定义设置，在此基础上，可以使用球形标签云的 tagcanvas.js 插件进行样式修改，具体修改步骤如下 1.下载插件 关于球形标签云 tagcanvas.js 插件的详细介绍：点击这里","text":"Next 7.0+ 可以对标签进行自定义设置，在此基础上，可以使用球形标签云的 tagcanvas.js 插件进行样式修改，具体修改步骤如下 1.下载插件 关于球形标签云 tagcanvas.js 插件的详细介绍：点击这里 将该插件下载后，放入 /theme/next/source/js 目录下 2.新建标签云 swig 文件 在 /theme/next/layout/_partials 目录下，建一个名为 tagcanvas.swig 的文件，并写入如下内容： 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=\"tags\" id=\"myTags\"&gt; &lt;canvas width=\"500\" height=\"500\" id=\"my3DTags\"&gt; &lt;p&gt;Anything in here will be replaced on browsers that support the canvas element&lt;/p&gt; &lt;/canvas&gt;&lt;/div&gt;&lt;div class=\"tags\" id=\"tags\"&gt; &lt;ul style=\"display: none\"&gt; &#123;&#123; tagcloud(&#123; min_font : theme.tagcloud.min, max_font : theme.tagcloud.max, amount : theme.tagcloud.amount, color : true, start_color: theme.tagcloud.start, end_color : theme.tagcloud.end&#125;) &#125;&#125; &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"/js/tagcanvas.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt; window.onload = function() &#123; try &#123; TagCanvas.Start('my3DTags','tags',&#123; textFont: 'Georgia,Optima', textColour: null, outlineColour: 'black', weight: true, reverse: true, depth: 0.8, maxSpeed: 0.05, bgRadius: 1, freezeDecel: true &#125;); &#125; catch(e) &#123; document.getElementById('myTags').style.display = 'none'; &#125; &#125;;&lt;/script&gt; 3.修改 page.swig 对 /theme/next/layout/ 中的 page.swig 文件进行修改 找到如下图所示的部分，将红框内的部分删除 删除之后，在相应位置添加如下代码 12&#123;# tagcanvas plugin 球型云标签 #&#125;&#123;% include '_partials/tagcanvas.swig' %&#125; 4.修改主题 _config.yml 打开 /theme/config.yml，找到 tagcloud 字段，根据实际需要进行修改即可： 1234567# 标签云设置页面tagcloud: min: 12 # 最小字体尺寸，以px为单位 max: 30 # 最大字体尺寸，以px为单位 start: \"#ccc\" # 开始颜色 (hex, rgba, hsla or color keywords) end: \"#111\" # 结束颜色 (hex, rgba, hsla or color keywords) amount: 200 # 标签数量，当大于200个后，请进行更改 效果图","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ FancyBox 图片缩放","slug":"14.Next7.0+FancyBox图片缩放","date":"2021-08-19T03:01:00.000Z","updated":"2022-06-03T14:46:53.331Z","comments":true,"path":"hexo/f343e158.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/f343e158.html","excerpt":"FancyBox 是基于 JQuery 开发的类 Lightbox 插件，可以将图片放大查看，同时支持对放大的图片添加阴影效果，并对于一组相关的图片添加导航操作按纽 关于 FancyBox 的更多介绍：点击这里 对于 Next 7.0+ 主题来说，当文章出现图片时，无法将图片放大查看，为此其内置了 FancyBox3，关于该插件的具体介绍见其 GitHub 仓库","text":"FancyBox 是基于 JQuery 开发的类 Lightbox 插件，可以将图片放大查看，同时支持对放大的图片添加阴影效果，并对于一组相关的图片添加导航操作按纽 关于 FancyBox 的更多介绍：点击这里 对于 Next 7.0+ 主题来说，当文章出现图片时，无法将图片放大查看，为此其内置了 FancyBox3，关于该插件的具体介绍见其 GitHub 仓库 若想开启 FancyBox 功能，具体操作步骤如下： 1.修改主题 _config.yml 文件 在 theme/next/ 文件夹下找到 Next 7.0+ 主题的 _config.yml 配置文件 之后在其中找到 fancybox 字段，将其改为 true 123# FancyBox 图片缩放# For more information: https://fancyapps.com/fancyboxfancybox: true 2.启用 fancybox CDN 在 NexT 主题下的配置文件 _config.yml 中，开启 CDN 12fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.jsfancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css 需要注意的是，FancyBox 是基于 JQuery 开发的，而 Next 7.0+ 没有直接导入 JQuery，因此在使用该插件前，要先导入 JQuery，具体方法见：Next 7.0+ JQuery 的导入","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ JQuery 的导入","slug":"13.Next7.0+JQuery的导入","date":"2021-08-18T12:54:00.000Z","updated":"2022-06-03T14:45:19.853Z","comments":true,"path":"hexo/cc697376.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/cc697376.html","excerpt":"在 Next 7.0+ 中，导入一些第三方插件时，经常会出现如下错误： 1Uncaught ReferenceError: $ is not defined` 这是因为插件使用了 JQuery，但 Next 7.0+ 并没有导入 JQuery","text":"在 Next 7.0+ 中，导入一些第三方插件时，经常会出现如下错误： 1Uncaught ReferenceError: $ is not defined` 这是因为插件使用了 JQuery，但 Next 7.0+ 并没有导入 JQuery 具体解决方法是，找到 NexT 主题下的配置文件 _config.yml，启用相应的 CDN 1jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 添加 Gittalk 评论","slug":"12.Next7.0+添加Gittalk评论","date":"2021-08-18T12:13:00.000Z","updated":"2021-08-23T14:19:47.613Z","comments":true,"path":"hexo/e6c59c7d.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/e6c59c7d.html","excerpt":"Next 7.0+ 主体整合了 Gittalk 评论，具体开启方法如下 1.创建评论存储仓库 在 GitHub上创建一个 public 仓库，用来存储评论","text":"Next 7.0+ 主体整合了 Gittalk 评论，具体开启方法如下 1.创建评论存储仓库 在 GitHub上创建一个 public 仓库，用来存储评论 2.创建 OAuth Application 创建 GitHub 提供的 OAuth Application 其中，Homepage URL 为第一步中新建的存储评论的仓库的 URL，Authorization callback URL 为使用 Gittalk 功能的主站域名，即博客的域名 创建完成后可以在 Settings/Developer settings 中查看创建好的 ClientID 和 Client Secret 之后，通过 generate a new client 按钮创建一个 Client Secret，创建完成后，将生成的 Client Secret 复制好，之后该 Client Secret 将不可见 3.修改 Next 主题的 _config.yml 文件 在 Next 主题的 _config.yml 文件中找到 gittalk 的选项，并进行填写，参考示例如下： 1234567891011121314# Gitalk# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalkgitalk: enable: true github_id: Alex-McAvoy # GitHub 仓库所有者 repo: Gitalk-Comment # 存储评论的 GitHub 仓库名称 client_id: # Client ID client_secret: # Client Secret admin_user: Alex-McAvoy # GitHub 的所有者和合作者，只有这些人可以初始化仓库中的issue distraction_free_mode: true # 类似 Facebook 的无干扰模式 # Gitalk 的显示语言取决于用户的浏览器或系统环境 # 如果您希望访问您网站的每个人都看到统一的语言，您可以设置强制语言值 # 可取的值: en | es-ES | fr | ru | zh-CN | zh-TW language: 4.修改 page.swig 在 Next 主题的分类与标签页上，会默认出现 Gittalk 的评论框 找到根目录下的 source/categories 和 source/tags，分别打开其中的 index.md 文件 打开后，在头信息中添加如下一行代码 1comments: false 效果如下图 5.对文章初始化 当发布一篇文章并同步到博客后，对该文章进行评论初始化，即以仓库所有者的 ID 登录评论系统即可","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 文章自动摘录","slug":"11.Next7.0+文章自动摘录","date":"2021-08-16T14:44:00.000Z","updated":"2021-08-20T11:41:47.779Z","comments":true,"path":"hexo/d98845d1.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/d98845d1.html","excerpt":"自 Next 7.6 中，已经移除自动将主页中的文章摘录的功能，即无法使用 auto_excerpt 这一特性 官方推荐使用 hexo-excerpt 插件来完成，该插件的 github 仓库 以及安装方法： 1npm install hexo-excerpt --save","text":"自 Next 7.6 中，已经移除自动将主页中的文章摘录的功能，即无法使用 auto_excerpt 这一特性 官方推荐使用 hexo-excerpt 插件来完成，该插件的 github 仓库 以及安装方法： 1npm install hexo-excerpt --save 之后在 Hexo 的主配置文件 _config.yml 中加入以下代码： 12345excerpt: depth: 3 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true 其中，各参数含义如下： depth：设置摘录的深度，默认为 10 excerpt_excludes 与 more_excludes：通过 css 选择器来从生成的摘录中排除某些标签 hideWholePostExcerpts：是否开启摘录功能","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Miss","slug":"daily/11.Miss","date":"2021-05-26T19:46:00.000Z","updated":"2021-10-07T10:54:10.897Z","comments":true,"path":"essay/daily/c222a5e0.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/c222a5e0.html","excerpt":"凌晨三点，有人相爱，有人夜里独自开车看海，有人酒吧买醉彻夜不归，有人夜半惊醒又久久无眠 曾经说过，不会再为任何人动心，自己过一辈子就好，可是在疫情肆虐与你相遇的那段日子，这句话暂且不作数了 你曾让我给你承诺，但我却一直抗拒一切形式的海誓山盟，最终的结局却是没有给出承诺的那个人后悔了","text":"凌晨三点，有人相爱，有人夜里独自开车看海，有人酒吧买醉彻夜不归，有人夜半惊醒又久久无眠 曾经说过，不会再为任何人动心，自己过一辈子就好，可是在疫情肆虐与你相遇的那段日子，这句话暂且不作数了 你曾让我给你承诺，但我却一直抗拒一切形式的海誓山盟，最终的结局却是没有给出承诺的那个人后悔了 在那天过后，大概彼此约定的都不作数了吧，那么，往日的那些悸动又有什么意义呢？ 生活终究会归于平淡与忙碌，就好像猛然扎进水里，等到浮出水面，只有远方的天际线，连水面的波纹都不曾留存一秒 人是会变的，但我无法接受的是，从喜欢到不在意的过程太漫长了，漫长到让我觉得我似乎根本离不开你，如果可以，真希望从过去到未来的每一秒都可以和你在一起，但谁又能让时光倒流呢 真正失去的你时候到底是哪一天呢？好像并不是这个春季，也不是在四月，更不是那让我孤独的无以复加的一天 大概是去年你飞去新加坡留学的那天，是遇到一件有趣的事掏出手机想跟你分享的时候，是耳机里毫无预兆的突然响起的《十年》 所有的这一切，都在无时无刻的提醒我，我已经失去你了 就算以后遇到再多的人又怎么样呢，我已经没有运气再遇到你一次了 不瞒你说，有时候，我也会怀疑自己是否是真心爱你，或许我只是爱上了自己的付出与牺牲，只是被青春岁月里的这把虚火烧昏了头脑 曾经那么了解你，爱你所爱，怨你所怨，如今我想承认我是爱你的，可是，你却不再愿听了 我用文字记录你，就像那天夜里独自看的烟火","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"Collapse","slug":"ego/08.Collapse","date":"2021-05-21T19:47:00.000Z","updated":"2021-09-22T08:08:14.633Z","comments":true,"path":"essay/ego/729b34d2.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/ego/729b34d2.html","excerpt":"在那些孤枕难眠的夜晚，会在走廊中坐到很晚。 有时会跟自我对话，谈论些什么，关于梦，关于死亡，关于艺术，关于星辰与大海。 有时也只是放空一切，什么都不想。","text":"在那些孤枕难眠的夜晚，会在走廊中坐到很晚。 有时会跟自我对话，谈论些什么，关于梦，关于死亡，关于艺术，关于星辰与大海。 有时也只是放空一切，什么都不想。 只有在这个时间段，才是独属我本人的，我的观念，我的命运。 在无法入睡的时刻憎恨夜晚，醒来后又憎恨白天，噩梦也变得是一种宣泄，能以让我平和地迎接新的一天。 总是说以后的事情以后再说，大概已经没有未来了吧。 就在某一天醒来的那一刻，我发觉，这几年来，一直在榨取那些我并不拥有的资源，通过抵押自己的身体和精神，与之相比，所回馈的又算的了什么呢。 这一年来，酒后总是想起，但这一切是在什么时候开始的呢？太早的事情早已模糊了，但那是个蛮不错的时刻，斜射进室内的阳光静谧舒适，回顾这一生，还没有过几次这样仿佛被阳光照亮过。 后来，就慢慢的崩塌了，直到现在。 本来就不该有所谓的期待，会变得过于依赖未来。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Ego","slug":"essay/ego","permalink":"https://alex-mcavoy.github.io/categories/essay/ego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Ego","slug":"ego","permalink":"https://alex-mcavoy.github.io/tags/ego/"}],"author":"Alex_McAvoy"},{"title":"漫长的告别","slug":"daily/10.漫长的告别","date":"2021-04-23T09:58:00.000Z","updated":"2021-09-22T08:07:26.788Z","comments":true,"path":"essay/daily/a4ae1ff0.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/a4ae1ff0.html","excerpt":"大概是前年，或许更早，那是在与你的一切还未开始的时间。 在雨后的黄昏，落日的余晖透过鬃积雨云，将晚霞染成了红紫色，红紫色的光倾斜着穿过屋檐下的窗，伴着暮春最后的凉风，将未开灯的酒吧分割成两个世界。 酒吧里只有在窗边的自己与吧台后抽烟的老板，在那个时刻，只有看着晚霞的沉默，那份景色是如此与酒吧名相彰得益，浮生若梦。","text":"大概是前年，或许更早，那是在与你的一切还未开始的时间。 在雨后的黄昏，落日的余晖透过鬃积雨云，将晚霞染成了红紫色，红紫色的光倾斜着穿过屋檐下的窗，伴着暮春最后的凉风，将未开灯的酒吧分割成两个世界。 酒吧里只有在窗边的自己与吧台后抽烟的老板，在那个时刻，只有看着晚霞的沉默，那份景色是如此与酒吧名相彰得益，浮生若梦。 时至今日，我已经忘记了当初为什么会在我最讨厌的黄昏时分前往浮生若梦，或许是又跟家里闹矛盾了，或许是想念逝去的亲人，或许是又想死了。 我只记得，老板拿着一杯刚调好的螺丝起子和一根烟放在我的面前，说了一句，你的侧身让我想起了《漫长的告别》里的马洛，这杯是免费的。 当晚回去后，伴着醉意找了电子书来看，或许是真的醉了，除了马洛最后对特里的那段话竟然记不清任何情节。 后来逛书店时买了纸质版，就一直放在书架上，再也没动过。 在这个慌乱的下午，我找出了这本书，读的过程中，我接了两通电话，替某个朋友圈屏蔽我的人填了三张表，发了一条朋友圈，帮人改了七个bug，抽了几根烟，喝了五杯茶，思考了一下宇宙，匆匆读完。 这是一本我认为最不像是侦探小说的侦探小说，它解构了许多，关于正义，关于制度，关于腐败，关于尊严，关于朋友，关于人性，但更多的，只是讲了一个叫 Marlowe 的人关于告别的故事。 只是为了一个萍水相逢的优雅酒鬼，就在一个铁石心肠的世界里，豁出去了自己的性命，他完成了与 Terry 的告别。 即使最后结局戏剧性的反转了，他也未曾后悔。 “You bought a lot of me, Terry. For a smile and a nod and a wave of the hand and a few quiet drinks in a quiet bar here and there. It was nice while it lasted. So long, amigo. I won’t say goodbye. I said it to you when it meant something. I said it when it was sad and lonely and final.” 可是，我又要如何去完成与你的告别呢？ 我不知道。 多少人就像 Marlowe 和 Terry，曾经那么要好，可历经世事，你不再是原来的你，我却还是原来的我，再难回到过去，甚至一生都不会再见。 或许十年后，如果我还活着的话，你或许会在街角与我擦肩而过，却怎么也想不起究竟在哪里见过我，假使你还能注意到我的话，就请去酒吧，点一杯螺丝起子吧。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"Windows Terminal 的使用","slug":"05.Windows_Terminal的使用","date":"2021-03-16T09:20:00.000Z","updated":"2021-10-08T13:33:35.685Z","comments":true,"path":"others/dcb54b04.html","link":"","permalink":"https://alex-mcavoy.github.io/others/dcb54b04.html","excerpt":"【安装】Windows Terminal 是一个面向命令行工具、PowerShell 、适用于 Linux 的 Windows 子系统（WSL）用户的新式终端应用程序 主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎等，还可用它来自定义文本、颜色、背景和快捷方式","text":"【安装】Windows Terminal 是一个面向命令行工具、PowerShell 、适用于 Linux 的 Windows 子系统（WSL）用户的新式终端应用程序 主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎等，还可用它来自定义文本、颜色、背景和快捷方式 在微软的应用商店里直接搜索 Windows Terminal 然后安装即可 【默认终端配置】安装好后，启动 Windows Terminal 将默认在 Windows PowerShell 窗格下 如需设为命令提示符窗格，点击标题栏的三角，进入设置，修改 settings.json 文件 在 settings.json 下，defaultProfile 用于通过指定 guid 来指定打开 Terminal 时的默认窗口 list 下的 guid 用于标识打开的窗口 id 如想默认打开命令提示符，将 defaultProfile 的值设为命令提示符的 guid 的值即可 同理，如果安装了 WSL，可以将默认终端设置为子系统的 guid 关于 WSL 的安装：点击这里 【Git 配置】Windows Terminal 除了可以配置上述的命令提示符、PowerShell、WSL 窗口外，还提供了自定义配置功能，只要更改配置文件即可实现自定义配置，这为 Git 的使用提供了极大的便利 在 settings.json 下的 list 添加如下代码，配置 git 的目录、图标、guid 即可 其中，guid 是全局唯一标识符，可以使用在线 Guid 随机生成的序列器来生成：点击这里 1234567891011121314151617181920&#123; // Git Bash \"closeOnExit\": true, \"colorScheme\": \"Campbell\", \"commandline\": \"I:/Git/bin/bash.exe\", //git的目录 \"cursorColor\": \"#FFFFFF\", \"cursorShape\": \"bar\", \"fontFace\": \"Consolas\", \"fontSize\": 14, \"guid\":\"&#123;cd411374-e41f-49dd-8ace-4f2b42b6cffa&#125;\", //guid \"historySize\": 9001, \"icon\":\"I:/Git/mingw64/share/git/git-for-windows.ico\", //git的图标 \"name\":\"Git Bash\", \"padding\": \"0,0,0,0\", \"snapOnInput\": true, \"startingDirectory\": \"%USERPROFILE%\", \"useAcrylic\": true, \"acrylicOpacity\":0.6, \"background\":\"#000000\"&#125;, 【半透明磨砂效果设置】在 profiles 下的 defaults 中，加入如下两行代码 12\"acrylicOpacity\": 0.5, \"useAcrylic\": true 即可达到如下效果","categories":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/categories/others/"}],"tags":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/tags/others/"}],"author":"Alex_McAvoy"},{"title":"Win10 子系统(WSL)的安装","slug":"04.Win10子系统(WSL)的安装","date":"2021-03-16T08:44:00.000Z","updated":"2021-10-08T13:32:59.075Z","comments":true,"path":"others/3aae44fd.html","link":"","permalink":"https://alex-mcavoy.github.io/others/3aae44fd.html","excerpt":"参考文档： Windows Subsystem for Linux Installation Guide for Windows 10 WSL2 请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化 Windows10 子系统(WSL)的配置和使用 【安装步骤】","text":"参考文档： Windows Subsystem for Linux Installation Guide for Windows 10 WSL2 请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化 Windows10 子系统(WSL)的配置和使用 【安装步骤】1.以管理员身份运行 PowerShell 2.启用子系统功能 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 3.启用虚拟机功能 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 3.下载 Linux 内核更新包并安装 下载链接：WSL2 Linux kernel update package for x64 machines 4.启用 wsl2 功能 1wsl --set-default-version 2 如果出现报错信息 请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化问题，那么需要手动安装 Hyper-V 虚拟机 具体安装方法：点击这里 5.下载合适的 Linux 系统 在微软商店搜索 WSL，下载合适的版本 6.创建用户 安装完成后，运行等待几分钟后会要求创建用户，输入用户名、密码即可 需要注意的是，该处创建的并不是 root 用户 7.root 用户 因为 Ubuntu 默认的 root 密码是随机的，即每次开机都会产生一个新的密码，在终端输入 sudo passwd，然后输入当前用户密码 回车后会提示输入新的密码，确认后即修改完成，使用 su root 输入密码，即可登录到 root 用户 【更换源】Ubuntu 的软件源配置文件是 /etc/apt/sources.list，首先执行以下命令，将系统自带的该文件做个备份 1cp /etc/apt/sources.list /etc/apt/sources_back.list 然后使用 vim，打开 sources.list，添加清华源，注意要添加版本一致的源 1vim /etc/apt/sources.list 清华源镜像查询：点击这里 添加完成后，执行以下命令进行更新 1apt-get update &amp;&amp; apt-get upgrade 【迁移到非系统盘】说明：在命令提示符界面中，输入 wsl --terminate 可以查看 wsl 所有相关命令 1.终止正在运行的分发 1wsl --shutdown 2.导出子系统 利用 wsl --export &lt;分发版&gt; &lt;文件名&gt; 导出子系统 1wsl --export Ubuntu-18.04 I:/WSL/Ubuntu-18.04.tar 导出完成后，可以看到文件结构如下 3.注销原分发 利用 wsl --unregister &lt;分发版&gt; 来注销分发，以免出现重复 1wsl --unregister Ubuntu-18.04 此时，再利用 wsl --list 命令查询，可以发现当前没有分发版本 4.导入子系统 利用 wsl --import &lt;分发版&gt; &lt;安装位置&gt; &lt;文件名&gt; 导入之前导出的分发 1wsl --import Ubuntu-18.04 I:/WSL/Ubuntu-18.04 I:/WSL/Ubuntu-18.04.tar 此时，可以看到新导入的分发 5.设置非 root 用户启动 重新导入后，不能像之前那样在应用商店中更新，同时默认以 root 账户启动，这显然存在安全隐患 在命令提示符窗口中，输入 regedit 打开注册表，找到当前用户，其中 S-1-5-18 代表 SYSTEM，S-1-5-19 代表 LocalService，S-1-5-20 代表 NetworkServer，S-1-5-21-...代表当前用户 接下来在当前用户下的 \\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss 中找到要更改默认账户的分发版 在 WSL 中利用 cat /etc/passwd 命令获取 Uid，这里的值是 1000，换算成十六进制是 3E8 对注册表中的 DefaultUid 进行编辑，将其值设为 3E8 即可 【Hyper-V 虚拟机的安装】新建文本文件，复制以下内容，另存为 Hyper-V.cmd 123456789pushd \"%~dp0\"dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 之后右键，以管理员身份运行，配置完成后输入 Y 重启计算机即可 重启后重新启动 WSL2 功能即可 1wsl --set-default-version 2","categories":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/categories/others/"}],"tags":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/tags/others/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 实现文章加密","slug":"10.Next7.0+实现文章加密","date":"2021-02-16T13:05:00.000Z","updated":"2021-08-20T11:41:56.082Z","comments":true,"path":"hexo/483939e0.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/483939e0.html","excerpt":"在 Next 7.0+ 中，若想对文章进行加密，可采用 hexo-blog-encrypt 插件，关于该插件的具体介绍详见其 GitHub 仓库，该插件的安装方法如下 1npm install hexo-bolg-encrypt 在安装完成后，需要在 Hexo 根目录下的 _config.yml 添加以下内容：","text":"在 Next 7.0+ 中，若想对文章进行加密，可采用 hexo-blog-encrypt 插件，关于该插件的具体介绍详见其 GitHub 仓库，该插件的安装方法如下 1npm install hexo-bolg-encrypt 在安装完成后，需要在 Hexo 根目录下的 _config.yml 添加以下内容： 12345678# 文章加密 hexo-blog-encrypt# See: https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.mdencrypt: enable: true theme: Up # 主题 abstract: '内容已加密，请输入密码后阅读' message: '内容已加密，请输入密码后阅读' wrong_pass_message: '密码错误，请重试' 保存后，在文章编辑界面设置新的文章参数 password，之后正常编辑文章即可 当想要打开加密的文章页面后，会显示加密对话框，密码输入成功后才可阅读","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 访客地图","slug":"09.Next7.0+访客地图","date":"2021-02-15T17:42:00.000Z","updated":"2021-08-23T14:21:51.486Z","comments":true,"path":"hexo/f7dadf6e.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/f7dadf6e.html","excerpt":"访客地图采取的是 RevolverMaps，其是一个博客的实时访问者统计小部件 在 Next 7.0+ 版本中，若想使用该统计小部件，在其官网选择好所需的样式并生成好 html 代码后 找到 themes/next/layout/_partials/sidebar/site-overview.swig 文件","text":"访客地图采取的是 RevolverMaps，其是一个博客的实时访问者统计小部件 在 Next 7.0+ 版本中，若想使用该统计小部件，在其官网选择好所需的样式并生成好 html 代码后 找到 themes/next/layout/_partials/sidebar/site-overview.swig 文件 在其中选择合适的位置，将 html 代码复制上，保存后重新生成页面，即可在侧边栏看到访客地图 效果图","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Times","slug":"superego/04.Times","date":"2021-02-09T18:29:00.000Z","updated":"2021-09-22T08:09:03.368Z","comments":true,"path":"essay/superego/1dd7ee8c.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/superego/1dd7ee8c.html","excerpt":"D：”Alex，我又梦到了那个最坏的结局。” Alex：”D 要知道 并不是每一个故事都会有好的结局 总有一些会令人难过” Alex：”人是极度依赖时间的动物 一件事对某一个人来说是否重要 关键是看他在这件事上花费了多少时间”","text":"D：”Alex，我又梦到了那个最坏的结局。” Alex：”D 要知道 并不是每一个故事都会有好的结局 总有一些会令人难过” Alex：”人是极度依赖时间的动物 一件事对某一个人来说是否重要 关键是看他在这件事上花费了多少时间” D：”领会从不是飘游无据的，总是现身的领会，所以我说这是最坏的结局。” Alex：”别再留遗憾了 D 要懂得爱你自己”","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Superego","slug":"essay/superego","permalink":"https://alex-mcavoy.github.io/categories/essay/superego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Superego","slug":"superego","permalink":"https://alex-mcavoy.github.io/tags/superego/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 字数统计与阅读时长","slug":"08.Next7.0+字数统计与阅读时长","date":"2020-09-27T16:19:00.000Z","updated":"2021-08-20T11:42:18.310Z","comments":true,"path":"hexo/c7b3748f.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/c7b3748f.html","excerpt":"Next 7.0+ 内置了 hexo-symbols-count-time 插件，该插件集成了文章字数统计、阅读时长统计等功能，关于其具体介绍见其 GitHub 仓库，该插件的具体启用步骤如下 1.安装插件 运行如下命令：","text":"Next 7.0+ 内置了 hexo-symbols-count-time 插件，该插件集成了文章字数统计、阅读时长统计等功能，关于其具体介绍见其 GitHub 仓库，该插件的具体启用步骤如下 1.安装插件 运行如下命令： 1npm install hexo-symbols-count-time 2.修改主题 _config.yml 打开 theme/next/ 文件夹下的 _config.yml，找到 symbols_count_time 字段，根据需要进行设置，其下各字段含义如下： 123456# 发布字数显示设置 # 依赖插件: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true # 是否另起一行（true的话不和发表时间等同一行） item_text_post: true # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长） item_text_total: false # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长） 3.修改根目录 _config.yml 打开 Hexo 根目录的 _config.yml，添加如下字段，并根据需要进行修改 1234567891011# 文章字数统计hexo-symbols-count-time# See：https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: symbols: true # 文章字数统计 time: true # 文章阅读时长 total_symbols: false # 站点总字数统计 total_time: false # 站点总阅读时长 exclude_codeblock: false # 排除代码字数统计 awl: 4 # 平均词长度 wpm: 275 # 每分钟阅读词数 suffix: \"mins.\" # 如果阅读时间少于 60 分钟，则添加后缀作为字符串参数 修改完成后，启动服务即可，效果如下：","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"网络四到七层测试","slug":"network-testing/30.网络四到七层测试","date":"2020-09-04T07:10:00.000Z","updated":"2021-08-23T13:03:07.376Z","comments":true,"path":"notes/network-testing/b94d30ad.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/b94d30ad.html","excerpt":"【并发 TCP 连接容量测试】并发 TCP 连接容量测试是为了检验被测设备或被测系统内存性能及其连接状态表能同时容纳的最大连接数目 在测试前，应进行如下配置：","text":"【并发 TCP 连接容量测试】并发 TCP 连接容量测试是为了检验被测设备或被测系统内存性能及其连接状态表能同时容纳的最大连接数目 在测试前，应进行如下配置： 应用层采用 HTTP1.1 或以上版本，因为其具有默认维持 TCP 连接的特性 设置一个初始 TCP 尝试连接速率，即每秒尝试发出的 TCP 连接请求数目，可参考产品手册说明或同类产品的最大速率，该值设置为等于或小于被测设备能容纳的最大连接请求速率 定义客户端请求对象的字节大小，该对象是服务器响应客户端 GET 请求时返回的传输对象，建议参数设置为 512B、1024B 等较小值，以免大尺寸的传输对象占据太多带宽，影响并发连接容量的测试结果 测试使用二分搜索法来确定最大并发 TCP 连接容量，测试过程如下： 根据设定的初始尝试连接速率，由客户端发起连接请求，被测设备将每一个连接状态记录在连接状态表中 如果被测设备可以容纳当前连接速率下的连接请求数目，则客户端提高尝试连接速率，增加并发连接请求数目 如果被测设备不能支持当前连接速率下的连接请求数目，则客户端降低尝试连接速率，减少并发连接请求数目 在每一轮测试结束后，测试仪表都需要发起一系列 TCP 的 RST 报文关闭 TCP 连接，由于绝大多数被测设备的连接表项在 TCP 连接关闭后仍会保存一段老化时间后才被删除，因此在发起下一轮测试之前，测试仪表需要等待一个连接记录生存周期，以确保连接表已清空，也可以通过重启设备或手动清空方式删除这些记录 【最大 TCP 连接建立速率测试】最大 TCP 连接建立速率测试是为了测试被测设备对连接的处理速度 在测试前，进行如下配置： 定义一个初始要建立的 TCP 连接数目，其大小应低于被测设备所能承受的最大并发连接数 请求对象的字节大小定义和并发容量测试中一样 测试使用二分搜索法来确立最大 TCP 连接建立速率，测试过程如下： 由虚拟客户端以初始 TCP 连接数目发起连接请求 如果被测设备能成功建立所有的连接，则增加连接请求数目 如果被测设备不能成功建立所有的连接，则减少连接请求数目 直到得到一个最大 TCP 连接建立速率，该速率下发送的所有连接都能成功建立 若最终期望速率与实际速率基本吻合，说明被测设备有足够的性能处理连接请求 【最大 TCP 连接拆除速率测试】最大 TCP 连接拆除速率测试是为了测试被测设备释放资源的速度 在测试前，进行如下配置： 欲拆除的 TCP 连接数目 规定 TCP 连接的关闭模式：3 次握手关闭方式或 4 次握手关闭方式 规定 TCP 连接的关闭发起方：客户端或服务器发起 测试过程同样使用二分搜索法，对配置参数中设定的 TCP 连接数目，迭代使用不同的速率进行连接拆除 【HTTP 传输速率测试】HTTP 传输速率测试用于测试被测设备处理应用层流量的性能，同时也检验传输层及以下的协议的性能是否足够支撑上层的应用 应用层平均传输速率的计算公式为： v=\\frac{n* size* 8}{time}其中，$n$ 为传输对象的数目，$size$ 为传输对象的大小，单位为字节，$time$ 为完成所有事务所持续的时间，单位为秒 测试前，需要模拟多个虚拟客户端和服务器，同时进行参数配置： 传输层需要设置尝试连接的数目、连接的关闭模式、连接关闭方向 设定每个连接请求中包含的 GET 请求对象个数 $n$、每次请求的对象大小 $size$ 测试运行中，根据所配置的虚拟客户端数目，连接总数将被平均分配给每个客户端，例如：连接总数为 100，参与测试的虚拟客户端数目为 4，则每个客户端将发起 25 个连接请求，此外，如果虚拟客户端在一个连接中发起多个 GET 请求，那么所请求的对象的大小必须是相同的 测试采用二分搜索法，测试过程如下： 在不同的测试轮次中改变 GET 请求的对象大小 如果客户端都能成功地获得服务器响应，则增加 GET 请求对象的大小 如果有客户的请求无法获得响应，则降低 GET 请求的对象的大小 进行多次迭代，每次利用公式计算传输速率 【最大 HTTP 事务处理速率测试】最大 HTTP 事务处理速率测试是为了检验 DUT/SUT 能支持的用户存取 HTTP 对象的最大速率，其侧重点在于在于检验服务器的CPU运算速度、内存资源利用率等性能指标 对用户而言，如果服务器端的运算性能和资源不足，尽管网络带宽足够，用户仍然无法体验快速流畅的网络应用 在进行测试前，需要进行参数设置，其与 HTTP 传输速率测试相同 测试采用二分搜索法，测试过程如下： 保持传输对象大小不变 如果某次事务都处理成功，则提高事务的数目 反之，则降低事务的数目 在所有事务处理都成功的前提下，根据事务的时间开销和事务数目，计算获得最大 HTTP 事务处理速率","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络四到七层测试相关文档","slug":"network-testing/29.网络四到七层测试相关文档","date":"2020-09-01T07:37:00.000Z","updated":"2021-08-23T13:03:17.854Z","comments":true,"path":"notes/network-testing/a0e1f88b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/a0e1f88b.html","excerpt":"【概述】四到七层测试中，相关的 RFC 文档包括：RFC1242、RFC2544、RFC2647、RFC3511 等 RFC1242 与 RFC2544 具有一般性的指导意义，涵盖了 OSI 全部七层的测试","text":"【概述】四到七层测试中，相关的 RFC 文档包括：RFC1242、RFC2544、RFC2647、RFC3511 等 RFC1242 与 RFC2544 具有一般性的指导意义，涵盖了 OSI 全部七层的测试 RFC2647 为防火墙性能测试定义了基本概念和术语，RFC3511 提供了与网络四到七层性能测试有关的方法、测试结果报告的格式 【RFC2647】RFC2647 为防火墙性能测试定义了基本概念和术语，由于防火墙性能测试中基于连接的部分与网络四到七层测试直接相关，因此，其中的测试内容和测试指标也适用于其他四到七层设备或系统的测试 连接连接是指两个主机之间或者主机与 DUT/SUT 之间同意使用某种协议交换数据的状态 在防火墙性能测试中，使用无连接协议 UDP 所进行的数据传输，也可以算在连接数之内 例如：一个主机穿过防火墙发送一个 UDP 包给另外一个主机，如果目标主机正在监听正确的 UDP 端口，那么它就收到这个 UDP 包，因而这次传输也算作一个连接 并发连接数一个主机或设备所能处理的并发连接数越大，就说明它的网络处理或转发性能越好 需要注意的是，连接本身只是一个描述状态的概念，不一定有实际的数据传输，而并发连接则是指所有的连接存在数据传输 因此，如果一个连接没有数据传输，那么这个连接将不会被计入并发连接数中 连接建立时间连接建立时间是指在两个主机或者主机和 DUT/SUT 之间，建立一个特定协议的连接所付出的时间开销 在数值上来说，连接建立时间是从收到连接建立帧的第一个 bit 开始，到最后一个帧的最后一个 bit 为止的这段时间 需要注意的是，这个定义只适用于基于连接协议 TCP，对无连接协议 UDP，连接建立时间的概念没有任何意义 连接拆除时间连接拆除是指拆除两个传输数据的主机或者主机与 DUT/SUT 之间的连接，连接拆除时间是指结束一个连接所花费的时间开销，这个时间是从收到连接拆除帧的第一个 bit 开始，到最后一个 bit 结束的时间间隔 基于连接的协议都有它自己的连接拆除机制，例如：TCP 协议的四次握手 这个定义只适用于基于连接的协议，对于无连接的协议，没有任何意义 【RFC3511】RFC3511 提供了有关网络四到七层性能测试的方法学，除了定义相关的测试方法，文档中还描述了测试结果报告的格式 虚拟客户/服务器在网络四到七层测试中，通常需要使用多个模拟用户端发起测试请求，以生成测试流量，而另一端则由模拟服务器接收并响应这些测试流量，这些模拟的客户与主机在测试方法学中被称为虚拟客户/服务器 在一些特定应用的测试中，会产生一个或多个客户对应多个服务器的场景，此时要求每个虚拟客户端采用循环方式与服务器进行初始化连接 例如：如果测试中包含 6 个虚拟客户对应 3 个虚拟服务器，连接采用如下方式进行初始化 测试拓扑网络设备模式利用仪表模拟客户端和服务端来检验网络通信设备对网络四到七层数据流量处理和转发的性能，有三种拓扑结构：服务器系统模式、网络设备模式、网络系统模式 服务器系统模式服务器系统模式是用于测试作为网络应用提供者的服务器的相关性能，利用仪表模拟客户端生成客户端数据流量来检验服务器系统的事务处理性能 被测设备是提供应用服务的真实的服务器，测试仪表模拟客户端生成应用数据流量对服务器进行性能测试或者压力测试 网络设备模式网络设备模式是用于测试网络设备的性能 被测设备是提供通信服务的网络设备，测试仪表模拟客户端产生的完全真实的第四到七层协议数据流量经过被测设备转发到模拟服务器 网络系统模式网络系统模式是用于测试网络应用系统的性能状况，分析是否存在性能瓶颈 被测系统是由网络设备、应用层服务器等多种设备构成的具体网络应用系统","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络四到七层性能指标","slug":"network-testing/28.网络四到七层性能指标","date":"2020-09-01T06:27:00.000Z","updated":"2021-08-23T13:03:27.851Z","comments":true,"path":"notes/network-testing/fc76777e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/fc76777e.html","excerpt":"【概述】在 OSI 模型中，四到七层是传输层、会话层、表示层、应用层 在网络体系结构和网络基础设施日趋复杂的今天，网络服务系统由早先的以超级节点为中心的单一系统向由多个对等节点或服务器群组成的复杂系统转变，对网络应用的部署带来了影响","text":"【概述】在 OSI 模型中，四到七层是传输层、会话层、表示层、应用层 在网络体系结构和网络基础设施日趋复杂的今天，网络服务系统由早先的以超级节点为中心的单一系统向由多个对等节点或服务器群组成的复杂系统转变，对网络应用的部署带来了影响 应用部署越来越丰富，网络多种业务如语音、视频、数据等的融合，在创造了新的网络服务的同时，也使得网络服务的复杂程度越来越高 这使得对网络的第四到七层要求越来越高，对于网络能够提供用户的最终服务体验和服务质量而言，不仅取决于第二层及第三层基础平台的通信质量，也取决于上层应用的部署是否合理以及对用户行为的预测是否准确 【TCP 指标】最大 TCP 连接建立速率最大 TCP 连接建立速率是指被测设备或被测系统能够成功处理请求连接的前提下，在单位时间内所能承受的最大 TCP 连接建立数目，单位为连接数/秒 它主要反映了被测设备的 CPU 使用情况以及对连接的处理速度，这一指标也称为最大 TCP 新建速率 对应用系统而言，在突发用户流量的情况下，如果系统没有足够的连接建立速率，就会导致无法及时建立新的连接，造成用户请求得不到及时响应，或者已登录用户掉线的现象 最大 TCP 连接拆除速率最大 TCP 连接拆除速率是指单位时间内关闭的有效 TCP 连接数目的最大值，它指示了被测设备释放资源的速度 在网络服务中，如果资源释放不够快，会导致后续的访问或请求在建立连接时没有足够的系统资源，从而影响正常服务的获得 在网络服务器中，这种情况就表现为不能及时处理持续的访问请求，出现用户等待超时现象 并发 TCP 连接容量并发连接是指多个主机或用户同时连接到一个主机或设备进行数据传输 并发 TCP 连接容量是指被测设备能够同时成功处理的最大 TCP 连接数目，被测设备内用以存放并发连接信息的地方叫做连接状态表，表的大小也就是被测设备所能支持的最大并发连接数 并发 TCP 连接容量体现了系统能够同时容纳的连接总数，其大小与设备的内存资源有关 【应用层指标】同步用户数与事物处理速率最大同步用户数是指被测系统能够容纳的最大同步用户数目，最大事务处理速率是指单位时间内被测系统能够成功处理事务数目的最大值 同步用户数和事务处理速率是衡量大多数基于 Web 的应用系统性能的指标，同步用户数和事务处理速率的测试，可以检验系统的全部处理能力，以及获悉是否在应用层存在性能瓶颈 突发流量处理突发流量处理是指被测系统处理巨大突发流量的能力 在实际应用中，网络系统有时候会遇到一些巨大的突发流量，例如：在节假日促销的最后一分钟，因为有更多的商品被订购，产生大量的突发流量，这些突发流量给系统带来巨大的负担，导致事务处理开销大大增加 突发流量处理测试的目的就是为了确定被测设备应对这种突发流量的能力","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络层路由测试","slug":"network-testing/27.网络层路由测试","date":"2020-08-30T12:14:00.000Z","updated":"2021-08-23T13:29:50.435Z","comments":true,"path":"notes/network-testing/a7c442d9.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/a7c442d9.html","excerpt":"【路由容量】测试路由设备的路由容量时，通常测试路由设备的转发表的大小，路由容量的测试方法主要有 3 种：控制台读数法、控制层学习法、数据转发层和控制层结合法 控制台读数法","text":"【路由容量】测试路由设备的路由容量时，通常测试路由设备的转发表的大小，路由容量的测试方法主要有 3 种：控制台读数法、控制层学习法、数据转发层和控制层结合法 控制台读数法控制台读数法即在被测路由设备的控制台上直接观察测试结果，通过将仪表的端口与被测路由设备的端口相连，令仪表向被测设备注入一定数量带有特定网络前缀的路由条目，然后在被测路由设备上通过控制台命令观察路由表中是否已正确学习到仪表所发送的路由信息 通常，对于一般路由设备，如果其路由表的容量超过了其最大值，就会在控制台上显示异常结果，一般采用二分法来注入路由条目数量，以进行测试，从而测出被测设备的最大路由容量 该方法可以直截了当的观测到测试结果，但观察到的为路由表的内容，而不是转发表的内容，而且当路由表表项较多时肉眼也难以观察，不适合大规模路由性能测试 控制层学习法控制层学习法在测试仪表上直接观察测试信息，该方法需要使用测试仪表上的至少两个端口： 一个端口 A 仿真成发送路由更新信息的邻居路由器向被测设备下发一定数量带有特定网络前缀的路由条目 被测路由设备在学到了来自端口 A 通告的路由后，会将其学到的路由通告给由端口 B 仿真的另一个邻居路由器 通过在仪表上直接观测端口 B 所学到的路由信息量与端口 A 所发送的路由信息量，并进行相应的比较就可以判断出被测设备的最大路由容量 如果端口 B 学到的路由信息量小于端口 A 所发送的路由信息量，则表示注入的路由条目数超过了被测设备的最大容量，此时，采用二分法减少所注入的路由条目再次测试，直到测出被测设备的最大路由容量 该方法相对于直接观察法来说有了改进，可以在仪表上进行测试结果的观测，可实现大量路由条目的注入、接收与比较，因此具有测试较大路由表容量测试的能力 但该方法和直接观察法一样，都只是对路由器的路由表进行了验证，即只验证了控制层面的转发，并没有验证到数据转发层面的转发，即测试出的最大容量为路由表的最大容量，而不是真正用于转发的转发表最大容量 数据转发层与控制层结合法数据转发层与控制层结合法需要使用测试仪表的两个端口： 仪表端口 A 仿真成 DUT 的一个邻居路由器 R1 向 DUT 注入一定数量带有特定网络前缀的路由条目 从路由学习的反方向，由仪表端口 B 仿真成一个主机向仪表端口 A 仿真的路由器 R1 发送路由测试流量 测试流量目的 IP 地址为仪表端口 A 向被测设备所发布的 IP 路由前缀 观测仪表端口 A 的接收流量速率与端口中 B 发送测试流量的速率是否相同 若接收流量速率远小于端口 A 的发送速率，即测试流在传输过程中出现大量丢包，则表明在路由学习过程中，超过了 DUT 的最大路由表容量而导致溢出 若接收流量速率等于端口 A 的发送速率，则应增加下发的路由表条目数 利用二分法，反复迭代，即可测出 DUT 的路由容量 该方法的拓扑结构如下图，R1 用于发送特定网络前缀的路由更新信息到 DUT，HOST 主机用于从路由学习的反方向，向 DUT 发送路由的验证流量 【路由振荡】概述路由振荡是网络中路由不稳定的主要表现形式，其可能导致全网范围内的路由重新计算，直接影响到路由的稳定性，从而影响 IP 报文的转发 如下图，是一个单域的 OSPF 网络 假如由于某种原因导致 R1 的 F0/0 端口由 UP 状态转为 DOWN 状态，则需要这个区域内的所有 OSPF 路由器更新链路状态数据库和路由表 完成路由更新需要时间，在正确的路由下发到 FIB 之前，路由器的转发可能是错误的，更为糟糕的是，在区域中的各路由器完成更新后，原故障链路恢复了连接 若频繁出现 UP 和 DOWN 交替，则各路由器就出现路由振荡 测试思路路由振荡测试的基本设计思路为： 使用测试仪表的一个端口向 DUT 下发多个特定 IP 网络前缀的路由，另一端口用来发送到这些特定 IP 网络前缀的测试流量 在路由振荡测试的整个过程中，流量发送端口始终保持流量的发送状态不变 当路由已稳定时，撤消下发的多个特定 IP 网络前缀中的部分路由，等路由再次稳定时，又重新下发刚撤消的路由 重复步骤 3 的反复下发、撤消过程，人为制造出路由振荡的环境 在测试仪表上观测控制层面的转发，并同时观测数据转发层面测试流的转发速率，得到测试结果 如下图，是路由振荡测试的逻辑拓扑结构 测试步骤路由振荡测试步骤如下： 将仪表的端口 A 仿真成一个 OSPF 路由器，在该仿真 OSPF 路由器上通过构造多种不同的 LSAs（如：网络路由 LSA、汇总路由 LSA、外部路由 LSA）来仿真出一个虚拟的互连网络环境，并将这些 LSA 下发给 DUT 由仪表端口 B 仿真的主机向仪表端口 A 所连的虚拟网络中的所有目标网络发送测试流量 在测试仪表上使用向导或手工命令建立与编辑反复撤消与重发外部路由通告的命令集，并设置测试的持续时间，该时间可根据用户需求进行设置 启动反复撤消与重发外部路由通告的命令集，在端口 A 上监测所接收的测试流量，并将其与端口 B 所发送的测试流量进行比较，以判断路由振荡的严重性 测试效果图如下图，是路由振荡测试后得到的效果图 由于网络状态或路由变化反映到路由器的 FIB 表存在一定的时间延迟，也就是说控制层面的变化需要一定的时间延迟之后才能从数据转发层面显示出来 通常这两条曲线会存在一定程度的偏离或不一致，这两条曲线重叠部分越多，说明控制层面的变化反映到数据转发层面的延迟越小，相应的表明被测路由设备振荡测试性能越好 【路由收敛】概述根据路由收敛时间的定义，在一个已经收敛的网络中，网络拓扑发生变化会导致网路中的各路由器通过交换网络信息、计算最佳路径并更新路由表等系列行为来重新达到对网络状态或拓扑的一致认识，从前一个收敛状态到新的收敛状态所需的时间即为路由收敛时间 测试思路路由收敛测试基本设计思路如下： 使用测试仪表的两个端口仿真成两个路由器，然后由这两个仿真路由器分别向 DUT 下发具有不同度量的关于同一 IP 网络前缀的路由 DUT 收到路由更新信息后，计算到该特定 IP 网络前缀的路由，选择其中的最优路由更新自己的路由表并将其插入到 FIB 表中 由仪表的第三个端口来发送到这个 IP 网络前缀的测试流量，以判断网络是否已处于稳定状态 当网络已处于稳定状态时，将原来下发的最优路由撤销，则 DUT 重新计算到这特定 IP 网络前缀的路由，并选择次优的路由来更新自己的路由表并插入到 FIB 表中 通过在测试仪表上观测流量转发曲线，即可计算出路由收敛的时间 如下图，是路由收敛测试的逻辑拓扑结构，端口 A 用来发布测试流量，B、C 分别仿真成邻居路由器 R1、R2 测试步骤路由收敛测试步骤如下： R1、R2 分别向 DUT 下发具有相同 IP 网络前缀的路由，但 R1 下发的路由其度量要小一些，为最优路由，R2 下发的路由其度量要大一些，为次优路由 端口 A 构建测试流量，测试流量的目的 IP 地址为 B、C 向 DUT 下发的 IP 网络前缀，由于 B 仿真成的 R1 下发的路由为最优，DUT 会将测试流量转发给 B 通过将 B 接收的流量与 A 发送的流量进行比较，即可判断路由是否收敛，若两者一致，表示路由已处于收敛状态 撤销 R1 所下发的路由，则 DUT 重新计算到目的地的路由，并选择次优的 C 作为到达目的网络的新的最优路由，在路由变化过程中，A 仍然持续的向 DUT 发送测试流量 通过将 C 接收的流量与 A 发送的流量进行比较，即可判断网络是否已经达到新的收敛状态 在测试仪表上观察两种不同收敛状态下的测试流量转发曲线，红线表示最优路由为 B 时的转发曲线，蓝线表示最优路由为 C 时的转发曲线 通过计算数据转发从原有的稳定状态到新的稳定状态的时间差，即可得到路由收敛时间 测试结果根据上图的曲线 从业务受影响的角度考虑，以时间 t4 减去 t1，即次优路由学到并达到稳定所需的时间减去最优路由撤销的时间 这种计算方法更加接近用户体验，因为当路由发生变化并影响到数据转发时，用户可以感知到这种影响，只有当路由收敛完毕，流量恢复到收敛前的水平，用户的业务才完全恢复 从网络运营商的角度考虑，即从收敛过程的丢包速率考虑，路由变化对业务的影响可以用丢包总数衡量，即： 路由收敛时间=\\frac{收敛过程总丢包数}{发包速率}从几何学的角度分析，X 轴为时间（秒），Y 轴为速率（包/秒），$总发包数 = X \\times Y$，总丢包数=图形的缺口面积，即： 路由收敛时间=\\frac{图形缺口面积}{发包速率}","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络层数据包转发测试","slug":"network-testing/26.网络层数据包转发测试","date":"2020-08-27T08:40:00.000Z","updated":"2021-08-23T13:32:27.850Z","comments":true,"path":"notes/network-testing/5c690370.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/5c690370.html","excerpt":"【基本方法】在网络层测试中，测试技术指标以包为关注对象 但由于每个包都必须经过数据链路层封装才能传输，即每个包都存在一个与之对应的帧","text":"【基本方法】在网络层测试中，测试技术指标以包为关注对象 但由于每个包都必须经过数据链路层封装才能传输，即每个包都存在一个与之对应的帧 因此，在网络层测试中仍以帧为对象定义每条测试流量 【地址学习】为确保被测设备能够在稳定的工作状态下直接转发每个 IP 测试数据包，需要先进行地址学习 即以学习 IP 地址与 MAC 地址映射关系为目的，事先学习转发 IP 测试包时所需的 MAC 地址，以完成 ARP 表的更新 下图为被测设备第三层地址学习示意图 【吞吐量】概述吞吐量测试是为了找到在没有丢包的情况下路由器能够转发的最大速率 吞吐量测试的判定唯一标准是：零丟包 通常看两个方面的性能：整机吞吐量、端口吞吐量 参与端口 测试对象 端口吞吐量 一对同种类型端口，各种类型端口都要进行一次同种类型端口直接的测试 端口和线卡的能力 整机吞吐量 全部或者多种类型的端口 背板或者交换网络的能力 测试方法在吞吐量测试过程中，常根据需要选择以下测试方法：步进法、二分搜索法、混合法 步进法：假设每次测试时速率的变化量为 $Δv$，如果在某个速率 $v$ 下的包能够正确转发，但在速率 $v+Δv$ 时包出现丢失，则 $v$ 就是吞吐量 二分搜索法：设置初始帧速率、最小速率和最大速率，如果测试时出现丢帧，则下一轮测试的速率为当前速率与最小速率间的中值，否则下一轮测试的速率为当前速率与最大速率间的中值，直到不丢帧时，当前速率即为吞吐量 帧大小的影响吞吐量随帧大小的不同而改变 在 RFC2544 中，对以太网测试帧大小的建议为 64、128、256、512、1024、1280、1518 字节 时长建议每次持续 60 秒以上 各种网络下帧长与最大理论速率的关系如下： 【背对背】背对背描述的是路由器在数据急剧增加、甚至达到该物理介质的理论速率时的表现 背对背测试通过向被测设备发送具有合法最小帧间隙的突发数据包，确定被测设备在不丢包的情况下能够处理的最大数据包数目，从而考察路由器接口对于突发数据的缓存能力 背对背测试与吞吐量测试都反映了路由器的数据包转发能力，但吞吐量测试重在转发引擎的转发能力，其单位是：包/秒，背对背测试重在接口缓存能力，其单位是：包 RFC2544 没有规定测试采用的算法，但最常用的算法是： 在每轮背对背测试中，以最大帧速率向 DUT 传送特定数量的测试帧 统计 DUT 转发的帧数 如果出现丢帧，则减少帧数或测试持续时间，否则增加帧数或测试持续时间 重复上述测试过程，直至找到没有丢帧时的最大帧数，此时，结果即为背对背值 为了保证足够的数据包数目，发送具有合法的最小帧间隙的突发数据包的持续时间必须大于等于 2 秒钟，并且测试应该至少进行 50 次，最终取平均值 【丢包率】概述丢包率测试是为了确定 DUT 在不同的负载和帧长度条件下的丢包率，该参数可以反映过载情况下网络设备的性能，有助于表明一个设备在面对广播风暴等网络异常情况下的行为 实际的测试方法是以一定速率向 DUT 发送一定数目的包，并对 DUT 转发的包的数量进行统计，最终结果为： 丢包率 = \\frac{(X - Y) * 100}{X}其中，$X$ 代表发送包数量，$Y$ 代表接收包数量 帧划分根据作用的不同，帧可以划分为多种类型，如：数据帧、学习帧、路由更新帧等，网络设备应当采取合适的丢弃策略，尽量保证关键帧和重要帧的顺利传输 例如：若丢失了某个关键的路由信息帧，就有可能导致大量数据不能交换，从而引起更大的丢失率 丢包率测试主要考虑待测设备在超负荷运转情况下的异常行为，包括包的丢失、重发、乱序和错发等 在接收时不能简单统计收到帧的个数，必须加以识别，这需要对帧进行编号，接收时可以通过对帧编号的查对来判断各种不同的异常情况 需要注意的是，重发和乱序不算作丢失，但在接收帧总数里不能重复统计收到的重复帧 测试方法在测试丢包率时，为了达到反映测试设备在超负荷情况下的实际运行情况，同时真实反映设备丢包率的情况，可采用三种方式： 一对一端口发送和接收：反映单端口的丢包情况，两端口可以随机选取，重复测量 10 次计算平均值即可 部分网状多对一/一对多端口测试：通过多个发送端口以一定速率向待测设备的某个接收端口发送数据，或者一个发送端口以一定速率随机发向多个接收端口，这种情况下，需要测量更多次数来反映平均性能 多对多全网状测试：多个结点形成一个连通图，即任意端口要发送报文到其余各端口，任意端口要收到其余各端口发向自身的报文 【延迟】概述延迟测试是确定数据包经过 DUT 传输所需要的时间，以反映 DUT 执行转发操作的速度以及转发队列的处理情况，延迟越小，说明路由器处理数据包的速度越快 延迟测试时，必须要测得以下两个参数： 输入帧的最后一位到达输入端口的时刻 输出帧的第一位出现在输出端口的时刻 在存储转发设备和位转发设备中对延迟的定义不同： 存储转发方式设备：延迟 = 输出帧的第一位出现在输出端口的时刻 – 输入帧的最后一位到达输入端口的时刻 位转发设备：延迟 = 输出帧的第一位出现在输出端口的时刻 – 输入帧的第一位的末尾到达输入端口的时刻 在实际情况下，设备被看成一种存储转发设备，设备的延迟仍然从输入的最后一位开始计算，到输出的第一位结束，即使这个计算结果是负的,这样计算的目的就是要将设备作为一个整体来看待，而不考虑设备的内部结构 标记帧方法在一个测试流中，每个帧的开始标志和结束标志都是相同的，为进行区分，引入了标记帧方法，即通过在整个报文中特定位置加入特殊标记来测试 对带有标记的帧，要求： 不能在传输过程中丢失 转发的时候网络设备应该已经工作在稳定状态，即标记帧设置在测试流的中间 由于整个报文的延迟是和报文中任意位的延迟是相等的，这样一来，测试就转化为：记录网络设备接收带有标记的帧的时间和发送带有标记的帧的时间 测试过程具体的测试过程为： 为确保在不丢包的情况下进行测试，要确定 DUT 在各个帧长下的吞吐量 针对每一个特定的帧长，以已经确定好的不超过吞吐量的发送速率发送该帧的数据流，该发送过程应该维持至少 120 秒 在数据流发送 60 秒之后，在其中的某一个帧中打上标记，并记录下该帧被发送的时间戳 A 测试设备的接收端必须能够识别该标记信息，并记录下接收到携带该标记的帧的时间戳 B 时间戳 B 减去时间戳 A，结果即为延迟 【系统重启】系统重启测试主要集中在系统重启时间的测试上 引发系统重启有三种可能： reset 引起重启：使用 DUT 设备软件的 reset 方式进行软件系统重启 硬件重启：使用 DUT 设备硬件的 reset 按钮进行硬件系统重启 电源中断重启：与上述相似，不同之处在于重启 DUT 时需要关闭电源 10 秒钟 为避免因等待接收路由更新引入新的延迟，通常采用直连网络或静态路由进行测试，测试过程如下： 确定最小帧长下的吞吐量 以最小帧长吞吐量的速率持续地发送数据流 重启 DUT 从数据包开始转发起一直监测输出端口，分别记录复位前测试端口接收到的最后数据包的时间（时间戳 A）、复位后测试端口接收到的第一个数据包的时间（时间戳 B） 重启时间由时间戳 B 减去时间戳 A 所得到","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络层测试相关文档","slug":"network-testing/25.网络层测试相关文档","date":"2020-08-27T03:32:00.000Z","updated":"2021-08-23T13:02:16.155Z","comments":true,"path":"notes/network-testing/c00ce65.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/c00ce65.html","excerpt":"【概述】网络层位于 OSI 模型中的第三层，因此网络层测试又被称为第三层测试 相关的 RFC 文档包括：RFC1242、RFC2544、RFC1812、RFC3222、RFC2889、RFC3918 等","text":"【概述】网络层位于 OSI 模型中的第三层，因此网络层测试又被称为第三层测试 相关的 RFC 文档包括：RFC1242、RFC2544、RFC1812、RFC3222、RFC2889、RFC3918 等 RFC1242 与 RFC2544 具有一般性的指导意义，涵盖了 OSI 全部七层的测试 RFC1812、RFC3222、RFC2889、RFC3918 是一些与路由测试相关的 RFC 文档 【RFC1242】RFC1242 为二到七层的网络互连设备的基准测试定义了基本术语和概念 在网络层测试中，常用的概念有： 背靠背 恒定负载 数据链路帧大小 丢包率 帧间空隙 延迟 重启行为 吞吐量 【RFC2544】RFC2544 被称为网络测试的圣经，其对网络二层到七层性能的衡量都有着重要指导作用 对于网络层测试来说，其定义了六个基准测试： 吞吐量（Throughput） 丢包率（Packet Loss Rate） 延迟（Latency） 背对背（Back-to-back） 系统恢复（System recovery） 重启（Reset） 【RFC1812】RFC1812 中定义了路由信息表（RIB）与转发信息表（FIB） 路由表(RIB) 是从邻居路由器收到的路由信息而形成的信息表，该表保存在路由器的内存中，通常使用命令 show ip route 来查看该表的内容，表中到目的网络可以存在多条不同的路径 转发表(FIB) 是路由设备上用于转发 IP 分组的信息表，FIB 表的内容由 RIB 表下发，在 FIB 表中只存在一条唯一路径到某个特定的目的网络 【RFC3222】RFC3222 中定义转发表表表项和大小等内容，并明确指出转发信息表和路由信息表是不同的 转发表条目是 FIB 中所出现的每一条数据记录，每个条目均包含了转发 IP 分组到一个特定目标网络所必须的基本信息，包括网络前缀、路由器接口标识和下一跳信息等基本字段 转发表大小是 FIB 表所支持的最大条目数，如果路由器的 FIB 表容量太小，路由器在进行数据转发时会由于找不到所匹配的网络而出现丢包的情况，因此 FIB 表大小是影响路由器转发性能的关键因素","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络层性能指标","slug":"network-testing/24.网络层性能指标","date":"2020-08-22T08:13:00.000Z","updated":"2021-08-23T13:02:24.245Z","comments":true,"path":"notes/network-testing/aa4c37f9.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/aa4c37f9.html","excerpt":"【概述】在数据传输层面，关注的是路由器基于数据包的数据转发能力，即数据包转发是否准确、有无丢包、转发延迟多大等，因此又被称为数据包转发测试，所谓数据包转发，即将数据包从路由器输入端口转发到输出端口的过程 常见的指标有：吞吐量、延迟、丢包率、背对背、时延抖动、背板能力、系统恢复、系统重启等","text":"【概述】在数据传输层面，关注的是路由器基于数据包的数据转发能力，即数据包转发是否准确、有无丢包、转发延迟多大等，因此又被称为数据包转发测试，所谓数据包转发，即将数据包从路由器输入端口转发到输出端口的过程 常见的指标有：吞吐量、延迟、丢包率、背对背、时延抖动、背板能力、系统恢复、系统重启等 在逻辑控制层面，考虑的问题因网络类型的差异会有所不同，主要是进行路由测试 对于小型网络：重点考虑路由协议类型的选择 对于大型网络：还应该考查路由表项大小是否满足、路由表项更新速度如何、路由更新时对数据通道上的处理有无影响等 此外，路由器采用不同的方式获取路由信息，会直接影响路由性能： 静态路由：消耗管理员的时间，但没有额外的路由维护开销，对网络拓扑变化的适应性较差，网络的可扩展性也受限制 动态路由：能较好的适应复杂多变的网络环境，但需要较多的资源消耗，包括路由器的 CPU 时间与内存、网络链路带宽等 尤其动态路由来说，当运行不同的路由协议时，路由算法和复杂度不同会带来性能上的差异，即使运行相同的路由协议，不同网络环境下的运行性能也会不同 因此，就特定的网络系统或网络环境而言，必须对路由进行测试，以检验路由是否能满足总体运行性能的需要，主要指标有路由振荡、路由学习速率、路由表容量、路由收敛时间等 【数据转发层面】吞吐量吞吐量是指在没有丢包的情况下，路由设备能够转发的最大速率，其衡量单位是每秒转发的数据包的数量，即：包/秒 在高速路由器中，包转发能力至少应在 20 包/秒以上 其有两层含义： 保证待转发的每一个包都能够从输入端口准确地转发到适当的输出端口 被测设备在不丢包的前提下，单位时间内能够转发的最大包数量 在吞吐量的基础上，有以下定义： 整机吞吐量：设备整机的包转发能力 端口吞吐量：路由器在某端口上的包转发能力 对于整机吞吐量，通常小于路由器所有端口吞吐量之和，整机的背板或交换网络是制约整机吞吐量的瓶颈 对于端口吞吐量，通常采用两个相同速率端口进行测试，一般情况下，端口吞吐量与端口所占的位置及端口间的关系相关 例如：同一插卡上端口间测试的吞吐量与不同插卡上端口间的吞吐量值不同 延迟延迟是指分组的最后一位比特进入路由器到第一位比特离开路由器的时间间隔，该时间间隔是存储转发方式工作的路由器处理时间 延迟产生的原因有二： 处理时延：转发数据包时完成的一系列操作，如计算路由、地址解析等需要一定时间 排队时延：数据包等候处理时，在输入端口和输出端口的缓冲队列中排队所产生的时间 时延对网络性能影响较大，对高速路由器，在最差情况下，要求对小于 1518 字节的 IP 包时延均都小于 1ms 丢包率丢包率是指路由器在不同负荷下，由于资源缺少而不能被网络设备转发的数据包在应该转发的数据包中所占的比例 其中不同负荷有吞吐量、线速等，对于吞吐量来说，在吞吐量的范围内丢包率为 0，超过吞吐量就会引起丢包 丢包率通常用作衡量路由器在超负荷工作时的性能 目前常使用 ping 命令来测试网络丢包率，当 ping 一个 IP 地址时，若出现 request timeout 就说明网络有问题，一般来说，使用 ping 命令的 -n 选项，如：ping -n 50 IP，快速发出 50 次 ping 命令，检查无应答的次数，将无应答的次数作为丢包次数，如果丢包率超过 5%，说明网络负载较大 背对背背对背指的是在一段较短的时间内，以合法的最小帧间隙在传输媒介上连续发送固定长度的包不引起丢包时的包数量，该指标用于测试路由器缓存能力 通常以被测试设备在某个速率下能转发的最长的连续包数目来进行检验 如果路由器具备线速能力，即对于吞吐量 = 100% 线速的路由器来说，该指标为无限大，测试没有意义 时延抖动时延抖动是指时延的变化 例如：语音本是连续的信号，在将分组数据从主机 A 发送到主机 B 的过程中，由于分组传输路径不同，每个路径的长短和数据流量各不相同，造成了分组到达接收端的时间有所不同，这样在接收端回放的语音变得时断时连 数据业务对时延抖动不敏感，所以该指标通常不作为衡量高速路由器的重要指标，只有对时延抖动敏感的业务，如语音、视频，该指标才有测试的必要性 背板能力背板是指输入与输出端口间的物理通路，背板能力决定了路由器的吞吐量 背板能力是路由器的内部实现，传统路由器采用共享背板，但是应用于高性能路由器时不可避免的会遇到拥塞问题，其次也很难设计出高速的共享总线，所以现有的高速路由器一般采用可交换式背板的设计 但是背板能力只能在设计中体现，一般无法测试 系统恢复系统恢复是指路由设备从超载行为状况下恢复到正常转发状态的行为特征，主要表现为系统恢复速度的快慢 简单来说，就是从丢包到不丢包的时间 路由设备必须具有高可用性，在出现软件崩溃或负荷超载等非致命问题的情况下，系统应该能够自动实现系统恢复，并且系统恢复时间应尽量短 系统重启在路由设备加入网络投入运行后，或者出现致命错误不能工作必须更换其他设备的情况，都会引起设备重启 系统重启时，路由器不能正常工作，会引起数据包的丢失，这段设备不可用的时间长短对于评估设备的性能优劣相当重要 系统重启时间越小，即因电源开关或系统重置而产生的等待时间就越小，网络的丢包也就越少，由此产生的网络不可用时间也就越短 【控制层面】路由表容量路由表容量是指路由器的路由表中所能容纳的最大路由信息条目数 不同型号或功能定位的路由器其最大的路由容量是不一样的，小的有上万条，大的可达上百万条 如果路由器需要的路由条目超过了其最大路由表容量，就会产生部分路由表项无法被保存的现象，即路由表溢出，这就导致某些目的网络不能到达，从而出现丢包 路由设备所支持的路由表的最大容量是决定路由器转发性能的一个重要因素 路由学习速率路由学习速率是指路由器接收到一条新路由的信息到路由器构建这条路由并插入到路由表中所花的时间 路由学习速率越高，则路由器通过新路由转发的分组丢失率就越小，其是决定路由器转发性能的一个重要因素 路由振荡路由振荡又称路由波动，其是指由于种种原因导致到某个目的网络的路由在短期内反复撤销和重现 导致路由振荡的原因有： 链路不稳定，如：传输上光缆的故障 路由协议使用的传送协议出现问题，如：BGP 协议工作在 TCP 之上，当 TCP 协议栈运行出现问题时，势必导致 BGP 协议的不稳定 网络拓扑结构的变化，如：网络割接（运行网络物理或者逻辑上的更改） 路由信息撤销与更新 路由振荡通常以每秒更新路由的数量来衡量，每秒更新路由的数量越大，说明路由振荡越严重 路由振荡是路由不稳定性的主要表现，对路由器转发能力有很大的影响 路由收敛时间路由收敛是指同一个网络中所有路由器对网络拓扑的认识达到一致的过程 路由器重启、网络拓扑发生变化等，都会引发全网路由的重新收敛，在该过程中，网络中的各路由器通过交换网络信息、计算最佳路径并更新路由表等重新达到对网络状态或拓扑的一致认识 路由收敛时间可以被理解为路由变化通知到全网所用时间，其是评估路由协议的一个关键指标 路由协议的收敛速度越快，其运行性能就越好","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络层测试与网络层设备","slug":"network-testing/23.网络层测试与网络层设备","date":"2020-08-21T06:19:00.000Z","updated":"2021-08-24T13:50:08.266Z","comments":true,"path":"notes/network-testing/374d7217.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/374d7217.html","excerpt":"【网络层概述】网络层的任务是将分组从源主机传送到目的主机，这期间可能要跨越多个异构的通信子网，经过许多中间节点，存在多条可达的网络路径 为满足上述要求，有以下解决方法：","text":"【网络层概述】网络层的任务是将分组从源主机传送到目的主机，这期间可能要跨越多个异构的通信子网，经过许多中间节点，存在多条可达的网络路径 为满足上述要求，有以下解决方法： 提供跨越异构网络的主机寻址方案：该方案能够为互连的每个节点分配一个唯一的网络地址，通过分组头部中的源地址和目的主机地址来识别相互通信的计算机，解决不同类型网络之间的主机寻址问题 提供路由选择功能：确保分组沿着最佳路径从一个网络转发到另一个网络，最终到达目的主机 提供对异构网络互连的支持：包括为不同网络的互连提供硬件接口和规定相应的通信协议 网络层是通信子网的最高层，关系到整个通信子网的运行控制，其提供的包转发和路由处理功能关系到从源主机到目标主机的数据可达问题，直接影响到整个网络的通信质量 如果网络层设备在处理包时出现了问题，不仅会引入传输问题和传输延迟，还会导致包将被丢弃，因此，为满足网络层的需求，有了路由器，其是整个网络的交通枢纽 【路由器概述】网络层的核心设备是路由器，其可以支持各种异构网络的互连，实现不同网络主机之间的通信，其是整个网络互连环境中最关键的设备 路由器实现了网络的互联，路由器最基本的功能是路由与交换，即为每个数据分组选择一条从源到目的端的最佳路径，并将分组通过所选定的路径转发出去 路由器中的分组转发主要依靠查找转发表来完成，而转发表又是根据内存中的路由表得到的，路由表能否正常工作直接影响互连网络的连通性 路由器必须完成两个基本功能：路由处理、数据包转发处理 路由处理：收集网络拓扑信息并动态形成路由表 数据转发：根据转发表转发 IP 数据包 【路由器结构】路由器是具有多个输入端口和多个输出端口的专用计算机，分为路由选择部分、分组转发部分，其中路由选择部分用于控制，分组转发部分用于数据转发 路由选择部分路由选择部分的核心构件是路由选择处理机，其运行系统软件或路由选择协议，定期交换网络的拓扑结构信息，依照拓扑结构动态更新和维护路由表 数据包转发部分数据包转发部分主要是根据控制层面生成的转发表转发 IP 数据包 转发表是根据路由表生成的，其表项和路由表项有直接对应关系，但转发表的格式和路由表的格式不同，它更适合实现快速查找 数据包转发部分分为三模块：交换结构、输入端口、输出端口 交换结构根据转发表对来自某个输入端口的数据包进行处理，并使之从一个合适的输出端口转发，以完成输入端口和输出端口之间的互连功能，常用的交换结构有：总线型交换、共享存储型交换、交叉开关型交换 输入端口是物理链路的连接点，也是数据包的接收点，端口通常由线卡提供，一块线卡一般支持 4、8、16 个端口。每个输入端口都有三个模块，它们分别是对应于物理层、数据链路层、网络层的模块 在输入端口接收到分组后： 如果是路由交换信息：交由路由选择处理机处理 如果是数据：查找转发表 一个分组未处理完，又到了新的分组：在输入队列中排队 输出端口主要提供对网络层数据进行队列和缓冲管理，其从交换结构接收数据包，然后将它们发送到路由器的线路接口卡上 当交换结构传送的数据包的速率超过输出链路的发送速率时，来不及发送的数据包就暂时存放在队列中，输出端口使用复杂的调度算法实现 QoS 功能 【路由器工作原理】路由器的工作流程如下： 线路输入：IP 分组从不同线路到达路由器的线卡接口，线路输入处理部分对它进行信号恢复、译码和 CRC 校验，放进输入 FIFO 队列 数据存储：输入 FIFO 队列的数据要送入数据存储器 数据包头部分析：取出分组进行分析，主要是三层目的 IP 地址 数据包头部修改：在进入输出队列前，要修改分组头部，包括 TTL 值减 1、更新 IP 头部校验和、替换二层 MAC 地址等，交给输出FIFO队列 线路输出：在数据包头部修改后，交给输出 FIFO 队列，进行输出 【路由器处理能力】衡量路由器性能的重要参数是路由器每秒能够处理的数据包数 决定路由器处理数据包的能力的因素有： 输入端口的处理速率 查找转发表的速率 数据包交换的速率 输出端口的处理速率 分组在输入和输出端口都有可能在队列中排队等候处理，从而产生一定的延时，如果分组处理的速率低于分组进入队列的速率，队列的可用存储空间最终会减少到 0，这使后续的分组由于没有存储空间而被丢弃 【路由表的生成与维护】路由分为静态路由、动态路由 静态路由是指由网络管理员根据其所掌握的网络连通信息手工配置的路由表表项，其有一种特殊的路由，称为默认路由(default) 默认路由能够为那些在路由表中没有其它路由与其目的地址匹配的数据包指出数据包转发所需的端口 动态路由是指路由器依靠路由协议自主学习而获得路由信息","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"以太网 LLC 子层测试","slug":"network-testing/22.以太网LLC子层测试","date":"2020-08-19T11:15:00.000Z","updated":"2021-08-23T13:02:38.156Z","comments":true,"path":"notes/network-testing/7a9afe2c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/7a9afe2c.html","excerpt":"【前压测试】当前端设备以超线速发送数据帧时，就会引起输入端口的过载，前压测试是为了度量 DUT 在输入过载的情况下，输出端口对过载的反应，即是否启用了前压 在进行前压测试时，为了人为造成输入端口的过载，需要将测试帧的帧间隙设置成小于 96 位，通常将测试帧间隔设置成 88 位比特长度","text":"【前压测试】当前端设备以超线速发送数据帧时，就会引起输入端口的过载，前压测试是为了度量 DUT 在输入过载的情况下，输出端口对过载的反应，即是否启用了前压 在进行前压测试时，为了人为造成输入端口的过载，需要将测试帧的帧间隙设置成小于 96 位，通常将测试帧间隔设置成 88 位比特长度 测试拓扑使用了 DUT 上的一对端口，并采用了单向流量模式，测试仪表生成的测试帧作为负载传输到DUT的第一个端口（端口1），接收与观测在 DUT 的第二个端口（端口2）进行，拓扑图如下： 当帧间隔为 88 位比特长度的测试帧加载到 DUT 后 若在观测用的端口 2 上，发现帧转发速率大于最大提交负载或介质的最大理论利用率，则表明 DUT 启用前压机制 若在观测用的端口 2 上，发现帧转发速率小于最大提交负载或介质的最大理论利用率，则表明 DUT 不具备前压机制 【地址容量测试】地址缓冲容量的测试是为了确定在 RFC2285 中定义的以太网交换设备地址缓冲的能力 该测试使用 DUT 上的三个端口，分别作为学习端口、测试端口、监听端口，测试过程如下： 1.测试仪表通过学习端口将所生成的多个带有不同源地址和同一个确定目的地址的学习帧传送到 DUT，该确定的目的地址和连接到 DUT 测试端口上的测试设备的 MAC 地址相同2.通过让测试端口接收这些具有不同源地址的帧，DUT 就可以学到这些新地址，并将所学到的地址写入地址表3.将测试端口所接收的测试帧回传到学习端口，并由 DUT 上的监听端口担当检查端口，以监听是否有洪泛帧或错误转发的帧： 若监听端口所统计到的洪泛帧计数不等于零，即它收到了洪泛帧，说明在此前的地址学习过程中，地址表已经发生溢出，导致部分源地址没有被 DUT 学习并写入地址表 若监听端口的洪泛帧计数为零，即它没有收到洪泛帧，说明在此前的地址习中，DUT 还拥有足够的地址缓存空间，来确保所有的源地址被 DUT 所学习并写入地址表 此外，为了确定地址表容量，也需采用某种查找算法来进行反复的测试，以找到 DUT 所能支持的最大地址数目，目前普遍采用的算法是二分迭代算法 【地址学习速率测试】地址学习速率测试的目的在于确定以太网交换设备的极限地址学习速率 其与地址容量测试类似的测试方法类似，采用相似的测试拓扑，学习端口以不同速率向测试端口发送学习帧，测试端口向学习端口回送所有的学习帧，监听端口监听是否有洪泛帧或错误转发的帧 与地址容量测试的区别在于：地址表容量测试采用基于学习帧的地址数的二分迭代法，地址学习速率测试采用基于学习帧发送速率的二分迭代法 【错误帧过滤测试】错误帧过滤测试是为了确定交换机在错误或反常帧情况下的行为 测试结果可以说明 DUT 是否具备了错误帧的过滤功能，还可以用来说明 DUT 所能过滤的错误帧类型 测试时间可在 1~300s 之间调整，推荐的测试时间为 30s 测试采用 DUT 一组共 8 个端口，其中 4 个作为测试帧的源端口，另 4 个作为监测端口，由测试仪表所生成的错误帧经过 DUT 的 4 个源端口后，向 4 个监测端口发送 在监测端口，通过观测是否有错误帧的流量泄漏，来判断 DUT 是否提供了错误帧过滤功能以及所能过滤的错误帧类型 若某种类型的错误帧能够被观测到，则标记为失效，若某种类型的错误帧未被观测到，则标记为通过 在测试完毕后，需要对各种类型错误帧观测结果的统计与分析： 若对所有指定类型的错误帧，标记状态为通过，说明 DUT 启用了错误帧过滤功能，且能过滤所有给定类型的错误帧 若对某些指定类型的错误帧标记状为通过，而另一些类型错误帧的标记状态为失效，说明 DUT 提供了错误帧过滤功能，但只能过滤某些特定类型的错误帧 若所有指定类型的错误帧，标记状态为失效，说明 DUT 未提供错误帧过滤功能，或错误帧过滤功能失效 【广播帧转发性能测试】广播帧转发性能测试是为了确定交换机对于广播帧的处理能力，包括： 广播转发速率：一台交换设备在单位时间内向所在广播域的所有端口发送的广播帧数量 广播时延：交换机将广播帧转发到位于同一广播域中的所有端口所需的时间 该测试拓扑结构由 1 个广播发送端口和若干个广播接收端口组成一个测试块，同时确保测试块中的源端口与接收端口位于同一广播域中，也就是说，若 DUT 上进行了 VLAN 划分，那么要确保测试块中的源端口与接收端口位于同一个 VLAN 中 广播吞吐量测试方法： 令测试仪表所生成的目的地址为 FF-FF-FF-FF-FF-FF 的广播测试流量通过 DUT 上的唯一源端口发送到各个广播接收端口 在接收端口，测试仪表只选择对广播测试流量进行转发率和帧丢失率的度量 通过测试不同负载下的广播帧转发率和帧丢失率，找到在零丢帧率下的最大广播帧转发率，即广播吞吐量 广播延迟的测试方法： 测试仪表在每次测试时仅发送一个测试帧，测试帧中包含了一个时间戳 在接收端口，通过该时间戳来计算帧的广播转发延迟 对于给定的 DUT，同一广播域中涉及的接收端口越多，需要复制并转发的广播帧数就越多，因此可能带来转发延时的增大 同一广播域中的不同接收端口，可能会存在延迟值的漂移 因此若有多个 UP 端口在接收广播流量，则需要对每个接收端口的延迟进行度量并取平均值，以作为广播帧延迟的最终值","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"以太网 MAC 子层测试","slug":"network-testing/21.以太网MAC子层测试","date":"2020-08-18T12:59:00.000Z","updated":"2021-08-23T13:02:44.698Z","comments":true,"path":"notes/network-testing/82ca5b3e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/82ca5b3e.html","excerpt":"【地址学习】在测试开始之前，让被测试交换机学习测试中将要用到的 MAC 地址 由于任何地址未被学习的帧都会被 DUT 作为洪泛帧转发，这减少了测试过程中被正确转发帧的数量，因此要求先学习 MAC 地址，再验证地址学习结果，最后进行测试","text":"【地址学习】在测试开始之前，让被测试交换机学习测试中将要用到的 MAC 地址 由于任何地址未被学习的帧都会被 DUT 作为洪泛帧转发，这减少了测试过程中被正确转发帧的数量，因此要求先学习 MAC 地址，再验证地址学习结果，最后进行测试 在地址学习时，要注意以下两点： 1.测试仪表向 DUT 发送地址学习帧的速率不可太大，以免因 DUT 地址学习速率上的限制而导致地址学习失败，一般要求地址学习速率 $\\leq$ 50 帧每秒 2.由于交换机地址表存在地址老化问题，即对于一个当前地址表中的地址项，若在地址老化时间内未被调用，则该地址将会从地址表缓存中被自动删除 因此要调整被测试交换机的地址老化时间，使其足够长，确保在测试结束前所学到的地址都不被老化，一般来说，地址老化时间大于测试学习时间、测试持续时间、配置测试设备时间之和 【帧长测试】理论上，选择任何一种长度在 64~1518 字节之间的测试帧都是被允许的 但是，帧长选择影响交换机的转发性能 帧长越大，交换机在单位时间内所要处理的帧数就越少；帧长越小，交换机在单位时间内所要处理的帧数就越多，交换机在帧接收、地址处理、帧转发以及拥塞控制上的压力就越大，最终会影响交换机的转发速率、丢帧率和吞吐量等性能指标 为了全面地反映被测试设备的性能，有必要在不同的帧长度下运行有关的以太网测试，三种常见的测试帧长方案如下： 完备性的测试方案：对所有长度的帧，进行测试 快速的测试方案：选择某些有代表性的帧长进行测试（RFC1242 建议，以太网快速测试可以采用 64、128、512、1024、1280、1518 字节等不同长度的帧） 基于统计的测试方案：以对设备所在网络环境的帧长监测与帧长分布统计信息为基础，确定相应的测试帧长 【帧格式测试】测试仪表仅对测试帧进行统计，为此需要对普通帧与测试帧加以必要的区分 在基本格式上，测试帧与普通以太网帧相同，但需要加入一个独特的签名字段，该字段出现在以太网帧的第 56 字节后或位于整个帧的结尾处 签名字段具有足够的可区分性，以帮助测试仪表从所接收的流量中提取出测试帧流量，并过滤掉那些不属于提交负载的普通帧流量 下图给出了一个来自思博伦通信公司的签名字段的实例，该字段共 20B 流标识(Stream ID)：4B，用于区分不同的测试流，具有相同流标识的帧属于同一测试流，32bit 的流标识最多可以支持 $2^{32}$ 条测试流 序列号(Sequence)：6B，用来指出帧在所在测试流中的顺序 时间戳(Timestamp)：4B，用来计算帧的传输时延 【吞吐量查找算法】由于在测量吞吐量时，需要提供相应的查找算法，该算法必须能够通过调整加载在 DUT 上的负载来逼近或找到在零丢帧率下的最大转发速率 步进查找法设当前负载为 $Load$，初始负载为 $Load_0$，步进长度 $△Load$ 将初始负载 $Load_0$ 赋值给当前负载 $Load$，即令：$Load=Load_0$，并判断当前负载下的丢帧率是否为零 如果为零，令：$Load=Load+△Load$，再度观察丢帧率 若丢帧率不为零：停止对 $Load$ 的步进，并将该负载下的转发率作为要查找的吞吐量 若丢帧率为零：继续步进 如果不为零，令：$Load=Load-△Load$，再度观察丢帧率 若丢帧率不为零：继续步进 若丢帧率为零：停止对 $Load$ 的步进，并将该负载下的转发率作为要查找的吞吐量 测试准确度取决于步长的大小，步长越小，所报告的吞吐量越接近实际结果，但步进次数越多，查找速率越慢 二分迭代法设最小负载 $Load_{Min}$、最大负载 $Load_{Max}$、当前负载为 $Load$、初始负载 $Load_0$ 将初始负载 $Load_0$ 赋值给当前负载，即令：$Load=Load_0$，并判断当前负载下的丢帧率是否为零 如果为零，令： Load=Load+\\frac{Load_{max}-Load}{2}再度观察丢帧率，反复迭代，一旦丢帧率不为零或间隔小于迭代分辨率时，停止迭代，并将当前负载下的转发率作为所要查找的吞吐量 如果不为零，令： Load=Load-\\frac{Load-Load_{Min}}{2}再度观察丢帧率，反复迭代，一旦丢帧率为零或间隔小于迭代分辨率时，停止迭代，并将当前负载下的转发率作为所要查找的吞吐量 测试准确度由迭代分辨率决定，迭代分辨率越小，吞吐量越接近实际结果，迭代次数越多 混合算法步进算法具有较二分迭代更快的查找速率，而二分迭代法具有较步进算法更准确的查找结果，混合算法兼顾两者优点，具有较好的查找速率与查找准确度 首先，采用步进查找算法来快速找到或逼近 DUT 的吞吐量所对应的负载大概范围或区间，然后，在上述区间内进行二分迭代查找 举例来说，当初始负载 $Load_0$ 未有丢帧现象，在第 $n$ 次步进时，首次观测到丢帧，那么就中止后续的步进过程，转而在区间 $[Load_0+(n-1)△Load，Load0+n△Load]$ 内进行二分迭代查找 若事先对 DUT 吞吐量所对应的区间有所了解，可直接在该区间内运行二分迭代查找算法，以加快整个测试进程 【吞吐量测试】全网状流量测试目的通过确定 DUT 在全网状流量下的吞吐量、丢帧率和转发率，即可反映出交换机的整机交换转发性能 通过调整负载的大小，可以测试 DUT 在不同负载下的转发速率和丢帧率，并从中找到零丢帧率下的吞吐量 测试拓扑在全网状双向流量模式下，测试仪表生成相应的测试流发往被测交换机（DUT）的各个源端口，测试仪表观测在 DUT 各个目标端口所能成功收到的帧数，通过对结果的统计计算转发速率和丢帧率 测试参数测试帧长设定为 64、128、256、512、1024、1280、1518 字节，至少要选择其中的五个不同帧长实施测试 突发帧中的帧间隙被指定成 96 比特长度的最小合法帧间隔，以能够反映极限帧间隙下的交换机性能，这个间隔在 10Mbps 以太网中相当于 9.6μs，在 100Mbps 以太网中相当于 960ns，在 1Gbps 以太网中相当于 96ns 端口工作模式，可选择半双工或者全双工 为反映 DUT 在执行不同数量地址查找时的交换能力，需要让测试仪表所生成的测试流中包含若干不同的帧目的地址，通常按照 $2^n$ 的方式来进行，即按照 1、2、4、8、16、32、64、128、256、…… 的数量去改变设置 对于在每端口采用多个地址的测试来讲，测试帧中的源地址和目标地址对还应是随机分布的，以真实反映 DUT 的地址查找性能 为了整个测试期间所有的端口平等而且满负载工作，以确保整个测试的平衡，即在不同的目的端口上，发往每个端口的目的地址在数量上有相等的分布，每一个目的端口都不会超负荷，每个端口以循环轮转的方式发送测试帧给其它端口 测试时长，在 1~300 秒之间调整，推荐的测试时间为 30 秒 测试结果报告对于负载，规定以媒质的最大理论负载的百分比表示 对于丢帧率，应当在测试结束时度量，而不应该以传输过程中的每秒为单位进行度量 对于转发速率，应当报告为每秒内设备能够被观察到的成功转发到正确目的接口的测试帧的数量，同时作为对一个特定提交负载的响应，要指出所对应的提交负载值 部分网状一对多/多对多测试一对多/多对多测试是为确定当从 DUT 的一个端口传输到多个端口或从多个端口传输到一个端口时的吞吐量 常被用来确定 DUT 利用一个以太网端口转发来自多个以太网端口的交换流量的能力，如用于确定一款非对称交换机上行端口为所有其他非上行端口进行数据帧转发的能力 主要的测试参数设置、测试过程、测试结果的统计以及测试结果的报告方式均可参照全网状吞吐量测试 与全网状吞吐量测试的主要区别在于流量方式的不同： 当测试为多对一时，来自多个端口的测试帧必须发往一个端口 当测试为一对多时，来自一个端口的测试帧必须以循环轮转方式发往多个端口 单向流量测试单向流量测试是为了确定 DUT 上一半端口向另一半的端口发送单向流量时 DUT 的吞吐量 如下图，以 DUT 上 8 个端口为例，给出了相应的测试拓扑，其中，1-4 端口为发送端口，5-8 端口为接收端口 主要的测试参数设置、测试过程、测试结果的统计以及测试结果的报告方式均可参照全网状吞吐量测试 与全网状测试类似，在端口地址配置上，为了确保每一次的流量传送中不同接收端口上的目的地址有相等的分布，以保持测试的平衡，在测试过程中每一个发送端口必须以循环轮转的方式将测试帧发送给所有的接收端口 【最大转发速率测试】最大转发速率测试是为了度量 DUT 设备在负载发生变化时的转发率峰值 测试拓扑如下： 测试仪表生成的测试帧作为负载传输到 DUT 的第一个端口(port1)，观测与度量在 DUT 的第二个端口(port2)进行 为了能够在负载 Load_T 和 Load_MOL 之间找到最大转发速率，须引入步进查找算法，设置一个合适的步进长度，对负载进行步进，从一组重复的 DUT 转发率测试结果中找到其中的峰值作为最大转发率最终报告值 步长值越小，测量结果越精确，但测试所需要的次数就越多","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"以太网测试相关文档","slug":"network-testing/20.以太网测试相关文档","date":"2020-08-16T08:38:00.000Z","updated":"2021-08-23T13:35:57.065Z","comments":true,"path":"notes/network-testing/e9f88fa2.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/e9f88fa2.html","excerpt":"【相关文档】以太网是数据链路层的技术，因此以太网测试又被称为二层测试 相关的 RFC 文档包括 RFC1242、RFC2544、RFC2285、RFC2889","text":"【相关文档】以太网是数据链路层的技术，因此以太网测试又被称为二层测试 相关的 RFC 文档包括 RFC1242、RFC2544、RFC2285、RFC2889 RFC1242 与 RFC2544 具有一般性的指导意义，涵盖了 OSI 全部七层的测试 RFC2285 为以太网交换设备基准测试提供了基本术语 RFC2889 为以太网交换设备基准测试提供基本方法学 【RFC2285】基本术语在 RFC2285 中，有两个基本术语： DUT：被测设备（Device under test） SUT：被测系统（System under test） 测试流方向单向流量单向流量是指测试流在被测设备中以单向方式传输 测试仪发送的测试帧从 DUT 的输入端口进入 DUT，由 DUT 上的输出端口发送回测试仪，DUT 上的输出端口本身不从测试仪接收任何流量 当测试者为 DUT 加载单向流量时，是由 DUT 上的不同端口处理帧的接收与发送，输入端口与输出端口的角色是不重叠的 双向流量双向流量是指每个端口在接收流量的同时也在发送流量 当测试者为 DUT 加载双向流量时，所有从测试仪表接收测试流量的端口同时也在向测试仪表回送测试流量，每个端口同时承担输入端口与输出端口的角色 流量模式概述为适应不同目的的测试，RFC2285中定义了 3 种不同的流量模式 以一款具有 24 个快速以太网接口(FE)和 2 个千兆以太网端口(GE)的非对称交换机为例 若要对交换机的 FE 端口转发性能进行测试，宜采用非网状流量模式，即将交换机上的 FE 端口组成端口对来运行相应的测试 若要对 2 个 GE 接口作为上行/下行链路的转发性能进行测试，就需要采用部分网状流量模式，即将每个 GE 端口与其他 24 个 FE 端口组成一个一对多的模式进行测试 若对交换机进行整机性能测试，将会采用全网状流量模式进行测试，这种流量分布最能模拟真实网络环境下交换机所承载的大量并发数据流量 非网状流量非网状流量也称端口对方式 DUT 上的接口被设置为输入和输出两类，每一个输入接口和一个输出接口对应，流量从一个输入端口加载后发送到另一个输出端口，形成一对一关系 不同的端口对之间是互斥的，流量不会相互泄漏 部分网状流量部分网状流量也称作骨干方式 DUT 与 SUT 的每个接口也被设置为输入和输出两类，输入和输出端口仍被捆绑成组来发送和接收帧，组与组之间互斥 在组内，输入和输出接口的模式变成了一对多、多对一或多对多模式 全网状流量全网状流量模式下，DUT 上的每个被测试接口既可以向所有其他的测试端口发送流量，也可以接收来自所有其他被测端口的流量，是一种完全多对多的关系 对于一个有 $n$ 个被测端口的交换机而言，在单向流量时，相当于有 $\\frac{n(n-1)}{2}$ 个端口对，在双向流量时，相当于有 $n(n-1)$ 个端口对 负载期望负载：外部信息源企图传输给 DUT/SUT 让其转发到指定输出端口的每秒帧数 提交负载：外部信息源能够被观察或测量到的传输给 DUT/SUT 让其转发到指定输出端口的每秒帧数 无论半双工模式下采用的 CSMA/CD 机制，还是全双工模式下的流量控制机制，都可能影响外部信息源向 DUT 发送流量的速率，从而使提交负载小于期望负载 最大提交负载：外部信息源每秒能够传送给 DUT/SUT 并让其向指定输出端口转发的最大帧数 理想状态下，最大提交负载可以达到线速发送下的负载，但实际上，最大提交负载不一定等于介质所允许的最大负载 例如，当外部信息源未能按最小的合法帧间隔来发送帧时，介质所能提供的信道带宽就不能得到最大限度的利用，最大提交负载就会小于介质所允许的最大负载 简单来说，期望负载是计划负载，提交负载是实际负载，最大提交负载是最大实际负载 过载：以超过介质允许的最大传输速率向 DUT／SUT 施加负载 过载会导致网络拥塞并可能因此引发帧的丢失，但如果交换机启用了有效的拥塞控制机制，则拥塞不一定会引起帧的丢失 转发速率转发速率：提交负载下，一台设备能够被观测到的每秒钟内成功向正确目的端口传送的帧数 最大提交负载下的转发速率：一台设备在最大提交负载的情况下能够被观测到的每秒钟内成功向正确目的端口转发的帧数 最大转发速率：一系列经过重复或迭代测试所获得的转发速率测量值 中的最大值 【RFC2889】概述RFC2889 为以太网交换设备的基准测试提供方法学，由 RFC2544 的方法学扩展而来 其核心部分分为测试设置、帧格式与长度和基准测试三大部分，其中基准测试涉及测试目标、参数设置、测试过程、测量方法和测试报告格式等方面 转发率、丢帧率和吞吐量是描述交换机转发性能的主要技术指标， RFC2889 中，半数的基准测试直接针对上述指标 负载、吞吐量、丢帧率和转发速率的关系负载、吞吐量、丢帧率和转发速率的关系可用如下的 FR-Load 曲线描述： 其中，Load_T 代表在没有丢帧时的最大转发速率，即吞吐量，Load_MaxF 代表在有帧丢失时的最大转发速率，Load_MOL 代表丢帧率增加，达到最大提交负载下的转发速率 可见，最大转发速率与吞吐量的区别在于：最大转发速率不关心 DUT 是否丢帧，而吞吐量以零丢帧为前提 在没有丢帧的状态下，随着负载从零开始逐渐增大到线速，转发速率应该随着负载的增加而线性增加，而且两者应该相等 在实际设备中，当负载超过某个临界值之后，因拥塞而导致帧丢失","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"Waiting","slug":"daily/06.Waiting","date":"2020-08-15T15:47:00.000Z","updated":"2021-09-22T08:07:46.859Z","comments":true,"path":"essay/daily/a767b432.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/a767b432.html","excerpt":"如果取得了重大胜利或是遭遇惨败，只想飞奔过去与一个人分享，而那个人却不在，这时又能怎么办呢？ 我一直不是很喜欢夕阳，当最后一丝余晖隐没在地平线下，天地间最终只会剩下一种灰暗的色调。 大概，是因为辉煌总是短暂的吧。","text":"如果取得了重大胜利或是遭遇惨败，只想飞奔过去与一个人分享，而那个人却不在，这时又能怎么办呢？ 我一直不是很喜欢夕阳，当最后一丝余晖隐没在地平线下，天地间最终只会剩下一种灰暗的色调。 大概，是因为辉煌总是短暂的吧。 其实我一直有在等一个像 Elementar 中的 Watson 那样的人，等待他能够给我救赎。 只是，她没有来，我还在等，大概还是因为我不值得吧。 这些年越发喜欢与机器和代码打交道，可能是因为他们总能理解我，也永远不会不喜欢我，更永远不会不理睬我吧。 -“Do you believe in love at first sight?”-“As long as we are together, what does it matter?”","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"以太网性能指标","slug":"network-testing/19.以太网性能指标","date":"2020-08-13T02:01:00.000Z","updated":"2021-08-23T13:35:30.590Z","comments":true,"path":"notes/network-testing/74ef6fb7.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/74ef6fb7.html","excerpt":"【概述】以太网工作在数据链路层上，其功能有： 帧的封装与拆封 基于 MAC 地址的帧接收与转发 拥塞控制(流量控制) 简单差错控制","text":"【概述】以太网工作在数据链路层上，其功能有： 帧的封装与拆封 基于 MAC 地址的帧接收与转发 拥塞控制(流量控制) 简单差错控制 在数据链路层上，上述功能可以归类到两个不同的层面： 介质访问控制 MAC 子层：数据传输 逻辑链路控制 LLC 子层：传输控制 传输控制功能是为了正确实现基于二层地址的帧转发，避免或减少因拥塞而产生的丢帧，而提供的控制功能，控制功能实现或正确与否，直接影响数据层面上的转发性能 【MAC 子层】背板带宽背板是交换机的中央交换部件，用于交换机的各个端口之间传送数据，背板带宽是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量 背板带宽也称交换容量，其标志了交换机总的数据交换能力，单位为 Gbps，一般的交换机的背板带宽从几 Gbps 到上百 Gbps 不等 一台交换机的背板带宽越高，所能处理数据的能力就越强，但同时设计成本也会越高，背板带宽资源的利用率与交换机的内部结构息息相关 当交换机所有端口容量乘以端口数量之和的 2 倍小于背板带宽时，能实现全双工无阻塞交换，证明交换机具有发挥最大数据交换性能的条件 负载信道或设备在单位时间内所承受的通信流量被称为负载，在数据链路层，通常以单位时间内设备或网络所承载的帧数来衡量。 负载过量会导致网络拥塞或设备工作状态不正常 交换机时延交换机时延是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔 采用直接转发技术的交换机有固定的时延，因为直接式交换机不管数据包的整体大小，而只根据目的地址来决定转发方向，所以它的时延取决于交换机解读数据包前 6 个字节中目的地址的解读速率 采用存储转发技术的交换机由于必须要接收完整的数据包才开始转发，所以它的延时与数据包大小有关，数据包大，则时延大，数据包小，则时延小 转发速率转发速率是用以描述交换设备帧转发能力的指标，其定义为：在某个特定负载下，交换机设备在单位时间内向目标端口成功转发的帧数 不同设备的转发速率与交换机的体系结构、端口带宽 、转发模式、设备的负载状况等因素有关 对于给定的设备，在没有丢帧的理想状态下，转发速率应该随着负载的增加而增加，但当负载增加并接近线路传输容量时，会因丢帧而导致转发速率下降 丢帧率丢帧率是指丢失的数据帧占应转发帧的比例 应转发帧指那些应该被转发的合法帧，不包括那些过长、过短和错误的无效帧 丢帧主要出现在负载过大时，因交换机存储容量、地址 表查找、端口拥塞等方面的瓶颈而产生 吞吐量吞吐量是一个描述交换设备数据包转发能力的指标，用以衡量交换机在不丢帧条件下每秒转发帧的极限能力 其定义为：在没有出现丢帧的条件下，能够传输给交换机让其转发到指定输出端口的每秒最大帧数 突发在某个时间段内，一组以合法最小帧间隔（96 比特时间）传输的以太网帧被称为突发 一次突发传输中所包含的帧数被称为突发量，突发量为 1 时，相当于无突发传输的恒定负载 两次突发之间的时间间隔被称为突发间隔，交换机所能承载的突发量越大，可以处理的突发间隔越小，说明交换机处理突发数据流量的性能越好 【LLC 子层】拥塞控制概念拥塞控制也称流量控制，是指控制源端发送数据的数量及速度使其不超过接收端所能承受的能力，以避免产生帧的丢失 当交换机发生拥塞时，产生的直接后果就是帧的丢失，从而导致网络性能的下降，即使在高层使用了 TCP 的可靠传输协议，仍然会因为 TCP 的重传机制所产生的延迟而引起数据传输的中断 下图给出了在不同 TCP 重传定时器的设置下，以太网丢帧率对网络响应性能的影响，例如：对于 5s 的 TCP 重传确认定时器，1% 的丢帧率就将导致网络响应性能降低 98% 可以看出，即使有 TCP 重传机制，在丢帧率达到一定水平后，网络响应性能仍然会出现急剧的下降 产生原因产生拥塞的原因有两个：过载、线端阻塞 过载是交换机外出端口产生拥塞的主要原因，但不是所有外出端口的拥塞都是由过载引起的 线端阻塞是因某个外出端口上的拥塞而阻碍了其他通往非拥塞端口流量的现象，对于在输入队列中采用共享存储的交换机，当队列头有转发到阻塞端口的帧时，造成后继转发到非阻塞端口帧也必须等待，当然，对于那些采用输出排队的交换机，是不会出现线端阻塞的 拥塞控制机制背压背压是指，当输出端口出现拥塞现象时，被交换机用来通知发送端降低帧发送速度，以阻止外部数据源继续向拥塞端口传输帧的方法 简单来说，就是在半双工方式下，通过向发送源发送拥塞信号使得信息源降低发送速度 例如：若一台 100Mbps 服务器通过交换机将数据发送给一个 10Mbps 的客户机，该交换机将尽可能多地缓冲其帧，一旦交换机的缓冲器装满，它就通知服务器停止发送 有两种方法可以达到这一目的： 交换机可以强行制造一次与服务器的碰撞，使得服务器退避 交换机通过插入一次载波检测，使得交换机的端口保持繁忙，这样就能使服务器感觉到交换机要发送数据一样 利用这两种方法，服务器都会在一段时间内停止发送，从而允许交换机去处理积聚在它的缓冲器中的数据 背压机制使发送到拥塞端口的流量得到减缓，但可能会导致到非拥塞输出端口的发送流量也被减缓 在全双工环境中，服务器和交换机之间的连接是一个无碰撞的发送和接收通道，没有碰撞检测，这样就不允许交换机去产生一次冲突而使得服务器停止发送，服务器将一直发送到交换机的帧缓冲器溢出 前压当上游设备以小于最小帧间隙的间隔或以超过线速的速率向下游交换机发送流量时，往往会导致下游交换机出现接收缓冲溢出甚至阻塞 前压是指，某些交换机通过减缓输出队列的饱和程度、禁止上游设备发送帧等强制性机制来消除或减少上述丢帧现象 正常情况下，在处理交换机内部共享资源争用时，会使用类似 CSMA/CD 协议中的后退算法，但在具备前压机制的交换机中，当对资源的争用加剧时，会通过禁用或放弃后退算法来获得对共享介质如缓存的强行访问，来加快帧的转发，并借此减轻输出队伍的拥塞或饱和程度 需要注意的是，前压机制不是以太网标准所推荐的，故不是所有的交换机都提供前压机制 地址处理地址缓存容量：交换机的 MAC 地址表中可以最多存储的 MAC 地址数量，存储的 MAC 地址数量越多，那么数据转发的速度和效率也就越高 地址学习速率：交换机在不用丢弃数据帧的情况下，可以学习新的 MAC 地址的速度，该指标用于网络重启后地址表的建立速度 错误帧过滤错误帧是指所有过长、过短、错位、含有错误校验序列的帧 IEEE802.3 标准规定以太网帧的合法长度为 64~1518B，长度小于 64B 的帧称为过短帧，长度大于 1518B 的帧称为过长帧，由物理传输过程中位错引起的帧称为错位帧，因帧中含有错误的 CRC 码而不能通过的校验的帧称为含有错误校验序列的帧 错误帧过滤可减少或避免因传输错误帧而产生的带宽浪费，以及后续转发设备因处理这些错误帧而付出不必要的资源消耗 广播当交换机的输入端口收到一个帧，并且在地址表中找不到与帧的目的 MAC 地址所对应的目的端口时，就会采用向所有端口洪泛广播的方法来转发该帧 常规用两个指标来衡量交换机的广播性能： 广播转发速率：一台交换设备在某个指定的广播负载下，一秒内向它所在广播域的所有端口发送的广播帧的数量 广播时延：交换机将广播帧转发到位于同一个广播域中的每个端口所需的时间 流量隔离流量隔离是用于衡量交换机对于 VLAN 流量隔离的功能的指标 VLAN 的最大特点就是它实现了不同 VLAN 间的流量隔离，每个 VLAN 都是一个独立的广播域，当交换机收到广播数据时，将在本 VLAN 中广播，不会广播到其它 VLAN 不同 VLAN 中的节点，相互之间不能直接进行流量的转发，即使是位于同一交换机上的两个端口，只要不在同一 VLAN 中，相互之间也不能渗透流量","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"以太网技术","slug":"network-testing/18.以太网技术","date":"2020-08-12T06:20:00.000Z","updated":"2021-08-23T13:01:34.158Z","comments":true,"path":"notes/network-testing/91de49b6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/91de49b6.html","excerpt":"【以太网技术发展】 名称 带宽 拓扑 组网方式 标准 适用范围 标准以太网 10M 总线、星型 共享、交换 IEEE 802.3 局域网 快速以太网 100M 星型 共享、交换 IEEE 802.3u 局域网 千兆以太网 1G 星型 交换 IEEE 802.3z、IEEE 802.3ab 局域网 万兆以太网 10G 星型、点对点 交换 IEEE 802.3ae 局域网、城域网","text":"【以太网技术发展】 名称 带宽 拓扑 组网方式 标准 适用范围 标准以太网 10M 总线、星型 共享、交换 IEEE 802.3 局域网 快速以太网 100M 星型 共享、交换 IEEE 802.3u 局域网 千兆以太网 1G 星型 交换 IEEE 802.3z、IEEE 802.3ab 局域网 万兆以太网 10G 星型、点对点 交换 IEEE 802.3ae 局域网、城域网 【共享以太网与交换以太网】共享以太网早期的以太网采用基于总线结构的共享广播式网络，以及基于集线器的星型拓扑，在以太网中，数据以帧的形式传输 共享式以太网是基于广播的方式来发送数据的，因为集线器不能识别帧，所以它就不知道一个端口收到的帧应该转发到哪个端口，它只好把帧发送到除源端口以外的所有端口 在这种工作方式下，所有设备与节点位于同一个冲突域，同一时刻网络上只能传输一组数据帧的通讯，对共享介质的争用造成节点间的碰撞或冲突，如果发生碰撞还得重试，影响了网络的运行性能 交换以太网通常，解决共享以太网存在的问题就是利用分段的方法，即将一个大型的以太网分割成两个或多个小型的以太网，使各网段成为隔离开的冲突域 交换以太网是借助交换的思想，在数据链路层的帧为数据交换单位，以以太网交换机为基础构成的网络，允许多对节点同时通信，每个节点可以独占传输通道和带宽，交换机为星状拓扑或扩展星状拓扑的中心节点 交换机的冲突域仅局限于交换机的一个端口上 【以太网交换机】工作原理交换机具有基于 MAC 地址进行帧过滤和转发的能力，其可以学习 MAC 地址，并将其存放在内部缓存的地址表中，该表给出关于交换机不同接口所连主机的 MAC 地址信息 交换机收到一个数据帧后，能够识别出这个帧的结构，根据帧的目的地址，将这个帧转发到对应的某个端口上去，而不是广播到其它所有的端口 根据帧中的目的地址，通过查找地址表决定转发行为： 若地址表显示目的节点与源节点位于交换机的同一端口，忽略帧 若地址表显示目的节点在交换机所连的某一端口，且与源节点不在 同一端口，转发到目的端口 若目的 MAC 地址为广播地址，向除源端口外的所有端口转发帧 若地址表中找不到目的地址，向除源端口外的所有端口转发帧 交换机体系结构背板是交换机的中央交换部件，用于交换机的各个端口之间传送数据，背板的结构和容量决定了一个交换机的性能 交换机背板主要有三种结构： 共享总线（Shared-bus） 共享存储（Shared-memory） 交叉矩阵（Cross-bar） 共享总线型交换端口通过 ASIC 芯片同高速总线相连，数据由端口传输至 ASIC 芯片，ASIC 芯片根据目的地址通过高速总线将数据传至目的端口 为了解决多个端口并发访问共享数据总线所产生的竞争或冲突，还引入了仲裁机制 在数据交换的具体实现上，可以选择分布式或集中式 集中式交换方式：由交换机的中心处理器保存端口与目的 MAC 地址的映射表，一旦某端口接收到分组，该端口将该分组中的目的 MAC 地址通过高速总线送至交换机仲裁处理器，仲裁处理器通过访问中央数据库，确定 MAC 地址所对应的目的交换端口，然后仲裁处理器对共享总线进行控制，使得来自源端口的数据帧经由共享总线传至目的端口 分布式交换方式：每个端口在本地维持一个端口与目的 MAC 地址的映射表，当数据进入交换机端口时，由该端口的 ASIC 芯片截获分组的目的 MAC 地址，ASIC 芯片将该地址在本地数据库中检索，寻找对应的目的端口： 如果发现目的端口，就将分组通过共享总线发送至目的端口 如果没有发现目的端口，该端口将目的 MAC 地址发送至所有的交换端口，由知道该目的 MAC 地址的交换端口通知源端口，然后再进行数据交换 共享存储器共享存储器使用一个全局共享存储池进行数据传输交换 进入交换机的数据首先存储在共享 RAM 中，共享 RAM 一般由专用集成电路（ASIC）芯片管理 ASIC 芯片通过查找地址表，找到与目的地址对应的目的端口，然后将数据发送至所对应的目的端口 共享内存结构实现简单，但受内存容量与速度限制，无法支持大容量交换，一般限制在 20G-80G，且交换延时比较大 交叉矩阵型早期的交叉结构中，所有的端口连接汇聚到一个交叉点，数据传输通过交叉点进行，当交叉点正在进行端口交换时，端口输入的数据必须暂时存储在输入端口的本地缓存中，等待别的数据传输结束后，再传输至目的端口，这使得当端口数据量大、网络负载重的情况下，会因交叉点的瓶颈而造成阻塞 为此提出了纵横式交换矩阵的结构，它是大容量高端交换机中普通采用的结构，通过内部的交换矩阵和仲裁矩阵实现了无阻塞交换 这种方式可以明显地看出其效率很高，不会浪费网络资源，只是对目的地址发送数据，一般来说不易产生网络堵塞，另一方面数据传输十分安全，因为它不是对所有节点都同时发送，发送数据时其它节点很难侦听到所发送的信息 转发方式交换机将数据从一个端口转发至到另一个端口的处理方式称为转发方式，又被称为交换模式 常见的转发方式有两种： 直接交换（cut-through） 存储转发（store-and-forward） 在实际交换机中，通常引入智能控制方式来进行选择，通过设置帧错误率的阈值，先采用直接交换，一旦帧错误率超过阈值，改用存储转发 直接交换快速转发方式在快速转发交换方式下，交换机只读出数据帧的前 6 个字节，即交换机确定目的 MAC 地址，就会查找转发表，将数据帧传输到相应的输出端口，将帧发出去 快速转发方式在转发帧的过程中不能有任何间隙，而任何时候从低速率转换到高速率时都会有一个间隙，除非使用某种类型的缓冲，这就导致其存在两个问题： 会转发小于 64 字节的破碎帧和错误帧 要求交换机的所有端口要以同样的速率工作 也就是说，如果交换机的大部分端口是 10Mbps 的，那么这台交换机上就不能有快速以太网的端口 该方法转发速率快，减少了时延，提高了整体吞吐率，但不提供帧的错误检测，在整个帧还未全部接收到之前就开始转发帧，因此错误帧也会被转发出去，导致网络资源的浪费 其具有最小的时延，适用于网络链路质量较好、错误数据包较少的网络环境 无碎片交换方式在无碎片交换方式下，交换机通过对无效碎片帧过滤来降低直接交换错误帧的概率 它检查数据包的长度是否够 64 个字节，如果小于 64 字节，说明是碎片帧，则丢弃该帧；如果大于等于64字节，则发送该帧 该方法数据处理速度比存储转发方式快，但相较于快速转发交换方式来说较慢，适用于一般的通讯链路 存储转发在存储转发时，交换机将帧向目的端口转发之前要先接收完整的帧，将数据帧存储到缓冲器中，进行 CRC 循环冗余校验，如果这个数据包有 CRC 错误，则该包将被丢弃；如果数据包完整，交换机查询地址映射表将其转发至相应的端口 该方法会过滤所有的错误帧，没有残缺数据包转发，减少不必要的数据转发，但由于存在 CRC 循环冗余校验，使得转发速率比直接转发方式慢，适用于普通链路质量或较为恶劣的网络环境","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"Elementary","slug":"daily/05.Elementary","date":"2020-08-10T20:21:00.000Z","updated":"2021-09-22T08:07:53.004Z","comments":true,"path":"essay/daily/b487462d.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/b487462d.html","excerpt":"前不久才发现 Elementary 在去年已经全剧完结了，刚刚才补完最后一集。 从 2012 到 2019，七年，七季，154 集。 或许在大多数人眼里，《神探夏洛克》中的 Sherlock 和 Watson 才更满足他们心中的那个想象。","text":"前不久才发现 Elementary 在去年已经全剧完结了，刚刚才补完最后一集。 从 2012 到 2019，七年，七季，154 集。 或许在大多数人眼里，《神探夏洛克》中的 Sherlock 和 Watson 才更满足他们心中的那个想象。 但不知怎得，我更偏爱于 Elementary 的 Sherlock 和 Watson，或许是因为这部剧的本质跟原著没有太大关系，只是借用 IP 来讲述了一个关于救赎的故事。 从第一季第一集的 Sherlock 初见 Watson 的第一句话 “Do you believe in love at first sight?” 到最后一季最后一集的 “As long as we are together, what does it matter?”，本是戏谑之言，谁料一语成谶。 我不知该如何形容他们之间的关系，Platonic love 或是 Soulmate 都不那么准确，拥抱是他们做过最亲密的事，但这种无关情欲的行为却是他们关系的注脚——超出情欲的陪伴与爱。 最后的开放式结局也算是最好的结局了，好像这么多年的过往只是描述了一段 Sherlock 和 Watson 的生命历程。 总之，感谢 Elementary 这些年的陪伴。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"Stacking 堆叠法","slug":"ensemble-learning/09.Stacking堆叠法","date":"2020-08-09T13:09:00.000Z","updated":"2023-04-08T13:40:10.712Z","comments":true,"path":"artificial-intelligence/ensemble-learning/9cabc15d.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/9cabc15d.html","excerpt":"References： Stacking：集成学习策略图解 典型 Stacking 方法图解 集成学习-Boosting,Bagging与Stacking 典型 Stacking 方法图解 机器学习中的集成方法（4）—Stacking（堆叠法） 模型融合(集成算法) - 堆叠法 Stacking 【Stacking】Stacking 堆叠法，是集成学习的经典算法之一，其属于异质学习，能够有效融合多个学习器的结果","text":"References： Stacking：集成学习策略图解 典型 Stacking 方法图解 集成学习-Boosting,Bagging与Stacking 典型 Stacking 方法图解 机器学习中的集成方法（4）—Stacking（堆叠法） 模型融合(集成算法) - 堆叠法 Stacking 【Stacking】Stacking 堆叠法，是集成学习的经典算法之一，其属于异质学习，能够有效融合多个学习器的结果 其工作原理是：利用训练集学习出若干个基学习器后，将这几个学习器的预测结果作为新的训练集，然后再利用这个新的训练集去学习一个新的学习器 其中，将利用训练集学习的基学习器称为初级学习器，将利用新的训练集学习的学习器称为次级学习器或元学习器 这样做的直觉在于，不同的模型能够提取数据中不同的信息，由于噪声的存在，不同的模型往往会在数据的不同特征上表现很好，但是也各有表现较差的部分 Stacking 能够把各个模型在提取特征较好的部分给抓取出来，同时舍弃它们各自表现不好的部分，这就能够有效地优化预测结果，提高最终预测的分数 此外，可以发现，Stacking 就像是 Bagging 的升级版，Bagging 中各个体学习器的结合是相同权重，Stacking 的结合是利用了一个学习器来寻找合适的组合方式 【构建不同个体学习器的方法】对于 Stacking 来说，其可以分为两层，第一层是各异质学习器，第二层是一个结合学习器 对于第一层来说，要想构建不同的个体学习器，有如下三种方法： 利用不同的机器学习算法 在不同的数据上训练 基于不同的随机种子训练 【验证策略】在 机器学习的模型选择 中，介绍了需要将数据集分为训练集、验证集、测试集三个部分 其中，训练集用于训练模型，验证集用于模型选择，即衡量同一个模型的不同参数的表现，以挑选一个模型的中最优的参数，测试集用于对学习方法进行评估，即用来比较不同的模型进而选择最优模型 在 Stacking 中，也要相应地配置这三个集合，由此就衍生出了不同的 Stacking 验证策略，如：简单留出法、基于 Fold 外超特征的高阶留出法等，这里不再详细介绍 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现 Stacking 堆叠法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.svm import LinearSVCfrom sklearn.pipeline import make_pipelinefrom sklearn.linear_model import LogisticRegressionfrom sklearn.ensemble import StackingClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立 Stacking 堆叠模型 estimators = [ ('rf', RandomForestClassifier(n_estimators=10, random_state=42)), ('svr', make_pipeline(StandardScaler(), LinearSVC(random_state=42)))] model = StackingClassifier(estimators=estimators, final_estimator=LogisticRegression()) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"OTDR 测试","slug":"network-testing/17.OTDR测试","date":"2020-08-07T07:35:00.000Z","updated":"2021-08-23T13:01:43.501Z","comments":true,"path":"notes/network-testing/8c6a0650.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/8c6a0650.html","excerpt":"【OTDR 工作原理】光功率计只能测试光功率损耗，如果要确定损耗的位置和损耗的起因，就要采用光时域反射仪(OTDR) 当光脉冲在光纤内传输时，会由于光纤本身的性质、连接器、接合点、弯曲或其它类似的事件而产生散射、反射。其中一部分的散射和反射就会返回到 OTDR 中，这些返回到入射端的光信号中包含有损耗信息，经过适当的耦合、探测和处理，就可以分析到光脉冲所到之处的光纤损耗特性","text":"【OTDR 工作原理】光功率计只能测试光功率损耗，如果要确定损耗的位置和损耗的起因，就要采用光时域反射仪(OTDR) 当光脉冲在光纤内传输时，会由于光纤本身的性质、连接器、接合点、弯曲或其它类似的事件而产生散射、反射。其中一部分的散射和反射就会返回到 OTDR 中，这些返回到入射端的光信号中包含有损耗信息，经过适当的耦合、探测和处理，就可以分析到光脉冲所到之处的光纤损耗特性 OTDR 测试是通过发射光脉冲到光纤内，然后在 OTDR 端口接收返回的信息（花费的时间、反射功率等）来进行 【OTDR 结构】OTDR 仪表主要是由脉冲发生器、光源、光定向耦合器、光纤连接器、光电检测器、放大器、内部时钟、信号处理器、显示器等几部分组成 脉冲发生器的功能是产生所需要的规则的电脉冲信号 光源的功能是将电信号转换成光信号，即将脉冲发生器产生的电脉冲转换为光脉冲进行测试使用 光定向耦合器的功能是使光按照规定的特定方向输出输入 光纤连接器的功能是将 OTDR 仪表与被测光纤相连接 光电检测器的功能是将光信号转换成电信号，即将经光定向耦合器传来的背向散射光转换成电信号 放大器的作用是将光电检测器转换的微弱电信号进行放大，以便处理 内部主时钟一方面为脉冲发生器提供时钟，使其有频率的产生电脉冲信号 内部主时钟另一方面为信号处理器提供工作频率，使其处理频率与脉冲频率保持同步 信号处理器是对由背向散射光转换的含有光纤特性的电信号进行平均化处理，即可以长时间测量信号进行信号处理提高信噪比 显示器的功能是将处理后的结果显示出来 综上，OTDR 工作流程如下： 【测试事件】OTDR 可以测试熔接、弯曲、活动连接器、机械固定接头、断裂、光纤末端，其测试曲线显示如下： 非反射事件光纤熔接、弯折会导致光功率衰耗，但是没有反射现象，它们在 OTDR 上具有相似的显示结果，统称为非反射事件 反射事件活动连接器、机械固定接头、光纤断裂都会引起光的反射和衰耗，它们在 OTDR 上有相似的显示结果，统称为反射事件 光纤末端光纤末端又称光纤尾端，其在 OTDR 上显示结果较为特殊，单独划分为一类事件 光纤末端的曲线有两种情况： 反射幅度较高的菲涅尔反射 曲线从背向反射电平简单地降到 OTDR 噪声电平以下 【OTDR 用途】光功率损耗起始反射结束段与测试结束点电平的高度差 光纤长度通过获得光纤长度信息，来辅助衰减测量 光纤衰减光纤衰减定义为链路损耗与长度的比值，单位为：dB/km 其两种评价方法： 两点衰减：两点损耗与长度的比值 两点最小二乘法衰减：为降低曲线波动性影响，而采取的数学分析方法，在两点间取一条近似逼近直线 插入损耗连接点的损耗值，对应熔接点即为熔接损耗 反射评价连接器的连接质量 故障位置通过可见红外光光故障定位仪来辅助检测","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"GBDT 梯度提升决策树","slug":"ensemble-learning/08.GBDT梯度提升决策树","date":"2020-08-06T05:36:00.000Z","updated":"2023-04-06T13:39:30.873Z","comments":true,"path":"artificial-intelligence/ensemble-learning/d6340b9d.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/d6340b9d.html","excerpt":"References： 简单易学的机器学习算法——梯度提升决策树GBDT 机器篇——集成学习(六) 细说 GBDT 算法 【GBDT 梯度提升决策树】梯度提升决策树（Gradient Boosting Decision Tree，GBDT）是 Boosting 算法族的一种，其可认为是学习算法采用梯度提升法的提升树","text":"References： 简单易学的机器学习算法——梯度提升决策树GBDT 机器篇——集成学习(六) 细说 GBDT 算法 【GBDT 梯度提升决策树】梯度提升决策树（Gradient Boosting Decision Tree，GBDT）是 Boosting 算法族的一种，其可认为是学习算法采用梯度提升法的提升树 关于梯度提升法，详见：Boosting 提升法 关于提升树，详见：提升树 【GBDT 回归算法】CART 回归树对于回归问题，设给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{-1,+1\\}$ 依照 CART 回归树，将输入空间 $\\mathcal{X}$ 划分为 $K$ 个互不相交的区域 $R_1,R_2,\\cdots,R_K$，并且在每个区域上确定输出的常量 $c_k$，那么决策树可表示为： G(\\mathbf{x}) = \\sum_{k=1}^K c_k \\mathbb{I}(\\mathbf{x}\\in R_k)其中，$K$ 为回归树的复杂度即叶结点个数，$\\{(R_1,c_1),(R_2,c_2),\\cdots,(R_K,c_K)\\}$ 为树的区域划分和各区域上的最优值 关于 CART 回归树，详见：决策树的 CART 生成算法 梯度提升法对于梯度提升决策树，使用梯度提升法进行学习，即： \\begin{gather*} G_0(\\mathbf{x}) = \\arg \\min_{c} \\sum_{i=1}^n L(y_i,c) \\\\ G_t(\\mathbf{x}) = G_{t-1}(\\mathbf{x}) + \\triangledown G_t(\\mathbf{x}),\\quad t=1,2,\\cdots,T \\\\ \\triangledown G_t(\\mathbf{x}) = \\Big[- \\frac{\\partial L(y,G(\\mathbf{x}))}{\\partial G(\\mathbf{x})} \\Big]_{G(\\mathbf{x})=G_{t-1}(\\mathbf{x})}\\\\ f(\\mathbf{x}) = \\sum_{t=1}^T G_t(\\mathbf{x}) \\\\ \\end{gather*}对于梯度提升法的第 $t$ 轮来说，给定当前模型 $G_{t-1}(\\mathbf{x})$，需求解： (R_t^*,c_t^*) = \\arg\\min_{R_t,c_t} \\sum_{i=1}^n L\\big(y_i,G_{t-1}(\\mathbf{x}_i)+\\triangledown G_t(\\mathbf{x}_i)\\big)得到第 $t$ 棵树的参数，即第 $t$ 棵树的区域划分和各区域上的最优值 由于采用梯度提升法，因此只需要简单地拟合当前模型的负梯度 $\\triangledown G_t(\\mathbf{x}) = \\Big[- \\frac{\\partial L(y,G(\\mathbf{x}))}{\\partial G(\\mathbf{x})} \\Big]_{G(\\mathbf{x})=G_{t-1}(\\mathbf{x})}$ 即可 算法流程下面给出回归问题的 GBDT 算法的算法流程 输入：容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}\\subset \\mathbb{R}$ 输出：梯度提升树 $f(\\mathbf{x})$ Step1：初始化 $G_0(\\mathbf{x})$ G_0(\\mathbf{x}) = \\arg \\min_{c} \\sum_{i=1}^n L(y_i,c)此时，$c$ 为根结点上的最优值 Step2：对 $t=1,2,\\cdots,T$ 1）计算负梯度 \\triangledown G_{ti}(\\mathbf{x}) = \\Big[- \\frac{\\partial L(y,G(\\mathbf{x}_i))}{\\partial G(\\mathbf{x}_i)} \\Big]_{G(\\mathbf{x}) =G_{t-1}(\\mathbf{x})},\\quad i=1,2,\\cdots,n2）根据 CART 算法，对负梯度 $\\triangledown G_{ti}(\\mathbf{x}) $ 学习一个回归树，得到树的区域划分 $\\{R_{t1},R_{t2},\\cdots,R_{tK}\\}$ 3）根据树的区域划分 $R_{tk}$ ，计算各区域上的最优值 $\\{c_{t1},c_{t2},\\cdots,c_{tK}\\}$ c_{tk} = \\arg \\min_{c} \\sum_{\\mathbf{x}_i\\in R_{tk}} L(y_i,G_{t-1}(\\mathbf{x}_i)+c)4）更新回归决策树 G_t(\\mathbf{x}) = G_{t-1}(\\mathbf{x}) + \\sum_{k=1}^K c_k \\mathbb{I}(\\mathbf{x}\\in R_{tk})Step3：根据加法模型得到最终的梯度提升树 f(\\mathbf{x}) = \\sum_{t=1}^T G_t(\\mathbf{x})【GBDT 分类算法】分类问题的 GBDT 算法思想上来说与回归问题 GBDT 算法没有区别，但是由于分类问题样本输出不是连续的值，而是离散的类别，这导致无法直接从输出类别去拟合类别输出的误差 为了解决这个问题，主要有两个方法： 使用指数损失函数：此时 GBDT 算法退化为 AdaBoost 算法 使用对数损失函数：用类别的预测概率值和真实概率的差来拟合损失 关于 AdaBoost 分类算法，详见：AdaBoost 算法 【GBDT 的正则化】为防止过拟合，GBDT 与 AdaBoost 一样，需要进行正则化 GBDT 的正则化主要有三种方式： 1）对于梯度上升法的更新 $G_t(\\mathbf{x}) = G_{t-1}(\\mathbf{x}) + \\sum\\limits_{k=1}^K c_k \\mathbb{I}(\\mathbf{x}\\in R_{tk})$，有： G_t(\\mathbf{x}) = G_{t-1}(\\mathbf{x}) + \\mu\\sum_{k=1}^K c_k \\mathbb{I}(\\mathbf{x}\\in R_{tk})其中，$\\mu \\in (0,1]$ 即为学习率 2）通过子采样（Subsample） 比例限制，取值 $(0,1]$ 如果取值为 $1$，则说明使用全部样本，相当于没有采用子采样；如果取值小于 $1$，说明只有一部分样本会进行 GBDT 的决策树拟合 需要注意的是，这里的子采样和随机森林不一样，随机森林使用的是有放回抽样，而这里是不放回抽样 3）对弱学习器，即 CART 回归树进行正则化剪枝 【sklearn 实现】GBDT 回归算法以 sklearn 中的波士顿房价数据集为例，选取其后两个特征来实现 GBDT 回归算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.ensemble import GradientBoostingRegressorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立GBDT回归模型 model = GradientBoostingRegressor(n_estimators=300, learning_rate=0.005, max_depth=4, max_features='sqrt', min_samples_leaf=15, min_samples_split=10, loss='ls') # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model) GBDT 分类算法以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现 AdaBoost 分类算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.ensemble import GradientBoostingClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立 GBDT 分类模型 model = GradientBoostingClassifier(n_estimators=200, learning_rate=0.8, max_depth=4, max_features='sqrt', min_samples_leaf=15, min_samples_split=10) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"提升树","slug":"ensemble-learning/07.提升树","date":"2020-08-05T05:50:00.000Z","updated":"2023-04-06T13:38:07.377Z","comments":true,"path":"artificial-intelligence/ensemble-learning/31e7ce3c.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/31e7ce3c.html","excerpt":"References： 深入理解提升树（Boosting tree）算法 集成学习(Ensemble Learning)——提升树（Boosting Tree） 统计学习方法—提升树模型（Boosting Tree）与梯度提升树（GBDT） 【提升树】提升树（Boosting Tree）是 Boosting 算法族的一种","text":"References： 深入理解提升树（Boosting tree）算法 集成学习(Ensemble Learning)——提升树（Boosting Tree） 统计学习方法—提升树模型（Boosting Tree）与梯度提升树（GBDT） 【提升树】提升树（Boosting Tree）是 Boosting 算法族的一种 对于 Boosting 提升法的加法模型： f(\\mathbf{x}) = \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x})当基函数 $G_t(\\mathbf{x})$ 为决策树，且基函数系数 $\\alpha_t=1$ 时，为提升树模型，即： f(\\mathbf{x}) = \\sum_{t=1}^T G_t(\\mathbf{x})关于 Boosting 算法，详见：Boosting 提升算法 【提升树的回归算法】CART 回归树对于回归问题，设给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}\\subset \\mathbb{R}$ 依照 CART 回归树，将输入空间 $\\mathcal{X}$ 划分为 $K$ 个互不相交的区域 $R_1,R_2,\\cdots,R_K$，并且在每个区域上确定输出的常量 $c_k$，那么决策树可表示为： G(\\mathbf{x}) = \\sum_{k=1}^K c_k \\mathbb{I}(\\mathbf{x}\\in R_k)其中，$K$ 为回归树的复杂度即叶结点个数，$\\{(R_1,c_1),(R_2,c_2),\\cdots,(R_K,c_K)\\}$ 为树的区域划分和各区域上的最优值 关于 CART 回归树，详见：决策树的 CART 生成算法 前向分步法对于提升树算法，使用前向分步法进行求解，即： \\begin{gather*} f_0(\\mathbf{x}) = 0 \\\\ f_t(\\mathbf{x}) = f_{t-1}(\\mathbf{x}) + G_t(\\mathbf{x}),\\quad t=1,2,\\cdots,T \\\\ f(\\mathbf{x}) = \\sum_{t=1}^T G_t(\\mathbf{x}) \\\\ \\end{gather*}对于前向分步法的第 $t$ 步来说，给定当前模型 $f_{t-1}(\\mathbf{x})$，需求解： (R_t^*,c_t^*) = \\arg\\min_{R_t,c_t} \\sum_{i=1}^n L\\big(y_i,f_{t-1}(\\mathbf{x}_i)+G_t(\\mathbf{x}_i)\\big)得到第 $t$ 棵树的参数，即第 $t$ 棵树的区域划分和各区域上的最优值 当采用平方损失函数 $L(y,f(\\mathbf{x}))=(y-f(\\mathbf{x}))^2$ 时，损失变为： \\begin{align*} L(y,f(\\mathbf{x})) &= L\\big(y,f_{t-1}(\\mathbf{x})+G_t(\\mathbf{x})\\big) \\\\ &= \\big[y-f_{t-1}(\\mathbf{x})-G_t(\\mathbf{x})\\big]^2\\\\ &= \\big[ r-G_t(\\mathbf{x}) \\big]^2 \\end{align*}其中，$r=y-f_{t-1}(\\mathbf{x})$ 为当前模型 $G_t(\\mathbf{x})$ 拟合数据的残差（Residual） 因此，对于回归问题的提升树来说，只需要简单地拟合当前模型 $G_t(\\mathbf{x})$ 的残差即可 算法流程下面给出回归问题的提升树的算法流程 输入：容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}\\in \\mathbb{R}$ 输出：提升树 $f(\\mathbf{x})$ 算法流程： Step1：初始化 $f_0(\\mathbf{x})$ f_0(\\mathbf{x})=0Step2：对 $t=1,2,\\cdots,T$ 1）计算残差 r_{ti} = y_i - f_{t-1}(\\mathbf{x}_i),\\quad i=1,2,\\cdots,n2）根据 CART 算法，对残差 $r_{ti}$ 学习一个回归树，得到树的区域划分 $\\{R_{t1},R_{t2},\\cdots,R_{tK}\\}$ 3）根据树的区域划分 $R_{tk}$ ，计算各区域上的最优值 $\\{c_{t1},c_{t2},\\cdots,c_{tK}\\}$ c_{tk} = \\arg \\min_{c} \\sum_{\\mathbf{x}_i\\in R_{tk}} L(y_i,f_{t-1}(\\mathbf{x}_i)+c)4）得到回归决策树 G_t(\\mathbf{x}) = \\sum_{k=1}^K c_k \\mathbb{I}(\\mathbf{x}\\in R_{tk})5）更新回归决策树 f_t(\\mathbf{x}) = f_{t-1}(\\mathbf{x})+G_t(\\mathbf{x})Step3：根据加法模型得到最终的提升树 f(\\mathbf{x}) = \\sum_{t=1}^T G_t(\\mathbf{x})【提升树的分类算法】对于分类问题，提升树算法可以看作是 AdaBoost 分类算法的特例，这里不再赘述 关于 AdaBoost 分类算法，详见：AdaBoost 算法","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"光纤衰减的测量","slug":"network-testing/16.光纤衰减的测量","date":"2020-08-04T14:44:00.000Z","updated":"2021-08-23T13:34:41.757Z","comments":true,"path":"notes/network-testing/7182a35e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/7182a35e.html","excerpt":"【概述】对光纤链路衰减的测量方法以截断法为基准，插损法和背向散射法为替代方法 其中，截断法和插损法通常用光功率计测试，背向散射法通常用 OTDR 测试","text":"【概述】对光纤链路衰减的测量方法以截断法为基准，插损法和背向散射法为替代方法 其中，截断法和插损法通常用光功率计测试，背向散射法通常用 OTDR 测试 【截断法】截断法是一种测量精度最好的方法，但其缺点是要截断光纤，其测量方法为：在不改变注入条件下，分别测出通过光纤两个点的光功率 $P(z_1)$ 和 $P(z_2)$，再按定义计算出光纤的衰减系数 $α$ 测量步骤如下： 测试按下图所示进行连接 取一条被测的长光纤接入测量系统中，并在下图中位置 2 用光功率计测出该点的光功率 $P(z_2)$ 保持光源的输入状态不变，在离被测光纤输入端 2m 的 1 点处，将光纤截断 测量 1 点处的光功率 $P(z_1)$ 当知道 1、2 两点间的距离 $L=z_2-z_1$，即可算出这段光纤的平均衰减系数 $α=\\frac{10}{L}lg\\frac{P(z_1)}{P(z_2)}\\:\\:dB/km$ 【插损法】对已敷设的光缆，可用插入损耗法来进行衰减测试，即用一个光功率计和一个光源来测量两个功率的差值，第一个是从光源注入到光缆的能量，第二个是从光缆段的另一端射出的能量 测量时为确定光纤的注入功率，必须对光源和功率计进行校准，校准后的结果可为所有被测光缆的光功率损耗测试提供一个基点，测得了两个功率就可以计算光纤链路的损耗 校准光功率计的目的是确定进入光纤段的光功率大小，校准光功率时，用两个测试用光缆跳线把功率计和光源连接起来，用参照适配器（耦合器）把测试用光缆跳线两端连接起来，此时测量出的功率 $P1$ 就相当于是发送部分的入纤功率 测量步骤如下： 测试按下图所示进行连接 测试连接前应对光缆连接的插头、插座进行清洁处理，防止由于接头不干净带来附加损耗，造成测试结果不准确 向主机输入测量损耗标准值 操作测试仪，在所选择的波长上分别进行两个方向的光传输衰耗测试 报告在不同波长下不同方向的链路衰减测试结果，通过或失败","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"光纤衰减","slug":"network-testing/15.光纤衰减","date":"2020-08-03T09:41:00.000Z","updated":"2021-08-23T12:59:07.118Z","comments":true,"path":"notes/network-testing/8c4e84ae.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/8c4e84ae.html","excerpt":"【光功率】在光纤测量中，光功率是最基本的测量参数，通常使用光功率计来测量绝对光功率或通过一段光纤的光功率相对损耗 光功率的单位是分贝毫瓦 dbm，dBm 是一个表示功率绝对值的值，可以认为是以 1mw 功率为基准的一个比值，计算公式为：","text":"【光功率】在光纤测量中，光功率是最基本的测量参数，通常使用光功率计来测量绝对光功率或通过一段光纤的光功率相对损耗 光功率的单位是分贝毫瓦 dbm，dBm 是一个表示功率绝对值的值，可以认为是以 1mw 功率为基准的一个比值，计算公式为： 10lg\\frac{功率值 W}{1mw}举例来说，一个 $40W$ 的灯泡的光功率为： 10lg\\frac{40W}{1mW}=10lg40000=10lg4+10lg10^4=46dBm在测试出光功率后，即可得到以下几个参数： 灵敏度：接收端能够接收的最小光功率 动态范围：能够接收的最大光功率减去灵敏度 允许的光纤衰耗值：发光功率减去接收灵敏度 光纤衰耗：测试时实际的发光功率减去实际接收到的光功率 【光损耗】光纤损耗的大小由基准光功率与光功率计测得接收光功率的差值表示，其单位用分贝 dB 表示 目前，常使用稳定光源和光功率计结合使用测量光纤系统的光损耗，稳定光源是对光系统发射已知功率和波长的光的设备 光纤损耗的计算式为： L=P_1'-P_2'其中，$P_1’$ 为基准光功率，$P’$ 为光功率计测得光功率 由于光功率单位为 $dBm$，因此在光功率 $P’$ 与功率 $P$ 之间存在转换关系，即： P'=30+10lgP那么，有： \\begin{matrix} P_1'\\: dBm=30+10lgP_1 &P_2'\\: dBm=30+10lgP_2 \\end{matrix}那么，用一个 dBm 减另外一个 dBm 时，得到的结果是 dB，即： P_1'\\: dBm-P_2'\\: dBm=10lgP_1-10lg_P2=10lg\\frac{P_1}{P_2}【光功率的衰减】在光纤中传播的光亮度会随着传播距离的延长而变弱，如果光亮度用光功率来表示，这种亮度的变弱就会体现在光功率的衰减上 其取决于光纤的波长类型和长度，并受测量条件的影响，光纤中功率损耗用分贝 dB 来度量，光缆技术规范以每公里长度上的衰减，即 dB/km 来表示光缆损耗 一段光纤上相距距离为 $L$ 的两个横截面 1 和 2 之间的光功率的衰减 $A$ 定义为： A=10lg\\frac{P(z_1)}{P(z_2)}\\:\\: dB其中 $P(z_1)$ 与 $P(z_2)$ 分别为光纤在横截面 $z_1$ 和 $z_2$ 处的光功率 【衰减系数】通常，对于均匀光纤来说，可用单位长度的衰减，即衰减系数，来反映光纤衰减性能的好坏，衰减系数越大，光纤的损耗越大，衰减系数 $α$ 定义为： α=\\frac{10}{L}lg\\frac{P(z_1)}{P(z_2)}\\:\\:dB/km其中 $L=z_2-z_1$ 【波长的影响】不同波长的光，在光纤中的传输损耗也各不相同,下图描述了在某种光纤里，不同波长的光传输时的损耗情况 从图上可以看出，随着传输光的波长增长，光功率的衰减会相对减少，计算机网络常用的 850nm、1310nm、1550nm 三个波长的光在石英玻璃光纤中传输时，1550nm 波长具有最低损耗，通常用于长途传输","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"AdaBoost 自适应提升算法","slug":"ensemble-learning/06.AdaBoost自适应提升算法","date":"2020-08-03T04:36:11.000Z","updated":"2023-04-08T09:28:18.167Z","comments":true,"path":"artificial-intelligence/ensemble-learning/f5f50863.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/f5f50863.html","excerpt":"References： 机器学习之自适应增强(Adaboost) 机器篇——集成学习(四) 细说 AdaBoost 算法 手写adaboost的分类算法—SAMME算法 【AdaBoost 自适应提升算法】AdaBoost 算法是自适应提升（Adaptive Boosting）算法的缩写，其是 Boosting 算法族的一种","text":"References： 机器学习之自适应增强(Adaboost) 机器篇——集成学习(四) 细说 AdaBoost 算法 手写adaboost的分类算法—SAMME算法 【AdaBoost 自适应提升算法】AdaBoost 算法是自适应提升（Adaptive Boosting）算法的缩写，其是 Boosting 算法族的一种 其中，自适应（Adaptive）体现在前一个个体学习器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个个体学习器，同时在每一轮中加入一个新的弱学习器，直到得到某个预定的足够小的错误率或达到预定的最大迭代次数 对于 Bootsing 提升法的加法模型： f(\\mathbf{x}) = \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x})而 AdaBoost 算法是损失函数为指数损失函数 $\\exp(-yf(\\mathbf{x}))$ 的 Boosting 算法 关于 Boosting 算法，详见：Boosting 提升算法 【AdaBoost 的最优化问题】对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$，第 $t$ 轮从训练集中学习的弱学习器为 $G_t(\\mathbf{x})$ 假设经过 $t-1$ 轮前向分步法已经得到 $f_{t-1}(\\mathbf{x})$： \\begin{align*} f_{t-1}(\\mathbf{x}) &= f_{t-2}(\\mathbf{x})+\\alpha_{t-1} G_{t-1}(\\mathbf{x}) \\\\ &= f_{t-3}(\\mathbf{x})+\\alpha_{t-2} G_{t-2}(\\mathbf{x})+\\alpha_{t-1} G_{t-1}(\\mathbf{x}) \\\\ &\\quad\\quad\\quad\\quad\\quad\\quad\\quad \\vdots \\\\ &= \\alpha_1G_1(\\mathbf{x}) + \\alpha_2G_2(\\mathbf{x}) + \\cdots +\\alpha_{t-1}G_{t-1}(\\mathbf{x}) \\end{align*}在第 $t$ 轮迭代得到 $\\alpha_t$ 和 $G_{t}(\\mathbf{x})$，有： f_{t}(\\mathbf{x}) = f_{t-1}(\\mathbf{x}) + \\alpha_t G_t(\\mathbf{x})那么，现在的目标是使前向分步法得到的 $\\alpha_t$ 和 $G_t(\\mathbf{x})$ 使 $f(\\mathbf{x})$ 在训练集 $D$ 上的指数损失最小，即： (\\alpha_t^*,G_t^*(\\mathbf{x})) = \\arg\\min_{\\alpha,G} \\sum_{i=1}^n \\exp \\Big[-y_i \\big( f_{t-1}(\\mathbf{x}_i)+\\alpha G(\\mathbf{x}_i) \\big)\\Big]由于 $\\exp[-y_if_{t-1}(\\mathbf{x}_i)]$ 既不依赖于 $\\alpha$，也不依赖于 $G$，因此与最小化无关，故令 $\\omega_{ti}=\\exp[-y_if_{t-1}(\\mathbf{x}_i)]$，那么上式可表示为： (\\alpha_t^*,G_t^*(\\mathbf{x})) = \\arg\\min_{\\alpha,G} \\sum_{i=1}^n \\exp \\big[-y_i\\alpha G(\\mathbf{x}_i) \\big] \\cdot \\omega_{ti}需要注意的是，$\\omega_{ti}$ 依赖于 $f_{t-1}(\\mathbf{x})$，其会随着每一轮的迭代而发生改变 【AdaBoost 分类算法】参数优化对 AdaBoost 的最优化问题： (\\alpha_t^*,G_t^*(\\mathbf{x})) = \\arg\\min_{\\alpha,G} \\sum_{i=1}^n \\exp \\big[-y_i\\alpha G(\\mathbf{x}_i) \\big] \\cdot \\omega_{ti}当第 $t$ 轮从训练集中学习的弱学习器 $G_t(\\mathbf{x})$ 是分类器时，考虑如何达到最小的 $\\alpha_t^*$ 和 $G_t^*(\\mathbf{x})$ 对于 $G_t^*(\\mathbf{x})$，对 $\\forall \\alpha&gt;0$，使上式最小的 $G(\\mathbf{x})$ 由下式可得到： G_t^*(\\mathbf{x}) = \\arg\\min_G \\sum_{i=1}^n \\omega_{ti}\\mathbb{I}(y_i\\neq G(\\mathbf{x}_i))也就是说，$G_t^*(\\mathbf{x})$ 是使第 $t$ 轮训练数据分类误差率最小的分类器，即为 AdaBoost 分类算法的基本分类器 $G_t(\\mathbf{x})$ 之后，考虑 $\\alpha_t^*$，有： \\begin{align*} \\sum_{i=1}^n \\exp \\big[-y_i\\alpha G(\\mathbf{x}_i) \\big] \\cdot \\omega_{ti} &= \\sum_{i=1}^n \\omega_{ti} e^{-\\alpha} e^{-y_iG(\\mathbf{x}_i)} \\\\ &= \\sum_{y_i\\neq G_t(\\mathbf{x}_i)} \\omega_{ti}e^{\\alpha} + \\sum_{y_i=G_t(\\mathbf{x}_i)} \\omega_{ti} e^{-\\alpha} \\\\ &= \\sum_{i=1}^{n} \\omega_{ti}e^{\\alpha}\\mathbb{I}(y_i\\neq G_t\\big(\\mathbf{x}_i)\\big) + \\sum_{i=1}^n\\omega_{ti}e^{-\\alpha}\\Big[1-\\mathbb{I}\\big(y_i\\neq G(\\mathbf{x}_i)\\big)\\Big] \\\\ &= (e^\\alpha-e^{-\\alpha})\\sum_{i=1}^n \\omega_{ti} \\mathbb{I}\\big(y_i\\neq G(\\mathbf{x}_i)\\big) + e^{-\\alpha}\\sum_{i=1}^n\\omega_{ti} \\end{align*}将 $G_t^*(\\mathbf{x})$ 带入上式，并对 $\\alpha$ 求导，同时令导数为 $0$，有： (e^\\alpha+e^{-\\alpha})\\sum_{i=1}^n \\omega_{ti} \\mathbb{I}\\big(y_i\\neq G(\\mathbf{x}_i)\\big) - e^{-\\alpha}\\sum_{i=1}^n\\omega_{ti} =0对于二分类问题来说，第 $t$ 个弱分类器 $G_t(\\mathbf{x})$ 在训练集上的分类误差率为： \\text{error}_t = \\frac{\\sum\\limits_{i=1}^n \\omega_{ti} \\mathbb{I}(y_i\\neq G_t(\\mathbf{x}_i)) }{\\sum\\limits_{i=1}^n \\omega_{ti}} = \\sum_{i=1}^n \\omega_{ti} \\mathbb{I}(y_i\\neq G_t(\\mathbf{x}_i))那么，将上式展开并化简，有： \\begin{gather*} &(e^\\alpha+e^{-\\alpha})\\sum_{i=1}^n \\omega_{ti} \\mathbb{I}\\big(y_i\\neq G(\\mathbf{x}_i)\\big) - e^{-\\alpha}\\sum_{i=1}^n\\omega_{ti} =0 \\\\ \\Rightarrow & e^\\alpha \\sum_{i=1}^n \\omega_{ti} \\mathbb{I}\\big(y_i\\neq G(\\mathbf{x}_i)\\big) = e^{-\\alpha}\\sum_{i=1}^n\\omega_{ti} -e^{-\\alpha} \\sum_{i=1}^n \\omega_{ti} \\mathbb{I}\\big(y_i\\neq G(\\mathbf{x}_i)\\big) \\\\ \\Rightarrow & e^\\alpha \\text{error}_t = e^{-\\alpha}(1-\\text{error}_t) \\\\ \\end{gather*}对 $e^\\alpha \\text{error}_t = e^{-\\alpha}(1-\\text{error}_t)$ 两边同取 $\\ln$，有： \\alpha + \\ln \\text{error}_t = -\\alpha + \\ln (1-\\text{error}_t)可得使优化问题最小的 $\\alpha$，即： \\alpha_t^* = \\frac{1}{2} \\ln \\frac{1-\\text{error}_t}{\\text{error}_t}可以看出，如果分类误差率 $\\text{error}_t$ 越大，那么对应的弱分类器权重系数 $\\alpha_t$ 就越小，也就是说，误差率大的分类器权重系数越小 权重更新假设第 $t$ 个弱分类器的训练集权重系数为： D_{t} = \\{ \\omega_{t1},\\omega_{t2},\\cdots,\\omega_{tn} \\}那么，利用前向分步法的更新公式 $f_t(\\mathbf{x})=f_{t-1}(\\mathbf{x})+\\alpha_t G_t(\\mathbf{x})$，更新后的第 $t+1$ 个弱分类器的训练集权重系数为： \\omega_{t+1,i} = \\frac{1}{Z_t} \\omega_{ti} \\exp[-\\alpha_t y_i G_t(\\mathbf{x}_i)]其中，$Z_t=\\sum\\limits_{i=1}^n \\omega_{ti} \\exp[-\\alpha_t y_i G_t(\\mathbf{x}_i)]$ 被称为规范化因子，其保证了 $D_t$ 是一个概率分布 从上式可以看出，如果第 $i$ 个样本分类错误，那么 $y_iG_t(\\mathbf{x}_i)0$，导致样本权重在第 $t+1$ 个弱分类器中减小 分类器最终，根据学习器的加法模型： f(\\mathbf{x}) = \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x})即可得到最终分类器： G(\\mathbf{x})=\\text{sign}(f(\\mathbf{x})) = \\text{sign}\\Big( \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x}) \\Big)算法流程下面给出 AdaBoost 分类算法的算法流程 输入：对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$、弱分类算法 输出：分类学习器 $G(\\mathbf{x})$ 算法流程： Step1：初始化训练集的权值分布 D_1 = \\{\\omega_{11},\\omega_{12},\\cdots,\\omega_{1n}\\},\\quad \\omega_{1i}=\\frac{1}{n}Step2：对 $T$ 个分类器进行迭代，即对 $t=1,2,\\cdots,T$ 1）使用权值分布为 $D_t$ 的训练集进行学习，得到弱分类器 G_t(\\mathbf{x}):\\mathcal{X}\\rightarrow \\{-1,+1\\}2）计算第 $t$ 个弱分类器 $G_t(\\mathbf{x})$ 上的分类误差率 \\text{error}_t = \\sum_{i=1}^nP(y_i\\neq G_t(\\mathbf{x}_i)) = \\sum_{i=1}^n \\omega_{ti} \\mathbb{I}(y_i\\neq G_t(\\mathbf{x}_i))3）计算第 $t$ 个弱分类器 $G_t(\\mathbf{x})$ 的系数 \\alpha_t = \\frac{1}{2} \\ln \\frac{1-\\text{error}_t}{\\text{error}_t}4）更新第 $t+1$ 轮的训练集的权值分布 \\begin{gather*} D_{t+1} = \\{\\omega_{t+1,1},\\omega_{t+1,2},\\cdots,\\omega_{t+1,n}\\} \\\\ \\omega_{t+1,i} = \\frac{1}{Z_t} \\omega_{t1} \\exp\\big[-\\alpha_t y_i G_t(\\mathbf{x}_i)\\big] \\\\ Z_t=\\sum\\limits_{i=1}^n \\omega_{ti} \\exp[-\\alpha_t y_i G_t(\\mathbf{x}_i)] \\end{gather*}Step3：构建弱分类器的加法模型 f(\\mathbf{x}) = \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x})Step4：得到最终分类器 G(\\mathbf{x})=\\text{sign}(f(\\mathbf{x})) = \\text{sign}\\Big( \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x}) \\Big)【AdaBoost 回归算法】AdaBoost 回归算法的推导流程与 AdaBoost 分类算法类似，这里不再给出 下面直接给出 AdaBoost 回归算法的算法流程： 输入：对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}$、弱回归算法 输出：回归学习器 $G(\\mathbf{x})$ 算法流程： Step1：初始化训练集的权值分布 D_1 = \\{\\omega_{11},\\omega_{12},\\cdots,\\omega_{1n}\\},\\quad \\omega_{1i}=\\frac{1}{n}Step2：对 $T$ 个分类器进行迭代，即对 $t=1,2,\\cdots,T$ 1）使用权值分布为 $D_t$ 的训练集进行学习，得到弱回归器 G_t(\\mathbf{x}):\\mathcal{X}\\rightarrow \\mathcal{Y}2）计算第 $t$ 个弱回归器 $G_t(\\mathbf{x})$ 上的最大误差 \\text{Error}_t = \\max |y_i-G_t(\\mathbf{x}_i)|,\\quad i=1,2,\\cdots,n3）根据最大误差和选用的误差计算方法，计算第 $t$ 个弱回归器 $G_t(\\mathbf{x})$ 对每个样本的相对误差 线性误差：$\\text{error}_{ti} = \\frac{|y_i-G_t(\\mathbf{x}_i)|}{\\text{Error}_t}$ 平方误差：$\\text{error}_{ti} = \\frac{(y_i-G_t(\\mathbf{x}_i))^2}{\\text{Error}_t^2}$ 指数误差：$\\text{error}_{ti} = 1-\\exp[\\frac{-y_i+G_t(\\mathbf{x}_i)}{\\text{Error}_t}]$ 4）计算第 $t$ 个弱回归器 $G_t(\\mathbf{x})$ 的回归误差率 e_k = \\sum_{i=1}^n \\omega_{ti} \\text{error}_{ti}5）计算第 $t$ 个弱回归器 $G_t(\\mathbf{x})$ 的系数 \\alpha_t = \\frac{\\text{error}_t}{1-\\text{error}_t}6）更新第 $t+1$ 轮的训练集的权值分布 \\begin{gather*} D_{t+1} = \\{\\omega_{t+1,1},\\omega_{t+1,2},\\cdots,\\omega_{t+1,n}\\} \\\\ \\omega_{t+1,i} = \\frac{1}{Z_t} \\omega_{t1} \\alpha_t^{1-\\text{error}_{ti}} \\\\ Z_t=\\sum\\limits_{i=1}^n \\omega_{ti} \\alpha_t^{1-\\text{error}_{ti}} \\end{gather*}Step3：得到最终回归器 G(\\mathbf{x})=\\sum_{t=1}^T \\ln \\frac{1}{\\alpha_t} g(\\mathbf{x})其中，$g(\\mathbf{x})$ 为所有 $\\alpha_tG_t(\\mathbf{x})$ 的中位数 【AdaBoost 的正则化】通常来说，为防止 AdaBoost 出现过拟合，会加入正则化项，这个正则化项即学习率（Learning Rate） 对于前向分步法的更新公式的 $f_t(\\mathbf{x})=f_{t-1}(\\mathbf{x})+\\alpha_t G_t(\\mathbf{x})$，有： f_t(\\mathbf{x})=f_{t-1}(\\mathbf{x})+\\mu\\alpha_t G_t(\\mathbf{x})其中，$\\mu\\in(0,1]$ 即为学习率 对于同样的训练集来说，较小的 $\\mu$ 意味着需要更多的弱学习器的迭代次数，通常用学习率和迭代最大次数来一起决定算法的拟合效果 【sklearn 实现】GBDT 回归算法以 sklearn 中的波士顿房价数据集为例，选取其后两个特征来实现 AdaBoost 回归算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.ensemble import AdaBoostRegressorfrom sklearn.tree import DecisionTreeRegressorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立AdaBoost回归模型 model = AdaBoostRegressor(base_estimator=DecisionTreeRegressor(max_depth=4), n_estimators=300) # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model) GBDT 分类算法以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现 AdaBoost 分类算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import AdaBoostClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立AdaBoost分类模型 # - algorithm：samme输出分类的标签，samme.R输出分类的概率 # - n_estimators：基学习器数量 # - learning_rate：学习率 model = AdaBoostClassifier(base_estimator=DecisionTreeClassifier(), algorithm=\"SAMME\", n_estimators=200, learning_rate=0.8) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"Boosting 提升法","slug":"ensemble-learning/05.Boosting提升法","date":"2020-08-02T11:36:00.000Z","updated":"2023-04-06T13:55:15.928Z","comments":true,"path":"artificial-intelligence/ensemble-learning/41b133f5.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/41b133f5.html","excerpt":"References： 机器篇——集成学习(三) 细说 提升(Boosting) 算法 集成学习-Boosting,Bagging与Stacking 梯度提升（Gradient Boosting）算法 机器篇——集成学习(五) 细说 梯度提升(Gradient Boost)算法 【Boosting 工作机制】Boosting 算法（提升算法）是将弱学习器提升为强学习器的一族算法，其基本工作机制是：","text":"References： 机器篇——集成学习(三) 细说 提升(Boosting) 算法 集成学习-Boosting,Bagging与Stacking 梯度提升（Gradient Boosting）算法 机器篇——集成学习(五) 细说 梯度提升(Gradient Boost)算法 【Boosting 工作机制】Boosting 算法（提升算法）是将弱学习器提升为强学习器的一族算法，其基本工作机制是： 从初始训练集中训练出一个弱学习器 根据弱学习器的表现对训练样本分布进行调整，使得先前的弱学习器做错的训练样本在后续受到更多关注 使用基于调整后的样本分布训练下一个弱学习器 重复上述步骤，直到弱学习器达到指定的数目 $T$ 将 $T$ 个弱学习器使用结合策略进行结合 可以发现，与 Bagging 袋装法不同，Boosting 是一种串行结构，整个训练过程呈阶梯状，弱学习器按次序进行训练，训练集每次都按照某种策略进行一定的转化，最后再以某种结合策略将弱学习器组合成一个强学习器 此外，Boosting 中所有的弱学习器可以是不同的学习器，即可以是异质集成，但因为过于复杂，很少会使用不同的弱学习器 【加法模型与前向分步法】Boosting 提升法主要涉及到两个部分，即加法模型与前向分步法 加法模型加法模型（Additive Model）是指强学习器是由一系列弱学习器线性相加而成的，即： f(\\mathbf{x}) = \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x})其中，$T$ 是弱学习器的个数，$G_t(\\mathbf{x})$ 是每个弱学习器的假设函数，被称为基函数，$\\alpha_t$ 是基函数的系数，即每个弱学习器在强学习器中所占的比重 前向分步法在给定容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$ 和损失函数 $L(y,f(\\mathbf{x}))$ 的情况下，学习加法模型 $f(\\mathbf{x})$ 就变成了损失函数极小化问题，即： \\min_{\\alpha_t,G_t} \\sum_{i=1}^n L\\Big(y_i,\\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x}_i) \\Big)前向分步法（Forward Stagewise Algorithm）是专门用于求解这一类优化问题的算法，其基本思想是：基于贪心算法，贪婪的逐步优化，即从前向后进行学习，每一步只学习一个基函数及其系数，逐步逼近优化目标函数 这样一来，前向分步法将同时求解从 $1$ 到 $T$ 的所有参数 $\\alpha_t$ 和 $G_t$ 的优化问题，就简化为逐步求解各个 $\\alpha_t$ 和 $G_t$ 的优化问题 具体来说，就是每一步优化如下损失函数： \\min_{\\alpha,G} \\sum_{i=1}^n L\\Big(y_i,\\alpha G(\\mathbf{x}_i) \\Big) 下面给出前向分步法的算法流程： 输入：容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，损失函数 $L(y,f(\\mathbf{x}))$ ，基函数集 $\\{G(\\mathbf{x})\\}$ 输出：加法模型 $f(\\mathbf{x})$ 算法流程： Step1：初始化 $f_0(\\mathbf{x})=0$ Step2：对 $t=1,2,\\cdots,T$ 1）极小化损失函数： (\\alpha_t,\\boldsymbol{\\theta}_t) = \\arg\\min_{\\alpha,G} \\sum_{i=1}^n L\\Big(y_i,f_{t-1}(\\mathbf{x}_i)+\\alpha G(\\mathbf{x}_i) \\Big)得到参数 $\\alpha_t$ 和 $G_t$ 2）更新： f_t(\\mathbf{x}) = f_{t-1}(\\mathbf{x}) + \\alpha_tG_t(\\mathbf{x})Step3：得到加法模型 f(\\mathbf{x}) = f_T(\\mathbf{x}) = \\sum_{t=1}^T \\alpha_t G_t(\\mathbf{x})【梯度提升法】梯度下降法是在参数空间中，进行最优参数的搜索，最优解 $\\boldsymbol{\\theta}^*$ 是初始值 $\\boldsymbol{\\theta}_0$ 迭代 $T$ 次而来的 对于损失函数 $L(\\boldsymbol{\\theta})$，设 $\\boldsymbol{\\theta}_0 = \\frac{\\partial{L(\\boldsymbol{\\theta})}}{\\partial{\\boldsymbol{\\theta}_0}}$，那么最优解可表示为： \\boldsymbol{\\theta}^* = \\sum_{t=1}^T \\alpha_t \\Big[- \\frac{\\partial L(\\boldsymbol{\\theta})}{\\partial \\boldsymbol{\\theta}} \\Big]_{\\boldsymbol{\\theta}=\\boldsymbol{\\theta}_{t-1}}其中，$\\Big[- \\frac{\\partial L(\\boldsymbol{\\theta})}{\\partial \\boldsymbol{\\theta}} \\Big]_{\\boldsymbol{\\theta}=\\boldsymbol{\\theta}_{t-1}}$ 为 $\\boldsymbol{\\theta}$ 在 $\\boldsymbol{\\theta}-1$ 处泰勒展开式的一阶导数 那么，在函数空间中，借鉴梯度下降的思想，可以对最优函数进行搜索，这就是梯度提升法（Gradient Boost） 对于模型 $f(\\mathbf{x})$ 的损失函数 $L(y,f(\\mathbf{x}))$，为求最优的函数 $f^*(\\mathbf{x})$，首先设初始值为： f_0(\\mathbf{x}) = G_0(\\mathbf{x})与梯度下降法的更新过程一致，假设经过 $T$ 次迭代： G_t(\\mathbf{x}) = G_{t-1}(\\mathbf{x}) + \\alpha_t\\triangledown G_t(\\mathbf{x})其中，$\\triangledown G_t(\\mathbf{x})$ 为： \\triangledown G_t(\\mathbf{x}) = \\Big[- \\frac{\\partial L(y,G(\\mathbf{x}))}{\\partial G(\\mathbf{x})} \\Big]_{G(\\mathbf{x})=G_{t-1}(\\mathbf{x})}得到的最优函数为： f^*(\\mathbf{x}) = \\sum_{t=1}^T G_t(\\mathbf{x})可以看到，梯度上升法在每一轮迭代中，首先计算出当前模型在所有样本上的负梯度 $\\triangledown G_t(\\mathbf{x})$，然后训练一个新的弱分类器 $G_t(\\mathbf{x})$，最终实现对模型的更新 关于梯度下降法，详见：梯度下降法 【Boosting 算法族】Boosting 并非是一种方法，而是一族算法 具体来说，依据损失函数 $L(y,f(\\mathbf{x}))$ 的不同，其可以分为若干具体的算法，常见的有： 算法 模型 基函数 针对问题 损失函数 学习算法 详见 AdaBoost 自适应提升 加法模型 $-$ 分类回归 分类：指数损失函数回归：回归误差率 前向分步法 AdaBoost 自适应提升算法 提升树 加法模型 决策树 分类回归 分类：指数损失函数回归：平方损失函数 前向分步法 提升树 GBDT 梯度提升决策树 加法模型 决策树 分类回归 一般损失函数 梯度提升法 GBDT 梯度提升决策树 此外，还有损失函数采用平方损失函数的 L2Boosting 算法、采用对数损失函数的 LogitBoost 算法，GBDT 的优化算法 XGBoost 算法等","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"Bagging 袋装法与随机森林","slug":"ensemble-learning/04.Bagging袋装法与随机森林","date":"2020-08-01T08:37:46.000Z","updated":"2023-04-06T13:33:06.088Z","comments":true,"path":"artificial-intelligence/ensemble-learning/ce6ccc0b.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/ce6ccc0b.html","excerpt":"References： 【机器学习】Bagging算法 机器学习中的集成方法（2）—Bagging（装袋法） 机器篇——集成学习(一) 细说 Bagging 算法 [机器学习基础复习] 随机森林(Random Forest) 机器篇——集成学习(二) 细说 随机森林(Rondoom Forest) 算法 【引入】对于集成学习来说，要想得到泛化性能较好的集成，个体学习器应尽可能的相互独立，虽然无法在实际应用中做到，但可以设法令个体学习器尽可能的具有较大的差异","text":"References： 【机器学习】Bagging算法 机器学习中的集成方法（2）—Bagging（装袋法） 机器篇——集成学习(一) 细说 Bagging 算法 [机器学习基础复习] 随机森林(Random Forest) 机器篇——集成学习(二) 细说 随机森林(Rondoom Forest) 算法 【引入】对于集成学习来说，要想得到泛化性能较好的集成，个体学习器应尽可能的相互独立，虽然无法在实际应用中做到，但可以设法令个体学习器尽可能的具有较大的差异 对于给定的训练集，可以对训练样本进行采样，从而产生若干不同的训练子集，再从每个子集中训练出一个基学习器，这样一来，由于训练子集的不同，获得基学习器就可能有较大的差异 同时，基学习器不能太差，如果采样出的每个子集都完全不同，那么每个基学习器只用到了一小部分的训练数据，甚至不足以进行有效的学习，为此，可以考虑使用相互有交叠的采样子集 【Bagging】Bagging 装袋法，是集成学习的经典算法之一，其本质是引入样本扰动，通过增加样本随机性，以降低方差 Bagging 基于自助采样法（Bootstrap Sampling），即：给定包含 $n$ 个样本的数据集 $D$，每轮有放回的随机选出一个样本放入采样集 $D’$ 中，经过 $n$ 次随机采样后，可以得到包含 $n$ 个样本的采样集 $D’$，有的样本在采样集中多次出现，有的样本在采样集中从未出现 通过自主采样法，初始数据集 $D$ 中约有 $36.8\\%$ 的样本从未出现过采样数据集 $D’$ 中 这样一来，可以采样出 $T$ 个含 $n$ 个训练样本的采样集，然后基于每个采样集训练出一个基学习器，最后再将这些基学习器进行结合 对于分类任务，Bagging 常采用相对多数投票法作为结合策略，对于回归任务，则采用简单平均法作为结合策略 关于自助采样法，详见：机器学习的模型选择 【模型平均】Bagging 是通过结合几个基学习器来降低泛化误差的技术，主要想法是分别训练几个不同的模型，然后让所有模型表决测试样例的输出，这种思想被称为模型平均（Model Averaging） 模型平均奏效的原因是不同的学习器通常不会在测试集上产生完全相同的误差，其是一种减少泛化误差的非常强大可靠的方法 此外，从偏差-方差分解的角度来看，Bagging 主要关注于降低方差，因此它在不剪枝的决策树、神经网络等容易受到样本扰动的学习器上效果更明显 【包外估计】使用 Bagging 来产生训练数据集有一个好处是，没有必要再使用交叉验证或使用一个独立的测试集来获取误差的无偏估计 这是因为每个基学习器只使用了训练集中约 $63.2\\%$ 的样本，剩下的 $36.8\\%$ 的样本可用作验证集来对泛化性能进行评估，这种评估方式被称为包外估计（Out-of-bag Estimate） 记 $D_t$ 为基学习器 $f_t(\\mathbf{x})$ 所实际使用的训练样本集，令 $H^{\\text{oob}}(\\mathbf{x})$ 为样本 $\\mathbf{x}$ 的包外预测，即仅考虑未使用 $\\mathbf{x}$ 训练的基学习器在 $\\mathbf{x}$ 上的预测，有： H^{\\text{oob}}(\\mathbf{x}) = \\arg\\max_{y\\in \\mathcal{Y}} \\sum_{t=1}^T \\mathbb{I}(f_t(\\mathbf{x})=y)\\cdot \\mathbb{I}(\\mathbf{x}\\notin D_t)则 Bagging 泛化误差的包外估计为： \\varepsilon^{\\text{oob}} = \\frac{1}{|D|}\\sum_{(\\mathbf{x},y)\\in D} \\mathbb{I}(H^{\\text{oob}}(\\mathbf{x})\\neq y)包外估计 $\\varepsilon^{\\text{oob}}$ 是对泛化误差的一个无偏估计，其结果近似于需要大量计算的 $k$ 折交叉验证 此外，包外样本还有诸多用途，例如：当基学习器是决策树时，可使用包外样本来辅助剪枝，或用于估价决策树中各结点的后验概率以辅助对训练样本结点的处理；当基学习器是神经网络时，可使用包外样本来辅助提前停止，以减小过拟合 【随机森林】随机森林（Random Forest，RF）是通过 Bagging 将决策树作为基学习器的集成学习算法 随机森林中的随机，是指两个随机性，一个是对训练集采用 Bagging 生成采样训练集来训练基决策树，另一个是在决策树的基础上引入了随机特征选择 具体来说，传统决策树在选择划分特征时，是在当前结点的特征集合中选择一个最优特征 而随机森林是对于基决策树的每个结点，从该结点的 $d$ 个特征中随机选择一个包含 $k$ 个特征的子集，然后再从这个子集中选择一个最优特征用于划分 其中，$k$ 控制了随机性的引入程度，若 $k=d$，则基决策树的构建与传统决策树相同，若 $k=1$，则是随机选择一个特征进行划分，一般情况下，推荐 $k=\\log_2 d$ 【sklearn 实现】Bagging在 sklearn 中看，Bagging 有两种，一种是用于回归的 BaggingRegressor()，另一种是用于分类的 BaggingClassifier() 12345678from sklearn.svm import SVCfrom sklearn.ensemble import BaggingClassifier# estimator: 指定的基学习器类型# n_estimators: 基学习器个数# oob_score: 进行包外估计# bootstrap: 有放回的采样model = BaggingClassifier(estimator=SVC(),n_estimators=10,oob_score=True,bootstrap=True) 随机森林以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现随机森林 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立随机森林模型 model = RandomForestClassifier(criterion='entropy', n_estimators=10, random_state=1) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"集成学习多样性","slug":"ensemble-learning/03.集成学习多样性","date":"2020-07-31T13:17:00.000Z","updated":"2023-04-08T09:24:25.618Z","comments":true,"path":"artificial-intelligence/ensemble-learning/fd54e4c6.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/fd54e4c6.html","excerpt":"References： 【机器学习】西瓜书集成学习的误差-分歧分解公式推导 集成学习多样性的数学分析 —— 误差分歧分解 【误差-分歧分解】单一样本","text":"References： 【机器学习】西瓜书集成学习的误差-分歧分解公式推导 集成学习多样性的数学分析 —— 误差分歧分解 【误差-分歧分解】单一样本分歧设个体学习器 $G_1(\\mathbf{x}),G_2(\\mathbf{x}),\\cdots,G_T(\\mathbf{x})$ 通过加权平均法结合产生的强学习器 $f(\\mathbf{x})$ 用于完成回归任务： f: \\mathbb{R}^m\\rightarrow \\mathbb{R}对于样本 $\\mathbf{x}_i$，定义个体学习器 $G_t(\\mathbf{x})$ 的分歧（Ambiguity）为： A(G_t | \\mathbf{x}_i) = \\big(G_t(\\mathbf{x}_i)-f(\\mathbf{x}_i)\\big)^2那么，个体学习器针对样本 $\\mathbf{x}_i$ 的加权分歧为： \\begin{align*} \\overline{A}(G|\\mathbf{x}_i) &= \\sum_{t=1}^T \\omega_t A(G_t|\\mathbf{x}_i) \\\\ &= \\sum_{t=1}^T \\omega_t \\big(G_t(\\mathbf{x}_i)-f(\\mathbf{x}_i)\\big)^2 \\end{align*}其中，$\\omega_t$ 为个体学习器 $G_t(\\mathbf{x})$ 的系数，即每个个体学习器在强学习器中所占的比重 其表征了个体学习器在样本 $\\mathbf{x}_i$ 上的不一致性，即在一定程度上反映了个体学习器的多样性 误差针对样本 $\\mathbf{x}_i$，个体学习器 $G_t(\\mathbf{x})$ 的平方误差为： \\text{Error}(G_t|\\mathbf{x}_i) = \\big( y_i - G_t(\\mathbf{x}_i) \\big)^2强学习器 $f(\\mathbf{x})$ 的平方误差为： \\text{Error}(f|\\mathbf{x}_i) = \\big( y_i - f(\\mathbf{x}_i) \\big)^2令 $\\overline{E}(G|\\mathbf{x})$ 代表个体学习器对样本 $\\mathbf{x}_i$ 的平方误差的加权均值，即： \\overline{E}(G|\\mathbf{x}_i) =\\sum_{t=1}^T \\omega_{t} \\text{Error}(G_t|\\mathbf{x}_i)分歧与误差的关系对于训练集 $D$ 上的任一样本 $\\mathbf{x}_i$，有： \\begin{align*} &\\overline{E}(G|\\mathbf{x}_i)-\\overline{A}(G|\\mathbf{x}_i) \\\\ &= \\sum_{t=1}^T \\omega_t\\text{Error}(G_t|\\mathbf{x}_i)-\\sum_{t=1}^T \\omega_t \\big(G_t(\\mathbf{x}_i)-f(\\mathbf{x}_i)\\big)^2 \\\\ &= \\sum_{t=1}^T \\omega_t \\Big[ \\big( y_i - G_t(\\mathbf{x}_i) \\big)^2- \\big(G_t(\\mathbf{x}_i)-f(\\mathbf{x}_i)\\big)^2\\Big] \\\\ &= \\sum_{t=1}^T \\omega_t \\Big( y_i^2-2y_iG_t(\\mathbf{x}_i) + G_t(\\mathbf{x}_i)^2 -G_t(\\mathbf{x}_i)^2+2G_t(\\mathbf{x}_i)f(\\mathbf{x}_i)-f(\\mathbf{x}_i)^2 \\Big) \\\\ &= \\sum_{t=1}^T \\omega_t \\Big[ y_i^2+2G_t(\\mathbf{x}_i)\\big(f(\\mathbf{x}_i)-y_i\\big) - f(\\mathbf{x}_i)^2 \\Big] \\\\ &= y_i^2\\sum_{t=1}^T \\omega_t + 2\\big(f(\\mathbf{x}_i)-y_i\\big)\\sum_{t=1}^T\\omega_tG_t(\\mathbf{x}_i) - f(\\mathbf{x}_i)^2\\sum_{t=1}^T\\omega_t \\end{align*}由于 $\\sum\\limits_{t=1}^T\\omega_t=1$，故有： \\begin{align*} &\\overline{E}(G|\\mathbf{x}_i)-\\overline{A}(G|\\mathbf{x}_i) \\\\ &= y_i^2\\sum_{t=1}^T \\omega_t + 2\\big(f(\\mathbf{x}_i)-y_i\\big)\\sum_{t=1}^T\\omega_tG_t(\\mathbf{x}_i) - f(\\mathbf{x}_i)^2\\sum_{t=1}^T\\omega_t \\\\ &= y_i^2 + 2\\big(f(\\mathbf{x}_i)-y_i\\big)\\sum_{t=1}^T\\omega_tG_t(\\mathbf{x}_i) - f(\\mathbf{x}_i)^2 \\\\ \\end{align*}由于采用的是加权平均法，有 $f(\\mathbf{x})=\\sum\\limits_{t=1}^T\\omega_t G_t(\\mathbf{x})$，故可得： \\begin{align*} &\\overline{E}(G|\\mathbf{x}_i)-\\overline{A}(G|\\mathbf{x}_i) \\\\ &= y_i^2 + 2\\big(f(\\mathbf{x}_i)-y_i\\big)\\sum_{t=1}^T\\omega_tG_t(\\mathbf{x}_i) - f(\\mathbf{x}_i)^2 \\\\ &= y_i^2 + 2\\big(f(\\mathbf{x}_i)-y_i\\big)f(\\mathbf{x}_i) -f(\\mathbf{x}_i)^2 \\\\ &= y_i^2 -2y_if(\\mathbf{x}_i)+2f(\\mathbf{x}_i)^2-f(\\mathbf{x}_i)^2 \\\\ &= y_i^2 -2y_if(\\mathbf{x}_i)+f(\\mathbf{x}_i)^2 \\\\ &= \\big(y_i-f(\\mathbf{x}_i)\\big)^2 \\end{align*}而对于样本 $\\mathbf{x}_i$，强学习器 $f(\\mathbf{x})$ 的平方误差为： \\text{Error}(f|\\mathbf{x}_i) = \\big( y_i - f(\\mathbf{x}_i) \\big)^2故有： \\overline{E}(G|\\mathbf{x}_i)-\\overline{A}(G|\\mathbf{x}_i) = \\text{Error}(f|\\mathbf{x}_i)即： \\overline{A}(G|\\mathbf{x}_i) = \\overline{E}(G|\\mathbf{x}_i) - \\text{Error}(f|\\mathbf{x}_i)样本集分歧由于 $\\mathbf{x}_i$ 是样本集 $D$ 中的任一样本，对于 $D$ 中的样本，令 $p(\\mathbf{x})$ 表示样本的概率密度，那么在样本集 $D$ 上，个体学习器 $G_t(\\mathbf{x})$ 在全样本上的分歧为： {A}(G_t) = \\int_D A(G_t|\\mathbf{x})p(\\mathbf{x}) d \\mathbf{x}那么，个体学习器在全样本上的加权分歧为： \\begin{align*} \\overline{A}(G) &= \\sum_{t=1}^T \\omega_t A(G_t) \\\\ &= \\sum_{t=1}^T \\omega_t \\int_D A(G_t|\\mathbf{x})p(\\mathbf{x}) d \\mathbf{x} \\end{align*}泛化误差对于全样本集 $D$，个体学习器 $G_t(\\mathbf{x})$ 在全样本上的泛化误差为： \\text{Error}(G_t) = \\int_D E(G_t|\\mathbf{x})p(\\mathbf{x})d\\mathbf{x}强学习器 $f(\\mathbf{x})$ 的泛化误差为： \\text{Error}(f) = \\int_D E(f|\\mathbf{x})p(\\mathbf{x})d\\mathbf{x}全样本集上对个体学习器的加权泛化误差为： \\begin{align*} \\overline{E}(G) &= \\sum_{t=1}^T \\omega_t \\text{Error}(G_t) \\\\ &= \\sum_{t=1}^T \\omega_t \\int_D E(G_t|\\mathbf{x})p(\\mathbf{x})d\\mathbf{x} \\end{align*}分歧与误差的关系根据单一样本上分歧与误差的关系，对于全样本集 $D$，有： \\sum_{t=1}^T \\omega_t \\int A(G_t|\\mathbf{x})p(\\mathbf{x})d\\mathbf{x} = \\sum_{t=1}^T\\omega_t \\int E(G_t|\\mathbf{x})p(\\mathbf{x})d\\mathbf{x} - \\int E(f|\\mathbf{x})p(\\mathbf{x})d\\mathbf{x}即： \\overline{A}(G) = \\overline{E}(G) -\\text{Error}(f)将上式进行变换，即有： \\text{Error}(f)= \\overline{E}(G) - \\overline{A}(G)其被称为误差-分歧分解（Error-Ambiguity Decomposition），其将泛化误差、误差、分歧联系到了一起，同时指出了个体学习器的准确率越高、多样性越大，则集成越好 遗憾的是，在实际应用中，很难直接对泛化误差 $\\overline{E}(G) - \\overline{A}(G)$ 进行优化，不仅是由于它们是定义在整个样本空间上，还因为 $\\overline{A}(G)$ 不是一个可直接操作的多样性度量，其仅是在强学习器构造好后才进行估计 此外，需要注意的是，上面的推导过程只适用于回归，难以将其推广到分类任务上去 【多样性度量】多样性度量是用于度量集成这种个体分类器的多样性，即估算个体学习器的多样化程度 对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{-1,+1\\}$ 分类器 $G_i(\\mathbf{x})$ 和 $G_j(\\mathbf{x})$ 的预测结果列联表为： $G_i(\\mathbf{x})=+1$ $G_i(\\mathbf{x})=-1$ $G_j(\\mathbf{x})=+1$ $a$ $c$ $G_j(\\mathbf{x})=-1$ $b$ $d$ 其中，$a$ 表示 $G_i(\\mathbf{x})$ 与 $G_j(\\mathbf{x})$ 均预测为正类的样本数，$b$ 表示 $G_i(\\mathbf{x})$ 预测为正类 $G_j(\\mathbf{x})$ 预测为负类的样本数，$c$ 表示 $G_i(\\mathbf{x})$ 预测为负类 $G_j(\\mathbf{x})$ 预测为正类的样本数，$d$ 表示 $G_i(\\mathbf{x})$ 与 $G_j(\\mathbf{x})$ 均预测为负类的样本数，且 $a+b+c+d=n$ 根据列联表，给出如下常见的多样性度量 1）不合度量（Disagreement Measure） \\text{dis}_{ij} = \\frac{b+c}{n}$\\text{dis}_{ij}\\in [0,1]$，值越大多样性越大 2）相关系数（Correlation Coefficient） \\rho_{ij} = \\frac{ad-bc}{\\sqrt{(a+b)(a+c)(c+d)(b+d)}}$\\rho_{ij}\\in [-1,1]$，若 $G_i(\\mathbf{x})$ 与 $G_j(\\mathbf{x})$ 无关，则 $\\rho_{ij}=0$，若 $G_i(\\mathbf{x})$ 与 $G_j(\\mathbf{x})$ 正相关，则值为正，否则为负 3）Q-统计量（Q-statistic） Q_{ij} = \\frac{ad-bc}{ad+bc}$Q_{ij}$ 与 $\\rho_{ij}$ 符号相同，且 $|Q_{ij}|\\geq |\\rho_{ij}|$ 4）k-统计量（k-statistic） k=\\frac{p_1-p_2}{1-p_2}其中，$p_1$ 是两个分类器取得一致的概率，$p_2$ 是两个分类器偶然达成一致的概率，它们可由数据集 $D$ 估算，即： \\begin{gather*} p_1=\\frac{a+d}{m} \\\\ p_2 = \\frac{(a+b)(a+c)+(c+d)(b+d)}{n^2} \\end{gather*}若 $G_i(\\mathbf{x})$ 与 $G_j(\\mathbf{x})$ 在 $D$ 上完全一致，则 $k=1$，若它们是偶然一致，则 $k=0$ 通常来说，$k$ 为非负值，仅在 $G_i(\\mathbf{x})$ 与 $G_j(\\mathbf{x})$ 达成一致的概率低于偶然性的情况下取负值 【多样性增强】要在个体学习器足够好的情况下，增强多样性，从整个算法学习过程上来考虑，有： 输入：如果每个学习器学习不同的样本，那么可以学习出相对来说不同的个体学习器，可以随机划分训练样本，或利用不同的属性子集训练出不同的个体学习器 模型：考虑异质集成，训练出不同的组件学习器 输出：依据标签的特性来进行划分，得到不同的个体学习器 从以上三点来考虑，有以下五种方法： 训练样本扰动：从原始训练样本中产生不同的样本子集，然后利用不同的样本子集训练不同的个体学习器 输入属性扰动：从初始属性集中抽取出若干个属性子集，然后利用不同的属性子集训练出不同的个体学习器，需要注意的是，若数据只包含少量属性，或则该方法不适用 算法参数扰动：通过随机设置不同的参数来训练差别较大的个体学习器 输出标记扰动：对训练样本的类别标记稍作变动，也可对输出进行转化 混合扰动：在同一个集成算法中同时使用上述多种扰动方法","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"集成学习结合策略","slug":"ensemble-learning/02.集成学习结合策略","date":"2020-07-31T04:06:00.000Z","updated":"2023-04-06T13:22:03.550Z","comments":true,"path":"artificial-intelligence/ensemble-learning/4f81e78a.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/4f81e78a.html","excerpt":"【结合的好处】在产生了个体学习器后，需要考虑如何结合这些个体学习器，即结合策略 学习器的结合可能会从三方面带来好处：","text":"【结合的好处】在产生了个体学习器后，需要考虑如何结合这些个体学习器，即结合策略 学习器的结合可能会从三方面带来好处： 从统计的角度来看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能会因误选而导致泛化性能不佳，使用多个学习器进行结合会减小该风险 从计算的角度来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能会很差，而通过多次运行后进行结合，可降低陷入糟糕的局部极小点的风险 从表示的角度来看，某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单学习器则肯定无效，而通过结合多个学习器，会使相应的假设空间有所扩大，可能学得更好的近似 【常见的结合策略】简单平均法简单平均法（Simple Averaging）是最简单的一种结合策略，其是将输出结果进行平均，即： H(\\mathbf{x}) = \\frac{1}{T} \\sum_{t=1}^T f_t(\\mathbf{x})加强平均法加权平均法（Weighted Averaging）是集成学习研究的基本出发点，对于给定的个体学习器，不同的集成学习方法可认为通过不同的方式来确定加权平均法中的个体学习器的权重 加权平均是将输出结果进行加权平均，即： H(\\mathbf{x}) = \\frac{1}{T} \\sum_{t=1}^T \\omega_tf_t(\\mathbf{x})其中，权重 $\\omega_t\\geq 0, \\sum\\limits_{t=1}^T \\omega_t=1$ 权重一般是从训练集中学习而得，在实际应用中，由于训练样本通常不充分或存在噪声，这使得学习出的权重不完全可靠，尤其是对规模较大的集成来说，要学习的权重较多，容易导致过拟合的产生 一般在个体学习器性能相差较大时，使用加权平均法，而在个体学习器性能相近时，则使用简单平均法 此外，可以发现，简单平均是 $\\omega_t=\\frac{1}{T}$ 的加权平均 投票法对分类任务来说，个体学习器 $f_t(\\mathbf{x})$ 要从类别集合 $\\{c_1,c_2,\\cdots,c_K\\}$ 中预测出一个标记，投票法（Voting）是最常用的结合策略 将 $f_t(\\mathbf{x})$ 在样本 $\\mathbf{x}$ 上预测的输出表示为一个 $K$ 维向量： (f_t^1(\\mathbf{x}),f_t^2(\\mathbf{x}),\\cdots,f_t^K(\\mathbf{x}))其中，$f_t^k(\\mathbf{x})$ 表示 $f_t(\\mathbf{x})$ 在类别标记 $c_k$ 上的输出 绝对多数投票法（Majority Voting）是当某标记得票过半时，则预测为该标记，否则拒绝预测，即： H(\\mathbf{x}) = \\left\\{\\begin{gather*} c_k, && \\sum_{t=1}^T f_t^k(\\mathbf{x}) > \\frac{1}{2}\\sum_{k=1}^K\\sum_{t=1}^T f_t^k(\\mathbf{x}) \\\\ \\text{reject}, && \\text{otherwise} \\end{gather*}\\right.相对多数投票法（Plurality Voting）是预测为得票最多的标记，若同时有多个标记获得最高票，则从中随机选取一个，即： H(\\mathbf{x}) = c_{k^*},\\quad k^* = \\arg\\max_{k} \\sum_{t=1}^T f_t^k(\\mathbf{x})加权投票法（Weighted Voting）与加权平均法类似，其是为每个预测的标记乘以一个权重后，预测加权最大的标记，若同时有多个标记获得最大权，则从中随机选取一个，即： H(\\mathbf{x}) = c_{k^*},\\quad k^* = \\arg\\max_{k} \\omega_t\\sum_{t=1}^T f_t^k(\\mathbf{x})其中，权重 $\\omega_t\\geq 0, \\sum\\limits_{t=1}^T \\omega_t=1$ 标准的绝对多数投票法提供了拒绝预测的选择，这在可靠性要求较高的学习任务中是一个很好的机制，但若学习任务要求必须提供预测结果时，绝对多数投票法会退化为相对多数投票法，因此，在不允许拒绝预测的学习任务中，绝对多数、相对多数投票法被统称为多数投票法 此外，上述的三种投票法都没有限制个体学习器输出值的类型，在实际应用中，不同类型的个体学习器 $f_t(\\mathbf{x})$ 可能会产生不同类型的 $f_t^k(\\mathbf{x})$ 值，例如： 类标记：$f_t^k(\\mathbf{x})\\in \\{0,1\\}$ 类概率：$f_t^k(\\mathbf{x})\\in[0,1]$ 使用类标记的投票被称为硬投票（Hard Voting），使用类概率的投票被称为软投票（Soft Voting） 需要注意的是，若个体学习器的类型不同，得到的类概率值不能直接进行比较，通常是将类概率转换为类标记输出后，再进行投票 而且不同类型的 $f_t^k(\\mathbf{x})$ 值不能混用，即对一些能在预测出类标记同时产生分类置信度的学习器，其分类置信度可转化为类概率来使用","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"集成学习概述","slug":"ensemble-learning/01.集成学习概述","date":"2020-07-30T04:10:00.000Z","updated":"2023-04-08T13:35:00.222Z","comments":true,"path":"artificial-intelligence/ensemble-learning/9b317383.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/ensemble-learning/9b317383.html","excerpt":"References： 经典机器学习系列之【集成学习】 机器学习 | 基础通俗讲解集成学习算法！ 集成学习三大法宝-bagging、boosting、stacking 【集成学习】Kearns 和 Valiant 提出了强可学习和弱可学习的概念，即在概率近似正确（Probably Approximately Correct，PAC）学习框架中，一个概念如果存在一个多项式学习算法能够学习它，且正确率很高，那么就是强可学习（Strongly Learnable）的，一个概念如果存在一个多项式学习算法能够学习它，但正确率仅比随机猜测略好，那么就是弱可学习（Weakly Learnable）的","text":"References： 经典机器学习系列之【集成学习】 机器学习 | 基础通俗讲解集成学习算法！ 集成学习三大法宝-bagging、boosting、stacking 【集成学习】Kearns 和 Valiant 提出了强可学习和弱可学习的概念，即在概率近似正确（Probably Approximately Correct，PAC）学习框架中，一个概念如果存在一个多项式学习算法能够学习它，且正确率很高，那么就是强可学习（Strongly Learnable）的，一个概念如果存在一个多项式学习算法能够学习它，但正确率仅比随机猜测略好，那么就是弱可学习（Weakly Learnable）的 Schapire 证明了强可学习和弱可学习是等价的，也就是说，在 PAC 学习框架下，一个概念是强可学习的充分必要条件是这个概念是弱可学习的 那么，在学习中，如果已经发现了一个弱学习算法，能否将其提升为强可学习算法？ 集成学习（Ensemble Learning）通过构建并结合多个学习器来完成学习任务，其先产生一组个体学习器，然后通过投票法、平均法等结合策略将这些个体学习器结合起来 简单来说，集成学习是将几种机器学习技术组合成一个预测模型的元算法，然后对数据进行预测，从而提高预测模型整体的泛化能力 关于集成学习的结合策略，详见：集成学习结合策略 【集成的准确性与多样性】在一般的经验中，将好坏不等的物品掺杂在一起，那么通常结果是比全好的坏一些，比全坏的好一些 那么集成学习将多个学习器结合起来，如何能获得比最好的个体学习器更好的性能？ 如下图所示，假定在一个二分类任务中，三个分类器在三个测试样本的表现如下，集成学习的结果通过投票法产生 可以看出，要获得好的集成，个体学习器既要有一定的准确性，即个体学习器至少不弱于弱学习器，还要有一定的多样性，即学习器之间具有一定的差异 实际上，个体学习器的准确性和多样性存在冲突，每个个体学习器学习的都是同一个问题，它们不可能做到完全相互独立，一般的，准确性很高后，要增加多样性就要牺牲准确性 如何产生 “好而不同” 的个体学习器，就是集成学习研究的核心 关于多样性的详细介绍，见：集成学习多样性 【集成学习方法】同质与异质对于集成学习中的个体学习器，其通常由一个现有的学习算法从训练集中产生，例如 C4.5 决策树、BP 神经网络等 如果在集成过程中，只包含同类型的个体学习器，那么就成这种集成是同质集成（Homogeneous Ensemble）的，每个个体学习器被称为基学习器（Base Learner），相应的学习算法被称为基学习算法（Base Learning Algorithm） 如果在集成过程中，包含不同类型的个体学习器，那么就成这种集成是异质集成（Heterogeneous Ensemble）的，每个个体学习器被称为组件学习器（Component Learner），由不同的学习算法生成，不再有基学习算法 方差-偏差-预测结果从方差、偏差、预测结果来说，集成学习可以分为三大类： Bagging 袋装法：用于减少方差，详见 Bagging 袋装法与随机森林 Boosting 提升法：用于减少偏差，详见 Boosting 提升法 Stacking 堆叠法：用于提升预测结果，详见 Stacking 堆叠法 串行与并行从个体学习器是串行生成的还是并行生成的，集成学习可归为以下两类： 串行集成：串行地生成个体学习器，其动机是利用个体学习器之间的依赖，通过给错分样本一个较大的权重来提升性能，如 AdaBoost 自适应提升 并行集成：并行地生成个体学习器，其动机是利用个体学习器的独立性，通过平均来较大地降低误差，如随机森林 RF","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"集成学习","slug":"artificial-intelligence/ensemble-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/ensemble-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"集成学习","slug":"ensemble-learning","permalink":"https://alex-mcavoy.github.io/tags/ensemble-learning/"}],"author":"Alex_McAvoy"},{"title":"Dr.F","slug":"daily/04.Dr.F","date":"2020-07-22T17:10:00.000Z","updated":"2021-09-22T08:06:41.794Z","comments":true,"path":"essay/daily/775c3cbe.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/775c3cbe.html","excerpt":"大学以来，虽与不少老师相熟，但最感激的莫过于费老，虽从未上过他的课，但自我加入其实验室后，其一直对我抱有莫大的期望，给了我诸多令他人羡慕的锻炼自我的机会，此外，其在我迷茫时为我指导方向，于闲暇时经常一起抽烟喝酒聊些生活琐碎，这大概就是恩师吧。 今日实验室两学姐返校收拾行李，傍晚约我同费老吃饭，席间，费老说他不希望我们以后能多有出息，平平淡淡快快乐乐地过好自己的生活找准自己的方向就好。 但最难过的莫过于，即使这样，我也一直在辜负他的期望，毕竟我是一个不懂得爱也不值得他人去爱，生活一直过得一团糟，却一直假装自己过得很好的自欺者。","text":"大学以来，虽与不少老师相熟，但最感激的莫过于费老，虽从未上过他的课，但自我加入其实验室后，其一直对我抱有莫大的期望，给了我诸多令他人羡慕的锻炼自我的机会，此外，其在我迷茫时为我指导方向，于闲暇时经常一起抽烟喝酒聊些生活琐碎，这大概就是恩师吧。 今日实验室两学姐返校收拾行李，傍晚约我同费老吃饭，席间，费老说他不希望我们以后能多有出息，平平淡淡快快乐乐地过好自己的生活找准自己的方向就好。 但最难过的莫过于，即使这样，我也一直在辜负他的期望，毕竟我是一个不懂得爱也不值得他人去爱，生活一直过得一团糟，却一直假装自己过得很好的自欺者。 道理都懂，可是又能如何？每每思量此事此理，未免有些心灰意冷。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"光纤损耗原因","slug":"network-testing/14.光纤损耗原因","date":"2020-07-15T12:20:00.000Z","updated":"2021-08-23T12:59:12.533Z","comments":true,"path":"notes/network-testing/32a44e8d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/32a44e8d.html","excerpt":"【外在损耗】弯曲损耗弯曲损耗发生在光缆的弯曲半径比光缆最小弯曲半径还要小的情况","text":"【外在损耗】弯曲损耗弯曲损耗发生在光缆的弯曲半径比光缆最小弯曲半径还要小的情况 例如，在外力作用下，光纤芯的突然弯曲、缓冲层或护套缺陷引起的纤芯移动、施工安装中操作不当造成的问题等 连接损耗光纤作为传输介质需要与设备相连接，所有接头的地方都有可能引起损耗 一根光缆不可能无限长，传输中肯定会有需要光纤连接或转接的地方，而且本身也需要与不同接口的设备相连接，这些由光纤之间连接而引起的损耗都称为光纤的连接损耗 【本征损耗】光纤的固有损耗光纤的固有损耗是指制造工艺中不能消除的光纤的光损耗，其是由玻璃中的杂质和分子层面的光吸收产生的 瑞利散射瑞利散射是指，当光脉冲输入到光纤中时，部分脉冲信号由于受到玻璃纤维中掺杂物的阻碍而向各个方向散射的现象 瑞利散射光向各个方向散射，其中一部分的方向与入射方向相反，沿着光纤返回到入射端，这部分散射光称为背向散射光 菲涅尔反射菲涅尔反射发生在任何有折射率变化的介质界面，当光脉冲遇到裂纹或在光纤的端头等时，也有一部分光因反射而返回到入射端，而且反射信号比散射信号强得多","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"光纤长度测量","slug":"network-testing/13.光纤长度测量","date":"2020-07-15T05:20:00.000Z","updated":"2021-08-23T13:07:31.905Z","comments":true,"path":"notes/network-testing/7e322ac9.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/7e322ac9.html","excerpt":"【传输脉冲时延法】在光纤中的光速 $V=\\frac{c}{n}$，其中 $c=3\\times 10^8m/s$ 为真空中光速，$n$ 为平均折射率 设光脉冲经长度为 $L$，经过平均折射率为 $n$ 的光纤传输后，其传输时延为 $D_t$，则长度","text":"【传输脉冲时延法】在光纤中的光速 $V=\\frac{c}{n}$，其中 $c=3\\times 10^8m/s$ 为真空中光速，$n$ 为平均折射率 设光脉冲经长度为 $L$，经过平均折射率为 $n$ 的光纤传输后，其传输时延为 $D_t$，则长度 L=\\frac{cD_t}{n}可见，只要测得 $D_t$，便能求得已知 $n$ 的光纤的长度 【反射脉冲时延法】反射脉冲时延法通过测量光纤中的后向散射光到达时间来计算距离 在光纤中的光速 $V=\\frac{c}{n}$，其中 $c=3\\times 10^8m/s$ 为真空中光速，$n$ 为平均折射率 设 $t$ 为后向散射光到达的往返时间，则长度： 2L=V*t=\\frac{ct}{n}","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"电缆测试方法","slug":"network-testing/12.电缆测试方法","date":"2020-07-13T05:24:00.000Z","updated":"2021-08-23T12:59:30.645Z","comments":true,"path":"notes/network-testing/ce134d2a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/ce134d2a.html","excerpt":"【接线图测试】概述接线图测试是布线链路有无终接错误的一项基本检查，目前使用 DSP4000 测试仪进行测试，通过测试仪显示出的接线图来确定每条 8 芯电缆与配线模块接线端的连接实际状态","text":"【接线图测试】概述接线图测试是布线链路有无终接错误的一项基本检查，目前使用 DSP4000 测试仪进行测试，通过测试仪显示出的接线图来确定每条 8 芯电缆与配线模块接线端的连接实际状态 对于 8 芯电缆，接线图的主要内容如下： 开路（Open） 短路（Short） 错对/跨接（Miswire，Cross） 反接/交叉（Reverse） 串绕（Split） 其中，开路、短路是与阻抗有关的故障，错对/跨接、反接/交叉是与线序有关的故障，串绕是与串扰有关的故障 开路当电缆内一根或更多导线没有连接到某一端的针上，本来已经被折断或不完全的情况下会出现开路故障 短路短路可分为： 短路线对：当某一线对导体在电缆内任意位置相连接时出现的短路 线对间短路：当两根不同线对导体在电缆内任意位置连接在一起时出现的短路 错对/跨接错对/跨接是指一端的 1、2 号线对接在了另一端的 3、6 号线对，而 3、6 号线对接在了另一端的 1、2 号线对 这种错误往往是由于两端的接线标准不统一造成的，即一端用 T568A，另一端用 T568B 反接/交叉当一个线对内的两根导线在电缆的另一端被连接到与线对相反的针上时，就会出现线对反接，又称为线对交叉 串绕串绕指原来的两个线对分别拆开后又重新组合成新的线对，串绕线对在布线系统的安装过程中是经常出现的，最典型的就是布线施工人员不清楚接线的标准，按照 1&amp;2、3&amp;4、5&amp;6、7&amp;8 的线对关系进行接线 由于相关的线对没有绞结，信号通过时线对间会产生很高的串扰信号，如果超过一定限度就会影响正常信息的传输 这种错误对端到端的连通性不产生影响，普通万用表不能检查故障原因，只有专用的电缆测试仪才能检测出来 【电缆长度测试】电缆长度应该是刚开始计划网络时一项重要的考虑因素，必须将网络组件放置于合适的位置，从而不会使得连接它们的电缆超出规定的最大长度 需要注意的是，此处的线缆长度指的是线缆绕对的长度，并不是指线缆表皮的长度，一般来说，绕对的长度要比表皮的长度长，并且由于每对线对的绞率不同，4 对绕对的线缆可能长度不一 测量电缆长度时，通常也使用 DSP4000 测试仪，采用 TDR 时域反射计测试技术，测试仪从电缆一端向一线对发出一个脉冲信号，然后测量同一线对上信号返回的总时间，用纳秒表示，依据脉冲信号往返时间、已知的信号在电缆额定传播速率 NVP，测试仪就可以计算出电缆的长度 电缆的 NVP 值可以从电缆生产厂所公布的规格中获得，NVP 值随电缆批次的不同而微有差别，通常，NVP 范围为光速的 60%～80% 电缆额定传输速度 NVP，是指电信号在电缆中传输的速率与光在真空中的传输速率的比值，其计算公式为： NVP=\\frac{2×L}{T×C}其中 $L$ 为电缆长度，$T$ 为信号在传送端与接收端的时间差，$C=3\\times 10^8m/s$ 为光在真空中传播速度 在正式测量时，测量的准确性取决于 NVP 值，正式测量前用一个已知长度在 15m 以上的电缆来校正测试仪的 NVP 值，测试样线愈长，测试结果愈精确 【衰减测试】衰减当信号在电缆中传输时，由于其所遇到的电阻而导致传输信号的减小，信号沿电缆传输损失的能量称为衰减，如果衰减过高，信号强度会过早衰退，数据就会丢失 衰减会随着频率的增高而增大，随着长度的增大而增高，也随着温度的升高而增长，以分贝 dB 来度量 衰减量衰减是一种插入损耗，即在传输系统的某处由于元件或器件的插入而发生的负载功率的损耗 当考虑一条通信链路的总插入损耗时，布线链路中所有的布线部件都对链路的总衰减值有贡献，一条链路的总插入损耗是电缆和布线部件的衰减的总和 衰减量由下述各部分构成： 布线电缆对信号的衰减 构成通道链路方式的 10m 跳线或构成基本链路方式的 4m 设备接线对信号的衰减量 每个连接器对信号的衰减量 不同类型电缆在不同频率、不同链路方式下每条链路的最大允许衰减值以 20°C 为基准，一般来说，温度每升高 10°C，线缆的信号衰减就增大 4%，常见的三类线缆温度与衰减量的关系如下： 3 类电缆每增加 1°C，衰减量增加 1.5% 5e 类电缆每增加 1°C，衰减量增加 0.4% 6 类电缆每增加 1°C，衰减量增加 0.3% 衰减原因现场测试中衰减有两个原因： 链路超长：电缆越长，链路的衰减就越明显，就好比一个人在向距离很远的另一个人喊话，如果距离过远，声音衰减过大导致对方无法听清，信号传输衰减也一样，它会导致网络速度缓慢甚至无法互联 链路阻抗异常：生产工艺不同导致双绞线插头和插座进行对接时有匹配兼容性问题，下图描述了双绞线阻抗变化的几种原因 过高的阻抗消耗了过多的信号能量，致使接收方无法判决信号，当传输通道阻抗存在时，会随着信号频率增加，使得信号的高频分量衰减加大 【串扰测试】串扰由于每对双绞线上都有电流流过，有电流就会在线缆附近造成磁场，为了尽量抵消线与线之间的磁场干扰，包括抵消近场与远场的影响，达到平衡的目的，所以把同一线对进行双绞 但线缆制造厂商采用了彼此不同的布线设计，质量稳定性差别很大，另外，在线缆连接处的水晶头和模块插座等，必须把双绞线拆开，这样就会造成 1、2 号线对的一部分信号泄漏出来，被 3、6 号线对接收到，泄漏出来的信号被称为串扰 串扰分为近端串扰(NEXT)、远端串扰(FEXT)两种，由于远端串扰影响较小，因此测试仪主要测量近端串扰 近端串扰测试近端串扰从一个发送信号线对泄漏出来的能量被认为是这条电缆内部噪声，因为它会干扰其他线对中的信号传输，近端串扰是测量来自其它线对泄漏过来的信号 近端串扰并不表示在近端点所产生的串扰，而只表示在信号发送端(近端)进行测量 测试方法测试仪通过在一个线对发送测试信号并测量在另一个线对上的串扰信号幅度的方法来测定串扰，在测量电缆的同一端时，串扰值是由测试信号与串扰信号幅度差来计算，即： 近端串扰=测试信号-串扰信号近端串扰值越高，串扰信号越小，高的近端串扰值相当于低串扰和更好的电缆性能 近端串扰是频率的函数，串扰随着频率的增大而增大，超过一定的限制就会对传输的数据产生破坏，从下图可看出，近端串扰曲线呈不规则形状，因为近端串扰与频率的函数关系太复杂，并且很多频率低的地方其近端串扰大于频率高的地方，必须参照电缆带宽频率范围测试很多频率采样点，以免漏掉最差频率采样点 双向测试一条非屏蔽双绞线的近端串扰损害会在每一对线之间进行，共有 4 对线对，因此对于一条双绞线电缆，需要测试 6 次近端串扰 当近端串扰发生在距离测试端较远的远端时，尤其当链路长度超过 40m 时，该串扰信号经过电缆的衰减到达测试点时，其影响可能已经很小，无法被测试仪器测量而被忽略，因此必须要进行双向测试 双向测试就是对近端串扰测试要在链路两端各进行一次测试，即总共需要测试 12 次，在一端进行测试的排列顺序如下： 其中，横线左边的数字表示干扰信号线对，横线右边的数字表示被干扰信号线对 综合近端串扰近端串扰是一个线对对另一个线对的串扰，如果同时考虑多对线缆之间同时发生的串扰的相互影响，即考虑同一时间 3 个线对对同一线对的影响，这就是综合近端串扰(PSNEXT) 简单来说，综合近端串扰是所有其它绕对对一对线的近端串扰的组合 综合近端串扰实际上是一个计算值，而不是直接的测量结果，综合近端串扰是在每对线受到的单独来自其他 3 对线的近端串扰影响的基础上通过公式计算出来的 综合近端串扰值是双绞线布线系统中的一个新的测试指标，只有 5e 类和 6 类电缆中才要求测试综合近端串扰，这种测试在千兆以太网基于 4 对双绞线全双工传输模式中非常重要 等效远端串扰与近端串扰定义相类似，远端串扰是信号从近端发出，而在链路的另一侧（远端），发送信号的线对向其同侧其他相邻接收线对造成的串扰 因为信号的强度与它所产生的串扰及信号的衰减有关，所以电缆长度对测量到的远端串扰值影响很大，因此远端串扰并不是一种很有效的测试指标，在测量中是用等效远端串扰(ELFEXT)的测量代替远端串扰值的测量 等效远端串扰是指某线对上远端串扰损耗与该线路传输信号的衰减差，其单位同样为分贝 dB，计算公式为： 等效远端串扰=远端串扰-A其中，$A$ 为受串扰接收线对的传输衰减(Attenuation) 综合等效远端串扰综合等效远端串扰(PSELFEXT)与综合近端串扰相似，其是几个同时传输信号的线对在接收线对形成的等效远端串扰的总和，对于 4 对非屏蔽双绞线而言，它组合了其他 3 对线对第 4 对线的等效远端串扰的影响 【衰减与串扰比测试】通信链路在信号传输时，衰减和串扰都会存在，串扰反映电缆系统内的噪声，衰减反映线对本身的传输质量，这两种性能参数的混合效应可以反映出电缆链路的实际传输质量，衰减与串扰比(ACR)用来表示这种混合效应 衰减与串扰比的单位仍为分贝 dB，其定义为：被测线对受相邻发送线对串扰的近端串扰值与本线对传输信号衰减值的差值，即： ACR=NEXT-A就其值来说，有： ACR=测试信号-串扰信号-A其中，$A$ 为受串扰接收线对的传输衰减(Attenuation) 近端串扰越高，衰减越小，则衰减与串扰比越高，其类似于信号噪声比，干扰噪声强度与信号强度相比越小越好 需要注意的是，衰减、近端串扰和衰减串扰比是频率的函数，因此应在同一频率下计算 【传输时延和时延偏离】传输时延是信号在电缆线对中传输时从电缆一端传输到另一端所需要的时间，其随电缆长度的增加而增加，测量标准是指信号在 100m 电缆上的传输时间，单位是纳秒，它是衡量信号在电缆中传输快慢的物理量 同一电缆中各线对之间由于使用的缠绕比率不同，长度也会有所不同，因而各线对之间的传输时延也会略有不同 由于在千兆网中使用 4 对线传输，且为全双工，在数据发送时，采用了分组传输，即将数据拆分成若干个数据包，按一定顺序分配到 4 对线上进行传输，而在接收时又按照反向顺序将数据重新组合，当信号通过不同线对传输的到达时间相差太远时，就会造成数据丢失 时延偏离是指同一非屏蔽双绞线中传输速度最快的线对和传输速度最慢线对的传输延迟差值，用纳秒标识，一般在 50ns 范围以内 传输时延和时延偏离是某些高速 LAN 应用的重要特征，因此它们应该包括在性能测试组中，尤其是对于准备运行使用多线对的某一高速协议的网络 对于传输时延，将报告最差的那个线对，对于时延偏离，则报告任意两个线对的最差组合 【回波损耗】在全双工网络中，当一对线负责发送数据的时候，在传输过程中遇到阻抗不匹配的情况时就会引起信号的反射，即整条链路有阻抗异常点，而信号反射的强弱与阻抗有关，例如断开时阻抗无穷大，导致信号 100% 的反射 信号在介质中传播时，介质应是均匀的，即介质针对该信号的阻抗应该是一致的，但由于介质与设备的连接需要接线，并且介质在传输线路中不可避免的改变形状、自身的加工误差等都会影响介质的阻抗，阻抗的变化会造成传输中信号的反射和损耗 在全双工通信时，整条链路既负责发送信号也负责接收信号，如果遇到信号的反射，之后与正常的信号进行叠加后就会造成信号的不正常，被反射到发送端的能量会形成噪声，导致信号失真，从而降低通信链路的传输性能 这种由于线路中阻抗不匹配所造成的能量反射而引起的损耗称为回波损耗，这个参数是在 CAT5E 链路测试标准中出现的，测试该参数是出于 1000BASE-T 全双工传输的需要 回波损耗定义为：开始输入给信号传送系统的信号与信号源接收到的反射信号的功率之比，即： 回波损耗=\\frac{发送信号}{反射信号}回波损耗越大，则反射信号越小，意味着电缆和相关连接硬件阻抗一致性越好、传输信号越完整、噪声越小，因此回波损耗越大越好","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"电缆测试类型","slug":"network-testing/11.电缆测试类型","date":"2020-07-10T12:17:00.000Z","updated":"2021-08-23T13:08:20.483Z","comments":true,"path":"notes/network-testing/4c47cc5.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/4c47cc5.html","excerpt":"【验证测试】验证测试又叫随工测试，是在施工过程中为了确保布线工程的施工质量，边施工边测试，主要是检测线缆的质量和安装工艺，及时发现并纠正问题，避免返工 验证测试不需要使用复杂的测试仪，只需要使用简单的测试设备测试接线通断、线缆长度及接线图等物理性能","text":"【验证测试】验证测试又叫随工测试，是在施工过程中为了确保布线工程的施工质量，边施工边测试，主要是检测线缆的质量和安装工艺，及时发现并纠正问题，避免返工 验证测试不需要使用复杂的测试仪，只需要使用简单的测试设备测试接线通断、线缆长度及接线图等物理性能 在工程竣工检查中，短路、反接、线对交叉、链路超长等问题约占整个工程质量问题的 80%，这些问题在施工初期通过重新端接、调换线缆、修正布线路由等措施比较容易解决，若等到完工验收阶段，再发现这些问题，解决起来就比较困难 【认证测试】概述认证测试又叫验收测试，是所有测试工作中最重要的环节，是在工程验收时对综合布线系统的安装、电气特性、传输性能、设计、选材和施工质量的全面检验 认证测试是基于国内或国际的标准对电缆进行测试，测试完成后要有测试报告，报告中包括了测试地点、操作人员和仪器、测试的标准、电缆的识别号、测试的具体参数和结果等 认证测试依据标准对综合布线系统逐项检测，以确保布线是否能达到设计要求，包括连接性能测试和电气性能测试 认证测试通常分为两种类型：自我认证测试、第三方认证测试 自我认证测试自我认证测试主要由施工方自行组织，按照设计施工方案对所有链路进行测试，确保每条链路都符合标准要求，如果发现未达标准的链路，应该进行整改，直至复测合格 由施工方组织的认证测试，可邀请设计、施工、监理多方参与，建设单位也应派遣网管人员参加这项测试工作，以便了解整个测试过程，方便日后管理与维护系统 第三方认证测试对于工程要求高、使用器材类别多、投资较大的工程，建设方除要求施工方要做自我认证测试外，还邀请委托第三方对工程做全面验收测试，以确保布线施工的质量 建设方请第三方对综合布线系统链路做抽样测试，按工程大小确定抽样样本数量，一般 1000 信息点以上的抽样 30%，1000 信息点以下的抽样 50%","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"电缆测试模型","slug":"network-testing/10.电缆测试模型","date":"2020-07-10T11:16:00.000Z","updated":"2021-08-23T12:57:27.172Z","comments":true,"path":"notes/network-testing/6224e557.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/6224e557.html","excerpt":"【概述】对综合布线系统进行测试之前，首先要确定被测试的链路的测试模型 综合布线的认证测试链路主要指双绞线水平布线链路，TSB-67 定义了两种标准的测试模型：基本链路模型、通道模型","text":"【概述】对综合布线系统进行测试之前，首先要确定被测试的链路的测试模型 综合布线的认证测试链路主要指双绞线水平布线链路，TSB-67 定义了两种标准的测试模型：基本链路模型、通道模型 GB 50312—2007 规定 3 类和 5 类布线系统按照基本链路和信道进行测试，5e 类和 6 类布线系统按照永久链路和信道进行测试 综上，常见的链路测试模型由三种： 基本链路模型测试 永久链路模型测试 通道测试 【基本链路模型】基本链路用来测试综合布线中的固定链路部分，由于综合布线承包商通常只负责这部分的链路安装，链路质量由其负责，所以基本链路又称为承包商链路 基本链路长度最长为 $90+2+2=94m$，其包括三部分： 最长为 90m 的在建筑物中固定的水平布线电缆 水平电缆两端的接插件，一端为工作区信息插座，另一端为楼层配线架 两条与现场测试仪相连的 2m 测试设备跳线 如下图，其中 $F$ 为信息插座至配线架之间的电缆，$G$、$E$ 为测试设备跳线，满足 $G+F+E\\leq 94$ 【永久链路模型】基本链路模型包含的两根 2m 长的测试跳线，与测试设备配套使用的，虽然它的品质很高，但随着测试次数的增加，测试跳线的电气性能指标可能发生变化并导致测试误差，这种误差包含在总的测试结果之中，就会直接影响总的测试结果 永久链路模型用永久链路适配器连接测试仪表和被测链路，测试仪表能自动扣除 F、I 和 2m 测试线的影响，排除了测试跳线在测试过程中本身带来的误差，从技术上消除了测试跳线对整个链路测试结果的影响，使测试结果更准确、合理 永久链路模型长度最长为 $90m$，其包括三部分： 最长为 90m 的水平电缆，不包括链路以外的总共 4m 的测试跳线 水平电缆两端的接插件，一端为工作区信息插座，另一端为楼层配线架 链路可选的转接连接器(CP) 如下图，$G$ 为可选转接电缆，$H$ 为从信息插座或可选转接连接器到楼层配线设备的水平电缆，$F$、$I$ 为测试仪跳线，满足 $ G+H\\leq 90$ 【通道模型】通道模型在永久链路模型的基础上，增加了包括工作区和电信间的设备电缆和跳线在内的部分，即端到端的整体链路，是用户所关心的，所以通道又称作用户链路 对于用户来说，用于高速网络的传输或其他通信传输时的链路不仅仅要包含永久链路部分，而且还包括用于连接设备的用户电缆，希望得到通道的测试报告 通道模型长度最长为 $90+10=100m$，其包括四部分： 最长 90m 的在建筑物中固定的水平电缆 水平电缆两端的接插件，一端为工作区信息插座，另一端为配线架 一个靠近工作区的可选的附属转接连接器 最长 10m 的在楼层配线间跳线架上的两处连接跳线和用户终端的连接跳线 如下图，$A$ 为用户端连接线，$B$ 为转接电缆，$C$ 为水平电缆，$D$ 为配线架连接线，$E$ 为配线架到网络设备间的连接线，满足 $B+C\\leq 90,A+D+E\\leq 10$","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"综合布线系统的故障","slug":"network-testing/09.综合布线系统的故障","date":"2020-06-17T12:02:00.000Z","updated":"2021-08-23T12:57:39.706Z","comments":true,"path":"notes/network-testing/6de6a538.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/6de6a538.html","excerpt":"【概述】局域网的安装是从电缆开始的，电缆是网络最基础的部分 据统计，大约 50% 的网络故障与电缆有关，因此电缆本身的质量以及电缆安装的质量都直接影响网络能否健康的运行","text":"【概述】局域网的安装是从电缆开始的，电缆是网络最基础的部分 据统计，大约 50% 的网络故障与电缆有关，因此电缆本身的质量以及电缆安装的质量都直接影响网络能否健康的运行 很多布线系统是在建筑施工中进行的，此时就很难或根本不可能再对电缆进行修复，即使修复，其代价也相当昂贵，所以最好的方法就是把电缆故障消灭在安装之中 如何检测安装的电缆是否合格，它能否支持将来的高速网络，用户的投资是否能得到保护就成为关键问题 【物理故障】物理故障主要是指由于主观因素造成的可以直接观察的故障，如：接头的线序错误，链路的开路、短路等 物理故障中最常见的是线序错误，标准的接线方式 T568A、T568B 能够保证正确的双绞线序，但在施工时，由于施工人员或用户不了解接线标准，会导致很多接线故障，这些故障利用一般的通断型测试仪就能轻易检测出来，这类仪器最便宜的仅几十元 对于开路、短路这类故障，通常利用具有时域反射技术(TDR)的设备进行定位，精度高的仪器距离误差可控制在 2% 左右 物理故障实际上通过随工进行的验证测试是很容易发现和解决的 【电气性能故障】电气性能故障主要是指链路的电气性能指标未达到测试标准的要求，诸如近端串扰、衰减、回波损耗等 目前，网络传输对线路的电气性能要求也越来越高，对电气性能测试的标准也越来越高，项目也越来越多 对于电气性能故障，不同的指标具有不同的测试方法 【电缆测试技术】时域反射技术 TDR时域反射技术是用来测试链路的长度以及确定链路故障，其在双绞线对上采用雷达原理，它向被测线对发送一个高能驱动脉冲，反射信号被捕捉、测量和输出显示出来 高能驱动脉冲行走于电缆线对上，对线缆上阻抗突然改变的故障点（开路、短路、电缆进水等）产生反射信号 高精度时域反射技术 HDTDR高精度时域反射技术是美国 Fluke 公司的测试仪中采用的高精度的时域反射技术，主要针对有阻抗变化的故障进行精确定位 它的原理是基于 TDR 技术的，该技术是通过在被测线对中发送测试信号，同时检测信号在该线对的反射相位和强度来确定故障的类型，通过信号反射的时间和信号在电缆中传输的速度精确地报告故障的具体位置 高精度时域串扰分析技术 HDTDX高精度时域串扰分析技术主要针对各种导致串扰的故障进行精确的定位，以往对串扰的测试仅能提供串扰发生的频域结果，即仅知道串扰发生在哪个频点（MHz），并不能报告串扰发生的物理位置 HDTDX 技术通过在一个线对上发送测试信号，同时在时域上对相邻线对测试串扰信号，由于是在时域进行测试，因此根据串扰发生的时间以及信号的传输速度可以精确定位串扰发生的物理位置","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"综合布线系统工程设计","slug":"network-testing/08.综合布线系统工程设计","date":"2020-06-15T06:52:00.000Z","updated":"2021-08-23T12:57:33.777Z","comments":true,"path":"notes/network-testing/da62c631.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/da62c631.html","excerpt":"【概述】综合布线系统工程设计是整个网络布线工程建设的蓝图和总体框架结构，网络方案的质量将直接影响到网络工程的质量和性价比 设计时，从整个系统的设计原则出发，在总体设计的基础上进行 6 个子系统的详细设计","text":"【概述】综合布线系统工程设计是整个网络布线工程建设的蓝图和总体框架结构，网络方案的质量将直接影响到网络工程的质量和性价比 设计时，从整个系统的设计原则出发，在总体设计的基础上进行 6 个子系统的详细设计 设计综合布线系统一般采用星型拓朴结构，该结构下的每个分支子系统都是相对独立的单元，对每个分支单元系统的改动都不影响其它子系统 【设计等级】按照 GB50311 中的规定，综合布线系统的设计可以划分为三种标准的设计等级：最低型、基本型、综合型 最低型的基本配置要求： 每一个工作区有 1 个信息插座 每个信息插座的配线电缆为一条 4 对对绞电缆 干线线缆配置要求每个工作区至少有 2 对双绞线 基本型的基本配置要求： 每个工作区有 2 个或 2 个以上信息插座 每个工作区的配线电缆为一条 4 对双绞线，引至楼层配线架 干线电缆配置要求每个工作区至少有 3 对双绞线电缆 综合型的基本配置要求： 在以上两种配置的基础上增设光缆系统 垂直干线的配置要求每 48 个信息插座宜配 2 芯光纤，适用于计算机网络，按信息插座所需线对的 25% 配置垂直干线电缆 当楼层信息插座较少时，在规定长度的范围内，可几层合用集线器，并合并计算光纤芯数，每一楼层计算所得的光纤芯数还应按光缆的标称容量和实际需要进行选取 如有用户需要光纤到桌面（FTTD），光纤可经或不经 FD 直接从 BD 引至桌面 楼层之间原则上不铺设垂直干线电缆，但在每层的 FD 可适当预留一些接插件，需要时可临时布放合适的缆线 【工作区子系统设计】一个独立的需要设置终端设备的区域称为一个工作区，工作区子系统应由水平布线系统的信息插座，以及延伸到工作站终端设备处的连接线缆及适配器组成 工作区子系统的设计首先要确定每个工作区内应安装信息插座的数量，一部电话机或一台计算机终端设备的服务面积可按 5-10 平方米设置，也可按用户要求设置 工作区子系统设计要点如下： 工作区内线槽的敷设要合理、美观 信息座设计在距离地面 30cm 以上 信息座与计算机设备的距离保持在 5m 范围内 购买的网卡接口类型要与线缆接口类型保持一致 各个工作区所需的信息座、面版的数量要准确 每个信息插座旁边有一个单相电源插座，以备计算机或其他有源设备使用 信息插座与电源插座间距不得小于 20cm 【水平布线子系统设计】水平布线子系统由每层配线间引至信息插座的配线电缆和工作区用的信息插座等组成，在整个网络布线系统中，水平子系统是最难事后维护的子系统之一，因此在设计时，应当充分考虑到线路冗余、网络需求和网络技术的发展 拓扑结构水平布线子系统的拓扑结构为星型拓扑结构，即每个信息点都有一条独立的从信息插座到楼层配线架的线路，星形拓扑结构可以使工作区和管理区之间使用专用线缆连接，相互独立，便于线路故障的隔离以及故障的诊断 传输介质长度当使用双绞线作为传输介质时，理论上 5 类双绞线传输 100Mb/s 网络信号的最大长度为 100m，但由于工作区的跳线和楼层配线架的的跳线要占用 10m，因此水平电缆最大长度为 90m 当信息插座借助水平线缆直接连接至楼层配线架时，水平线缆的最小长度不应小于 15m 当水平线缆中拥有一个集合点(CP)时，集合点与楼层配线间的线缆最小长度不应小于 15m，集合点至信息插座的线缆最小长度不应小于 5m 布线材料要求水平布线子系统通常采用 4 对超 5 类或 6 类非屏蔽双绞线，对网络传输速率和安全性有较高要求或者电磁干扰严重的场合，可选用光缆或屏蔽双绞线 水平线缆应布设在线槽内，线缆布设数量应考虑只占用线槽截面积的 70%，以方便以后的线路扩充的需求 从配线架至每一个工作区水平光缆宜按 2 芯光缆配置，光纤至工作区满足用户群或大客户使用时，光纤芯数至少应有 2 芯备份，即按 4 芯光缆配置 每一个工作区信息插座模块数量不宜少于 2 个，宜采用双口面板。 信息模块的需求量一般为： m=n*(1+3\\%)其中 $m$ 为信息模块的总需求量，$n$ 为信息点的总量，$3\\%$ 为富余量 路由规划在进行路由规划时，要根据建筑物的结构特点，从路由最短、造价最低、施工方便、布线规范等几个方面考虑，可采用以下三种类型： 直接埋管式 地面线槽式 先吊顶内桥架再支管到信息出口式 直接埋管式直接埋管式由一系列密封在现浇混凝土里的金属布线管道或金属走线槽组成，这些金属管道或金属线槽从配线间向信息插座的位置辐射，目前多使用厚壁镀锌钢管及高阻燃强度的 PVC 管 这种方式在老式建筑的设计中非常普遍，老式建筑面积不大，信息点不多，设计、安装、维护方便，造价较低 地面线槽式该方式就是从弱电井出来的线走地面线槽到地面出线盒或由分线盒出来的支管到墙上的信息出口 它是将长方形的线槽打在地面垫层中，每隔 4~8m 拉一个过线盒或出线盒 这种方式适用于大开间或需要打隔断的场合，不适合楼层中信息点特别多的场合，不适合石质地面，地面线槽方式造价昂贵，是吊顶内线槽方式的 3~5 倍，目前大多数用在资金充裕的金融楼宇中 先吊顶内桥架再支管到信息出口式吊顶内桥架即线槽，其由金属或高阻燃强度 PVC 材料制成，线槽通常悬挂在天花板上方的区域，用在大型建筑物或布线系统比较复杂而需要额外支持物的场合 弱电井出来的线缆先走吊顶内的线槽，到各房间后，经分支线槽从横梁式电缆管道分叉后将电缆穿过一段支管引向墙柱或墙壁，贴墙而下到本层的信息出口，最后端接在用户的插座上 【垂直干线子系统设计】概述垂直干线子系统是通过建筑物内部的传输线缆，把各个管理间的信号传送到设备间，然后传送到最终接口，再通往外部网络，它必须既满足当前的需求，又适应今后的发展 垂直干线子系统采用星形拓扑结构，即从主设备间到每个楼层配线架间都有一条独立的多芯光缆。同时，敷设 2~4 根 6 类非屏蔽双绞线作为数据主干的备份 设计要点1.确定干线子系统的规模 主要从所要服务的可用楼层面积来考虑，如果在给定楼层所要服务的所有 I/O 设备都在配线间的 75 米范围之内，则采用单干线接线系统，凡不符合这一要求的则要采用双通道干线子系统，或者采用经分支电缆与楼层配线间相连接的二级交接间 2.确定每层楼和整座楼的干线要求 要根据水平子系统所有的语音、数据、图像等信息插座的要求计算干线电缆类别和数量 基本型：每个工作区可选定 2 对双绞线 增强型：每个工作区可选定 3 对双绞线 综合型：每个工作区可在基本型或增强型的基础上增设光缆系统 确定每楼层的规模后，将所有楼层的干线分类相加，就可确定整座建筑物的干线线缆类别和数量 3.确定楼层配线间至设备间的垂直干线电缆路由 应选择干线线缆最短、确保人员最安全和最经济的路由，有电缆孔方法、电缆井方法两种方法 电缆孔方法是在干线信道中钻设电缆孔，通常是一根或几根直径 10 厘米的钢性金属管道 电缆井方法是在每层楼板开出一些方孔，这些电缆穿过这些电缆井从这层延伸到相临的楼层，但安装造价过高，很难防火，如果没采取措施防止破坏楼板支撑件，则楼板的结构完整性将受到破坏 4.确定单层建筑物的水平主干线电缆路由 垂直干线子系统并非一定是垂直布置的，如在单层平面的大型厂房中，主干子系统就是平面布置的，它同样起着连接各配线间的作用，有金属管道法、电缆托架法两种方法 金属管道法是将干线电缆放在金属管道中，金属管道保护电缆，管道对电缆机械保护，而且防火，但难以重新布置，不太灵活，造价高 电缆托架法是利用外形像梯子的托架吊顶使用，常用于电缆繁多的时候，很难防火，不太美观 5.确定二级交接间和配线间之间的结合方法 对于二级交接间和配线间之间的结合，有点到点端接法、分支接合法两种方法 点到点端接法是最简单、最直接的接合方法，其首先选择一根含有足够数量双绞线电缆或光纤，容量足以支持一个楼层的全部信息插座需要，然后从设备间引出这根电缆，经过干线通道，端接于该楼层的一个指定配线间里的连接用硬件 分支接合法使用一根大对数电缆作为主干，经过线缆接头保护箱分出若干根小线缆，分别延伸到每个交接间或每个楼层，并终结于目的地的配线设备 布线材料要求由于主干布线的距离都非常近，因此可以采用廉价的 $50/125μm$ 或 $62.5/125μm$ 多模光纤 【管理子系统设计】概述管理子系统通常设置在各楼层的设备间内，主要由配线间（包括中间交接间，二级交接间）的配线硬件设备、输入/输出设备等组成 作为管理子系统，应根据管理的信息点的多少安排管理间的大小，如果信息点多，就应该考虑一个房间来放置，如果信息点少，就没有必要单独设立一个管理间，可选用墙上型机柜来处理子系统 配线架连接方式综合布线管理人员通过调整配线设备的交接方式，就有可能安排或者重新安排传输线路，而传输线路可延伸到建筑物内部的各个工作区，配线间内配线架与网络设备的连接方式有互相连接、交叉连接两种 相互连接互相连接是指水平线缆一端连接至工作间的信息插座，一端连接至配线间的配线架，配线架和网络设备通过插软线进行连接的方式,其使用的配线架前面板通常为 RJ-45 端口，因此网络设备与配线架之间使用 RJ-45-to-RJ-45 端口 交叉连接交叉连接是指水平链路中安装两个配线架，一端连接至工作间的信息插座，一端连接至设备间的配线架 1，网络设备通过接插软线连接至另一个配线架 2，再通过多条接插软线将两个配线架连接起来，从而便于对网络用户的管理 目前最常用的是交叉连接，其有三种方式：单点管理单交连、单点管理双交连、双点管理双交连 单点管理单交连在整幢大楼只设一个设备间作为交连区，从设备间直通到工作区的终端，信息点均直接点对点的与设备间连接，即只有一个管理单元，负责各信息点的管理，适用于楼层低、信息点数少的布线系统 单点管理双交连的管理单元位于设备间中的交换设备或互连设备附近，并在每楼层设置一个二级交接间的接线区作为互连区，该方式易于布线施工，适用于楼层高、信息点较多的场所 双点管理双交连在整幢大楼设有一个设备间，在各楼层还分别设有管理子系统，负责该楼层信息节点的管理，各楼层的管理子系统均采用主干线缆与设备间进行连接，由于每个信息点有两个可管理的单元，因此被称为双点管理双交连系统，该方式适合楼层高、信息点数多的布线环境 管理标记管理标记是由用户的网络管理人员和综合布线系统的设计人员共同制定标记方案，标记方案规定了各种参数和识别方法，以便查清配线架上交连场的各种线路和设备端接点，目前最常用是的 TIA/EIA-606 国际标识标准 三种标记综合布线系统一般常用三种标记： 电缆标记由背面为不干胶的白色材料制成，可直接贴到各种表面上，在交连场安装和做标记之前利用这些电缆标记辩别电缆的源发地和目的地 场标记也是由背面有不干胶的材料制成，可贴在设备间，配线间、二级交接间等布线场的平整表面上 插入标记用于设备间和二级接线间的管理场，插入标记是硬纸片，可以插入 1.27cm × 20.32cm 的透明塑料夹里，这些塑料夹位于接线块上的水平齿条之间，用色标来指明电缆的源发地 色标TIA/EIA-606 规定的色标如下： 橙色：多路复用器引来的线路 绿色：来自电信局的输入中继线 紫色：连接到用户交换机、大型计算机、局域网 红色：连接到关键的电话系统 白色：实现干线和建筑群电缆的连接 灰色：配线间与二级交接间之间的连接电缆或各二级交接之间的连接电缆 蓝色：对工作区的信息插座实现连接 黄色：辅助电路，如报警系统、安全或其他混杂线缆的端接 【设备间子系统设计】设备间子系统是按照核心网络设备和楼层网络设备的场地，是综合布线系统中最重要的管理区域，对综合布线工程设计而言，设备间主要安装总配线设备 由于在设备间安装了集线设备、网络服务器等大量电子设备，因此对设备的运行环境、防雷和接地等均有较为严格的规定 其设计要点如下： 1.设备间的位置 设备间的位置和大小应根据建筑物的结构、综合布线的规模和管理方式及应用系统设备的数量等综合考虑，择优选取 设备间宜设置在 2、3 层，高度为 3～18m 应尽量建在建筑物平面及其综合布线干线综合体的中间位置，可以保证水平布线的距离最短，不会超过双绞线所允许的 100m 最大传输距离 尽量靠近电梯附近，以便装运笨重设备 尽量避免设在建筑物的高层或地下室以及用水设备的下层 尽量远离强振动源和强噪声源 尽量避开强电磁场的干扰 尽量远离有害气体源以及易腐蚀、易燃、易爆物 2.建筑结构 设备间最小使用面积不得小于 20 平方米，设备间的净高依设备间使用面积的大小而定，一般为 2.5～3.2m 3.设备间的环境条件 温湿度的正常范围：10～30℃，湿度 60%～80% 照明：不低于 150lx 在频率范围 0.15 ～1000MHz 内，无线电干扰场强不大于120dB，机房内磁场干扰场强不大于 800A/m 4.电源 每个电源插座的容量不小于 300W 设备间应有可靠的交流电源供电，200V、50Hz 配有独立的开关控制电源插座，减少偶然断电的事故发生 设备间应采用 UPS 不间断电源，防止因市电停电或电压不稳导致的网络通信中断、设备损坏或故障 UPS 电源应提供不低于 2h 的后备供电能力，其功率应依据网络设备功率进行计算，并拥有 20%～30% 的余量 5.防火 根据消防防火级别设置确定设备间的设计方案，建筑内首先要求具备常规的消防栓、消防通道等，按设备间面积和设备分布装设烟雾、温度检测装置、自动报警警铃和指示灯、自动/手动灭火设备和器材 设备间火灾报警要求在一楼设有值班室或监控点 吊顶和墙面装修材料和构架应符合消防防火要求，使用阻燃型装修材料，进行表面阻燃涂覆处理，达到阻燃、防火的要求 根据综合布线系统的要求，在配线间安装布线硬件的墙壁上须覆盖涂有阻燃漆的 2cm 厚的木板 使用防火门、至少能耐火 1h 的防火墙和阻燃漆 提供合适的门锁，至少要有一扇窗口留作安全出口 【建筑群子系统设计】一个企业或某政府可能分散在几幢相邻建筑物或不相邻建筑物内办公，彼此间有语音、数据、图像和监控等联系，其连接各建筑物之间传输介质和各种支持设备组成一个建筑群综合布线系统 线缆选择建筑群数据网主干线缆一般应选用多模或单模室外光缆，芯数不小于 12 芯，宜用层绞式、中心管束式 建筑群数据网主干线缆使用光缆与电信公网连接时，应采用单模光缆，芯数应根据综合通信业务的需要确定 选用双绞线时，一般应选择高质量的大对数双绞线，当建筑群子系统使用双绞线电缆时，总长度不应超过 1500m 对于建筑群语音网，主干线缆一般可选用 3 类大对数电缆 线缆布设方式架空布线法用于现有的电线杆，电缆的走线方式不是主要考虑的场合，穿过建筑物的 U 形钢保护套，然后向上或下延伸，从电缆口进入建筑物内部，电缆入口的孔径一般是 5cm，最近的电线杆与建筑物距离应小于 30 米 直埋布线法根据选定的布线路由在地面上挖沟，然后将线缆直接埋在沟内，除了基础墙的那部分有导管保护，电缆其余部分直埋于地下，没有管道保护，直埋电缆通常应埋在距地面 0.6m 以下的地方，或按照当地城管等部门的有关法规去施工 地下管道布线法是一种采用管道和入孔组成的地下系统来布线，它把建筑群的各个建筑物进行互连，一根或多根管道通过基础墙进入建筑物内部的结构","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"综合布线系统的布线材料","slug":"network-testing/07.综合布线系统的布线材料","date":"2020-06-13T14:25:00.000Z","updated":"2021-08-23T12:57:46.033Z","comments":true,"path":"notes/network-testing/1f9a7a29.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/1f9a7a29.html","excerpt":"【概述】综合布线系统的传输介质主要是双绞线、同轴电缆和光纤，但组成一个网络传输通道系统还必须有其他布线设备、部件的配合 此外，虽然线缆的品质在很大程度上决定着综合布线的性能，但布线材料的选择和使用，也会对布线系统的整体性能产生决定性的影响","text":"【概述】综合布线系统的传输介质主要是双绞线、同轴电缆和光纤，但组成一个网络传输通道系统还必须有其他布线设备、部件的配合 此外，虽然线缆的品质在很大程度上决定着综合布线的性能，但布线材料的选择和使用，也会对布线系统的整体性能产生决定性的影响 在综合布线系统的设计和实施过程中，主要用到的布线材料有：配线架、信息插座、跳线、机柜、机架、线槽、管道等 【配线架】配线架用于联结光缆和电缆，为光缆和电缆与其他设备的连接提供接口，使布线系统变得更加易于管理 根据适用传输介质的不同，分为电缆配线架和光缆配线架 根据配线架所在位置的不同，分为用于建筑物或建筑群的主配线架和用于楼层的中间配线架 在规模较大的建筑物中，分配线架与信息插座之间还设置了中间交叉配线架，安装在二级交接间中 【机柜】机柜通常用于配线架、网络设备、通信器材和电子设备的叠放，采用全封闭或半封闭结构，具有增强电磁屏蔽、削弱设备工作噪音、减少设备地面面积占用的优点 最常见的一种标准机柜是用于 $19in(1in=2.54cm)$ 宽的服务器，机柜高度一般为 $700mm \\sim 2400mm$，机柜内设备安装所占高度用一个特殊的单位 $u(1u=44.45mm)$ 表示，常见规格有 $20u$、$30u$、$35u$、$40u$ 【机架】机架仅被用于综合布线，通过安装配线架和理线器，以实现对电缆和光缆布线系统的管理 一般为敞开式结构，不像机柜采用全封闭或半封闭结构，所以在空气洁净程度比较差的环境中，设备表面更容易积聚灰尘 【线槽】线槽主要包括金属槽和 PVC 槽两种，通过将凌乱的线缆置于线槽内，既可以美化布线环境，又起到阻燃、抗冲击、抗老化、防锈等作用 【管道】管道的作用与线槽类似，分为金属管和塑料管 【桥架】桥架用于水平和主干的架空式布线，适用于信息点数量较多的布线场合 【理线器】理线器安装在机柜或机架内，配合网络设备和配线架使用，其用于固定和整理线缆，使布线系统更加整洁、规范","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"综合布线系统的传输介质","slug":"network-testing/06.综合布线系统的传输介质","date":"2020-06-13T07:38:00.000Z","updated":"2021-08-23T12:57:52.836Z","comments":true,"path":"notes/network-testing/c00ea433.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/c00ea433.html","excerpt":"【概述】网络综合布线系统的设计和安装的对象是线缆，线缆的品质在很大程度上决定着综合布线的性能 常见的线缆有：双绞线、同轴电缆、光纤等","text":"【概述】网络综合布线系统的设计和安装的对象是线缆，线缆的品质在很大程度上决定着综合布线的性能 常见的线缆有：双绞线、同轴电缆、光纤等 【双绞线】概述双绞线是综合布线工程中最常用的一种传输介质，由两根、四根或八根具有绝缘保护层的铜导线组成，一个线对可以作为一条通信线路， 各线对为降低信号干扰互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消 虽然从表面上看，双绞线都差不多，但不同品牌双绞线的材料、结构以及绞率都不同，双绞线测试的不仅是连通性的问题，同时也包含了线缆材质测试和性能测试，涉及相当多的测试参数和标准 分类双绞线分为非屏蔽双绞线(UTP)和屏蔽双绞线(STP)，屏蔽双绞线电缆的外层由铝箔包裹，相对非屏蔽双绞线具有更好的抗电磁干扰能力，造价也相对高一些 实际应用中，在水平布线子系统和工作区子系统布线通常采用 4 对双绞线，而在垂直干线子系统布线时，往往采用大对数双绞线 大对数双绞线即将多对电缆组成一小捆，再由很多小捆组成一大捆 接线顺序EIA/TIA 的布线标准中，对于 RJ-45 水晶头接线方式进行了如下规定： 1、2 号线用于发送，3、6 号线用于接收，4、5、7、8 号线是双向线 1、2 号线双绞，3、6 号线双绞，4、5 号线双绞，7、8 号线双绞 此外，还规定了两种双绞线的线序 568A 和 568B： 直通线与交叉线直通线又称平行线，其两端都使用相同的接线标准，即两端 RJ-45 水晶头中的线序排列完全相同，适用于计算机到集线设备的连接 交叉线在制作时，两端 RJ-45 水晶头中的第 1、2 线和第 3、6 线对调，即一端采用 568A 标准，另一端采用 568B 标准，适用于计算机与计算机的连接 【光纤】概述随着光纤和光纤网络设备价格的不断下降，光纤被越来越多的应用于综合布线，目前，几乎所有的长途通信都是由光缆传输 光导纤维是一种传输光束的细而柔韧的媒质，通常是由石英玻璃制成，其横截面积是很小的双层同心圆柱体，也称为纤芯，质地脆，易断裂，由于这一缺点，需要外加一保护层，即包层 光纤的玻璃芯外面包裹一层折射率比芯低的玻璃封套，以使光纤保持在芯内，再外面是一层薄的塑料外套，用来保护封套，由于光纤本身非常脆弱，无法直接应用于布线系统，因此光纤通常被扎成束，外面有外壳保护，中间有抗拉线，就构成了光缆 主要特征光纤具有两个特征： 损耗：光纤单位长度上的衰减，其高低直接影响传输距离或中继站距离的远近，单位 db/km 色散：光纤传输中光信号达到一定距离后必然产生的信号失真 分类以一定角速度进入光纤的一束光称为模，根据光纤传输点模数，光纤可分为：单模光纤、多模光纤 单模光纤的纤芯较细，一般为 $8μm \\sim 10μm$，使单个波长的光线沿光纤一直传播，适用于远程通信，对光源要求较高，多用激光二极管来完成 多模光纤的纤芯较粗，一般为 $50μm \\sim 62.5μm$，多束光线以不同的反射角在同一条光纤中传播，因此到达目的地的时间不同，造成光脉冲逐渐展宽、失真，多用发光二极管作为光源 不同类型的光纤规格也不同： 单模光纤：$8/125μm$ 、$9/125μm$、 $10/125μm$ 多模光纤 欧洲标准：$50/125μm$ 美国标准：$62.5/125μm$ 工业、医疗和低速网络：$100/140μm$、$200/230μm$ 光纤连接器在安装任何光纤系统时，都必须以低耗的方法把光纤或光缆相互连接起来，以实现光链路的接续 光纤链路的接续，又可以分为永久性、活动性两种 永久性接续对于永久性的接续，大多采用熔接法、粘接法或固定连接器来实现，一般由专业网络公司完成 活动性接续对于活动性的接续，一般采用活动连接器来实现，活动连接器是用于连接两根光纤或光缆形成连续光通路的可以重复使用的器件，许多中小型局域网和网络的边缘连接一般都属于活动性连接 常见的光纤连接器类型有：SC(Subscriber Connector)、ST(Straight Tip)、LC(Lucent Connector)、FC(Fiber Connector) SC 型光纤连接器：外壳呈矩形，采用插针与耦合套筒结构， 通常用于连接设备，多用于千兆位接口转换器 GBIC 模块或其他 SC 型接口，价格低廉，插拔操作方便，介入损耗波动小，安装密度高 ST 型光纤连接器：外壳呈圆形，采用插针与耦合套筒结构，尺寸与 FC 型完全相同，紧固方式为螺丝扣，适用于各种光纤网络，很少用于连接网络设备，常用于实现与光纤配线架的连接 LC 型光纤连接器：采用操作方便地模块化插孔闩锁机理制成，尺寸是普通 SC、FC 型等所用尺寸的一半，提高了光纤配线架中光纤连接器的密度，损耗小，通常用于端口密度高的设备 FC 型光纤连接器：外部采用金属套，紧固方式为螺丝扣，结构简单，操作方便，制作容易，多用于单模光纤 光纤适配器光纤适配器被固定于光纤终端盒或信息插座，用于实现光纤连接器之间的连接，并保证光纤之间保持正确的对准角度 在某些情况下，由于终端设备与信息插座间的插头插座不匹配，无法直接使用信息插座，此时就必须借助于适当的适配器，使不同尺寸或类型的插头与信息插座相匹配，实现终端设备与信息插座之间的兼容，从而使光缆所连接的应用系统设备顺利接入网络 光电转换设备当垂直布线子系统采用光缆，水平布线子系统采用双绞线时，可以采用两种方式实现两种传输介质的连接： 同时拥有光纤端口、RJ-45 端口的交换机 光电转换器 两者相比较来说，模块化交换机的传输性能更高，而光电转换设备的价格更便宜","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"综合布线系统的组成","slug":"network-testing/05.综合布线系统的组成","date":"2020-06-11T02:51:00.000Z","updated":"2021-08-23T12:56:14.974Z","comments":true,"path":"notes/network-testing/bab2ed61.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/bab2ed61.html","excerpt":"【概述】综合布线系统是由线缆及相关连接硬件组成的信息传输的通道，是智能建筑连接 3A 系统各类信息必备的基础设施 综合布线的发展与建筑智能化系统密切相关，传统布线如电话、计算机局域网都是各自独立的，各系统分别由不同的厂商设计和安装，采用不同的线缆和不同的终端插座，而且连接这些不同布线的插头、插座及配线架均无法互相兼容","text":"【概述】综合布线系统是由线缆及相关连接硬件组成的信息传输的通道，是智能建筑连接 3A 系统各类信息必备的基础设施 综合布线的发展与建筑智能化系统密切相关，传统布线如电话、计算机局域网都是各自独立的，各系统分别由不同的厂商设计和安装，采用不同的线缆和不同的终端插座，而且连接这些不同布线的插头、插座及配线架均无法互相兼容 但办公布局及环境改变的情况是经常发生的，需要调整办公设备时，必须更换布线，这样会因增加新电缆而留下不用的旧电缆，天长日久，导致了建筑物内一堆堆杂乱的线缆，造成很大的隐患，维护不便，改造也十分困难 随着全球社会信息化和经济国际化的深入发展，人们对信息共享的需求日趋迫切，就需要一个适合信息时代的布线方案，经过多年的研究，在办公楼和工厂实验成功的基础上，美国电话电报公司的贝尔实验室在 20 世纪 80 年代率先推出了建筑与建筑群综合布线系统（PDS），后来发展为结构化布线系统 SCS，中华人民共和国国家标准 GB/T50311-2000 将系统正式命名为综合布线 GCS 综合布线系统由六个子系统组成：工作区子系统、水平布线子系统、管理间子系统、垂直干线子系统、设备间子系统、建筑群子系统 其网络链路结构组成如下： 【工作区子系统】工作区子系统是指包括办公室、写字间、作业间、机房等需要电话、计算机或其他终端设备（网络打印机、网络摄像头等）等设施的区域和相应设备的统称 工作区子系统是用户的办公区域，由设在各办公区内的信息插座至终端设备之间的连接线缆构成 工作区子系统由 RJ-45 跳线与信息插座所连接的设备组成，信息插座一般安装在距离地面 30cm 以上，有墙上型、地面型、桌上型等多种，从信息插座到工作设备间的连线用双绞线，一般不超过 5m 【水平布线子系统】水平布线子系统是连接工作区子系统和垂直干线子系统的部分，主要功能是将电缆从楼层配线架(FD)连接到各用户工作区上的信息插座的连线，一般处在同一楼层 水平布线子系统包括各楼层配线架至工作区信息插座之间的线缆、信息插座、转接点及配套设施 水平布线子系统通常使用的连接线是 4 对非屏蔽双绞线，长度一般不超过 90m，当需要更高的带宽应用时，亦可以采用光缆 【管理间子系统】管理间子系统是连接垂直干线子系统和水平布线子系统的纽带，主要功能是将垂直干线子系统与各楼层的水平布线子系统相互连接 主要设备有：配线架、交换机、集线器与标准机柜、电源等 【垂直干线子系统】垂直干线子系统是建筑物内综合布线系统的主干部分，提供高速数据通讯主干通道，由连接设备间子系统的主配线架至各楼层配线架之间的线缆及配套设施构成 垂直干线子系统通常安装在弱电井中，两端分别铺设到设备间子系统或管理间子系统，连接介质主要为光缆或大对数非屏蔽双绞线 【设备间子系统】设备间子系统是在每一幢大楼的适当地点设置进线设备，进行网络管理以及管理人员值班的场所，并建立与其他建筑物的连接，形成对外传输的通道 它是建筑群的线缆进入建筑物终接的场所，一般设在建筑物中部或在建筑物的一、二层，由建筑物引入建筑的线缆、各种公共设备（主机、各种控制系统、网络互联设备、监控设备等）和其他连接设备（主配线架等）组成 【建筑群子系统】建筑群子系统是将两个以上建筑物间的通信信号连接在一起的布线系统，其两端分别安装在设备间子系统的接续设备上，可实现大面积地区建筑物间的通信连接 其包括导线电缆、光缆、避免延及至其他建筑的铜缆漏电的保护设备等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"联系","slug":"daily/08.联系","date":"2020-05-28T16:35:00.000Z","updated":"2021-09-22T08:07:39.727Z","comments":true,"path":"essay/daily/ca8786c7.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/ca8786c7.html","excerpt":"你是否与我一样？ QQ 只是在挂机，微信用来付款，并没有人主动找你与你分享生活，你只是将手机当作一个既有用又累赘的工具，每天只是闲暇之余看看刷刷微博，看看评论区，更多的则是一直欺骗自己，让自己沉溺于假装繁忙的日常事务中。 如果是这样的话，那么，祝你安好，陌生人。","text":"你是否与我一样？ QQ 只是在挂机，微信用来付款，并没有人主动找你与你分享生活，你只是将手机当作一个既有用又累赘的工具，每天只是闲暇之余看看刷刷微博，看看评论区，更多的则是一直欺骗自己，让自己沉溺于假装繁忙的日常事务中。 如果是这样的话，那么，祝你安好，陌生人。 不记得什么时候开始，或许早个五六年，又或许早个七八年，生日、节日、过年这些东西完全与我无关，从未有人会在这些特殊的日子里想起我，哪怕是一声微不足道的 “节日快乐”。 最开始好像还有些难过，后来也就习惯了，然后，不知道什么时候开始，每到这些特殊的日子，我就会把自己关起来，扔掉一切电子设备，在房间里待上整整一天，或是深度阅读，或是一直睡觉，又或是躺在床上盯着天花板发呆，然后期待第二天打开手机后，有人能够想起我来。 但怎么可能会有呢？ 最近有在重读《德意志意识形态》，读着读着就突然想到了联系的普遍性与客观性，头一次觉得这听起来是这么的浪漫又心酸。 无论相隔多远，我们仍在相互纠缠。 我好像逐渐在失去所有的联系。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"网络系统性能测试","slug":"network-testing/04.网络系统性能测试","date":"2020-05-26T11:55:00.000Z","updated":"2021-08-23T12:56:03.735Z","comments":true,"path":"notes/network-testing/d882e289.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/d882e289.html","excerpt":"【网络容量】交换机容量交换机的交换容量又称为背板带宽或交换带宽，是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量，其表明了交换机总的数据交换能力，单位为 Gbps，一般的交换机的交换容量从几 Gbps 到上百 Gbps 不等，一台交换机的交换容量越高，所能处理数据的能力就越强，但同时设计成本也会越高","text":"【网络容量】交换机容量交换机的交换容量又称为背板带宽或交换带宽，是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量，其表明了交换机总的数据交换能力，单位为 Gbps，一般的交换机的交换容量从几 Gbps 到上百 Gbps 不等，一台交换机的交换容量越高，所能处理数据的能力就越强，但同时设计成本也会越高 交换容量交换机的交换容量是交换机实际能转发的速率，与该交换机本身的设计有关，其计算公式为： 交换容量 = 缓存位宽 * 缓存总线频率假设交换机的缓存位宽为 $96bit$，缓存总线频率为 $133MHz$，那么其交换容量为： 96*133=12.8Gbps端口容量对于交换机的端口容量，其计算公式为： 2 *（n*100Mbps+m*1000Mbps)其中，$2$ 代表全双工工作模式，$n$ 表示交换机有 $n$ 个 $100M$ 端口，$m$ 表示交换机有 $m$ 个 $1000M$ 端口 对于一由 $24$ 个 $100Mbps$ 口的交换机构成的子网段，各端口的连接介质都是速度可达 $100Mbps$ 的非屏蔽双绞线，若要求各端口都以全双工 $100Mbps$ 的速度工作，则该交换机的端口容量为： 2*24*100Mbps=4.8Gbps即若要保证该网段能够全线速工作，则该交换机的交换容量必须达到 $4.8Gbps$ 以上 帧的转发速度在物理介质上允许的最大传输速度称为线速，对于以太网而言，目前的线速有 $10Mbps$、$100Mbps$、$1000Mbps$、$10Gbps$ 几种 在物理层的线路和接口上是以位来计算速度，以便与通信技术匹配，而在数据链路层上，是以帧的形式来激进型传输和计算的，因此，对于一个二层设备，在衡量其性能时，主要使用帧转发速度，其单位是pps(帧/秒) 一个普通的以太网数据帧大小可以从 $64B$ 到 $1518B$，长度是不固定的，那么帧的转发速度也就因帧的长度不同而各异，其计算公式为： 帧转发速度=\\frac{线速bps}{(最小数据帧长+最小帧间隙+前同步位)bit}以 $10Mbps$ 的以太网来说，最小的数据帧长度为 $64B$ 即 $512bit$，帧间隙最小为 $12B$ 即 $96bit$，帧的前同步位 $8B$ 即 $64bit$，因此 $10Mbps$ 以太网所能达到的帧的最快转发速度为： \\frac{10Mbps}{(512+96+64)b}=\\frac{107bps}{672b}=14881 pps以太网有效吞吐量吞吐量是指在没有帧丢失的情况下，设备能够接受的最大速率 以太网的最大有效吞吐量计算公式为： 有效吞吐量=\\frac{帧大小B\\:\\:*\\:\\:线速bps}{(前导位+帧大小+校验位+最小帧间隙)B}以 $10Mbp$ 以太网为例，最小数据帧为 $64B$，其中包含 $4B$ 的校验位，最小帧间隙为 $12B$，前导位为 $8B$，则最大有效吞吐量为： \\frac{60B*10Mbps}{(8+60+4+12)B}=7.14Mbps【网络性能】虽然有了网络容量，但在实际运行中由于线路及环境情况的影响，加上拓扑设计、设备和协议本身都可能对信息传输造成影响，使系统无法达到理论上的网络容量值 最常见的以太网采用的是 CSMA/CD 的存取访问方式，资源的争用冲突是必然存在的，但过多的冲突会导致网络性能下降，以至于严重时会出现瘫痪的情况 数据包丢失在所有的网络设备里都设有数据包缓冲区，如果到达的数据包超过了该设备的传输能力，缓冲区就会被很快填满，新到达的数据包因无缓冲区可用而被设备丢弃 通常使用大的 ping 数据包来进行测量丢包情况，小包直接用 ping 命令，测试次数根据需要调整，如果小数据包通过，大数据包出现丢失，通常表明某处路由器或交换机缓冲出现了问题 网络响应时间丢包是网络性能的一个要素，但是不能精确反映网络的整体性能，用户对网络的感受并不局限于某个应用是否能连通，还包括利用该网络服务处理数据要花多长时间，即网络响应时间 网络响应时间是从用户发出服务请求开始，到用户收到了服务应答为止，中间所需的时间延迟 大型网络中，有许多因素可能影响到客户端和服务器之间的响应时间，有些管理员可以控制，有些在管理员的控制范围之外，常见的影响因素有：过载的网段、网络错误、网络布线出现故障、广播风暴、网络设备出现问题、过载的网络主机 在网络正常的时候使用 ping 命令，发送多个数据包，计算这些数据包响应时间的平均值，以此为标准建立一个基线值 当出现故障时，就可以将 ping 的响应时间值和正常时的基线值相比较，找出链路上响应时间值偏差最大的设备节点，便于问题的查找 如下图，执行 ping -n 10 211.84.7.10 命令，发送 10 个数据包，以建立基线值 一般对于一个单位内部的局域网来说，响应时间通常在 $1ms\\sim 2ms$ 之间，对于外网来说，取决于因特网的连接速度，响应时间多在 $10ms\\sim 300ms$之间 【网络利用率】网络利用率的计算一个 $10Mbps$ 的网络在很多情况下可能已经够用了，然而有的网络容量已经达到了 $100Mbps$，网络却仍处于拥塞状态，这时要用反映网络实际情况的另一个参数，网络利用率来进行衡量 网络利用率是指在给定时间内，该链路上收发信息字节数的总和除以该链路或设备接口的总容量 实际上，网络利用率代表了在给定时间内网络处于使用状态的时间的百分比，即： 网络利用率=\\frac{(发送数据数+接收数据数)bit}{线路容量\\:\\:*\\:\\:统计时间}\\:\\:\\:\\:\\:\\:\\:\\:\\:* \\:\\: 100\\%以 $10Mb$ 的半双工网络为例，在 $5$ 秒内发送 $700,000B$，接收 $175,000B$，其网络利用率为： \\frac{(700,000+175,000)*8}{10,000,000*5}*100\\%=14\\%网络利用率通常只计算接口和线路上的利用率，网络中分开两点之间的网络利用率计算比较复杂，通常要利用网络吞吐量来表示两远程端点之间流量瓶颈位置的带宽，以确定两个远程端点之间的网络利用情况 两个远程端点之间的网络利用率计算公式为： \\frac{(发送数据数+接收数据数)bit\\:\\:\\:\\:}{对应网络吞吐量\\:\\:*\\:\\:统计时间\\:\\:\\:\\:}\\:\\:\\:\\:* \\:100\\%网络流量的检测网络利用率的计算需要知道在给定的期间内网络所处理的数据信息流量的字节数，也就是要检测网络的流量，对于可网管的交换机、路由器，均可通过对应的操作命令来观察网络流量情况 如下图，通过端口状态的显示命令：show interface 端口号，可以看到对应的流量情况，通过对信息的观察，可以获得有关网络健康状况的大量信息","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络的可用性检测","slug":"network-testing/03.网络的可用性检测","date":"2020-05-26T04:25:00.000Z","updated":"2021-08-23T12:56:25.911Z","comments":true,"path":"notes/network-testing/1630cea1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/1630cea1.html","excerpt":"【概述】为保证对应应用的正常运行，网络的检测首先是可用性检测 从实现对应应用的功能而言，网络的测试应从支持应用的各层协议开始，逐一检测各协议的支持与参数的配置情况，从而保证对应应用的正常运行，当网络中某个组成失效时，网络管理器必须迅速查找到故障并及时排除","text":"【概述】为保证对应应用的正常运行，网络的检测首先是可用性检测 从实现对应应用的功能而言，网络的测试应从支持应用的各层协议开始，逐一检测各协议的支持与参数的配置情况，从而保证对应应用的正常运行，当网络中某个组成失效时，网络管理器必须迅速查找到故障并及时排除 网络的可用性检测从最低层开始，从低到高逐层检测能够反映出网络较完整的状态信息，而且每层的检测都有前层检测结果作为依据 一般设备厂商都会提供两个层次的检测方法： 网络接口和线路状态的检测 基于因特网控制消息协议 ICMP 协议的网络节点的连通性检测，对于高层应用可以通过其他手段来完成对应的可用性检测 【物理接口与线路】DB9 规范各个网络设备都是通过接口与介质相连，接口的机械、电气光学特性都已经有了相应的规范，这些规范既保证了不同厂家产品通过介质进行互连，又给接口提供了检测的标准和依据 广域网物理层规定的接口标准 V.24规程 规定的接口电气特性须符合 EIA/TIA-RS-232 电气标准(也称 DB9) DB9 的常用信号脚说明如下： RXD：接收数据 TXD：发送数据 DCD：载波检测 DTR：数据终端准备就绪 DSR：数据准备就绪 RTS：数据请求发送 CTS：清除发送 GND：信号接地 RI：振铃提示 数据收发引脚 RXD 和 TXD 的逻辑 $1$ 电平为 $-3V\\sim -15V$，逻辑 $0$ 电平为 $+3V \\sim +15V$ 控制信号 DCD、DTR、DSR、RTS、CTS 等的逻辑 $1$ 电平为 $+3V\\sim +15V$，表示信号有效，逻辑 $0$ 电平为 $-3V \\sim -15V$，表示信号无效 控制信号常被用来对当前链路情况进行检测和管理，即各设备生产厂商都是依据这些标准和规范来设计接口和针对介质接口的检测方法 检测结果表达方式LED 指示灯在网卡、交换机和路由器这些网络节点设备的介质接口上，一般都配置有 LED 指示灯，通过状态灯的提示情况，就可以反映出线路接口与网络链接的连通性问题，从而简化网络维护的难度 网卡与集线器网卡、集线器端口上的指示灯：根据其灯是否亮反映出该端口是否在工作，根据其颜色反映该端口正在传输数据的速度 黄色：对应 10Mbps 绿色：对应 100Mbps 红色：为故障状态 交换机交换机上的指示灯分为两种，一种是系统指示灯 灭：系统未通电 绿色：系统已加电且运行正常 淡黄色：系统出现故障，发生了一个或多个 POST 错误 另一种是端口模式指示灯，其有四种模式：STAT、UTIL、DUPLEX、SPEED，在不同模式下，不同颜色的指示灯的含义不同 STAT 指示灯：处于端口状态 灭：没有连接链路 绿色：正常连接了链路，但没有活动 绿色闪烁：链路上有数据流传输 交替显示绿色和淡黄色：链路出现故障 UTIL 指示灯：指示带宽使用情况 绿色：背板利用率在合理范围内 淡黄色：最后 24 小时的背板利用率达到最高值 DUPLEX 指示灯：指示端口工作模式 灭：半双工 绿色：全双工 SPEED 指示灯：指示端口速度 灭：端口运行速度为 10Mb/s 绿色：端口运行速度为 100Mb/s 绿色闪烁：端口运行速度为 1Gb/s 路由器 运行参数显示方式可网管设备对接口及线路的检测结果，能通过显示运行参数的方式体现出来 这种方式需要通过对相应设备使用操作命令来完成，如路由器可在特权模式下使用命令 show interface 端口号 来直接查看对应连接的端口情况 其他方式如果没有网络设备的支持，对于简单的通断检测也可使用简单的工具进行初步的检测来完成 对于双绞线，可以利用 LED 闪烁的顺序来进行简易检测 对于同轴电缆等导电介质，可使用万用表来判定通断，即将介质的远端分别置成开路或短路状态，再用万用表测试本地端对应的电阻情况，以确定介质是否连通 对于光纤，可以使用激光笔照射光纤一端，同时检查另一端有无光点出现，但此方法因光纤太细，在背景亮度大、光纤本身衰减过大时，容易出现判断失误 【网络故障诊断】网络通信故障诊断通过 ping 命令可检查网络连通与分析网络速度，若执行 ping 成功，只能保证当前主机与目的主机间存在一条连通的物理路径；若执行 ping 不成功，则故障可能是网线不通、网络适配器配置不正确、IP 地址不可用等 ping 命令的格式为：ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] target_name 其中，常用的参数有： -t：表示连续测试，此时按 Ctrl+c 或 Ctrl+Break 键可以中断测试 -n count：count 代表发送的请求数 -l size：size为发送的载荷大小，以字节为单位 target_name：为目的主机域名或 IP 地址 网络故障可能由许多原因引起，如本地配置错误、远程主机协议失效、设备故障等，通过 ping 命令按照如下步骤，可逐步诊断故障： ping 127.0.0.1：127.0.0.1 是回环地址，目的是检测本机的回路是否正常，如果不正常说明本地的 TCP/IP 协议没有设置好 ping 本机 IP 地址：若没有应答，则表示本地配置或安装存在问题，局域网用户可断开网络电缆，然后重新发送该命令，如果网线断开后本命令正确，则表示另一台计算机可能配置了相同的 IP 地址 ping 本网其他主机 IP 地址：该命令经过网卡及网络电缆到达其他主机，如果收到 0 个应答，表示子网掩码不正确、网卡配置错误、或电缆系统有问题 ping 网关 IP 地址：若得到应答，表示局域网中的网关路由器正在运行，说明和局域网可正常通信 ping 远程 IP 地址：检查本网或本机与外网的连接是否正常 ping www.xxxx.com：即 ping 域名，若出现故障，则表示本机 DNS 的 IP 地址配置不正确，或 DNS 服务器有故障 网络接口故障诊断使用 IPConfig 命令可以检查网络接口配置 当使用 IPConfig 时，不带任何参数选项，则 IPConfig 实用程序将为每个已经配置了的接口显示 IP 地址和子网掩码，若已经分配了默认网关，那么默认网关也将被显示 若存在重复的 IP 地址，则 IPConfig 实用程序将指出该 IP 地址已经配置了，且子网掩码为 0.0.0.0 若带上 \\all 参数，与不带参数相比，其信息更全更多，如 IP 是否动态分配、显示网卡的物理地址等 网络整体状态统计Netstat 程序有助于用户了解网络的整体使用情况，它可以显示当前正在活动的网络连接的详细信息，例如：显示网络连接、路由表和网络接口信息、目前总共有哪些网络连接正在运行等 -a：显示所有活动的TCP连接以及计算机侦听的 TCP 和 UDP 端口 -p proto：显示通过 proto 参数指定的协议的连接，proto 参数可以是 TCP、UDP、IP -r：显示本机路由表的内容 网络路由故障诊断tracert 命令当数据包从源计算机经过多个网关传送到目的地时，使用跟踪路由 tracert 命令可以用来跟踪 IP 数据包访问目标所采取的路径 当使用不带参数的 tracert 命令时，会把数据包所走的全部路径、节点的IP以及花费的时间都显示出来 pathing 命令Pathping 命令是一个路由检查工具，它将 ping 和tracert 命令的功能和这两个工具所不提供的其他信息结合起来，主要用于监视数据包在传输中经过的网络路径 Pathping 在一段时间内将多个回响请求消息发送到源和目标之间的各个路由器，然后根据各个路由器返回的数据包计算结果，确定可能导致网络问题的路由器或链接 使用Sniffer诊断网络Sniffer 即嗅探器，Sniffer 工具实际上就是一个网络上的抓包工具，同时还可以对抓到的包进行分析 Sniffer 工具利用以太网的特性把网络适配卡（NTC，以太网卡）置为混杂模式，一旦网卡设置为这种模式，它就能接收在网络上传输的每一个信息包，而不论其目的地址是否是它","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络测试的工具集","slug":"network-testing/02.网络测试的工具集","date":"2020-05-24T12:11:00.000Z","updated":"2021-08-23T12:56:32.987Z","comments":true,"path":"notes/network-testing/11b51f72.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/11b51f72.html","excerpt":"【概述】网络测试中使用的工具有以下三类： 物理电缆分析仪 网络运行模拟工具 网络测试仪","text":"【概述】网络测试中使用的工具有以下三类： 物理电缆分析仪 网络运行模拟工具 网络测试仪 【物理电缆分析仪】物理电缆测试仪，简单地说就是检测线路是否连通 常见的物理线路有单模、多模光纤、铜缆、双绞线和同轴电缆等，接口类型众多，传输技术也多样，为解决物理连通问题，有些特性人们眼睛就可以看出来，如物理外形、长短大小等，有些就要用仪器检测，如线路串扰、传输频率、信号衰减距离等 物理电缆测试仪是最常用的网络测试工具，能够测试电缆的连通性、开路、短路、跨接、反接、以及电缆的长度等各种参数 目前，最常见的是 DSP 系列电缆测试仪中的 DSP-400x，其带有可扩展的数字化平台，支持新标准中要求的所有测试，例如：近端串扰、等效远端串扰、综合近端串扰、综合等效远端串扰、衰减、衰减串扰比、时延、时延偏离和回波损耗等 此外，DSP-400x 带有强大的故障诊断功能，可以识别和定位被测试链路中的开路、短路和异常等问题 【网络运行模拟工具】在研究新协议的过程中，用实际网络系统的实现往往是成本过高或是不现实的，在这种情况下，使用网络运行模拟工具来仿真、模拟进行开发、测试、评估和验证往往是最佳的选择， 常见的网络运行模拟工具的类型有： 开放源代码的 NS2 商业化的大型仿真软件 OPNET Modeler 用于教学演示的 Cisco Packet Tracer 【网络测试仪】网络测试仪用于检测 OSI 模型定义的物理层、数据链路层、网络层运行状况，主要适用于局域网故障检测、维护和综合布线施工等 常见的网络测试仪有： 福禄克公司的 OptiView Intergrated Analyze（OPV-INA） 集成式网络综合分析仪 福禄克公司的网络万用仪 思博伦公司的 Spirent TestCenter 安捷伦公司的 Agilent N2X","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"网络测试的一般准则与类型","slug":"network-testing/01.网络测试的一般准则与类型","date":"2020-05-24T10:09:00.000Z","updated":"2021-08-23T12:56:39.739Z","comments":true,"path":"notes/network-testing/43dc53d6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-testing/43dc53d6.html","excerpt":"【一般准则】网络测试强调从网络的体系结构出发，按照网络分层的思想，参照 OSI 及 TCP/IP 分层模型，从物理层到应用层自下而上的逐层测试 从物理层开始，在测试数据链路层时，先要确保物理层是完好的；在检测网络层连通性时，先要确保下面两层的 LAN 和 WAN 是正常联通的","text":"【一般准则】网络测试强调从网络的体系结构出发，按照网络分层的思想，参照 OSI 及 TCP/IP 分层模型，从物理层到应用层自下而上的逐层测试 从物理层开始，在测试数据链路层时，先要确保物理层是完好的；在检测网络层连通性时，先要确保下面两层的 LAN 和 WAN 是正常联通的 以此类推，只有作为基础的下层是完好的，测试上层才有意义 【网络测试的类型】根据网络测试方式的不同，可分为： 单品测试：使用测试设备单独对网络设备进行测试，这种测试多用于在网络设备的研发阶段对设备的质量进行保障，以提高设备的性能为目标，也可用于多厂家同一档次设备的对比测试 真实测试：将网络设备放在具体的网络环境中进行测试，这种在真实环境下的测试常用于运营商、企业网中，用以评估该设备的互通性及互操作性 根据网络测试的目的，网络测试可以分为： 设备测试：功能测试、设备性能测试、协议测试 网络性能测试：负载测试、压力测试、主动测试、被动测试 【设备测试】功能测试功能测试主要是对设备的接口、通信协议、数据包转发等多方面的功能进行测试，以验证产品所标称支持的功能是否满足标准或能正常实施 其分为两种： 积极测试：积极地发现网络设备或网络的问题，以帮助生产商或研发者发现问题，为设备或网络的改进提供证据 消极测试：通过引入损伤的方式给一个稳定的设备或网络造成伤害，以测试一个设备或网络对于灾难的抵抗能力 设备性能测试设备性能测试主要是对设备的基本性能的验证，如设备的基本转发性能、协议处理性能进行测试，为使用者提供测试依据 网络设备的基本转发性能测试，主要依据 RFC-2544 来测试设备的吞吐量、时延、丢包率等指标 网络设备的协议处理性能测试主要是测试设备的路由表容量、路由协议收敛时间，以及路由振荡对设备转发能力的影响等指标 协议测试协议测试主要分为两种： 一致性测试：检验被测设备相关协议的实现是否遵循了协议规范 互操作测试：评价被测设备与相连接相似设备之间在网络环境中是否能够正确地交互并且完成协议标准中规定的功能，从而确定被测设备是否支持所需要的功能 Internet 包含了大量来自不同厂商的路由或交换设备，为了确保各不同厂商设备间的互通性，必须要求这些设备支持相同的协议或通信规范，并保证在设备之间实施协议的准确性，当网络设备通过了一致性测试，就可以保证基本的正确性 在互操作测试中，被采用最多的形式是测试单位选择经互操作认可的设备来与被测设备进行互操作测试，认可设备可能是终端设备、网络设备或者应用软件，也可能是一个单独设备或者若干设备组合 【网络性能测试】负载测试用于确定在各种负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况 通常在部署网络后需要对网络运营时可能产生的负载进行验证，比如在骨干带宽的 50% 或 70% 时的负载进行验证，从而了解当前的网络在一定负载下的运行情况，并了解该网络何时出现应用瓶颈 压力测试通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试，主要是用来在高压负载下，检测设备或网络的运行情况 产生高压负载的原因很多，例如：一个出现问题的网卡向网络发送广播包，此时这个源地址将生成数百万个包，并通过交换机转发到多个目的地址 主动测试主动测试是在选定的测量点上利用测量工具有目的地主动向被测网络注入测试流量，并通过测试数据流的传送情况来分析网络的性能参数 主动测试法能够明确地控制测试中所产生的流量的特征，如：流量的大小、发包频率、包大小和类型等 主动测试可以主动发送测试数据，对测试过程的可控制性比较高，但注入测试流量本身就改变了网络的运行情况，即改变了被测对象本身，使得测量的结果与实际情况存在一定的偏差，而且注入网络的测试流量还可能会增加网络的负担 被动测试被动测试是指利用特定的测试工具收集网络中活动的元素的特定信息，即路由器、交换机、服务器等网络设备的特定信息，以这些信息为参考，通过量化分析，实现对网络性能、功能的测试 类似于协议分析，被动测试在真实的运行状态下观察协议运行的过程，测试时可以人为制造一些干扰，如关闭路由协议的端口等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络测试","slug":"notes/network-testing","permalink":"https://alex-mcavoy.github.io/categories/notes/network-testing/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"网络测试","slug":"network-testing","permalink":"https://alex-mcavoy.github.io/tags/network-testing/"}],"author":"Alex_McAvoy"},{"title":"移动蜂窝通信","slug":"wireless-network/20.移动蜂窝通信","date":"2020-05-23T04:24:37.000Z","updated":"2021-11-07T13:45:14.391Z","comments":true,"path":"notes/wireless-network/1ed0360.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/1ed0360.html","excerpt":"【蜂窝移动通信】蜂窝移动通信系统将地理区域分割成许多蜂窝单元（小区），每个小区半径视用户分布密度在 1-10km 不等，由一个小功率发射基站为本小区内的用户服务 在一个小区内使用同一信道频率，在相邻小区使用不同频率，相距较远的若干不相邻小区可复用同一频率","text":"【蜂窝移动通信】蜂窝移动通信系统将地理区域分割成许多蜂窝单元（小区），每个小区半径视用户分布密度在 1-10km 不等，由一个小功率发射基站为本小区内的用户服务 在一个小区内使用同一信道频率，在相邻小区使用不同频率，相距较远的若干不相邻小区可复用同一频率 若干相邻小区组成一个无线区群，一个典型区群中包含 4/7/12 个小区，若干个相邻的无线区群构成一个服务区 【服务覆盖】移动蜂窝通信的服务覆盖方式有两种 在公路、铁路、沿江、沿海等地域，采用带状模式，基站使用定向天线，许多细长的小区横向排列覆盖整个服务区 在一般的陆地平面，若地形地貌相同或接近的区域，采用面状模式，基站采用全向天线，一个小区的覆盖范围可看作是一个圆，但考虑到相邻小区的范围重叠，一个小区的有效覆盖可看作是一个圆的内接六边形。而由于地形地貌起伏和遮挡环境等的实际影响，小区的无线覆盖往往是一个不规则的多边形 【2G 技术】全球移动通信系统（Global System for Mobile Communication，GSM）是 2G 蜂窝通信的代表技术，相比模拟移动通信，具以下特点： 由若干子系统组成，与 PSTN 等公用通信网互连互通 提供跨国界自动漫游功能，移动用户可进入 GSM 系统而与国别无关 除话音业务外，还可开放各种承载业务、补充业务等 有加密和鉴权功能，确保通信保密和网络安全 组网结构灵活方便，频率复用率高，交换机的话务承载能力较强 抗干扰能力强，覆盖区域内的通信质量高 终端手机向更小型、轻巧和增强功能趋势发展 美国高通公司最早提出了窄带 CDMA（CDMA IS95）技术，采用更先进的无线扩频技术，提高了移动通信容量和品质，具有频谱利用率高、话音质量好、保密性强、掉话率低、电磁辐射小、容量大、覆盖广等特点，可减少投资和降低运营成本 在 2G 时代，CDMA 的全球市场占有率仅次于 GSM 【3G 技术】第三代移动通信技术（3rd Generation，3G），国际电信联盟在2000年确定 W-CDMA、CDMA2000 和 TD-SCDMA 三大主流无线接口标准，写入 3G 技术指导性文件 3G 标准组织主要由 3GPP、3GPP2 组成，以 CDMA 码分多址技术为核心，其中 TD-SCDMA、WCDMA 由 3GPP 负责具体标准化工作，CDMA2000 由 3GPP2 负责具体标准化工作 WCDMA 的支持者主要是欧洲厂商，包括爱立信、阿尔卡特、诺基亚、朗讯、NTT 等 系统能架设在 GSM 网络上，在 GSM 普及地区具有优势，CDMA2000 由高通公司主导，是从窄带 CDMA 标准发展而来，可从原有的 CDMA 直接升级，建设成本相对低廉 TD-SCDMA 由我国主导，原邮电部电信科学技术研究院提出，在我国占据了较大市场空间 【4G 技术】在 3G 基础上，继续提高移动通信网络的性能，有了 4G 传统电信运营商，认为 4G 是基于 IP 协议的高速蜂窝移动网，各种移动通信技术从现有 3G 演进，在 LTE 阶段完成统一，要求 4G 传输速率达到 100Mbps 或更高 4G 网络结构分为物理网络层、中间环境层、应用网络层。物理网络层提供接入和路由选择功能，无线网和核心网结合；中间环境层负责QoS 映射、地址变换和完全性管理等。各层间接口开放，便于开发和提供新应用及服务 提供无缝高速率数据服务，并运行于多个频带，自适应多个无线标准及多模终端，跨越多个运营商，提供大范围服务 LTE 是 3G 的演进，改进并增强了 3G 的空中接入，分为 FDD（频分双工）和 TDD（时分双工）两种制式 FDD-LTE 在国际上应用广泛，而 TDD-LTE 则在我国占主导地位 中国移动主推 TDD-LTE，占用频段为 1880-1900MHZ、2320-2370MHZ 和 2575-2635MHz，共 130MHz。 中国联通和中国电信则同时支持 TDD-LTE 和 FDD-LTE，前者获批使用 1755-1765MHz、1850-1860MHz、2300-2320MHz 和2555-2575MHz，后者获批使用 1765-1780MHz、1860-1875MHz、2370-2390MHz 和 2635-2655MHz 【5G 技术】5G 是最新一代蜂窝移动通信技术，也是继4G（LTE-A、WiMax）、3G（UMTS、LTE）和2G（GSM）系统之后的延伸 其采用了超密集异构网络、自组织网络、内容分发网络、D2D 通信、M2M 通信、信息中心网络等技术，速度高达20 Gbit/s，可以实现宽信道带宽和大容量 MIMO","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"无线城域网与无线广域网","slug":"wireless-network/19.无线城域网与无线广域网","date":"2020-05-22T12:54:03.000Z","updated":"2021-11-07T13:43:02.831Z","comments":true,"path":"notes/wireless-network/9aa26aff.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/9aa26aff.html","excerpt":"【概述】无线城域网（Wireless Metropolitan Area Network，WMAN） 以无线方式构建城域网，提供高速互联网接入，为满足宽带无线接入的市场需求，解决城域网最后一公里接入问题，代替电缆、xDSL)、光纤等","text":"【概述】无线城域网（Wireless Metropolitan Area Network，WMAN） 以无线方式构建城域网，提供高速互联网接入，为满足宽带无线接入的市场需求，解决城域网最后一公里接入问题，代替电缆、xDSL)、光纤等 无线广域网（Wireless Wide Area Network，WWAN）进一步扩展了传统无线网络范围，是一种覆盖范围更大的无线网络，提供更方便和灵活的无线接入，用户能使用笔记本PC、智能手机等移动设备在覆盖范围内灵活接入网络，进而访问因特网 典型的 WWAN 有：卫星通信网络、蜂窝移动通信（2G/3G/4G/5G）等 其中，卫星通信网络堪称空间范围最大的 WWAN，蜂窝移动通信网络是覆盖人群范围广的 WWAN 【IEEE802.16 标准】概述IEEE802.16 标准为基础的无线城域网，覆盖范围达几十公里，传输速率高，提供灵活、经济、高效的固定和移动宽带无线接入方式 IEEE802.16，也称全球微波接入互操作性（WiMax，World wide Interoperability for Microwave Access），能达30M~100Mbps 或更高速率，移动性优于 WiFi 其下辖标准有多个，具体见下图： 常用的标准有 IEEE802.16a、IEEE802.16d、IEEE802.16e、IEEE802.16m，他们的对比如下： WiMax 系统组成WiMax 网络可在需牌照或公用无线频段运行，授权频段运行时可使用更多频宽、时段和更强功率，WiFi 传输功率在 1~100 毫瓦之间，而 WiMax 系统的传输功率可达 100 千瓦 WiMax 系统通常由两部分组成： WiMax 发射塔：与移动通信发射塔相似，单台 WiMax 发射塔可覆盖面积多达数千平方公里，发射塔用有线链路连接因特网，也可用视距微波连接另一个发射塔 WiMax 接收机：接收机和天线可以是一个小盒子或一张 PCMCIA 卡，也可内置笔记本中 多天线与安全性IEEE802.16 标准的多天线技术有两种： MIMO：空时发射分集、复用、分集与复用混合模式 自适应天线阵：可提高系统容量、扩大覆盖范围、提高可靠性、降低成本 WiMax 与 WiFi 所使用的认证加密方法相似：WiMax 使用 3DES、AES、EAP 等，称为 PKM-EAP，而 WiFi 的 WPA2 使用典型的 PEAP 认证与 AES 加密 视距与非视距服务非视距服务：使用较低频率范围（2~11GHz），较低波长传输不易受物理干扰，传输可衍射、弯曲或绕过障碍物，服务范围半径约 6~10km 视距服务：使用较高频率（可达66GHz），利用安装在屋顶或电杆上的固定抛物面天线和发射塔通过视距连接，这种类型功率更大、更稳定、误码更少，服务范围半径可达 50km 信道编码按不同业务 QoS 和速率可以灵活选择合适编码方式： 咬尾卷积编码：强制支持，编译码复杂度低，处理时延小，适合小编码块、控制消息和时延敏感的数据传输，快速解调，帧控制消息就采用该编码 归零卷积编码：可选支持，编译码复杂度低、处理时延小，相比咬尾卷积编码，其每个编码块需一个字节，对小编码块传输不利，但译码略简单，性能更好 低密度奇偶校验码：适合大编码块数据传输，通常编码复杂度较高，使用结构化构造方法，可以有效降低编码复杂度 MAC 层自适应机制在当前信道条件下，通过对某些传输参数的适配，可以让链路更加有效的运行，其有三大机制： 自适应调制编码（AMC） 自动请求重传（ARQ） 混合自动请求重传（H_ARQ） 自适应调制编码（AMC）AMC 根据信道的质量状况，自适应的调整调制和编码方式，从而产生不同的传输速率 AMC 能够最大限度利用无线信道，提高频谱效率，根据模式不同，数据传输速率和抗干扰能力不同 AMC 的最主要作用是在 802.16 标准中衡量信道质量，在距离基站较近的位置可采用高阶的调制方式（如：64QAM），以获得更高的传输速率，而在远离基站的位置信道质量变差，可调整到低阶的调制方式（如：QPSK），以扩展覆盖范围，同时，其能通过避免发射功率的途径来提高系统性能，降低干扰 自动请求重传（ARQ）ARQ 的接收端在正确接收发送端数据包前，会向发送端发送确认信息（ACK），否则发送（NACK） 发送端根据接收端情况选择重传，同时，其支持简单停止等待和滑动窗口 混合自动请求重传（H_ARQ）H_ARQ 是前向纠错（FEC）和自动重传（ARQ）相结合的技术 在信道好时，FEC 会降低吞吐量，使得 ARQ 更好；在信道差时，FEC 更好，此时存在时延 简单来说，错误少纠错，错误多重传 【IEEE802.20 标准】IEEE802.20 标准也称 Mobile-Fi，最初由思科等厂商提出 该标准在低于 3.5GHz 的许可频段工作，基于 IP，单用户峰值数据速率超 1Mbps，支持终端移动速度 250km/h 的移动通信，同时在 MBWA 物理层和 MAC 层具有互操作性 由于某些原因，该工作组暂停多次，标准制定一波三折，虽然具有一定的技术价值，但未来并不乐观","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件工程管理","slug":"software-engineering/15.软件工程管理","date":"2020-05-20T11:08:00.000Z","updated":"2022-05-13T04:57:46.526Z","comments":true,"path":"notes/software-engineering/453486e8.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/453486e8.html","excerpt":"【概述】软件工程管理是通过计划、组织、控制一系列活动，合理配置使用资源，达到既定目标的活动 其内容包括：软件开发成本、控制、开发人员、 组织机构、用户、软件开发文档、软件质量等方面的管理","text":"【概述】软件工程管理是通过计划、组织、控制一系列活动，合理配置使用资源，达到既定目标的活动 其内容包括：软件开发成本、控制、开发人员、 组织机构、用户、软件开发文档、软件质量等方面的管理 【软件估算】概述软件估算是指以准确的调查资料和项目信息为依据，从估算对象的历史，现状及其规律性出发，运用科学的方法，对估算对象的规模，所需工作量和成本进行的测定 软件估算的内容包括软件规模、工作量和进度，对于估算来说，有 些可以做的很仔细，而大多数只是凭主观经验判断 所以多数估算难以做到 10% 以内的精确度，有的甚至误差达几倍，尤其是估算人员经验不足或估算项目没有可参考凭借之时 不同的软件开发阶段，估算的对象和使用的方法都会有所不同，估算的精确度也不一样，一般来说，随着项目进展，对项目内容了解愈多，估算也会越来越精确 软件估算方法软件估算的方法有很多，大致分为基于分解技术的估算方法和基于经验模型的估算方法两大类 基于分解技术的方法包括：功能点估算法、特征点估算法、对象点估算法、代码行（LOC）估算法、MARK Ⅱ 等 基于经验模型的方法包括：IBM 模型、普特南模型、COCOMO 模型等 其中，代码行技术和功能点技术是最常用的方法 代码行技术代码行技术通过估计每个功能需要源代码、估计整个软件源程序行数等来进行估计，当程序较小时常用的单位是代码行数（LOC），当程序较大时常用的单位是千行代码数（KLOC） 其优点在于代码是所有软件开发项目都有的产品，而且很容易计算代码行数，其缺点在于源程序并不等于软件，而且实现语言不同代码行数不同，同时不同的开发人员的能力是不同的，并无法很好的估算 功能点技术功能点技术依据软件信息域特性和软件复杂性评估结果估算软件规模 功能点技术与所用编程语言无关，比代码行要合理，但主观因素过多 信息域特性有： 用户输入数：各用户面向不同应用的输入数据计数 用户输出数：为用户提供面向应用的输出信息 用户查询数：即是一次联机输入，以输出方式产生某种即时响应 文件数：每一个逻辑主文件都应计数 外部接口数：所有将信息传到另一系统中的机器可读写接口 评估过程如下： 1.估算未调整功能点 UFP 一般根据下表计算估算未调整功能点 UFP 2.计算技术复杂性因子 TCF 规定： $TCF=0.65+0.01* DI$ 其中，$DI=\\sum_{i=1}^14F_i$ $F_i$ 为复杂性校正值，每个因素的尺度是 0~5： 0 1 2 3 4 5 没有影响 偶然的 适中的 普通的 重要的 极重要的 F_i 各项如下： F1：是同是否需要可靠的备份和恢复？ F2：是否需要数据通信？ F3：是否有分布处理的功能？ F4：性能是否关键？ F5：系统是否运行在既存的高度实用化的操作环境中？ F6：系统是否需要联机数据项？ F7：联机数据项是否需要联机处理以建立多重窗口显示或操作？ F8：主文件是否联机更新？ F9：输入、输出、文件、查询是否复杂？ F10：内部处理过程是否复杂？ F11：程序代码是否被设计成可重用的？ F12：设计中是否包括转换和安装？ F13：系统是否被设计成可重复安装在不同机构中？ F14：应用是否被设计成便于修改和易于用户使用？ 3.计算功能点数 FP 规定：$FP=UFP * TCF$ 【软件开发进度计划】概述项目管理者的目标是定义全部项目任务，识别出关键任务，规定完 成各项任务的起、止日期，跟踪关键任务的进展状况，以保证能及时发 现拖延进度的情况 为了做到这一点，管理者必须制订一个足够详细的进度表，以便监督项目进度，并控制整个项目 常见的进度表有甘特图和计划评审技术图两种 甘特图甘特图（Gantt 图），是一种能有效显示行动时间规划的方法，也叫横道图或条形图 其将计划和进度安排两种职能结合在一起，纵向列出项目活动，横向列出时间跨度，每项活动计划或实际的完成情况用横道线表示，还显示了每项活动的开始时间和终止时间，此外，还甘特图还利用菱形标记表示里程碑 某项目进度计划如下： 现在一矩形木板房需重新油漆，过程分为三步：刮旧漆，刷新漆，清除溅在窗上油漆，现在有 15 名工人，5 把刮旧漆刮板，5 把刷漆刷子，5 把清除溅在窗上油漆小刮刀，各项工序估计用时如下： 画出的甘特图如下： 计划评审技术图计划评审技术图（PERT 图），它采用网络图来描述一个项目的任务网络 不仅可以表达子任务的计划安排，还可以在任务计划执行过程中估计任务完成的情况，分析某些子任务完成情况对全局的影响，找出影响全局的区域和关键子任务，以便及时采取措施，确保整个项目的完成 【软件开发人员组织】概述为成功地完成软件开发工作，项目组成员必须以一种有意义且有效的方式彼此交互和通信 如何组织项目组是一个管理问题，管理者必须合理地组织项目组，使项目组有较高生产率，能够按预定的进度计划完成所承担的工作 经验表明，项目组组织得越好，其生产率越高，而且产品质量也越高，组织软件开发人员的方法，取决于所承担的项目的特点、以往的组织经验以及软件开发公司负责人的看法和喜好 民主制程序组民主制程序员组的小组成员完全平等，享有充分民主，通过协商做出技术决策，对发现错误抱着积极的态度，这种积极态度有助于更快速地发现错误，从而导致高质量的代码，小组有高度凝聚力，组内学术空气浓厚，有利于攻克技术难关 小组成员间的通信是平行的，如果一个小组有 $n$ 个成员，则可能的通信信道有 $\\frac{n(n−1)}{2}$ 条 但小组人多的话，通信量会非常大，同时如果组内多数成员技术水平不高，或是缺乏经验的新手，很有可能不能完成项目 主程序员组为了使少数经验丰富、技术高超的程序员在软件开发过程中能够发挥更大作用，程序设计小组也可以采用主程序员组的组织方式 实际的主程序员应该由两个人来担任：一个是技术负责人，负责小组的技术活动，一个是行政负责人，负责所有非技术的管理决策 由于程序员组的成员人数不宜过多，当软件项目规模较大时，应该把 程序员分成若干个小组，每组 2-8 人，并行开发 现代程序员组现代程序员组把民主制程序员组和主程序员组的优点结合起来，在合适的地方采用分散作决定的方法 这样做有利于形成畅通的通信渠道，以便充分发挥每个程序员的积极性和主动性，集思广益攻克技术难关 【软件过程能力成熟度模型】软件过程能力成熟度模型（Capability Maturity Model，CMM）是用于评估软件能力与成熟度的一套标准，它由美国卡内基—梅隆大学软件工程研究所推出，侧重于软件开发过程的管理及工程能力的提高与评估，是国际软件业的质量管理标准 软件过程能力成熟度模型认为，软件质量难以保证的问题在很大程 度上是由管理上的缺陷造成的，而不是由技术方面的问题造成的 因此，软件过程能力成熟度模型从管理学的角度出发，通过控制软 件的开发和维护过程来保证软件产品的质量 它的核心是对软件开发和 维护的全过程进行监控和研究，使其科学化、标准化，能够合理地实现预定目标。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"无线传感网络的路由协议","slug":"wireless-network/18.无线传感网络的路由协议","date":"2020-05-19T11:52:23.000Z","updated":"2021-11-07T11:50:08.826Z","comments":true,"path":"notes/wireless-network/e0c710a3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/e0c710a3.html","excerpt":"【从洪泛路由到 WSN 路由协议】洪泛路由是最简单、最基本、最健壮的路由协议，其无需知道局部拓扑、地理信息等，也虚无维护路由，但其资源浪费严重，很少使用，常用于小规模的共享信道，此外，其常作为衡量标准来评价其他路由协议 其基本思想是：当网络中的节点在任何时刻收到其它节点传输过来的数据时，它将向它的所有邻居进行转发。","text":"【从洪泛路由到 WSN 路由协议】洪泛路由是最简单、最基本、最健壮的路由协议，其无需知道局部拓扑、地理信息等，也虚无维护路由，但其资源浪费严重，很少使用，常用于小规模的共享信道，此外，其常作为衡量标准来评价其他路由协议 其基本思想是：当网络中的节点在任何时刻收到其它节点传输过来的数据时，它将向它的所有邻居进行转发。 但洪泛路由具有以下缺陷： 资源的盲目使用：不考虑节点可用能量、位置等 信息爆炸：一个节点可能得到一个数据的多个副本 重叠现象：处于同一观测环境的两个相邻同类传感器节点同时对一个事件作出反应，二者采集的数据性质相同，数值相近，这两个节点的邻居节点将收到双份数据副本 在 WSN 中，基于应用的不同，存在以下四种路由协议： 能量感知路由协议：从数据传输的能量消耗出发，讨论最优的能量消耗路径、最长的网络生存期等问题 基于查询的路由协议：环境检测应用，sink 节点发出查询命令，传感器节点不断报告采集的数据 地理位置路由协议：跟踪应用，已知节点的位置，并作为路由选择的依据 可靠的路由协议：对通信的服务质量要求较高的应用 【能量感知路由协议】能量感知路由协议考虑了通信路径上的能量消耗以及剩余能量，路径的选择概率与能量相关，并维护保持多条活动的冗余路径，增加了可靠性，同时实现整个网络能量的平稳降级，最大限度的延长了网络的生存期 能量感知路由协议能量感知路由协议是最早的路由机制之一，其主要思想是：根据节点的可用能量（Power Available，PA）或者传输路径上的能量需求，选择数据的转发路径 如下图所示，大写字母表示节点，括号内表示可用能量，双向线表示通信链路，链路上数字表示数据发送所需的能量消耗 常见的能力路由策略： 最大 PA 路由：选择 PA 之和最大的高效路径 最小能耗路由：选择节点能耗最小的路径 最小跳数路径：选择跳数最小的路径 最大最小 PA 节点路由：用路径上 PA 最小的节点表示这条路径的 PA，选择路径 PA 最大的路径 能量多径路由能量多径路由在源节点和目的节点之间建立多条路径，根据路径上节点的通信能耗及剩余能量，依概率选路 主要过程： 路径建立阶段：建立从源节点到目的节点的多条路径，并确定能量代价 数据传播阶段：根据上一阶段建立的路由信息，实现数据分组从源节点到目的节点的传送，中间节点按照与能量代价相关的转发概率进行转发 路由维护阶段：目的节点发起源-目的洪泛查询，以维持路径畅通 【基于查询的路由协议】定向扩散定向扩散（Directed Diffusion，DD）以数据为中心，可以定义多任务与多区域，其采用多路径，且不需要全局的地址机制，节点不需要维护网络的拓扑结构，每个节点都可以进行数据融合，大幅减少通信量，同时，汇聚点根据实际情况周期性的调整路由，能量的消耗均衡、高效 其主要思想是：Sink 节点（汇聚节点）周期地通过洪泛方式广播一种被称为兴趣的消息，告诉网络中的节点需要搜集何种信息 兴趣在网络中扩散的同时建立从源节点到汇聚节点的路由路径（梯度），通过兴趣扩散阶段建立的路径，源节点将数据消息传送到汇聚节点 汇聚节点选择一条最优的路径进行强化，后续的数据沿着这条路径传输 定向扩散梯度的建立依靠洪泛传播，维护兴趣消息列表在多应用支持下代价极大，此外，数据融合过程需要用到时间同步技术，会带来较大的开销和时延 谣传路由谣传路由（Rumor Routing，RR）与 DD 相比，可以有效的减少路由建立的开销，但其路径为随机生成，不是最优路径 在某些应用中，只有少量的数据需要从源节点传递到 Sink 节点，在这种情况下，没有必要向整个网络以洪泛的方式广播兴趣 当一个节点发现网络中某种事件的发生的时候，它把事件洪泛发送到整个网络，其他的节点就可以形成一个指向事件源节点的梯度表： 假设网络中的节点数量是 $N$，事件的数量是 $E$ 通过事件洪泛，需要消耗的网络的能量为 $E*N$ 该能量消耗与关心该事件的节点的数量无关 如果事件报告的数量相对于查询的数量而言很少，则该策略有效 当 Sink 节点对网络中某种事件的发生感兴趣的时候，它把兴趣洪泛发送到整个网络，其他的节点就可以形成一个指向 Sink 节点的梯度表： 对于 $N$ 节点的网络，每次查询会执行 $N$ 次传输 执行 $Q$ 次查询，需要进行的传输数量是 $N*Q$ 能量消耗与网络跟踪的事件的数量无关 当事件的数量相对于查询的数量非常高时，本策略可以节省很多能量 【地理位置路由协议】地理位置路由协议要求每个节点知道自己在网络中的位置，而确定节点位置的方法是 GPS（Global Positioning System） 该路由协议常作为其他路由算法的辅助，或直接用于路由计算 【可靠的路由协议】某些 WSN 应用对数据传输的可靠性（数据包抵达的概率）要求很高，这就要求使用可靠的路由协议 造成数据包丢失的可能方面： 节点能量有限、失效 无线信道的不稳定性和更高的误码率 高密度部署造成信道竞争冲突 网络拥塞发生时，拥塞节点缓冲区溢出 接收节点处理不及时","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件维护","slug":"software-engineering/14.软件维护","date":"2020-05-18T08:53:00.000Z","updated":"2022-05-13T04:55:19.451Z","comments":true,"path":"notes/software-engineering/43e61b7e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/43e61b7e.html","excerpt":"【概述】软件维护是软件产品生命周期的最后一个阶段 概括地说，软件维护就是指在软件产品交付给用户之后，为了改正软件测试阶段未发现的缺陷，改进软件产品的性能，补充软件产品的新功能等，所进行的修改软件的过程","text":"【概述】软件维护是软件产品生命周期的最后一个阶段 概括地说，软件维护就是指在软件产品交付给用户之后，为了改正软件测试阶段未发现的缺陷，改进软件产品的性能，补充软件产品的新功能等，所进行的修改软件的过程 进行软件维护通常需要软件维护人员与用户建立一种工作关系，使软件维护人员能够充分了解用户的需要，及时解决系统中存在的问题 软件维护分为纠错性维护、适应性维护、预防性维护、完善性维护这四种，各种维护的工作量比例如下图： 【软件维护过程】典型的软件维护的过程可以概括为以下五个阶段： 建立维护机构 用户提出维护申请并提交维护申请报告 维护人员确认维护类型并实施相应的维护工作 整理维护记录并对维护工作进行评审 对维护工作进行评价 在维护人员实施相应的维护工作过程中，涉及到的技术工作如下图： 在整理维护记录过程中，需要记录的数据有： 在对维护工作进行评价时，可参考的评价标准有： 每次程序运行平均失效的次数（每次运行失效的概率） 用于每一类维护活动的总人时数 平均每个程序、每种语言、每种维护类型所做的程序变动数 维护过程中增加或删除一个源语句平均花费的人时数 维护每种语言平均花费的人时数 一张维护申请报告的平均周转时间 不同维护类型所占的百分比 【软件的可维护性】软件的可维护性是用来衡量对软件产品进行维护的难易程度的标准， 它是软件质量的主要特征之一 软件产品的可维护性越高，纠正并修改其错误或缺陷，对其功能进行扩充或完善时，消耗的资源越少，工作越容易 开发可维护性高的软件产品是软件开发的一个重要目标，而影响软件可维护性的因素有很多，如可理解性、可测试性、可修改性等 要想提高软件产品的可维护性，软件开发人员需要在开发过程和维护过程中都对其非常重视，提高可维护性的措施有以下几种： 建立完整的文档 采用先进的维护工具和技术 注重可维护性的评审环节 【软件维护的副作用】软件维护是存在风险的，对原有软件产品的一个微小的改动都有可能引入新的错误，造成意想不到的后果 软件维护的副作用主要有三类： 修改代码的副作用：人类通过编程语言与计算机进行交流，每种编程语言都有严格的语义和语法结构 修改数据的副作用：数据结构被改动时有新的错误产生的现象 修改文档的副作用：在软件产品的内容更改之后没有对文档进行相应的更新而为以后的工作带来不便的情况","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"无线传感网络的 MAC 协议","slug":"wireless-network/17.无线传感网络的MAC协议","date":"2020-05-15T11:15:13.000Z","updated":"2021-11-07T11:50:12.160Z","comments":true,"path":"notes/wireless-network/76b14f9b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/76b14f9b.html","excerpt":"【S-MAC 协议】概述S-MAC 协议假设信道是单信道，平均数据率很低，且网络能够容忍一定程度的通信延迟","text":"【S-MAC 协议】概述S-MAC 协议假设信道是单信道，平均数据率很低，且网络能够容忍一定程度的通信延迟 其基本思想是： 采用周期性的休眠/侦听方法减少空闲侦听带来的能量损耗 当有节点收发数据时，与此无关的邻居节点进入休眠减少冲突与串音带来的能量损耗 采用消息传递机制，减少控制消息带来的能量损耗 采用自适应的侦听机制，减少消息传输延迟 S-MAC 协议会周期性的休眠/唤醒，降低空等时间，避免了冲突，同时使用自适应侦听和消息传递机制，但调度周期是固定的，不能适应网络流量变化，而且簇边界节点能量消耗快，同时，节点休眠带来了时延 周期性睡眠和侦听每一个节点都有一个预先确定的时间表，用于周期性睡眠和侦听 如下图，Wakeup Period 是唤醒周期（调度周期），Active Period 是侦听时段（活跃时段），Sleep Period 是睡眠周期 定义占空比为： 占空比=\\frac{唤醒周期}{调度周期}那么选择较小的占空比时，收发机大部分时间处于休眠状态，可以避免空闲监听（Idle Listening）所造成的能量消耗，同时，由邻居节点流向给定节点的通信量会集中在一个较小的时间窗口内，从而可能会引发显著的竞争和较重的负载；如果选择较长的休眠时段，则会出现一个显著的每跳等待时间，在多跳的情况下，这个等待时间的累积可能会产生较大的端到端的延迟 节点选择自己的调度表或遵循其他节点的调度表，这就使得一个节点的调度周期与邻居节点的调度周期保持一致。 节点启动时的处理流程图如下： 节点工作时的处理流程图如下： 冲突避免如果多个邻居节点同时想与一个节点通信，它们将试图在该节点开始侦听时发送消息，在该情况下，它们需要竞争媒体 在竞争协议中，IEEE 802.11 在冲突避免这方面做得很好，S-MAC 遵循类似的流程，包括虚拟载波侦听和物理载波侦听，解决隐藏终端问题的 RTS/CTS 交换 每个传输包中都有一个持续时间域来标识该包要传输多长时间，如果一个节点收到一个传输给另外一个节点的包，该节点就能从持续时间域知道在多长时间内不能发送数据 节点以变量形式记录该值，被称为网络分配矢量（NAV），NAV 可以被看成一个计时器，每次计时器开始计时，节点递减它的 NAV，直到减少到 $0$ 在传输之前，节点首先检查它的 NAV，如果它的值不为 $0$，节点就认为媒体忙，这被称为虚拟载波侦听，而物理载波侦听在物理层执行，通过侦听信道进行可能的传输 载波侦听时间是竞争窗口内的一个随机值，以避免冲突和饥饿现象，如果虚拟载波侦听和物理载波侦听都标识媒体空闲，那么媒体就是空闲的 流量自适应侦听由于周期性睡眠，会导致了通信延迟的累加问题 为解决该问题，就有了流量自适应侦听技术 消息传递机制消息（Message）是具有密切的内部联系的数据的集合，只有得到完整的数据才可以在网络内部进行数据处理、聚合 S-MAC 协议将长的信息包分成若干个短的信息段 DATA，使用一个 RTS／CTS 控制分组占用信道，每个 DATA 都有 ACK 保障传输成功，任一 DATA 未收到应答，则立刻重传 【T-MAC 协议】概述T-MAC 协议与自适应睡眠的 S-MAC 协议基本思想大体相同 数据传输仍然采用 RTS/CTS/DATA/ACK 的 $4$ 次握手机制，不同的是，在节点活动的时隙内插入了一个 TA（Time Active）时隙，若 TA 时隙之间没有任何时间发生，则活动结束进入睡眠状态 设计思想的区别在于根据网络负载状况动态调整活动期的长度，并且用突发方式发送数据消息，减少空闲侦听 活跃周期时间的选择T-MAC 协议的活跃时间的长度是固定的，其能按照能够处理最高负载来设计，但如果网络中消息传递的速率很低的话，仍然有大量的能量浪费在空闲等待 因此，在设计时，通过调整调度周期中的活跃时间长度，在活跃周期时间内没有发生激活事件则进入睡眠 在活跃状态下，节点可能保持监听，也可能发送数据。当在一个时间段内没有发生激活事件时，活跃状态结束，节点进入睡眠状态 激活事件的定义如下： 定时器触发周期性调度唤醒事件 物理层从无线信道接收到数据包 物理层指示有的无线信道忙 节点的 DATA 帧或 ACK 帧发送完成 通过监听 RTS、CTS 帧，确认邻居的数据交换已经结束 活跃周期时间决定了每个周期的最短空闲侦听时间，其取值约束为： T_A>C+R+T其中，$T_A$是活跃周期时间，$C$ 是竞争信道的时间，$R$ 是发送 RTS 包所需时间，$T$ 是从 RTS 发送结束到开始发送 CTS 的时间 一般来说，常将活跃周期时间设为： T_A=1.5*(C+R+T) 早睡的解决早睡问题在采用周期性调度的 MAC 协议中，如果一个节点在邻居准备向其发送数据时进入了睡眠状态，就称为出现了早睡 如下图所示，$A$、$B$ 之间，$B$、$C$ 之间，$C$、$D$ 之间可以相互通信，假设数据传输方向是 $A$、$B$、$C$、$D$ 如果节点 $A$ 通过竞争获得了与节点 $B$ 通信的机会，节点 $A$ 发送 RTS 给 $B$，$B$ 回复 CTS 给 $A$ 那么当 $C$ 收到 $B$ 发出的 CTS 时，会触发一个新的监听时间段，使 $C$ 保持监听状态，而 $D$ 没有发现 $A$、$B$ 之间正在进行的通信，由于无法触发新的 $T_A$，$D$ 会进行睡眠 但 $A$、$B$ 之间通信结束时，$C$ 竞争获得信道，由于 $D$ 此时已经睡眠，所以必须等到 $D$ 在下一次调度唤醒时才能进行 RTS/CTS 交互 在 T-MAC 中，对早睡问题，有两种解决方案：预请求发送机制（FRTS，Future Request To Send）、满缓冲区优先机制（Full-buffer Briority） 预请求发送如下图所示，当节点 $C$ 收到 $B$ 发给 $A$ 的 CTS 后，立即向 $D$ 发送一个 FRTS，FRTS 帧包含节点 $D$ 接收数据前需要等待的时间长度，$D$ 在此时间内必须保持在监听状态 由于 $C$ 发送的 FRTS 可能干扰 $A$ 发送的数据，所以 $A$ 需要将发送的数据延迟相应的时间 $A$ 在接收到 CTS 之后发送一个与 FRTS 长度相同的 DS 帧，该帧不包含有用信息，只是为了保持 $A$、$B$ 对信道的占用，在发送 DS 之后 $A$ 立即向 $B$ 发送数据信息 因为采用了 FRTS 机制，这会增加一个 CTS 时间，使得吞吐量提高的同时减少了延迟，但是增加了控制开销，会降低 TMAC 协议的能量效率 满缓冲区优先机制当节点的缓冲区接近占满时，对接收到的 RTS 帧不回复 CTS，而是立即向缓冲区中数据包的目的节点发送 RTS，以建立数据传输 在 $B$ 向 $C$ 发送 RTS 时，$C$ 因缓冲区快占满不发送 CTS，而是发送 RTS 给 $D$ 这个方法减少了早睡问题发生的可能性，在一定程度上能够控制网络的流量，但是在网络数据量较大时增加了冲突的可能 【Sift 协议】概述Sift 协议是基于事件驱动的 MAC 协议，充分考虑了 WSN 的三个特点： WSN 是事件驱动的，存在事件检测的空间相关性和事件传递的相关性 由于汇集节点的存在，不是所有节点都需要报告事件 感知事件的节点密度随时间动态变化 其设计目标是：当共享信道的 $N$ 个节点同时检测到同一个事件时，希望 $R(R&lt;N)$ 个节点能够在最小时间内无冲突地成功地发送事件检测消息，抑制剩余 $N-R$ 个节点的消息发送 Sift 协议很好地利用了 WSN 流量具有突发性和局部相关性，通过在不同时隙采用不同的发送概率，使得在短时间内部分节点能够无冲突地广播事件，从而在节省能量的同时，节省了传输延时 基本思想基于事件驱动的无线传感器网络具有如下特点： 网络中的数据传输由事件驱动，存在空间相关的竞争 不是所有节点都需要报告事件 节点的密度是时变的 当数据需要发送时，节点首先在发送窗口 $[1，CW]$ 内的概率随机选择一个发送时隙，然后节点监听直接选择的发送时隙到来 如果监听期间没有其他节点使用信道，则节点立即发送数据，否则需要在信道空闲时重新选择发送时隙 冲突时就倍增时间窗口大小 $CW$，并且在新窗口内重新选择发送时隙，以增大无冲突发送的概率 工作过程当节点发送消息时，首先假设当前 $N$ 个节点与其竞争发送 如果第一个时隙内节点不发送消息，也没有其他节点发送消息，则节点就减少假设的发送节点数目，并相应地增加选择在第二个时隙发送数据的概率 如果节点没有选择第二个时隙，且没有其他节点在该时隙发送消息，则节点继续减少假设的发送节点数目，并进一步增加选择在第三个时隙发送数据的概率 以此类推，在第 $r$ 个时隙发送数据的概率为： P_r = \\frac{ (1-\\alpha) \\alpha^{CW} }{1 - \\alpha^{CW}} \\alpha^{-r},r=1,2,...,CW","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"标签","slug":"ego/06.标签","date":"2020-05-14T19:33:00.000Z","updated":"2021-09-22T08:08:28.933Z","comments":true,"path":"essay/ego/eaabd222.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/ego/eaabd222.html","excerpt":"每个人都有自己固有的标签，比如你说自己是一个程序猿，这就会让人想起秃头格子衫、找不到女朋友的老实人、挣得多死得早等等。 因此当你对一个人说自己从事某个职业时，他总会联想到这个职业的某些特性，然后把这个职业所具有的特征强加到你身上。 于是，你仅仅是表明了自己的职业，但对方的心里却对你的人设有了一个大概的轮廓，即使这并非真正的自己。","text":"每个人都有自己固有的标签，比如你说自己是一个程序猿，这就会让人想起秃头格子衫、找不到女朋友的老实人、挣得多死得早等等。 因此当你对一个人说自己从事某个职业时，他总会联想到这个职业的某些特性，然后把这个职业所具有的特征强加到你身上。 于是，你仅仅是表明了自己的职业，但对方的心里却对你的人设有了一个大概的轮廓，即使这并非真正的自己。 这就是人固有的标签，它让别人能够更好的了解自己，同时也更容易让人通过这些标签将真正的自己掩饰下去。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Ego","slug":"essay/ego","permalink":"https://alex-mcavoy.github.io/categories/essay/ego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Ego","slug":"ego","permalink":"https://alex-mcavoy.github.io/tags/ego/"}],"author":"Alex_McAvoy"},{"title":"软件测试步骤","slug":"software-engineering/13.软件测试步骤","date":"2020-05-13T12:11:00.000Z","updated":"2022-05-13T04:54:19.520Z","comments":true,"path":"notes/software-engineering/20067354.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/20067354.html","excerpt":"【概述】在软件测试阶段，采取如下步骤进行测试：","text":"【概述】在软件测试阶段，采取如下步骤进行测试： 单元测试：集中于每个独立的模块，该测试以详细设计文档为指导，测试模块内的重要控制路径，大量使用白盒测试技术 集成测试：集中于模块的组装。集成测试同时解决程序验证和程序构造这两个问题，将经过单元测试的模块构成一个满足设计要求的软件结构 确认测试：目标是发现软件实现的功能与需求规格说明书不一致的错误，通常采用黑盒测试技术 系统测试：集中检验系统所有元素（包括硬件、软件）之间协作是否 合适，整个系统的性能、功能是否达到要求 验收测试：以用户测试为主，分为 a 测试和 b 测试，a 测试指的是由用户、 测试人员、开发人员等共同参与的内部测试，b 测试指的是完全交给最终用户的测试 【单元测试】概述单元测试，是针对软件设计的最小单位（程序模块）进行的正确性检验的测试工作，其目的是在于发现各模块内部可能存在的各种差错 单元测试需要从程序的内部结构出发设计测试用例，多个模块可以平行地进行单元测试 测试内容单元测试内容如下： 模块接口：数据是否正确进出模块 局部数据结构：局部数据的说明、初始化、默认值是否有问题 独立路径：重要独立执行路径是否有错误计算、不正确比较或不适当控制流 出错处理通路： 错误描述是否难于理解 记下错误是否与实际遇到错误不同 错误处理之前，错误条件已引起系统干预 错误处理不正确 描述错误信息不足以帮助确定错误位置 边界条件：软件容易在边界上失效，边界条件的测试是最重要的 测试方法单元测试利用计算机进行测试，需要辅助模块模拟与被测模块相联模块 驱动模块：相当被测模块主程序，接收测试数据后，传送给被测模块，再输出测试结果 桩模块：存根模块，代替被测模块调用的子模块 【集成测试】概述集成测试，是将多个测试进行完单元测试的模块组合起来进行测试，其要求必须每个模块必须经过单元测试 要做好集成测试，必须加强集成测试的分析工作，集成测试分析可以从以下几个方面进行： 体系结构分析 模块分析 接口分析 集成测试策略分析 由模块组装成软件系统有两种方法： 非增量集成：先分别测试每个模块，再将所有模块按照设计要求放在一 起结合成所要的程序 增量集成：将下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完后再将下一个应测试的模块结合起来进行测试 需要注意的是，对两个以上模块进行集成时，需要考虑它们和周围模块之间的关系，为了模拟这些联系，需要设计驱动模块或者桩模块这两种辅助模块 非增量式集成测试非增量集成测试采用一步到位的方法来进行测试 增量式集成测试增量式集成测试中单元的集成是逐步实现的，集成测试也是逐步完成的，按照实施的不同次序，增量式集成测试可以分为自顶向下和自底向上两种方式 自顶向下增量式集成测试自顶向下增量式集成测试表示逐步集成和逐步测试是按结构图自上而下进行的，即模块集成顺序是首先集成主控模块，然后按照软件控制层次接口向下进行集成 从属于主控模块的模块按照深度优先策略或广度优先策略集成到结构中去： 深度优先策略：首先集成在结构中的一个主控路径下的所有模块，主控路径的选择是任意的，一般根据问题的特性来确定 广度优先策略：首先沿着水平方向，把每一层中所有直接隶属于上一层的模 块集成起来，直至最底层 自顶向下的集成方式的主要优点有： 可以及早地发现和修复模块结构图中主要控制点存在的问题 能较早地验证功能的可行性 最多只需要一个驱动模块，减少驱动模块的开发成本 支持故障隔离 自顶向下的集成方式的主要缺点是：需要开发和维护大量的桩模块 自底向上增量式集成测试自底向上增量式集成策略是从最底层的模块开始，按结构图自下而上 逐步进行集成并逐步进行测试工作 由于是从最底层开始集成，测试到较高层模块时，所需的下层模块功 能已经具备，因此不需要再使用被调用模拟子模块来辅助测试 因为是自底向上进行组装，对于一个给定层次的模块，它的所有下属 模块已经组装并测试完成，所以不再需要桩模块 自底向上集成方式的主要优点有： 大大减少了桩模块的开发 先对底层模块进行测试，减少了回归测试成本 在集成的早期实现对底层模块的并行测试，提高了集成的效率 支持故障隔离 自底向上集成方式的主要缺点有： 需要大量的驱动模块 主要控制点存在的问题要到集成后期才能修复，需要花费较大成 本 随着测试的逐步推进，组装的系统愈加复杂，对底层模块的异常 很难测试 三明治集成测试三明治集成测试是将自顶向下测试与自底向上测试两种模式有机结合起来，采用并行的自顶向下、自底向上集成方式 其采取持续集成的策略，自底向上集成时，先期完成的模块将是后期模块的驱动模块，节省了测试代码的编写，有利于提高工作效率 【系统测试】概述系统测试的对象包括源程序、需求分析阶段到详细设计阶段中的各 技术文档、管理文档、提交给用户的文档、软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口 测试范围可分为功能测试、性能测试、压力测试、容量测试、安全性测试、图形用户界面测试、可用性测试、安装测试、配置测试、异常测试、备份测试、健壮性测试、文档测试、在线帮助测试、网络测试、稳定性测试等 功能测试不管软件内部是如何实现的，只是根据需求规格说明书和测试需求列表，验证产品的功能是否符合需求规格 主要检验以下几个方面： 功能是否全部实现，有没有遗漏 功能是否满足用户需求和系统设计的隐藏需求 能否正确地接受输入，并给出正确结果 性能测试性能测试是用来测试软件系统在实际的集成系统中运行性能的 无论是单元测试，还是集成测试中，都没有将系统作为一个整体放入实际环境中运行，因此，只有在性能测试阶段，才能够真正看到系统的实际性能 对于实时系统和嵌入式系统，提供符合功能需求但不符合性能需求的软件是不能接受的 性能测试的目的是度量系统相对于预定义目标的差距，需要的性能级别针对于实际的性能级别进行比较，并把其中的差距文档化 安装测试安装测试用来确保软件在正常情况和异常情况的不同条件下都不丢失数据或者功能，具体测试活动包括首次安装、升级、完整安装、自定义安装、卸载等。测试对象包括测试安装代码以及安装手册 安装代码提供安装一些程序能够运行的基础数据，安装手册提供如何进行安装 可用性测试所谓可用性测试，即是对软件可用性进行测试，检验其是否达到可用性标准，发现人为因素或者使用上的问题 压力测试检查在系统运行环境恶劣的情况下，系统可以运行到何种程度的测试 因此，进行压力测试，需要提供非正常数量、频率或总量资源来运行系统 容量测试在进行压力测试时，如果发现了被测系统在可接受的性能范围内的极限负载，则在一定程度上完成了容量测试 容量测试的目的是通过测试预先分析出反映软件系统应用特征的某项指标的极限值，如最大并发用户数、数据库记录数等，系统在该极限值下没有出现任何软件故障或还能保持主要功能正常运行 或者说容量测试是为了确定测试对象在给定时间内能够持续处理的最大负载或工作量 安全性测试安全性测试的目的是验证系统的保护机制是否能够在实际的环境中抵御非法入侵，恶意攻击等非法行为 包含敏感信息或能够对个人造成不正当伤害的计算机系统都会成为 被攻击的目标 健壮性测试健壮性是指在故障存在的情况下，软件还能正常运行的能力 容错性测试与恢复测试是有区别的，而健壮性测试包含这两种测试。健壮性有两层含义：一是容错能力，二是恢复能力 容错性测试通常依靠输入异常数据或进行异常操作，以检验系统的保护性。如果系统的容错性好，系统只给出提示或内部消化掉，而不会导致系统出错甚至崩溃 恢复测试通过各种手段，让软件强制性地发生故障，然后验证系统已保存的用户数据是否丢失，系统和数据是否能尽快恢复 图形用户界面测试图形化用户接口测试包含两方面内容： 界面实现与界面设计是否吻合 界面功能是否正确 为了更好地进行 GUI 测试，一般将界面与功能分离设计，比如分成：界面层、界面与功能接口层、功能层，这样 GUI 的测试重点就可以放在前两层上 文档测试文档的种类包括：开发文档、管理文档、用户文档 在这 3 类文档中，一般最主要测试的是用户文档，因为用户文档中的错误可能会误导用户对软件的使用，而且如果用户在使用软件时遇到的问题没有通过用户文档中的解决方案得到解决，用户将因此对软件质量产生不信赖感，甚至厌恶使用该软件，这对软件的宣传和推广是很不利的 【验收测试】概述验收测试是在系统测试之后进行的测试，目的是为了验证新建系统产品是否能够满足用户的需要，产品通过验收测试工作才能最终结束 具体说来，验收测试就是根据各自需求说明书的标准，利用工具进行的一项检查工作，其中包括对进程的验收、进程质量是否达到需求说明书的要求，以及是否符合工程的设计要求等 验收测试是依据软件开发商和用户之间的合同、软件需求说明书以及相关行业标准、国家标准、法律法规等的要求对软件的功能、性能、 可靠性、易用性、可维护性、可移植性等特性进行严格的测试，验证软件的功能和性能及其他特性是否与用户需求一致 验收测试分为 α 测试与 β 测试： α 测试：由用户在开发者的场所进行，并且在开发者对用户的指导下进行测试 β 测试：由软件的最终用户在一个或多个客户场所进行 验收测试内容验收测试是在软件开发结束后，用户实际使用软件产品之前，进行的最后一次质量检验活动，主要回答开发的软件是否符合预期的各项要求以及用户能否接受的问题 验收测试主要验证软件功能的正确性和需求符合性，其是以用户为主的测试 单元测试、集成测试和系统测试的目的是发现软件错误，将软件缺陷排除在交付客户之前；验收测试需要客户共同参与，目的是确认软件符合需求规格 验收测试主要包括配置复审、合法性检查、文档检查、软件一致性 检查、软件功能和性能测试与测试结果评审等内容。 【回归测试】回归测试不是一个测试阶段，而是一种可以用于单元测试、集成测 试、系统测试和验收测试各个测试过程的测试技术 回归测试指软件系统被修改或扩充后重新进行的测试，其是为了保证对软件修改后，没有引入新的错误而重复进行的测试 【软件调试】调试是在测试发现错误之后排除错误的过程，其是将症状和原因联系起来的尚未被人很好理解的智力过程 常见调试的方法有：蛮干法、回溯法、原因排除法（二分查找法、归纳法、演绎法）等 调试与测试的区别如下： 测试是不断发现错误证明；调试是发现问题解决问题 测试以已知条件开始，使用预先定义的程序，且有预知的结果， 不可预见的仅是程序是否通过测试，调试一般是以不可知的内部条件开始，结果不可预见 测试是有计划的，并要进行测试设计；调试是不受时间约束的 测试经常是由独立的测试组在不了解软件设计的条件下完成的，调试必须由了解详细设计的程序员完成 大多数测试的执行和设计可由工具支持；调试时，程序员使用的主要工具就是调试器","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"无线传感网络概述","slug":"wireless-network/16.无线传感网络概述","date":"2020-05-12T12:28:00.000Z","updated":"2021-11-07T11:34:00.666Z","comments":true,"path":"notes/wireless-network/bb9ba1ab.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/bb9ba1ab.html","excerpt":"【传感器网络】传感器网络（Sensor Network，SN）是由大量广泛分布的小型轻量无线节点组成，这些节点通过测量诸如温度、压力和相对湿度等物理参数来监控环境或系统 传感器网络有两种类型：","text":"【传感器网络】传感器网络（Sensor Network，SN）是由大量广泛分布的小型轻量无线节点组成，这些节点通过测量诸如温度、压力和相对湿度等物理参数来监控环境或系统 传感器网络有两种类型： 先应式网络：连续操作模式，节点定期打开传感器和发送器感测环境，并将感性需的数据发送出去，用于需要定期监测数据的应用 反应式网络：查询-响应模式，节点根据操作员发来查询命令给予立即响应，此外，节点还会根据网络某些属性值发生的激烈变化立即予以响应 传感网络的查询分类有三种： 历史查询：用来分析存在基站上的历史数据 一次查询：获得网络的瞬间视图 持续查询：监控某段时间内的一些物理参数 【无线传感器网络】概述无线传感器网络（Wireless Sensor Network，WSN）是由部署在检测区域内大量的廉价卫星传感器节点组成，通过无线通信方式形成的一个多跳的自组织的网络系统，目的是协作地感知、采集和处理网络覆盖区域中感知的对象信息，并发送给观察者 构成 WSN 有三个要素：传感器、感知对象、观察者，其中最核心的是传感器，其由三部分组成： 传感子系统：负责感测环境 处理子系统：负责对感测数据进行本地处理 通信子系统：负责与邻近节点交换消息 特性无线传感器网络具有如下特性： 1.数据聚合 在无线传感器网络中，临近的传感器结点具有相似的数据 这就使得不需要每个节点发送数据，但要求节点具备数据聚合的能力 2.位置感知 在无线传感器网络中，多数数据搜集是基于位置的节点，需要了解自己的位置 同时，要求节点应对环境的激烈变化作出立即反应，通过有效利用有限无线信道带宽和电池能量以最小延迟，以及令端用户感知猛烈的异常情况 3.查询控制 无线传感器网络具备查询控制能力，即用户手持设备向基站或者附近的传感节点查询数据 这必须有可靠的机制确保查询命令到达恰当的节点和节点逆向回答到手持设备用户 影响因素影响传感器网络的因素有： 容错：传感网络在出现节点失效而无人干涉下继续工作的能力，容错能力的大小取决于传感器网络的应用 能耗：感测事件、通信、数据处理时的能量消耗 网络拓扑：分为先期部署、后期部署、重新部署额外节点三个阶段 节点位置：当传感节点移动时，节点位置的检测 可达性：节点之间的可达性是保证网络连通的基本条件 制造成本：单个节点的成本是衡量整个网络成本的关键 传输介质：选择的传输介质必须是全球可用的，例如无线电、红外线、其他光波等 传感器的环境：要适用于各种复杂的环境，包括但不限于海底、大型机器内部、生物/化学污染区域、战场、居家、动物等 【体系结构与协议栈】体系结构WSN 的体系结构有两种，一种是层次结构，另一种是集群结构 层次结构由一个强大的基站（BS）和围绕着它的一系列分层传感节点组成，与 BS 跳计数相同的节点位于同一层次 集群结构将传感节点组成一个个簇（Cluster），每个簇由一个簇头（Cluster Head）控制，每个节点与各自的簇头交换信息，簇头与与 BS 交换信息，BS 与有线网络连接 协议栈 1.应用层 应用层令底层硬件和软件对传感应用是透明的，常用的有三个协议： 传感器管理协议（Sensor Management Protocol，SMP） 任务分配和数据通告协议（Task Assignment and Data Advertisement Protocol，TADAP） 传感器查询和数据分发协议（Sensor Query and Data Dissemination Protocol，SQDDP） 2.传输层 当传感系统需要被 Internet 或者其他外部网络访问时，传输层至关重要，但至今未有实质性的工作 3.网络层 传感网络多数是以数据为中心的，数据聚合不能影响传感节点的协同，理想的传感器网络基于属性寻址并能感知位置，因此，在 WSN 的网络层，最重要任务就是路由协议的设计 在传统网络中，路由协议要寻找延迟小的优化路径，以提高网络利用率和公平性，同时还要避免通信拥塞和均衡网络流量；而在无线传感器网络中，由于能量消耗影响网络生存期，节点只有局部信息，因此要以数据为中心，同时考虑应用相关性 故而，无线传感器网络的路由协议有以下特点： 能量优先 基于局部拓扑信息 以数据为中心 应用相关 同时，信息传输模式有以下四种： 事件触发：节点采集信息后判断，若超过一定的阈值，则认为发生了某种事件，立即上报 sink 周期上报：节点定期把采集到的信息报告给 sink 基于查询：节点不主动向 sink 上报采集到的信息，而是等待用户查询，根据用户需要反馈信息 混合模式：前三种模式的综合 4.数据链路层 数据链路层主要是确保通信网络中的点-点、点-多点连接，同时负责介质访问控制（创建网络架构、传感节点间公平有效共享通信资源）和差错控制（前向纠错、自动重发检错） 此外，由于在 WSN 中，造成网络能量浪费有以下原因： 节点间的数据碰撞导致重传 节点接收并处理不必要的数据 节点无数据发送时侦听信道 控制消息过多 因此，在设计 WSN 的 MAC 协议时，要考虑节省能量、可扩展性、网络效率这三个方面 5.物理层 WSN 的物理层主要负责频率选择、频率产生、信号检测、调制解调、数据加密","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件测试方法","slug":"software-engineering/12.软件测试方法","date":"2020-05-11T07:53:00.000Z","updated":"2022-05-13T04:49:39.256Z","comments":true,"path":"notes/software-engineering/77aee074.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/77aee074.html","excerpt":"【概述】黑盒测试与白盒测试，是动态测试中两种非常流行的测试技术 不论是黑盒测试还是白盒测试，它们都可以发现被测系统的问题，但是由于它们侧重的角度不同，所以发现的问题也不尽相同","text":"【概述】黑盒测试与白盒测试，是动态测试中两种非常流行的测试技术 不论是黑盒测试还是白盒测试，它们都可以发现被测系统的问题，但是由于它们侧重的角度不同，所以发现的问题也不尽相同 一般在软件测试的过程中，既要用到黑盒测试，又要用到白盒测试。大的功能模块采用黑盒测试，小的构件采用白盒测试 可以说，黑盒测试和白盒测试都是基于用例的测试方法，因为它们都通过运行测试用例来发现问题。 白盒测试和黑盒测试是两类软件测试方法，传统的软件测试活动基 本上都可以划分到这两类测试方法中，下表给出了两种方法的一个基本比较 白盒测试 黑盒测试 考察程序逻辑结构 不涉及程序结构 用程序结构信息生成测试用例 用软件规格说明书生成测试用例 主要适用于单元测试和集成测试 可适用于从单元测试到系统验收测试 对所有逻辑路径进行测试 某些代码段得不到测试 【黑盒测试】概述黑盒测试着重于测试软件功能，其能发现的错误类型有： 功能不正确或遗漏 输入能否正确的接受 能否输出正确的结果 性能错误数据 结构或外部数据库访问错误 初始化或终止错误 常见黑盒测试技术有：等价类划分、边界值分析、错误推测、因果图等 黑盒测试的每种测试方法都有各自的优缺点，需要测试人员根据实际项目特点和需要选择合适的方法设计测试用例，以下是选择方法的几条经验： 在任何情况下都必须选择边界值分析方法，用该方法设计出的测试用例发现程序错误的能力最强 必要时用等价类划分法补充一些测试用例 用错误推测法再追加一些测试用例 如果程序的功能说明中含有输入条件的组合情况，则可选用因果图法和决策表法 等价类划分等价类分为有效等价类和无效等价类。有效等价类是指对程序的规格说明是有意义的、合理的输入数据所构成的集合；无效等价类是指对程序的规格说明是无意义的、不合理的输入数据构成的集合 在划分等价类时，有可遵循以下原则： 1）按双边区间划分 如果输入条件规定了取值范围或个数，则可确定一个有效等价类和两个无效等价类。 例如：输入值是选课人数，在 0 到 100 之间，那么可根据范围来划分出以下三个等价类 2）按单边区间划分 如果输入条件规定了输入值的集合，则可确定一个有效等价类和一个无效等价类 例如：输入值必须是日期类型的数据，那么可根据输入条件来划分出以下两个等价类 3）按取值划分 如果输入条件是一组值，且程序对不同的值有不同的处理方式，那么每个允许的输入值对应一个有效等价类，所有不允许的输入值的集合为一个无效等价类 例如：输入条件“职称”的值是初级、中级或高级，那么可划分为以下四个等价类 4）按限制条件划分 如果规定了输入数据必须遵循的规则，则可以划分出一个符合规则的有效的等价类和若干个从不同角度违反规则的无效的等价类 例如：在 Pascal 语言中对变量标识符规定为一个语句必须以;结束，那么可以划分以下为若干等价类 在划分完等价类后，即可设计测试用例，其可归纳为三步： 对每个输入和外部条件进行等价类划分，画出等价类表，并为每个等价类进行唯一的编号 设计一个测试用例，使其尽可能多地覆盖有效等价类，重复这一步，直到所有的有效等价类被覆盖 为每一个无效等价类设计一个测试用例，直到所有无效等价类都被覆盖为止 等价类表如下： 边界值分析法边界值分析法是等价类划分的补充，通过确定边界情况，选择边界值、大于边界值的测试外点、小于边界值的测试内点作为测试数据 用边界值分析法设计测试用例时遵守以下原则： 1）规定范围 如果输入/输出条件规定了取值范围，应以该范围的边界内及刚刚超范围的边界外的值作为测试用例 例如：重量 10-50kg 的邮件，选择边界值 10、50、10.01、49.99、9.99 及 50.01 作为测试用例 2）规定个数 若输入/输出条件规定了值的个数，应分别以最大、最小个数和稍小于最小和稍大于最大个数作为测试用例 例如：一个输入文件有 1-300 个记录，设计测试用例时则可以分别设计有 1、300、0、301 个记录的输入文件 3）有序集合 如果输入/输出范围是有序的集合，如顺序文件、表格等，选取有序集的第一个和最后一个元素作为测试用例 例如：一个输入文件是一个从 1~10 的有序表格，设计测试用例时可以选取 1、10 作为测试用例 错误推测法错误推测法是依靠经验和直觉来推测程序可能存在错误，通过有针对性编写来检查这些错误的测试用例 常见的有： 输入数据或输出数据为零 输入或输出数目为零 缺省值 空白与空值 多个数据的组合效应 错误的群集现象 因果图法因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，该方法充分考虑了输入情况的各种组合及输入条件之间的相互制约关系，适用于检查程序输入条件的各种组合情况 在因果图中，用 C 表示原因，E 表示结果，各节点表示状态，取值0 表示某状态不出现，取值 1 表示某状态出现。 在原因和结果之间，有四种关系： 恒等：若 C1 是1，则 E1 也是 1，否则 E1 为0 非：若 C1 是 1，则 E1 是 0，否则 E1 是 1 或：若 C1 或 C2 是 1，则 E1 是 1，否则 E1 为 0 与：若 C1 和 C2 都是 1，则 E1 为 1，否则 E1 为 0 在原因与原因之间、结果与结果之间存在以下约束关系： 互斥（E 约束）：a 和 b 中至多有一个可能为 1，即 a 和 b 不能同时为 1 包含（I 约束）：a、b 和 c 中至少有一个必须是 1，即 a、b 和 c 不能同时为 0 唯一（O 约束）：a 和 b 必须有一个，且仅有 1 个为 1 要求（R 约束）：a 是 1 时，b 必须是 1，即不可能 a 是 1 时 b 是 0 屏蔽/强制（M 约束）：若结果 a 是 1，则结果 b 强制为 0 需要注意的是，以上五种约束关系，前四种是输入条件的约束，只有最后一种是输出结果的约束。 用因果图生成测试用例的基本步骤如下： 分析软件规格说明描述：原因、结果、标识符 分析软件规格说明描述中的语义：找出逻辑关系 由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现，需要添加必要的约束条件 把因果图转换成判定表 把判定表的每一列拿出来作为依据，设计测试用例 【白盒测试】概述白盒测试，又称玻璃盒测试，其关注软件产品的内部细节和逻辑结构，即把被测的程序看成是一个透明的盒子 白盒测试利用构件层设计的一部分而描述的控制结构来生成测试用例，其需要对系统内部结构和工作原理有一个清楚的了解 白盒测试也有多种技术，比如：代码检查法、逻辑覆盖法、基本路径法、静态质量度量、域测试、Z 路径覆盖等 白盒测试的每种测试方法都有各自的优点和不足，需要测试人员根据 实际软件特点、实际测试目标和测试阶段选择合适的方法设计测试用例，这样能 有效地发现软件错误，提高测试效率和测试覆盖率 在选择测试方法时有以下经验： 在测试中，可采取先静态再动态的组合方式，先进行代码检查和静态结构分析，再进行覆盖测试 利用静态分析的结果作为引导，通过代码检查和动态测试的方式对静态分析的结果做进一步确认 覆盖测试是白盒测试的重点，一般可使用基本路径测试法达到语句覆盖标准，对于软件的重点模块，应使用多种覆盖标准衡量测试的覆盖率 在不同的测试阶段测试重点不同，在单元测试阶段，以代码检查、覆盖测试为主，在集成测试阶段，需要增加静态结构分析等，在系统测试阶段，应根据黑盒测试的结果，采用相应的白盒测试方法 逻辑覆盖法概述对于一个具有多重选择和循环嵌套的程序，当选择不同的路径进行测试时，路径数目可能是一个天文数字，这就是完全测试的困难性 逻辑覆盖法以程序内在的逻辑结构为基础，根据程序的流程图设计测试用例 上面的程序流程图，可分为四条路径： L1(a-&gt;c-&gt;e)：$(A&gt;1\\: and \\: B=0)\\: and \\:(A=2 \\: or \\: X/A&gt;1) $ L2(a-&gt;b-&gt;d)：$\\overline{(A&gt;1 \\: and \\: B=0)} \\: and \\: \\overline{(A=2 \\: or \\: X&gt;1)}$ L3(a-&gt;b-&gt;e)：$\\overline{(A&gt;1 \\: and \\: B=0)} \\: and \\: (A=2 \\: or \\: X&gt;1)$ L4(a-&gt;c-&gt;d)：$(A&gt;1\\: and \\: B=0)\\: and \\: \\overline{(A=2 \\: or \\: X/A&gt;1)} $ 化简后有： 对于这四条路径设计测试用例，其格式为：【输入 (A,B,X)，输出（A,B,X）】 那么当这四条路径覆盖时，有： 覆盖 L1：【(2,0,4),(2,0,3)】 覆盖 L2：【(1,1,1),(1,1,1)】 覆盖 L3：【(1,1,2),(1,1,3)】 覆盖 L4：【(3,0,3),(3,0,1)】 分类根据覆盖的目标不同，又可分为语句覆盖、分支覆盖、条件覆盖、分支-条件覆盖、条件组合覆盖和路径覆盖。 1）语句覆盖 语句覆盖，是设计若干个测试用例，运行被测程序，使得每一可执行 语句至少执行一次 在上图中，正好所有的可执行语句都在路径 L1 上，所以选择路径 L1 设计测试用例，就可以覆盖所有的可执行语句 2）分支覆盖 分支覆盖，就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次 在上图中，选取路径 L1 和 L2 是一个分支，选取路径 L3 和 L4 又是另一个分支 3）条件覆盖 条件覆盖，就是设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次 在上图中，选取路径 L3 就是一个条件覆盖 4）分支-条件覆盖 分支-条件覆盖，是取足够多测试数据，使判定表达式每个条件都取各种可能值，且每个判定表达式也都取到各种可能结果，实现不同的分支 5）条件组合覆盖 条件组合覆盖，是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次 6）路径覆盖 路径覆盖思想，是覆盖被测试程序中的所有可能路径 即选择上图中的四条路径 基本路径法基本路径法设计出的测试用例要保证在测试中程序的每条可执行语句至少执行一次，其需要使用程序的控制流图进行可视化表达 基本路径法的步骤如下： 1）根据过程设计结果画出相应流图 2）计算流图的环形复杂度 V(G)=边数-点数+2 V(G)=图所在平面被划分为的区域数 V(G)=判定节点数+1 3）确定线性独立路径的基本集合 独立路径是指至少包含一条在定义该路径之前不曾用过的边。 从程序的环形复杂度可以导出程序基本路径集合中的独立路径数，这是确保程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。 4）设计测试用例覆盖基本集合的路径 【灰盒测试】除黑盒测试和白盒测试外，还有一种灰盒测试，其是介于白盒测试和黑盒测试之间的测试方法，它关注输出对于输入的正确性，同时也关注内部表现，但是不像白盒测试那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态 有时候输出是正确的，但是程序内部已经是错误的，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此可采取灰盒测试这种方法 灰盒测试结合了白盒测试和黑盒测试的要素，考虑了用户端、特定 的系统知识和操作环境。它在系统组件的协同性环境中评价应用软件的设计，可以认为，集成测试就是一类灰盒测试","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"分区路由协议 ZRP","slug":"wireless-network/15.分区路由协议ZRP","date":"2020-05-08T05:21:44.000Z","updated":"2021-11-04T12:04:31.104Z","comments":true,"path":"notes/wireless-network/dd981625.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/dd981625.html","excerpt":"【概述】分区路由协议（Zone Routing Protocol，ZRP），是目前最常用的分层路由协议 在 ZRP 协议中，整个网络被分成若干个以节点为中心、一定跳数为半径的分区，分区内的节点数与设定的域半径有关","text":"【概述】分区路由协议（Zone Routing Protocol，ZRP），是目前最常用的分层路由协议 在 ZRP 协议中，整个网络被分成若干个以节点为中心、一定跳数为半径的分区，分区内的节点数与设定的域半径有关 域半径和路由域的定义如下： 域半径（Zone Radius）：指定每个节点维护的域，以跳计数 路由域（Routing Zone）：所有包含在域半径内的节点 边界节点（Border）：最小距离正好等于域半径的节点 ZRP 协议只允许目的域内的节点应答，延长了源节点获得路由的时间，其不仅需要周期性地广播分组，还需要消耗一定的电源能量和网络带宽，此外，路由域半径的设置将直接影响路由的效率，而每个节点可动态自动配置自己的优化域半径 由于 ZRP 协议混合的独立域路由框架，使得其支持节点非统一的独立配置，其能够较好地适应网络的时空特性，同时，自适应的架构重构能力使得在网络特性的变化方面更加鲁棒，令协议具有很好的扩展性 【域路由架构】ZRP 协议混合使用了主动路由策略和按需源路由策略，对于域内的节点通信，使用域内路由协议；对于跨域节点通信，使用域间路由协议；对于边界结点通信，使用边界传播协议 区内路由协议（ IntrAzone Routing Protocol，IARP）：采用传统的主动路由法，其支持距离向量和链路状态两种路由策略，节点之间通过周期性地交互路由表获得到 Zone 内各节点的最新路由 区间路由协议（ IntErzone Routing Protocol，IERP）：采用按需路由协议，负责寻找区外节点的路由 边界传播协议（ Bordercast Resolution Protocol，BRP）：使得路由查询分组只在边界节点之间广播 对于域内路由的维护，会周期性地交换路由信息；对于域间路由的维护，当链路断开时，节点可以通知源节点，也可以进行局部查找路由，查找方法与域间路由协议中的路由查找相同，只是查找的范围较小 【IARP 协议 】IARP 协议用于域内节点通信，其采用主动策略维护本地路由信息 构造路由域的前提是了解自己的邻居，有两种方法： 通过 MAC 协议 通过邻居发现协议（NDP 协议） 每个节点给域内一些节点发送区域构建数据包（Zone Building Packets），使得节点了解自己的发送域 同时，每个节点将路由更新包的 TTL 设置为域内最远节点的距离 【IERP 协议】IERP 协议用于域间节点通信，域间路由发现基于 BRP 协议，按需发现全局路由 当本地没有数据报的目的地路由时，会进行路由发现过程： 数据报源产生一个路由查询包，利用边界广播算法来确定该查询包的一组节点中继 对于收到查询包的节点，会检查目标节点是否在自己的路由域中，或者检查本地路由 Cache 中是否存有目标路由信息 若有，则会返回一个路由响应包给源端，若没有，则会边界广播查询包 需要注意的是，对于 IERP 协议，其会利用边界广播机制来确定节点中继： 源节点 $S$ 构造字节的边界广播树 $S$ 根据未覆盖的外围节点选择再广播节点 $S$ 通过转发节点发送查询包给再广播节点 再广播节点收到查询包后，自己就变成边界广播节点 重复上述过程 【BRP 协议 】BRP 协议使用 IARP 提供的拓扑信息，组播路由查询包到外围节点，广播接收者（Bordercast）在边界广播查询到自己的外围节点，直至发现一条到目标的路由 关于 BGP 协议的详细介绍，见：BGP 协议 【实例】假设域半径为 $2$，源节点为 $S$，目标结点为 $M$，那么 $S$ 的域中结点为：$Z(S)=\\{A,B,C,D,E,F,G,H\\}$ 如果目的节点不属于 $Z(S)$，则源节点 $S$ 发路由请求给本域的边界节点 $\\{H,G,B,C,E\\}$，然后这些节点在各自的路由域中查找是否有到目的地的路由 如果目标节点在某个边界节点的区中，则该边界节点给源节点 $S$ 发送路由应答消息，然后 $S$ 在可能的多个路由应答消息中选择一条最短路由","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"动态源路由协议 DSR","slug":"wireless-network/14.动态源路由协议DSR","date":"2020-05-07T03:56:24.000Z","updated":"2021-11-04T12:03:52.068Z","comments":true,"path":"notes/wireless-network/f5050039.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/f5050039.html","excerpt":"【概述】动态源路由协议（Dynamic Source Routing protocol，DSR）是基于源路由概念的按需自适应路由协议，其允许节点动态地发现到任何目的地的源路由，中间节点不必存储转发分组所需的路由信息，而是采用 Cache 来存放路由信息，同时允许网络完全自我组织和自我配置，但存在陈旧路由 DSR 协议简单而有效，网络开销较小，是 Ad-Hoc 网络的首选路由协议","text":"【概述】动态源路由协议（Dynamic Source Routing protocol，DSR）是基于源路由概念的按需自适应路由协议，其允许节点动态地发现到任何目的地的源路由，中间节点不必存储转发分组所需的路由信息，而是采用 Cache 来存放路由信息，同时允许网络完全自我组织和自我配置，但存在陈旧路由 DSR 协议简单而有效，网络开销较小，是 Ad-Hoc 网络的首选路由协议 DSR 协议有如下假设： 所有节点都愿意参与协议工作 当节点收到损坏分组时，能检测出来并丢弃 节点的移动速度相对于分组的传输延迟，以及底层网络硬件的无限传输范围来说，相对温和 节点的无线网络接口硬件可以混杂模式（Promiscuous）工作，即接口将收到的每个帧都上交给驱动器软件，不会针对目的地址进行过滤 任何一对节点之间的无线通信能力可不同 每个节点只能宣称一个 IP 地址 【DSR 协议描述】DSR 协议由两个相互协同的机制组成： 1.路由发现 路由发现（Route discovery），用于发现网络中的路由 由需要发送数据给节点 $D$ 的节点 $S$ 使用，该过程只在 $S$ 需要发送数据，并且不知道到 $D$ 的路由时才启动 2.路由维护 路由维护（Route maintenance），用于维护网络中的路由 节点 $S$ 在给 $D$ 发送数据时，要能检测出由于网络拓扑动态变化导致源路由中断的情况 当前的源路由不能用时，节点 $S$ 会切换到另一条已知的路由，或者重新发起 Route discovery 来寻找新路由 DSR 协议的路由发现和路由维护都是按需进行的，既不需要周期性地发送路由广播分组，也不需要感测链路状态，更不需要邻居检测，同时其不依赖于任何底层协议，仅需要维护路径上结点间的路由，能够完全地消除路由环路，并且能够同时提供多条路由 但相较于周期性通告来说，DSR 协议的每个分组都要携带完整路由的信息，这不仅增大了开销，还降低了网络带宽利用率，同时，会引起过时路由问题 【DSR 多路径】在 DSR 协议中，如果正在使用的一条路径中断，节点可立即切换到另一条缓存的路由，这样多条路由的缓存可避免每次路由中断后执行路由发现，减少了开销 多路径的获得途径有以下三种： 作为路由发现的响应 其他路由控制包和数据包中的路由信息 为任何目的地缓存多条路由 【路由发现】过程当源节点将路由请求消息（Route Request）作为局部广播分组发送时，这个分组包含两个参数： Request id：请求 id List：初始为空的链表，用于记录路由发现包经过的结点 如下图，$A$ 是路由发现的发起者，$E$ 是路由发现的目标 如果目标结点 $E$ 收到请求包，那么会给请求源 $A$ 回答一个路由回复消息（Route Reply），其值是 List 的拷贝，当路由请求源收到路由回复消息后，会在本地的路由 Cache 中缓存该路由信息。 路由请求消息记录了一条从路由发现发起端到本节点的路由，路由回复消息给出了一条从目标端到发起端的反向路由，数据分组给出记录了一条从数据报源端到目标端的正向路由 无穷迭代路由发现如果网络存在单向链路，且目标端在路由 Cache 中未找到去往发起端的路由信息，那么会发起新一轮路由发现过程，来寻找一条路径，这就造成了无穷迭代路由发现 为避免上述问题，DSR 规定目标端可使用路由请求消息中记录的路由，作为返回的路由回复消息的源路由，这样首选逆向路由，不仅可以避免无穷迭代路由的发现过程，还可以避免第二次路由发现过程带来的开销 路由缓存如果两个节点间的链路是双向的，那么在缓存侦听时获得的路由信息会被缓存 如下图，假设 $C$ 与 $X$ 间的链路是双向的，那么在从节点 $V$ 到节点 $Z$ 的路由发现过程中，$C$ 会缓存如下路由 收到路由请求包的中间结点可以使用自己的路由 Cache 缓存的到目标节点的路由信息应答路由请求，即： 路由回复消息中的路由记录=路由请求消息中的 List+缓存的路由消息需要注意的是，在返回路由回复消息前，要检查是否存在路由环路，若存在环路，则需要丢弃 应答风暴应答风暴是指：当一个节点广播针对某目标端的路由请求时，若其邻居的 Cache 中都有该目标端的路由，每个邻居都试图以自己的缓存路由响应 应答风暴会加剧局部网络冲突，且浪费网络带宽，为预防应答风暴，可采用以下三种方法： 节点将网络接口置于混杂接收方式（promiscuous） 延迟发送路由回复消息 同时侦听路由请求端是否在用更短的路径发送 【路由维护】过程路由维护过程会确保每个节点能够使用源路由发送或转发的数据分组被路由的下一跳接收，当没有收到下一跳的确认时，会不断地重发，直至最大重试次数 如果数据分组被重发了最大次数，但仍未收到下一跳的确认，那么节点要向源端路由发送路由错误消息（Route Error），并指明中断的链路 同时，分组的源端会将该路由从路由缓存中删除 之后，若源端路由缓存中存在另一条到目标的路由，那么会重发此分组，否则，重新开始路由发现过程 在新一轮的路由发现过程中，新的路由请求消息会捎带路由错误消息的内容，以便通告所有邻居特定链路中断情况，由此保证之后收到的路由回复消息不是原来的过时路由 营救分组如果节点在自己的缓存路由中发现有到目标的路由，那么在报告路由错误消息后会努力营救分组（Slavaging） 营救分组有两种方式： 将分组的源路由替换成缓存的路径 保留分组源路由的前缀，用缓存的路由替换分组源路由的后缀 路由最短自动化数据分组使用的源路由在一个或多个中间节点不需要时，节点会给数据分组的源端发回一个免费的路由回复消息消息，从而能够自动实行路由最短化 缓存否定消息节点收到路由错误消息后，其实并不是简单地删除该路由，而是会将特定链路中断信息缓存一段时间，这样随后收到的所有包含该中断链路的路由都很容易判断为不可用，但缓存的链路中断信息必须超时删除，以便在该链路恢复工作时可用","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"Disillusionment and Nothingness","slug":"ego/05.Disillusionment_and_Nothingness","date":"2020-05-06T20:46:00.000Z","updated":"2021-09-22T08:08:34.760Z","comments":true,"path":"essay/ego/d7950a94.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/ego/d7950a94.html","excerpt":"可能是一个人呆久了，过去的很多很多事情就变得朦胧又模糊，有时突然回忆起来，就会觉得很奇特，好像过了那么久。 或许是陷入到长久的疯狂中后，对时间的尺度的感知会被放慢到无限长吧，明明只有几个月，可总是觉得过去了很多很多年。 最近这些天，回想过去这段日子不由感到愚昧可笑，好像总有些东西一直在干扰着我。","text":"可能是一个人呆久了，过去的很多很多事情就变得朦胧又模糊，有时突然回忆起来，就会觉得很奇特，好像过了那么久。 或许是陷入到长久的疯狂中后，对时间的尺度的感知会被放慢到无限长吧，明明只有几个月，可总是觉得过去了很多很多年。 最近这些天，回想过去这段日子不由感到愚昧可笑，好像总有些东西一直在干扰着我。 随时会撒手人寰的幻灭感、不时来袭的对整个世界的虚无感，彼此交织在一起，这一切着实令我矛盾不已。 说到底，也只是想要的太多了，人心太复杂了一些。想要的东西太多，欲望就会变得毫无尽头。 人生好像总是如此，遇到了，分别了，就再也不见了，从来没有那些让人觉得哪怕物是人非，也会有稍许故事留心头。大概是有时话到嘴边，念头才起也便落下了吧。 对于习惯了孤独的人来说，最可怕的就是某天突然多了个伴，而这个伙伴又注定会在某天离开，于是在那个注定离开的时间点前，总是数着日子，患得患失。可是得而复失，不是要远比不曾得到痛苦的多吗？ 或许倒退个两三年又或许再过个几年，事情可能就不一样吧，谁知道呢。真希望这是一场永远永远永远不会醒来的梦。 “人生碌碌，竞短论长，却不道枯荣有数，得失难量。” 大概就是这样吧。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Ego","slug":"essay/ego","permalink":"https://alex-mcavoy.github.io/categories/essay/ego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Ego","slug":"ego","permalink":"https://alex-mcavoy.github.io/tags/ego/"}],"author":"Alex_McAvoy"},{"title":"目的节点序列距离矢量协议 DSDV ","slug":"wireless-network/13.目的节点序列距离矢量协议DSDV","date":"2020-05-05T11:23:47.000Z","updated":"2021-11-04T11:41:50.471Z","comments":true,"path":"notes/wireless-network/87ab53d8.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/87ab53d8.html","excerpt":"【从 DV 到 DSDV】对于传统的距离矢量路由协议 DV，其基于 Bellman-Ford 算法，利用距离向量来进行路由表的更新，每个结点都维持一张路由表，定期的将路由表发给所有邻居 关于 DV 算法，详见：路由算法与路由选择协议","text":"【从 DV 到 DSDV】对于传统的距离矢量路由协议 DV，其基于 Bellman-Ford 算法，利用距离向量来进行路由表的更新，每个结点都维持一张路由表，定期的将路由表发给所有邻居 关于 DV 算法，详见：路由算法与路由选择协议 如下图，是一个使用 DV 协议的路由表传播过程 但 DV 协议存在无法发现路由回路从而导致无穷计算的问题，并不适用于 Ad-Hoc 网络，因此，在距离矢量协议 DV 的基础上出现了其改进算法：目的节点序列距离矢量协议 DSDV DSDV 协议保持了 DV 协议的简单性，通过对新出现的路由表带有目的地序列标号，能够确保无路由回路，同时，当路由表发生重大变化时，立即启动路由通告（Route Advertisement），以保证对拓扑变化做出快速反应 DSDV 协议非常简单，几乎和 DV 协议一致，只是通过目的地赋予序号值来防止出现路由回环，其不存在路由发现带来的延迟，但使用该协议会使得没有节点睡眠，同时多数路由信息几乎从不使用，开销过大 【DSDV 路由表】在 DV 协议中，路由表包含三项：所有可达目的地 Dest、到目的地的下一跳 Next、到目的地的跳计数 Metric DSDV 的路由表在 DV 路由表的基础上添加了三项： 序列号 Seq.no：Sequence Number，由目的端确定，用来保证不出现路由回环 创建时间 Install Time：记录该路由表的创建时间，以用来删除表中过时路由信息 稳定数据 Stable Data：指向其他表的指针，包含有关路由如何稳定的信息，用于缓解路由波动 【路由通告】路由选择在一个节点收到路由表时，会将收到的路由更新信息与自己的路由表进行比较 为确保使用的总是来自目的地的最新路由信息，会选择目的地序号大的路由，如果目的地序号相同，则选择具有较好 metric 值的路由 路由通告当路由表发生重大变化时，会进行路由通告（Route Advertisement），以快速应对网络拓扑变化 该操作会向每个邻居通告自己的路由信息，包括：目的地址 Dest、到目的地的跳数 Metric、目的地序列号 Seq.no 在告知路由信息时，设置序列号 Seq.no 时会遵循如下规则： 每次通告将自己的序号递增 $2$，且要求只用偶数值 若一个节点不再可达（timeout），则将该节点的序号递增 $1$（奇数值），并置跳数 metric 为无穷 在网络拓扑结构发生变化时，路由会做出如下的响应： 立即通告：有关新路由、链路中断、metric 变化的信息立刻传播给邻居 更新：发送路由表的路由信息 完全更新：发送自己路由表的全部路由信息 增量更新：仅发送路由表中有变化的表项，使用一个分组即可完成更新 如下两图，是增加一个新结点 $D$ 后的路由变化 当网络拓扑变化时，得益于 DSDV 协议的立即通告，其能够很好的解决回环和无穷计算问题 【路由波动】当任一节点更新路由，会导致不必要的路由通告，即路由表的波动，这是由序列号带来的 例如：$A$ 收到来自 $P$ 路由的更新消息 (D, 15, D-102)，也收到来自 $Q$ 路由的更新信息 (D, 14, D-102)，这就造成了不必要的路由通告 (D, 15, D-102) 为减缓路由波动，常采用的方法是记录不同表中给定序号值的路由过时数据，以及最近设置时间 rec.Setting Time 和平均设置时间 avg.Setting Time，其中，设置时间 Setting Time 为第一条路由和最好路由的到达时间间隔 这样，当在新序号第一条路由到达时更新路由表，但延迟广播该条路由，推迟的时间为 $2$ 倍的平均设置时间 avg.Setting Time","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"Matlab——微积分相关技巧","slug":"25.Matlab-微积分相关技巧","date":"2020-05-04T03:48:00.000Z","updated":"2021-08-24T01:43:30.684Z","comments":true,"path":"matlab/8f92bfc8.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/8f92bfc8.html","excerpt":"【反函数求导】一阶导数对于 $y=f(x)$ 可导且 $f’(x)\\neq 0$，则存在反函数 $x=\\phi(y)$，且有 $\\frac{dx}{dy}=\\frac{1}{\\frac{dy}{dx}}$","text":"【反函数求导】一阶导数对于 $y=f(x)$ 可导且 $f’(x)\\neq 0$，则存在反函数 $x=\\phi(y)$，且有 $\\frac{dx}{dy}=\\frac{1}{\\frac{dy}{dx}}$ 即：$\\phi’(y)=\\frac{1}{f’(x)}$ 1234&gt;&gt; syms x f(x)&gt;&gt; f(x)=2*x;&gt;&gt; 1/diff(f,x)ans(x) = 1/2 二阶导数在 $y=f(x)$ 二阶可导情况下，反函数为 $x=\\phi(y)$ 时 有： $\\phi’(y)=\\frac{dx}{dy}=\\frac{1}{\\frac{dy}{dx}}=\\frac{1}{f’(x)}$ 进一步：$\\phi’’(y)=\\frac{d^2x}{dy^2}=\\frac{d(\\frac{dx}{dy})}{dy}=\\frac{d(\\phi’(y))}{dx}\\frac{dx}{dy}=\\frac{d(\\phi’(y))}{dx}\\phi’(y)=[\\frac{1}{f’(x)}]’\\frac{1}{\\phi’(y)}=\\frac{-f’’(x)}{[f’(x)]^2}\\phi’(y)$ 即：$\\phi’’(y)=\\frac{-f’’(x)}{[f’(x)]^2}\\phi’(y)=\\frac{-f’’(x)}{[f’(x)]^3}$ 1234567891011&gt;&gt; syms x f(x)&gt;&gt; f(x)=x^3;% 法一&gt;&gt; temp=1/diff(f)temp(x) = 1/(3*x^2)&gt;&gt; -diff(f,2)/(diff(f)^3)% 法二&gt;&gt; -diff(f,2)/(diff(f)^3)ans(x) = -2/(9*x^5) 【参数方程求导】一阶导数设函数 $y=y(x)$ 由参数方程 $\\left\\{\\begin{matrix}x=f(t)\\\\y=g(t)\\end{matrix}\\right.$ 确定，$f(t),g(t)$ 均对 $t$ 可导，且 $f’(t)\\neq 0$ 则：$\\frac{dy}{dx}=\\frac{dy/dt}{dx/dt}=\\frac{g’(t)}{f’(t)}$ 12345&gt;&gt; syms t x(t) y(t)&gt;&gt; x(t)=sin(t);&gt;&gt; y(t)=t*sin(t)+cos(t);&gt;&gt; diff(x)/diff(y)ans(t) = t 二阶导数设函数 $y=y(x)$ 由参数方程 $\\left\\{\\begin{matrix}x=f(t)\\\\y=g(t)\\end{matrix}\\right.$ 确定，$f(t),g(t)$ 均对 $t$ 二阶可导，且 $f’(t)\\neq 0$ 则：$\\frac{dy}{dx}=\\frac{dy/dt}{dx/dt}=\\frac{g’(t)}{f’(t)}$ 进一步：$\\frac{d^2y}{dx^2}=\\frac{d(\\frac{dy}{dx})}{dx}=\\frac{d(\\frac{dy}{dx})/dt}{dx/dt}=\\frac{[\\frac{g’(t)}{f’(t)}]’}{f’(t)}=\\frac{g’’(t)f’(t)-f’’(t)g’(t)}{[f’(t)]^2}\\frac{1}{f’(t)}=\\frac{g’’(t)f’(t)-f’’(t)g’(t)}{[f’(t)]^3}$ 123456789101112131415&gt;&gt; syms t f(t) g(t)&gt;&gt; f(t)=sin(t);&gt;&gt; g(t)=t*sin(t)+cos(t);% 法一&gt; temp=diff(g)/diff(f)temp(t) = t&gt;&gt; diff(temp)/diff(f)ans(t) = 1/cos(t)% 法二&gt;&gt; (diff(g,2)*diff(f)-diff(g)*diff(f,2))/(diff(f)^3)ans(t) = (cos(t)*(cos(t) - t*sin(t)) + t*cos(t)*sin(t))/cos(t)^3&gt;&gt; simplify(ans)ans(t) = 1/cos(t) 【隐函数求导】单个方程设 $y=y(x)$ 是由方程 $F(x,y)=0$ 确定的可导函数 对于 $F(x,y)=0$ 两边同时对于 $x$ 进行求导 有：$F_xx’+F_y y_x’=0$ 化简有：$F_x+F_y y_x’=0 $ 即：$y_x’=\\frac{dy}{dx}=-\\frac{F_x}{F_y}$ 例：求 $sin(x*y)=ln(\\frac{x+\\pi}{y})+1$ 的导数 1234&gt;&gt; syms x y F(x,y)&gt;&gt; F(x,y)=sin(x*y)-log((x+pi)/y)-1;&gt;&gt; -diff(F,x)/diff(F,y)ans(x, y) = (1/(x + pi) - y*cos(x*y))/(x*cos(x*y) + 1/y) 三元方程组设两个一元隐函数 $y=y(x),z=z(x)$ 由方程组$\\left\\{\\begin{matrix}F(x,y,z)=0\\\\G(x,y,z)=0\\end{matrix}\\right.$ 确定 对于 $F(x,y)=0$ 两边同时对于 $x$ 进行求导 有：$F_x+F_y y_x’+F_z z_x’=0$ ① 同理，对于 $G(x,y)=0$ 两边同时对于 $x$ 进行求导 有：$G_x+G_y y_x’+G_z z_x’=0$ ② 对于式 ①，有：$y_x’=\\frac{F_z z_x’-F_x}{F_y}$ ③ 对于式 ②，有：$z_x’=\\frac{-G_y y_x’-G_x}{G_z}$ ④ 将式 ④ 带入式 ③ 中，有：$y_x’=\\frac{F_z\\frac{-G_y y_x’-G_x}{G_z}-F_x}{F_y}$ ⑤ 将式 ③ 带入式 ④ 中，有：$z_x’=\\frac{-G_y\\frac{F_z z_x’-F_x}{F_y}-G_x}{G_z}$ ⑥ 将 ⑤、⑥ 化简，有：$\\left\\{\\begin{matrix} y_x’=-\\frac{F_z G_x-F_x G_z}{F_y G_z-F_z G_y}\\\\ z_x’=-\\frac{F_y G_x-F_x G_y}{F_y G_z-F_z G_y}\\end{matrix}\\right.$ 即：$\\left\\{\\begin{matrix} y_x’=\\frac{dy}{dx}= -\\frac{1}{J}\\begin{vmatrix}F_x &amp; F_z \\\\ G_x &amp; G_z \\end{vmatrix}\\\\ z_x’=\\frac{dz}{dx}=-\\frac{1}{J}\\begin{vmatrix} F_y &amp; F_x\\\\ G_y &amp; G_x\\end{vmatrix}\\end{matrix}\\right.$，其中 $J=\\begin{vmatrix} F_y &amp; F_z \\\\ G_y &amp; G_z \\end{vmatrix}\\neq 0 $ 例： 求：$\\left\\{\\begin{matrix}z=x^2+y^2\\\\x^2+2y^2+3z^2=20\\end{matrix}\\right.$ 的 $\\frac{dy}{dx},\\frac{dz}{dx}$ 12345678910111213141516171819202122232425262728293031&gt;&gt; syms x y z&gt;&gt; F(x,y,z)=z-x^2-y^2;&gt;&gt; G(x,y,z)=x^2-2*y^2+3*z^2-20;% 法一&gt;&gt; Fx=diff(F,x);Fy=diff(F,y);Fz=diff(F,z);&gt;&gt; Gx=diff(G,x);Gy=diff(G,y);Gz=diff(G,z);&gt;&gt; J=det([Fy,Fz;Gy,Gz]); &gt;&gt; dy=(-1/J)*det([Fx,Fz;Gx,Gz])dy(x, y, z) = (2*x + 12*x*z)/(4*y - 12*y*z)&gt;&gt; simplify(dy)ans(x, y, z) = -(x*(6*z + 1))/(2*y*(3*z - 1))&gt;&gt; dz=(-1/J)*det([Fy,Fx;Gy,Gx])dz(x, y, z) = (12*x*y)/(4*y - 12*y*z)&gt;&gt; simplify(dz)ans(x, y, z) = -(3*x)/(3*z - 1)% 法二&gt;&gt; J=det(jacobian([F,G],[y,z]));&gt;&gt; dy=(-1/J)*det(jacobian([F,G],[x,z]))dy(x, y, z) = (2*x + 12*x*z)/(4*y - 12*y*z)&gt;&gt; simplify(dy)ans(x, y, z) = -(x*(6*z + 1))/(2*y*(3*z - 1))&gt;&gt; dz=(-1/J)*det(jacobian([F,G],[y,x]))dz(x, y, z) = (12*x*y)/(4*y - 12*y*z)&gt;&gt; simplify(dz)ans(x, y, z) = -(3*x)/(3*z - 1) 隐函数求偏导 设 $\\left\\{\\begin{matrix} F(x,y,u,v)=0 \\\\ G(x,y,u,v)=0 \\end{matrix}\\right.$ 在点 $P(x_0,y_0,u_0,v_0)$ 的某一邻域内有对各变量的连续偏导数，满足 $\\left\\{\\begin{matrix} F(x_0,y_0,u_0,v_0)=0 \\\\ G(x_0,y_0,u_0,v_0)=0 \\end{matrix}\\right.$，且偏导数所组成的行列式（雅克比行列式） $J=\\frac{\\partial(F,G)}{\\partial(u,v)}=\\begin{vmatrix}\\frac{\\partial F}{\\partial u} &amp; \\frac{\\partial F}{\\partial v} \\\\ \\frac{\\partial G}{\\partial u} &amp; \\frac{\\partial G}{\\partial v} \\end{vmatrix}$ 在点 $P(x_0,y_0,u_0,v_0)\\neq 0$ 那么该方程组在点 $P$ 的某一邻域内恒能唯一确定一组单值连续且具有连续偏导数的函数 $\\left\\{\\begin{matrix} u=u(x,y) \\\\ v=v(x,y) \\end{matrix}\\right.$ ，它们满足 $\\left\\{\\begin{matrix} u_0=u(x_0,y_0) \\\\ v_0=v(x_0,y_0) \\end{matrix}\\right.$ ，并有： $\\frac{\\partial u}{\\partial x}=-\\frac{1}{J}\\frac{\\partial(F,G)}{\\partial(x,v)}=-\\frac{\\begin{vmatrix}F_x&amp;F_v\\\\G_x&amp;G_v\\end{vmatrix}}{\\begin{vmatrix}F_u&amp;F_v\\\\G_u&amp;G_v\\end{vmatrix}}$ $\\frac{\\partial u}{\\partial y}=-\\frac{1}{J}\\frac{\\partial(F,G)}{\\partial(y,v)}=-\\frac{\\begin{vmatrix}F_y&amp;F_v\\\\G_y&amp;G_v\\end{vmatrix}}{\\begin{vmatrix}F_u&amp;F_v\\\\G_u&amp;G_v\\end{vmatrix}}$ $\\frac{\\partial v}{\\partial x}=-\\frac{1}{J}\\frac{\\partial(F,G)}{\\partial(u,x)}=-\\frac{\\begin{vmatrix}F_u&amp;F_x\\\\G_u&amp;G_x\\end{vmatrix}}{\\begin{vmatrix}F_u&amp;F_v\\\\G_u&amp;G_v\\end{vmatrix}}$ $\\frac{\\partial v}{\\partial y}=-\\frac{1}{J}\\frac{\\partial(F,G)}{\\partial(u,y)}=-\\frac{\\begin{vmatrix}F_u&amp;F_y\\\\G_u&amp;G_y\\end{vmatrix}}{\\begin{vmatrix}F_u&amp;F_v\\\\G_u&amp;G_v\\end{vmatrix}}$ 例：求 $\\left\\{\\begin{matrix}xu-yv=0\\\\yu+xv=1\\end{matrix}\\right.$的偏导数 $\\frac{\\partial u}{\\partial x},\\frac{\\partial u}{\\partial y},\\frac{\\partial v}{\\partial x},\\frac{\\partial v}{\\partial y}$ 1234567891011121314151617181920212223242526272829&gt;&gt; syms x y u v&gt;&gt; F(x,y,u,v)=u*x-v*y;&gt;&gt; G(x,y,u,v)=y*u+x*v-1;% 法一&gt;&gt; Fx=diff(F,x);Fy=diff(F,y);Fu=diff(F,u);Fv=diff(F,v);&gt;&gt; Gx=diff(G,x);Gy=diff(G,y);Gu=diff(G,u);Gv=diff(G,v);&gt;&gt; J=det([Fu,Fv;Gu,Gv]);&gt;&gt; dux=-det([Fx,Fv;Gx,Gv])/Jdux(x, y, u, v) = -(u*x + v*y)/(x^2 + y^2)&gt;&gt; duy=-det([Fy,Fv;Gy,Gv])/Jduy(x, y, u, v) = -(u*y - v*x)/(x^2 + y^2)&gt;&gt; dvx=-det([Fu,Fx;Gu,Gx])/Jdvx(x, y, u, v) = (u*y - v*x)/(x^2 + y^2)&gt;&gt; dvy=-det([Fu,Fy;Gu,Gy])/Jdvy(x, y, u, v) = -(u*x + v*y)/(x^2 + y^2)% 法二&gt;&gt; J=det(jacobian([F,G],[u,v]));&gt;&gt; dux=-det(jacobian([F,G],[x,v]))/Jdux(x, y, u, v) = -(u*x + v*y)/(x^2 + y^2)&gt;&gt; duy=-det(jacobian([F,G],[y,v]))/Jduy(x, y, u, v) = -(u*y - v*x)/(x^2 + y^2)&gt;&gt; dvx=-det(jacobian([F,G],[u,x]))/Jdvx(x, y, u, v) = (u*y - v*x)/(x^2 + y^2)&gt;&gt; dvy=-det(jacobian([F,G],[u,x]))/Jdvy(x, y, u, v) = (u*y - v*x)/(x^2 + y^2)","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"无线自组织网络的网络层","slug":"wireless-network/12.无线自组织网络的网络层","date":"2020-05-04T01:56:13.000Z","updated":"2021-11-04T11:55:07.553Z","comments":true,"path":"notes/wireless-network/cdb872e0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/cdb872e0.html","excerpt":"【Ad-Hoc 网络层体系结构】在 Ad-Hoc 的网络层中，其存在两种结构： 1.平面结构","text":"【Ad-Hoc 网络层体系结构】在 Ad-Hoc 的网络层中，其存在两种结构： 1.平面结构 平面结构即完全分布式，所有节点的地位平等，网络控制、路由选择、流量管理能力相同，只要存在多条路径就能通信 简单而健壮，相对安全，但节点覆盖范围较小，路由开销大，可扩充性差，在节点数目多移动性强的环境下，维持网络最新拓扑的控制开销大 2.层次结构 层次结构即分层分布式，网络被划分为簇，每个簇由一个簇头和多个簇成员组成，簇头可形成更高一级的网络 簇成员功能简单，节点定位简单，路由信息局部化能够减少路由协议开销，可扩展性好，抗毁性好，但簇头需要选择，所有传输都通过头 路由不一定最短 【Ad-Hoc 网络层路由】路由协议体系在 Ad-Hoc 网络中，通信两点可能不在相互的无线传输范围内，需要其他节点承担路由器的转发工作，同时，节点移动要能改发现新路由 而由于 Ad-Hoc 网络的特性，使得路由信息不完整也不易获得，同时网络的所有结点路由信息随时可能过期，这使得常规的 DV 路由协议（距离向量协议）周期性地路由更新会消耗大量的网络带宽和节点资源，当网络节点失效时容易形成路由回路，这就要求开发一套新的路由协议，来满足 Ad-Hoc 网络的需求 针对这两种结构，开发出了平面寻址的平面路由和分层寻址的分层路由，以满足两种体系结构的路由需要 路由评价指标路由协议的性能在不同的网络环境中表现不同，在 Ad-Hoc 中有如下评价指标： 端-端的数据吞吐量和延迟：反映数据报的传输质量 路由请求的时间：数据需要发送到发送出去的时间 路由协议的效率：路由控制信息与数据信息的比率 平面路由平面路由有两种驱动方式：表驱动的表驱动路由协议、按需驱动的按需路由协议 1.表驱动路由协议 表驱动路由协议是一种先应式路由，可以认为是传统的分布式最短路径路由协议，使用该方式的每个节点都会维护到网络中所有节点的路由，这使得所有路由都已经存在并且随时可用，路由请求的延迟低但路由开销高 目前，常用的协议有： DSDV 协议：目的节点序列距离矢量协议，由传统的距离矢量路由协议 DV 改进得来，保持了 DV 协议的简单性的同时，能快速对拓扑变化做出反应，是表驱动路由协议的首选协议 OLSR 协议：优化的链路状态路由协议，是基于多点中继概念的对常规表驱动路由协议的改进，其继承了链路状态协议的稳定性，同时最小化了报文转发前的等待时间，该协议的核心是多点转播（MPRs），即在广播洪泛的过程中挑选的转发广播的节点 TBRPF 协议：基于拓扑广播的逆向路径转发，本质上是一种 LS 协议，该协议由邻居发现模块、路由模块组成，与传统链路状态协议相比，该协议的拓扑更新消息更小，路由开销更少，更适合拓扑迅速变化的无线网络 关于 DSDV 协议的介绍，见：目的节点序列距离矢量协议 DSDV 2.按需路由协议 按需路由协议是一种反应式路由，在源端需要的时候通过路由发现过程来确定路由，控制信息采用泛洪方式，该方式路由请求延迟高，路由开销低，有源路由（报文头携带完整的路由信息）和 hop-hop 路由两种实现技术 目前，常用的协议有： DSR 协议：动态源路由协议，是基于源路由概念的按需自适应路由协议，该简单而有效，网络开销较小，是 Ad-Hoc 网络的首选路由协议 AODV 协议：Ad-Hoc 按需距离矢量路由协议，是 DSDV 协议和 DSR 协议的综合，借用了 DSR 协议中路由发现和路由维护的基础，采用 DSDV 协议逐跳路由（hop-by-hop）、顺序编号和路由维护阶段的周期更新机制 关于 DSR 协议的介绍，见：动态源路由协议 DSR 分层路由分层路由协议是一种层次式路由，通过一些节点组成一个簇（Cluster）或者一个分区（Zone），这些簇和分区可组成较大的超级簇（Super Cluster）或者超级分区（Super Zone） 需要说明的是，簇内所有节点都与簇头直接通信，簇内节点间的通信一般是两跳，而分区的大小没有限制，其内节点的通信可多跳 在分层路由协议的设计上，遵循以下原则： 减少参与路由计算的节点数，以降低交换路由信息的通信开销，同时要缩短路由表的长度和维护开销 通过分区策略来产生较为稳定的子网，以减少拓扑结构变化对路由协议带来的影响 如下图，是一个使用分层路由协议的二级网络 目前，最常用的协议是 ZRP 协议，其混合使用了主动路由策略和按需源路由策略，对于域内的节点通信，使用域内路由协议；对于跨域节点通信，使用域间路由协议；对于边界结点通信，使用边界传播协议 关于 ZRP 协议的介绍，见：分区路由协议 ZRP","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"Matlab——拟合与参数估计","slug":"24.Matlab-拟合与参数估计","date":"2020-05-03T13:47:00.000Z","updated":"2021-08-24T01:43:39.047Z","comments":true,"path":"matlab/69660f8c.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/69660f8c.html","excerpt":"【多项式拟合】在 matlab 中，函数 polyfit() 用于多项式拟合，其采用最小二乘法进行计算 polyfit(x,y,n)：找到次数为 n 的多项式系数 polyval(x,y)：计算多项式的误差","text":"【多项式拟合】在 matlab 中，函数 polyfit() 用于多项式拟合，其采用最小二乘法进行计算 polyfit(x,y,n)：找到次数为 n 的多项式系数 polyval(x,y)：计算多项式的误差 1234567891011121314151617&gt;&gt; x=ceil(randn(1,10)*10);&gt;&gt; x=sort(x);&gt;&gt; y=ceil(randn(1,10)*10);&gt;&gt; y=sort(y);&gt;&gt; subplot(2,1,1)&gt;&gt; plot(x,y,'s')&gt;&gt; subplot(2,1,2)&gt;&gt; p5=polyfit(x,y,5);&gt;&gt; y5=polyval(p5,x);&gt;&gt; plot(x,y5,'-s')&gt;&gt; hold on&gt;&gt; p3=polyfit(x,y,3);&gt;&gt; y3=polyval(p3,x);&gt;&gt; plot(x,y3,'-s')&gt;&gt; legend('p5','p3') 注：除利用最小二乘法的多项式拟合外，常用的拟合方法有 WLS 拟合、非线性曲线拟合等，但由于 matlab 中没有集成的方法，且原理涉及到机器学习知识，故不再赘述 【参数估计】常见分布的参数估计在 matlab 中，对于常见分布的参数估计有集成的函数，下面以正态分布的参数估计为例，介绍该类函数的用法 [mu_hat,sigma_hat,mu_ci,sigma_ci]=normfit(x)：对于给定的正态分布 x，返回参数为 u 的估计值 mu_hat，sigma 的估计值 sigma_ci，其中两个参数的置信区间均为 95% [mu_hat,sigma_hat,mu_ci,sigma_ci]=normfit(x,alpha)：对于给定的正态分布 x，返回参数为 u 的估计值 mu_hat，sigma 的估计值 sigma_ci，其中两个参数的置信区间均为 (1-alpha)*100% 常见分布的参数估计集成函数见下表： 分布 函数 泊松分布 poissfit 均匀分布 unifit 正态对数似然函数 normlike 二项分布 binofit 伽马分布 gamfit 伽马似然函数 gmalike 指数分布 expfit 贝塔分布 betafit 贝塔对数似然函数 betalike 点估计点估计的常用方法有最大似然法和矩法两种，在 matlab 中，分别利用 mle() 和 moment() 函数进行计算 p=mle(name,data)：返回 name 指定的分布，关于数据 data 的最大似然估计 m=moment(x,order)：返回由 n 指定的 x 的中心矩 123456789101112131415&gt;&gt; x=30+(randn(1,10)*10);&gt;&gt; y=30+(randn(1,10)*10);% 最大似然法&gt;&gt; p=mle('norm',[x,y]);&gt;&gt; mu_hat_mle=p(1)mu_hat_mle = 30.0936&gt;&gt; sigma_hat_mle=p(2)^2sigma_hat_mle = 111.8298% 矩法&gt;&gt; mu_hat_mle=mean([x,y])mu_hat_mle = 30.0936&gt;&gt; sigma_hat_mle=moment([x,y],2)sigma_hat_mle = 111.8298 区间估计在 matlab 中，求区间估计时，利用 mle() 来计算区间估计 [p_hat,p_ci]=mle(name,data)：返回 name 指定分布，关于数据 data 最大似然估计和 95% 的置信区间 [p_hat,p_ci]=mle(name,data,alpha)：返回 name 指定分布，关于数据 data 最大似然估计和 (1-alpha)*100%% 的置信区间 1234567&gt;&gt; x=30+(randn(1,10)*10);&gt;&gt; [p,p_ci]=mle('norm',[x,y],0.05)p = 30.0936 10.5750p_ci = 25.0157 8.2511 35.1714 15.8467","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——插值法","slug":"23.Matlab-插值法","date":"2020-05-03T10:46:00.000Z","updated":"2021-08-24T01:43:16.957Z","comments":true,"path":"matlab/66bf937f.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/66bf937f.html","excerpt":"【是什么】根据实验来得到的点，绘制出的函数 $y=f(x)$ 可能不那么精确，有时就需要通过构造一些点，来构造一个近似函数，以满足我们的需要 拟合：不需要过所有点","text":"【是什么】根据实验来得到的点，绘制出的函数 $y=f(x)$ 可能不那么精确，有时就需要通过构造一些点，来构造一个近似函数，以满足我们的需要 拟合：不需要过所有点 插值：需要过所有点 【一维插值】interp1(x,y,q,method)：x 为自变量，y 为因变量，q 为插值变量，method 为插值方法 关于 method： &#39;nearest&#39;：临近点插值，插值点函数估计为与插值点最近的数据点的函数值 &#39;linear&#39;：线性插值，相邻点根据线性关系进行插值，默认 &#39;spline&#39;：三次样条插值，相邻点建立三次多项式函数来进行插值 &#39;pchip&#39;：立方插值，相邻点通过分段立方法来进行插值 优缺点： 临近点插值：速度最快，平滑性最差 线性插值：运算时间长，曲线结果不会改变，但顶点斜率会变，一般很少使用 三次样条插值：运算时间最长，内存占用较立方插值少，曲线结果与导数是连续的，平滑性最好 立方插值：运算时间较长，内存占用最多，平滑性较好 线性插值与分段线性插值线性插值，是根据两点坐标得到一条线后，根据另一点坐标求得该点另一坐标值 即：$y=y_i+\\frac{y_i-y_{i-1}}{x_i-x_{i-1}}(x-x_i)$ 在 matlab 中，利用 interp1() 来进行线性插值 分段线性插值，是在每个区间 $[x_i,x_{i+1}]$ 上采取简单的线性插值 在区间 $[x_i,x_{i+1}]$ 上的子插值多项式为：$F_i=\\frac{x-x_{i+1}}{x_i-x_{i+1}}f(x_i)+\\frac{x-x_i}{x_{i+1}-x_i}f(x_{i+1})$ 在 matlab 中，利用 interp1() 来进行分段线性插值 12345678&gt;&gt; x=0:2*pi;&gt;&gt; y=sin(x);&gt;&gt; subplot(2,1,1)&gt;&gt; plot(x,y)&gt;&gt; subplot(2,1,2)&gt;&gt; xx=0:0.5:2*pi;&gt;&gt; yy=interp1(x,y,xx);&gt;&gt; plot(xx,yy) 快速傅里叶插值一维快速傅里叶插值利用傅里叶变换，将数据变换到频域，然后频域上增采样点，再逆傅里叶变换回时域 在 matlab 中，利用 interpft(y,q) 来进行分段线性插值 123456789&gt;&gt; x=0:1.2:10;&gt;&gt; y=sin(x);&gt;&gt; n=2*length(x);&gt;&gt; subplot(2,1,1)&gt;&gt; plot(x,y)&gt;&gt; subplot(2,1,2)&gt;&gt; yy=interpft(y,n);&gt;&gt; xx=0:0.6:10.2;&gt;&gt; plot(xx,yy) 【二维插值】 interp2(X,Y,Z,qx,qy,method)：在数据点 [Xi,Yi] 上进行插值，Z 为函数，qx、qy 为要插值的点，method 控制方法 关于 method： &#39;nearest&#39;：临近点插值，插值点函数估计为与插值点最近的数据点的函数值 &#39;linear&#39;：双线性插值，相邻点根据线性关系进行插值，默认 &#39;spline&#39;：三次样条插值，相邻点建立三次多项式函数来进行插值 &#39;pchip&#39;：双立方插值，相邻点通过分段立方法来进行插值 优缺点： 临近点插值：速度最快，平滑性最差 线性插值：运算时间长，曲线结果不会改变，但顶点斜率会变，一般很少使用 三次样条插值：运算时间最长，内存占用较立方插值少，曲线结果与导数是连续的，平滑性最好 立方插值：运算时间较长，内存占用最多，平滑性较好 123456789&gt;&gt; [X,Y]=meshgrid(-5:0.5:5);&gt;&gt; Z=peaks(X,Y);&gt;&gt; subplot(2,1,1)&gt;&gt; plot3(X,Y,Z)&gt;&gt; [qx,qy]=meshgrid(-5:0.05:5);&gt;&gt; zz=interp2(X,Y,Z,qx,qy,'spline');&gt;&gt; subplot(2,1,2)&gt;&gt; plot3(qx,qy,zz)","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"无线自组织网络的 MAC 层","slug":"wireless-network/11.无线自组织网络的MAC层","date":"2020-05-02T14:34:00.000Z","updated":"2021-11-03T14:14:03.433Z","comments":true,"path":"notes/wireless-network/b3fc9ee3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/b3fc9ee3.html","excerpt":"【概述】在 Ad-Hoc 网络中，节点移动、无线信道脆弱、缺乏中心协调机制这三个问题是在设计 MAC 协议时要仔细考虑的问题。 针对上述三种问题，有三种不同的解决方案，也就有了以下三类协议：","text":"【概述】在 Ad-Hoc 网络中，节点移动、无线信道脆弱、缺乏中心协调机制这三个问题是在设计 MAC 协议时要仔细考虑的问题。 针对上述三种问题，有三种不同的解决方案，也就有了以下三类协议： 竞争协议（Contention Protocol）：使用直接竞争来决定信道访问权，通过重传机制解决碰撞问题 分配协议（Allocation Protocol）：分配结点传输时间，分为动态分配协议和静态分配协议 混合协议（Hybrid Protocol）： 【竞争协议】概述常见的竞争协议有以下四种： ALOHA 协议 载波侦听多址访问协议（CSMA） 基于控制分组握手的访问控制协议 忙音类多址访问协议 关于 ALOHA 协议和 CSMA 协议，详见：随机访问介质控制 基于控制分组握手的访问控制协议基于控制分组握手的访问控制协议有三种: 多址访问与碰撞回避协议（MACA 协议） IEEE 802.11 MAC 协议 准许式多址访问与碰撞回避协议（MACA-BI 协议） 1.MACA 协议 多址访问与碰撞回避协议，会发送数据前先向接收者发送 RTS 帧，帧中包含将要发送的分组的长度，接收者收到 RTS 后，回送 CTS 帧，并将长度消息捎回，收到 CTS 后，发送者开始发送数据 收到 RTS/CTS 的其它节点在传输时间内不发送任何消息，冲突后会遵循指数退避 该协议提高了无线信道的利用率，仅会发生长度比数据帧小得多的 RTS/CTS 帧的冲突，冲突几率降低，部分解决了隐藏终端问题，但不能解决控制分组之间 RTS/CTS 的冲突问题，在链路层上无确认机制，发生冲突时，需要上层超时重发，效率低 2.IEEE 802.11 MAC 协议 IEEE 802.11 MAC 协议是 IEEE 802.11 标准中的 MAC 协议，其即结合了各种时隙的 CSMA/CA 的协议 关于该协议的详细介绍，见：随机访问介质控制 中的 CSMA 协议 3.MACA-BI 协议 准许式多址访问与碰撞回避协议是基于 MACA 的收方主动的信道接入协议 接收方轮询其他节点是否有数据要发送，只有接到 RTR（Ready To Receive）邀请的节点才能发送数据 MACA-BI 减少了握手次数，从而在高速、短距离的 Ad-Hoc 网络中提高了吞吐量 忙音类多址访问协议忙音多址访问协议（BTMA 协议），将带宽划分为两个独立的信道， 数据信道用于传输数据分组，控制信道用于传输特殊的忙音信号 忙音信号用于表示数据信道上出现数据发送，节点发送数据前先收听控制信道上的忙音信号 若无忙音信号，则发送数据，同时其他节点检测到数据信道上的数据发送后，立即开始往控制信道上发送忙音信号，直到数据信道上的发送停止。若有忙音信号，则随机时间后再发送 该协议虽然防止了隐藏节点的干扰，降低了 RTS/CTS 碰撞率，但暴露节点问题增多，同时降低了信道利用率 【分配协议】概述分配类协议分为两类： 静态分配协议：集中式传输时间安排算法，事先为每个节点静态地分配一个固定的传输时间安排 动态分配协议：使用分布式传输时间安排算法，按需计算传输时间安排 常见的协议有： 时分多址访问协议（TDMA 协议） 五步预留协议（FPRP 协议） 跳频预留多址访问协议（HRMA 协议） 时分多址访问协议TDMA 协议可分为固定分配类 TDMA 协议和动态分配类 TDMA 协议两种 固定分配类 TDMA 协议按照网络中的最大节点数量来做出其传输时间安排，对于一个有N个节点的网络，TDMA协议使用的帧的长度划分时隙，每个节点分得唯一的一个时隙，有效避免各种冲突，但点越多时延越大 该协议的问题在于：在移动 Ad-Hoc 网络中，节点可以没有任何事先告警就被激活，或者被关闭，自由移动导致网络拓扑的易变 为解决上述问题，有了动态分配 TDMA 协议，该协议使用本地参数指定网络内的有限范围（x-跳内），据此为节点确定分配传输时隙 本地参数很可能随时间而变化，所以传输时间安排算法按照分布式方式工作，并且周期性地重复执行，以便适应网络变化 移动 Ad-Hoc 网络的多跳网络拓扑允许带宽的空间复用，不同的节点只要相距得足够远，就可以同时使用相同的带宽，距离一般必须至少等于三跳 五步预留协议概述五步预留协议 FPRP 是一个单信道、基于 TDMA 的广播传输时间安排协议 该协议使用竞争机制，使得网络节点相互竞争以获取 TDMA 广播时隙，它通过很小的控制分组的 5 次广播式的握手过程完成两跳范围内的节点间低冲突概率的 TDMA 时隙的分配 节点有业务要传送时,在预约信道通过控制分组的竞争预约信息信道的信息时隙进行业务传送。 在每个预约帧 RF 后可跟有不同数目的信息帧 IF，在 RF 和 IF 中都包含有同等数目的时隙，预约时隙 RS 和信息时隙 IS 一一对应。每 RS 中又划分 M 个预约周期 RC，每个 RC 是一个预约过程，RC 中节点通过 5 次握手过程实现 IS 的预约 过程该协议的过程分为五个阶段： 1）预约请求阶段（RR，Reservation Request Phase）：需要预约资源的节点以概率 $p$ 发送预约请求分组（RR）。发送 RR 分组的节点称为 RN（Reservation Node）,不需要进行资源预约的节点在该段里进行监听 2）冲突报告阶段（CR，Collision Report Phase）：节点如果在阶段 1） 收到多个 RR，在该阶段它将发送一个 CR，否则保持沉默。若未接收到 CR，RN 认为它所发送的 RR 没有和别的节点发送的 RR 冲突。这样一个 RN 节点就变成了一个传递节点 TN，在状态 3） 里就可以预约，通过 RR/CR 交互消除了隐藏终端问题 3）预约证实阶段（RC，Reservation Confirmation Phase, RC）：TN 在该阶发送 RC，每一个一跳邻节点都能正确地接收到这个 RC，都知道该时隙已被预约。它们将在信息时隙里从 TN 接收信息，并且将不再竞争该时隙 4）预约确认阶段（RA，Reservation Acknowledgement Phase,）：在该阶段，TN 的一跳邻节点把当前的预约信息通知给 TN 的两跳邻节点。如果 TN 没有一跳邻节点，它将接收不到 RA，因此就可以明确地知道本节点是孤立的，TN 就没必要进行信息的发送。如果没有该阶段，孤立 RN 就因从来没有收到过 CR 而总成为 TN，从而产生孤立死锁 5）填充/消除阶段（P/E，Packing/Elimination Phase，P/E）：该阶段以两种类型的分组进行传送 填充分组（PP，Packing Packet）：，由 TN 的两跳邻节点发送。节点 K 接收到 PP 分组后，知道三跳的某个节点预约了资源并且节点 K 的某些邻节点将不能与其竞争当前的时隙资源。 K 提高发送 RR 分组的概率 p，加快预约收敛速度，增加距 TN 三跳远的节点的预约成功率 消除分组（EP，Elimination Packet）：由 TN 节点按照 0.5 的概率发送。由于节点发送的同时不能进行接收，当两个节点同时发送预约分组 RR 时就会造成非孤立死锁现象，如果 TN 节点在该阶段没有发送 EP 反而收到一个 EP 分组，那么就知道存在有非孤立死锁问题，收到 EP 分组的节点的状态由发送改为接收状态，这样，协议通过发送 EP 分组可以消除可能存在的非孤立死锁问题 非孤立死锁的消除非孤立死锁的解决是在 5）阶段通过发送 EP 完成的 在 5）阶段中，假设 4）阶段以的 0.5 概率发送了 EP，而同时 5）阶段以 0.5 的概率未发送 此时，5）阶段将接收到 4）阶段发送的 EP，从而知道有非孤立死锁存在。这种情况下，5）阶段将放弃该时隙的使用权，将自己的节点状态标为接收状态，在这个时隙里它将接收而不发送 跳频预留多址访问协议跳频预留多址访问协议 HRMA 使用一个公共跳频序列，即使用简单的半双工慢速跳频电台来实现而不使用载波帧听 该协议允许一对节点预留一个跳频频率，以便该节点对能够在该预留频率上无干扰地进行通信。其能够保证在出现隐含终端干扰的情况下不会在源节点或者接收节点上发生数据分组或者应答分组与任何其他分组的碰撞 同时，HRMA 协议允许多个系统合并在一起，也允许节点加入已有的系统 【混合协议】混合协议是竞争协议和分配协议的混合，常见的协议有：HTDMA 协议、ADAPT 协议、ABROAD 协议、AGENT 协议、Meta-协议等，这里仅简单介绍 HTDMA 协议 混合时分多址访问协议混合时分多址访问协议 HTDMA 是一种动态、按需分配的媒介访问控制协议，其是竞争协议的 CSMA/CA 协议、RTS/CTS 协议和分配协议的 TDMA 协议的混合协议 该协议将时间划分成若干个时隙，其中第一个时隙为公共竞争时隙，全网在该时隙内竞争其他时隙的使用权，竞争采用 CSMA 和 RTS/CTS 方式相结合进行，竞争时隙结束后各个节点按照竞争的结果在各个时隙进行发送、接收或者相应的退避 在通信结束之后，通信双方将占用时隙进行释放","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"Matlab——IO操作","slug":"22.Matlab-IO操作","date":"2020-05-01T10:06:00.000Z","updated":"2021-08-24T01:43:23.902Z","comments":true,"path":"matlab/8dc8eb69.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/8dc8eb69.html","excerpt":"【IO 操作】IO 操作在不同层次有不同的概念和单位，每一次 IO 就是一次请求，对于磁盘来说，一个 IO 就是读或者写磁盘的某个或者某段扇区，读写完了，这个 IO 也就结束了 在 matlab 中，IO 操作即将数据从磁盘读入 matlab 的工作区，或将数据从 matlab 的工作区写入磁盘","text":"【IO 操作】IO 操作在不同层次有不同的概念和单位，每一次 IO 就是一次请求，对于磁盘来说，一个 IO 就是读或者写磁盘的某个或者某段扇区，读写完了，这个 IO 也就结束了 在 matlab 中，IO 操作即将数据从磁盘读入 matlab 的工作区，或将数据从 matlab 的工作区写入磁盘 【文件打开与关闭】 FID=fopen(fileName,permission)：根据 fileName 所指定的路径，依照 permission 所指定的模式打开文件，返回文件标识符 FID status=fclose(FID)：关闭 FID 所映射的文件，并返回状态码 status 说明： FID：文件标识符，在系统(无论何种系统均有 FID，类似 PID)中用于唯一标识文件，需要注意的是，如果 FID 不代表打开文件或其等于 0(标准输入)、1(标准输出)、2(标准错误)，关闭文件时会引发错误 fileName：可以是相对路径，也可以是绝对路径 permission 的模式如下表： 标识 模式 标识 模式 ‘r’ 读文件，要求文件必须存在 ‘r+’ 读写文件，要求文件必须存在 ‘w’ 写文件，若文件已存在会将内容覆盖，若文件不存在会创建文件 ‘w+’ 读写文件，若文件已存在会将内容覆盖，若文件不存在会创建文件 ‘a’ 写文件，若文件已存在会将内容追加，若文件不存在会创建文件 ‘a+’ 读写文件，若文件已存在会将内容追加，若文件不存在会创建文件 ‘b’ 表明打开文件为二进制文件，一般与上述 6 种标识混合使用，例如：’rb’、’ab+’ status：关闭文件的状态码，关闭成功返回 0，关闭失败返回 1 1234&gt;&gt; fid=fopen('test.txt','r')fid = 4&gt;&gt; status=fclose(fid)status = 0 【fread 与 fwrite】fread() 与 fwrite() 函数对二进制文件进行读写 a = fread(FID,num,precision)：根据 FID 读取文件信息，用 precision 指定的数据格式，用 num 指定读取个数 num=fwrite(FID,data,precision)：根据 FID 写入数据 data，用 precision 指定的数据格式，返回写入数据个数 注： 关于 precision：其数据格式为 int32、float 等，若未指定，默认为 uint8 关于 num：在 fread()中，若 num 未指定，默认读取所有元素 无法利用 fread 和 fwrite 同时读写 由于 fread 和 fwrite 涉及到二进制编码问题，因此很少使用 1234567891011121314151617181920&gt;&gt; fid=fopen('test.bin','r+');&gt;&gt; a=magic(3);&gt;&gt; num=fwrite(fid,a,'int32')num = 9&gt;&gt; fclose(fid);&gt;&gt; fid=fopen('test.bin','r+');&gt;&gt; data=fread(fid,'int32');&gt;&gt; fclose(fid);&gt;&gt; datadata = 8 3 4 1 5 9 6 7 2 【fscanf 与 fprintf】fscanf() 与 fprintf() 函数对文本文件进行读写 data=fscanf(FID,formatSpec,num)：根据 FID 读取文件信息，用 formatSpec 指定的数据格式，num 表示读取个数，inf 表示读取到末尾(默认) num=fprintf(FID,formatSpec,data)：根据 FID 写入文件信息，用 formatSpec 指定的数据格式 注：每次读写完数据后，指针句柄会指向接下来要读数据的位置 123456789101112&gt;&gt; fid=fopen('test.txt','r+');&gt;&gt; a=magic(3);&gt;&gt; num=fprintf(fid,'%d %d %d\\n',a);&gt;&gt; fclose(fid);&gt;&gt; fid=fopen('test.txt','r+');&gt;&gt; data=fscanf(fid,'%d %d %d\\n',[3,inf])data = 8 1 6 3 5 7 4 9 2&gt;&gt; fclose(fid); 【importdata 与 load】importdata() 与 load() 用于将文件加载到工作区，一般来说，对于文本数据(.txt)，利用 importdata() 加载，对于 matlab 标准数据(.mat)，利用 load() 加载 a=importdata(fileName,delimiter,num)：加载 fileName 指定的文件，delimiter 为分隔符，num 为跳过的标题行数 load(fileName)：将 mat 文件中的变量加载到工作区 注：可以利用 whos -file fileName.mat 来查看 mat 文件中的内容，使用该命令时不需将文件利用 load 载入，只要 mat 文件处于检测目录中即可 123456789101112131415&gt;&gt; importdata('test.txt',' ')ans = data: [3x3 double] textdata: &#123;'dwd' 'qwq' 'qaq'&#125; colheaders: &#123;'dwd' 'qwq' 'qaq'&#125;&gt;&gt; importdata('test.txt',' ',2)ans = data: [2x3 double] textdata: &#123;2x3 cell&#125; colheaders: &#123;'8' '3' '4'&#125; &gt;&gt; whos -file bird_small.mat Name Size Bytes Class Attributes A 128x128x3 393216 double 【textscan 与 textread】matlab 中，一般利用 textscan() 或 textread() 来读取格式化文本文件 a=textscan(FID,formatSpec)：按照 formatSpec 格式读取 FID 所标识的文件，按列返回到元胞数组 a=textscan(FID,formatSpec,&#39;headerlines&#39;,num)：按照 formatSpec 格式读取 FID 所标识的文件，读取过程中跳过第 num 行，按列返回到元胞数组 a=textscan(FID,formatSpec,n)：按照 formatSpec 格式读取 n 次 FID 所标识的文件，按列返回到元胞数组 12345678910111213141516171819202122232425262728293031&gt;&gt; fid=fopen('test.txt');&gt;&gt; a=textscan(fid,'%s %s');&gt;&gt; fclose(fid)&gt;&gt; fid=fopen('test.txt');&gt;&gt; b=textscan(fid,'%d %f','headerlines',1);&gt;&gt; fclose(fid)&gt;&gt; fileId=fopen('test.txt');&gt;&gt; c=textscan(fid,'%d %d',1,'headerlines',1);&gt;&gt; fclose(fid)&gt;&gt; a&#123;1&#125;ans = 'asd' '1' '5'&gt;&gt; b&#123;1&#125;ans = 1 5&gt;&gt; b&#123;2&#125;ans = 3.4000 3.5000&gt;&gt; c&#123;1&#125;ans = 1&gt;&gt; c&#123;2&#125;ans = 3 [A,B,C...]=textread(filename,formatSpec)：按照 formatSpec 格式读取 filename 所标识的文件，按列返回到向量 [A,B,C...]=textread(filename,formatSpec,&#39;headerlines&#39;,num)：按照 formatSpec 格式读取 filename 所标识的文件，读取过程中跳过第 num 行，按列返回到向量 [A,B,C...]=textread(filename,formatSpec,n)：按照 formatSpec 格式读取 n 次 filename 所标识的文件，按列返回到向量 1234567891011&gt;&gt; [a,b]=textread('test.txt','%s %s');&gt;&gt; aa = 'asd' '1' '5'&gt;&gt; bb = 'qwe' '3.4' '3.5' 注： 对于 a=textscan(FID,formatSpec,n) 和 [A,B,C...]=textread(filename,formatSpec,n)，其一般用于每 n 行格式相同的数据 textscan() 将多组数据读到一个元胞矩阵中；textread() 将数据分别读取到不同的向量中 textscan() 使用前要先 fopen()，完成后要 fclose()；textread() 不需 fopen() 与 fclose()，适用于格式统一的 txt 的一次性大批量读取 textscan() 每次读完数据后，指针句柄会指向接下来要读数据的位置；textread() 每次读完数据后，指针句柄会返回文件头 不推荐使用 textread() 【xlsread 与 csvread】xlsread 用于读取 xls 文件 a=xlsread(fileName)：读取 xls 文件中的所有单元格的数据 a=xlsread(fileName,-1)：读取 xls 文件中的单元格的数据，用户可以利用鼠标来选定范围。执行后，会后台打开 xls 文件并弹窗，在 xls 文件中用鼠标选定单元格后，点击弹窗的确认即可 a=xlsread(fileName,sheet)：读取 xls 文件中所在的 sheet，例如：’sheet1’ a=xlsread(fileName,range)：读取 xls 文件中的单元格范围，例如：’A1:B2’ a=xlsread(fileName,sheet,range)：读取 xls 文件中所在的 sheet 与 范围 csvread 用于读取 csv 文件 a=csvread(fileName)：读取 csv 文件中的所有数据 a=csvread(fileName,R,C)：从 csv 文件中的行偏移 R 和列偏移 C 开始读取数据 a=csvread(fileName,R1,C1,R2,C2)：读取从 csv 文件中的行偏移 R1、列偏移 C1 和 行偏移 R2、列偏移 C2 范围内的数据 注：当需要写 xls 文件或写 csv 文件时，利用 xlswrite() 和 csvwrite() 即可，使用方法与上述基本相同 【dlmread】dlmread() 用于将 ASCII 分隔的数值数据文件读取到矩阵中，一般用于读取 tsv 文件 dlmread(fileName)：将文件中重复的空白视为分隔符进行读取 dlmread(fileName,&#39;delimiter&#39;)：使用指定的分隔符 delimiter 读取数据，同时会将重复的分隔符视为单独的分隔符 dlmread(fileName,delimiter,R,C)：使用指定的分隔符 delimiter 从行偏移 R 和列偏移 C 开始读取数据读取数据 dlmread(fileName,delimiter,R1,C1,R2,C2)：使用指定的分隔符 delimiter 读取行偏移 R1、列偏移 C1 和 行偏移 R2、列偏移 C2 范围内的数据 注：当需要写 ASCII 分隔的文件时，利用 dlmwrite() ，使用方法与上述基本相同 【文件读写句柄控制】在大多数 I/O 函数中，读写完毕后，指针都会指向接下来要读文件的位置，这就造成了无法连续的读写数据，因此可以利用以下几个函数来控制句柄，从而实现自主控制文件读写 st=feof(FID)：如果文件设置了文件结束指示符且已到达，则返回 1；如果未设置文件标识符，则返回 0 frewind(FID)：将文件指针位置重定向至开头 pos=ftell(FID)：返回文件指针位置，以字节为单位从头开始计算，若返回 -1 表示查询失败 status=fseek(FID,offset,origin)：重新定位文件指针位置，定位成功返回 1，定位失败返回 -1 origin &gt;= 0：在 origin 后移动指针 offset 个字节 origin &lt;0：在 origin 前移动指针 offset 个字节 注： 关于文件结束符 EOF：End of File，是程序中判断 I/O 结尾的标志，其值为 1 origin 常见取值解释为： bof 或 -1：文件开头 cof 或 0：文件当前位置 eof 或 1：文件结尾 123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt; fid=fopen('test.txt','r+');&gt;&gt; data=fscanf(fid,'%d %d %d\\n',[3,inf])data = 8 1 6 3 5 7 4 9 2&gt;&gt; data=fscanf(fid,'%d %d %d\\n',[3,inf])data = []&gt;&gt; feof(fid)ans = 1&gt;&gt; frewind(fid)&gt;&gt; data=fscanf(fid,'%d %d %d\\n',[3,inf])data = 8 1 6 3 5 7 4 9 2&gt;&gt; ftell(fid)ans = 18&gt;&gt; frewind(fid)&gt;&gt; ftell(fid)ans = 0&gt;&gt; data=fscanf(fid,'%d %d %d\\n',[1,3])data = 8 3 4&gt;&gt; ftell(fid)ans = 6&gt;&gt; fclose(fid);&gt;&gt; fseek(fid,6,0);&gt;&gt; data=fscanf(fid,'%d %d %d\\n')data = 6 7 2","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——概率统计","slug":"21.Matlab-概率统计","date":"2020-04-30T07:40:00.000Z","updated":"2021-08-24T01:43:10.649Z","comments":true,"path":"matlab/480c817a.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/480c817a.html","excerpt":"【随机变量的产生】matlab 中产生随机数的函数有很多，除了 特殊矩阵 中提到的用于生成测试矩阵的函数外，还有一些可生成常见分布的随机数产生函数 对于常用的二项分布的随机数据的产生，有：","text":"【随机变量的产生】matlab 中产生随机数的函数有很多，除了 特殊矩阵 中提到的用于生成测试矩阵的函数外，还有一些可生成常见分布的随机数产生函数 对于常用的二项分布的随机数据的产生，有： binornd(N,P)：产生服从 N、P 的二项分布随机数 binornd(N,P,m,n)：产生服从 N、P 的二项分布随机数 R，m、n 用于指定 R 的行数和列数 binornd(N,P,[m,n])：产生服从 N、P 的二项分布随机数 R，m、n 用于指定 R 的行数和列数 123456789101112&gt;&gt; n=10:10:50;&gt;&gt; p=1./n;&gt;&gt; binornd(n,p)ans = 3 2 2 0 2&gt;&gt; binornd([n;n],[p;p])ans = 1 1 0 0 0 0 1 0 1 3&gt;&gt; binornd(10,100,2,5)ans = NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 除二项分布外，常见随机数产生函数表如下，他们的用法均于上述的二项分布的随机数据的产生相同： 函数 说明 binornd 产生服从 N、P 的二项分布随机数 normrnd 产生服从 mu、sigma 的正态分布随机数 unifrnd 产生 [a,b] 上均匀分布且连续的随机数 unidrnd 产生均匀分布且离散的随机数 exprnd 产生服从 Lambda 的指数分布随机数 poissrnd 产生服从 Lambda 的泊松分布随机数 chi2rnd 产生自由度为 n 的卡方分布随机数 trnd 产生自由度为 n 的 t 分布随机数 frnd 产生第一自由度为 N1，第二自由度为 N2 的 F 分布随机数 gamrnd 产生参数为 a、b 的伽马分布随机数 betarnd 产生参数为 a、b 的贝塔分布随机数 lognrnd 产生参数为 mu、sigma 的对数正态分布随机数 nbinrnd 产生参数为 r、p 的负二项式分布随机数 ncfrnd 产生参数为 n1、n2、delta 的非中心 F 分布随机数 nctrnd 产生参数为 n、delta 的非中心 t 分布随机数 ncx2rnd 产生参数为 n、delta 的非中心 t 卡方分布随机数 raylrnd 产生参数为 b 的瑞利分布随机数 weibrnd 产生参数为 a、b 的韦伯分布随机数 geornd 产生参数为 p 的几何分布随机数 hygernd 产生参数为 M、K、N 的超几何分布随机数 【概率密度】通用函数概率密度 pdf(name,X,A)：返回 x=X 处，参数为 A 的概率密度值 pdf(name,X,A,B)：返回 x=X 处，参数为 A、B 的概率密度值 pdf(name,X,A,B,C)：返回 x=X 处，参数为 A、B、C 的概率密度值 注： 关于参数 A、B、C：根据不同的分布，参数个数不同 关于 name：用于指定是何种分布，常见取值见下表 取值 说明 取值 说明 beta beta分布 bino 二项分布 chi2 卡方分布 exp 指数分布 f F分布 gam 伽马分布 geo 几何分布 hyge 超几何分布 logn 对数分布 norm 正态分布 poiss 泊松分布 rayl 瑞利分布 t t分布 unif 均匀分布 unid 离散均匀分布 123&gt;&gt; pdf('normal',-5:5,0,1)ans = 0.0000 0.0001 0.0044 0.0540 0.2420 0.3989 0.2420 0.0540 0.0044 0.0001 0.0000 此外，通用函数计算概率密度可以推广到任意函数、数据的情况 [f,Xi]=ksdensity(x)：对于待统计的向量 x，计算概率密度的点 Xi 与概率密度 f f=ksdensity(x,Xi)：对于待统计的向量 x 和概率密度的点 Xi，计算概率密度 f 123456&gt;&gt; x=randn(10000,1);&gt;&gt; fx=sin(x*pi);&gt;&gt; [f,Xi]=ksdensity(fx);&gt;&gt; figure&gt;&gt; plot(Xi,f)&gt;&gt; axis tight 专用函数概率密度专用函数概率密度，是 matlab 中封装好的用于计算特定分布的概率密度的函数 以计算二项分布的概率密度函数为例，其余的函数调用方法与之类似： binopdf(X,n,p)：计算实验次数为 n，每次实验中事件发生概率为 p 在 x=X 处的概率密度值 专用函数概率密度函数表如下： 调用格式 说明 unifpdf(x,a,b) 计算[a,b]上连续概率密度在X=x处的概率密度函数值 unidpdf(x,n) 计算离散概率密度函数值 exppdf(x,lambda) 计算参数为 lambda 的指数分布概率密度函数值 normpdf(x,mu,sigma) 计算参数为 mu、simga 的正态分布概率密度函数值 chi2pdf(x,n) 计算自由度为 n 的卡方分布概率密度函数值 tpdf(x,n) 计算自由度为 n 的 t 分布概率密度函数值 fpdf(x,n1,n2) 计算第一自由度为 n1，第二自由度为 n2 的 F 分布概率密度函数值 gampdf(x,a,b) 计算参数为 a、b 的伽马分布概率密度函数值 betapdf(x,a,b) 计算参数为 a、b 的贝塔分布概率密度函数值 lognpdf(x,mu,sigma) 计算参数为 mu、sigma 的对数正态分布概率密度函数值 ralypdf(x,b) 计算参数为 b 的瑞利分布概率密度函数值 geopdf(x,p) 计算参数为 p 的几何分布概率密度函数值 hygepdf(x,m,k,n) 计算参数为 p 的超几何分布概率密度函数值 poisspdf(x,lambda) 计算参数为 lambda 的泊松分布概率密度函数值 实例：正态分布函数概率密度的计算 1234&gt;&gt; mu=[0:0.1:5];&gt;&gt; [y,i]=max(normpdf(1.5,mu,1));&gt;&gt; mle=mu(i)mle = 1.5000 【累计概率分布】通用函数累计概率使用 cdf() 可以计算随机变量 $x\\leq X$ 的概率之和 cdf(name,X,A)：返回 x=X 处，参数为 A 的累计概率 cdf(name,X,A,B)：返回 x=X 处，参数为 A、B 的累计概率 cdf(name,X,A,B,C)：返回 x=X 处，参数为 A、B、C 的累计概率 注： 关于参数 A、B、C：根据不同的分布，参数个数不同 关于 name：用于指定是何种分布，常见取值见上表 专用函数累计概率专用函数累计概率的写法，与上表写法基本相同，不同的是将 pdf 换为了 cdf 例如：poisscdf(x,lambda) 由于用法相同，只是返回结果不同，故不再赘述 【统计特征】 mean(A)：求 A 的平均值 median(A)：求 A 的中位数 nanmedian(A)：忽略 NaN 求 A 的中位数 geomean(A)：求 A 的几何平均值 harmmean(A)：求 A 的调和平均值 var(A)：求 A 的方差 std(A)：求 A 的标准差 skewness(A)：求 A 的三阶统计量斜度 cov(A,B)：求 A 和 B 的协方差 corrcoef(A,B)：求 A 和 B 的皮尔逊相关系数 【统计作图】正整数频率表tabulate(A)：求 A 的正整数频率表 123456&gt;&gt; a=ceil(randn(1,5));&gt;&gt; tabulate(a) Value Count Percent -2 1 20.00% 1 3 60.00% 2 1 20.00% 累积分布函数图形cdfplot(a)：画出向量 a 的累积分布图形 123&gt;&gt; x=0:0.05:5;&gt;&gt; figure&gt;&gt; cdfplot(x) 最小二乘拟合曲线h=lsline：画出最小二乘拟合曲线 1234567891011121314151617&gt;&gt; x=1:10;&gt;&gt; y=x+randn(1,10);&gt;&gt; figure&gt;&gt; scatter(x,y)&gt;&gt; lsline&gt;&gt; h=lslineh = Line (lsline) (具有属性): Color: [0.7500 0.7500 0.7500] LineStyle: '-' LineWidth: 0.5000 Marker: 'none' MarkerSize: 6 MarkerFaceColor: 'none' XData: [1 10] YData: [1.2620 11.1478] ZData: [1x0 double] 正态分布概率图形h=normplot(X)：绘制 X 的正态分布概率图形，若 X 为向量，则直接显示；若 X 为矩阵，则显示每一列的图形 1234567&gt;&gt; x=1:10;&gt;&gt; y=x+randn(1,10);&gt;&gt; subplot(2,1,1)&gt;&gt; normplot(y)&gt;&gt; subplot(2,1,2)&gt;&gt; x=magic(3);&gt;&gt; normplot(x) 箱线图 boxplot(X)：绘制 X 的箱线图 boxplot(X,Y)：绘制变量为 X，附加群为 Y 的箱线图 123456&gt;&gt; x=1:10;&gt;&gt; subplot(2,1,1)&gt;&gt; boxplot(x)&gt;&gt; subplot(2,1,2)&gt;&gt; boxplot(x,1) 参考线 refline(k,b)：绘制斜率为 k，截距为 b 的参考直线 refcurve(p)：绘制参数为多项式系数的参考曲线 123456789&gt;&gt; subplot(2,1,1)&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y)&gt;&gt; refline(1,1)&gt;&gt; subplot(2,1,2)&gt;&gt; plot(x,y)&gt;&gt; refcurve([3 2 1 0]) 样本概率图形 p=capaplot(X,[a,b])：绘制参数为 X，范围为 [a,b] 的样本概率图形，并返回在范围内的概率 123&gt;&gt; X=normrnd(1,0.05,300,1);&gt;&gt; capaplot(X,[0.5,1.5])ans = 1 正态拟合曲线图 histfit(X)：画出 X 的正态拟合曲线图 histfit(X,num)：画出 X 的正态拟合曲线图，num 指定柱状图个数 123456&gt;&gt; X=normrnd(1,0.05,300,1);&gt;&gt; subplot(2,1,1)&gt;&gt; histfit(X)&gt;&gt; subplot(2,1,2)&gt;&gt; histfit(X,5)","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"关于孤独","slug":"ego/04.关于孤独","date":"2020-04-28T14:25:00.000Z","updated":"2021-09-22T08:08:41.520Z","comments":true,"path":"essay/ego/97dca775.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/ego/97dca775.html","excerpt":"我常常独来独往，别人都说我孤僻又难以相处。 那么，人到底会思考些什么？金星合昴刚刚过去，下一次要等八年后了，最近窗外的梧桐开了，淡淡香气总会溢满房间，夜晚悬铃隙间的春季大三角也不再那么清晰可见，只有长庚与残月依然立在西方，谷雨刚过温度渐渐回暖，后街上的槐树又冒起了花骨朵，算算时间也该立夏了，届时又会槐花满地，最近刚刚读完《随园食单》，赶在春末蒸一屉艾草青团应当才算不辜负这个季节。 你看，我觉得孤独没什么不好，他让我有足够的时间去思考自己喜欢的事。","text":"我常常独来独往，别人都说我孤僻又难以相处。 那么，人到底会思考些什么？金星合昴刚刚过去，下一次要等八年后了，最近窗外的梧桐开了，淡淡香气总会溢满房间，夜晚悬铃隙间的春季大三角也不再那么清晰可见，只有长庚与残月依然立在西方，谷雨刚过温度渐渐回暖，后街上的槐树又冒起了花骨朵，算算时间也该立夏了，届时又会槐花满地，最近刚刚读完《随园食单》，赶在春末蒸一屉艾草青团应当才算不辜负这个季节。 你看，我觉得孤独没什么不好，他让我有足够的时间去思考自己喜欢的事。 “他是我一个随时等待着被别人替代的朋友。但他从不会分享我的快乐，因为每当我开心的时候，就感受不到他的存在。”","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Ego","slug":"essay/ego","permalink":"https://alex-mcavoy.github.io/categories/essay/ego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Ego","slug":"ego","permalink":"https://alex-mcavoy.github.io/tags/ego/"}],"author":"Alex_McAvoy"},{"title":"Matlab——数据可视化","slug":"20.Matlab-数据可视化","date":"2020-04-28T10:37:00.000Z","updated":"2021-08-24T01:42:04.652Z","comments":true,"path":"matlab/1a003c5a.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/1a003c5a.html","excerpt":"【图形绘制流程】 数据准备：产生采样自变量，计算相应函数值向量 选定图形窗口与子图 调用绘图函数 设置坐标轴、刻度、网格 设置线性、标记类型、粗细 添加图名、坐标名、图例 导出 【画布与子图】","text":"【图形绘制流程】 数据准备：产生采样自变量，计算相应函数值向量 选定图形窗口与子图 调用绘图函数 设置坐标轴、刻度、网格 设置线性、标记类型、粗细 添加图名、坐标名、图例 导出 【画布与子图】子图matlab 中，画布默认从 figure1 开始，导出的图形依次为：figure.1、figure.2… 因此一般画图时，直接利用 figure 新建画布即可 12&gt;&gt; figure %新建画布&gt;&gt; ... 若绘制了多个画布，想在不同的画布间进行切换时，利用 figure(k) 即可完成画布切换 1234&gt;&gt; figure(2) % 切换到画布2&gt;&gt; ...&gt;&gt; figure(1) % 切换到画布1&gt;&gt; ... 子图matlab 允许在同一画布下绘制多幅相互独立的子图，利用 subplot() 命令即可设置子图大小并切换绘制域 调用格式：subplot(n,m,k) 将画布分为 nm 大小，选中第 k 个*(行优先排序)作为当前绘制域 在调用 subplot() 后，所有的操作均在当前绘制域内完成，若想切换绘制域，再次调用 subplot() 即可 需要说明的是，在使用 subplot() 后，若想再绘制充满整个图形窗的图形时，利用 clf 命令进行清空即可 123456&gt;&gt; figure&gt;&gt; subplot(2,1,1) % 在第1个子图进行绘制&gt;&gt; ...&gt;&gt; subplot(2,1,2) % 在第2个子图进行绘制&gt;&gt; ...&gt;&gt; subplot(2,1,1) % 在第1个子图进行绘制 实例： 12345678&gt;&gt; figure&gt;&gt; subplot(2,2,1)&gt;&gt; plot(1:5)&gt;&gt; subplot(2,2,4)&gt;&gt; plot(2:3)&gt;&gt; subplot(2,2,1)&gt;&gt; plot(log(1:2))&gt;&gt; plot(log(1:10)) 【二维图形】散点图与曲线图基本使用利用 plot() 函数即可完成散点图和连线图的绘制： plot(x,y)：以 x 为横坐标，y 为纵坐标，有序绘制曲线 1234&gt;&gt; figure&gt;&gt; x=0:0.05:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y) plot(x,y,&#39;o&#39;)：以 x 为横坐标，y 为纵坐标，有序绘制散点图 1234&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y) plot(y)：以 1:n 为横坐标，y 为纵坐标，有序绘制曲线，其中 n 是数组 y 的长度 123&gt;&gt; figure&gt;&gt; y=0:0.05:5;&gt;&gt; plot(y) plot(z)：以横轴为实轴，纵轴为虚轴，在复平面上绘制有序集合 123&gt;&gt; figure&gt;&gt; z=[1+2i,3+4i,5+55i,45+4i];&gt;&gt; plot(z,'o','MarkerFaceColor','b') 线型、标记、颜色用法：plot(x,y,&#39;str&#39;)： 颜色：在绘制多个图形时，matlab 会自动分配颜色，但如果对分配的颜色不满意，可以自己指定 str 颜色 r 红色 m 粉红 g 绿色 c 青色 y 黄色 k 黑色 线型 str 线型 ‘-‘ 实线 ‘—‘ 虚线 ‘:’ 点线 ‘-.’ 点划线 标记点 str 标记 str 标记 . 点 s 正方形 ^ 上三角 &gt; 右三角 v 下三角 &lt; 左三角 + +号 p 五角星 * 星号 h 六角星 d 菱形 o 空心圆 注：选项可以连在一起用，如:-.g表示绘制绿色的点划线，g+ 表示用绿色的 + 号绘制曲线 例如：plot(x,y,&#39;+-r&#39;)：将散点图的每个点的大小指定为 n 1234&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y,'+-r') 线型粗细plot(x,y,&#39;o&#39;,&#39;MarkerSize&#39;,n)：将散点图的每个点的大小指定为 n 1234&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y,'o','MarkerSize',15) plot(x,y,&#39;LineSize&#39;,n)：将曲线图的线的大小指定为 n 1234&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y,'LineSize',15) 散点曲线图的颜色当绘制散点与曲线的叠加时，有时希望将空心圆的散点填充，并使得两种颜色不同 例如：plot(x,y,&#39;-ok&#39;,&#39;MarkerFaceColor&#39;,&#39;r&#39;) 1234&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y,'-ok','MarkerFaceColor','r') 栅格有时想要对当前图形开启栅格，可以利用 grid 命令 grid on：开启栅格 grid off：关闭栅格 grid：在开启/关闭间切换 12345&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; plot(x,y,'+-r')&gt;&gt; grid on 图形叠绘当有时需要在一张图形上画多个图形时，可利用 hold 命令来开启/关闭图形叠绘 hold on：开启图形叠绘 hold off：关闭图形叠绘 hold：在图形叠绘开启/关闭中切换 123456&gt;&gt; figure&gt;&gt; x=0:0.5:5;&gt;&gt; y=log(x);&gt;&gt; hold on&gt;&gt; plot(x,y)&gt;&gt; plot(x,2*y) 3.2 散点图scatter(x,y)：以 x、y 为坐标绘制散点图 scatter(x,y,&#39;fill&#39;)：以 x、y 为坐标绘制散点图，并将散点填充 1234567&gt;&gt; figure&gt;&gt; x=rand(1,5);&gt;&gt; y=rand(1,5);&gt;&gt; subplot(1,2,1)&gt;&gt; scatter(x,y)&gt;&gt; subplot(1,2,2)&gt;&gt; scatter(x,y,'fill') 【柱状图】matlab 中利用 bar() 来绘制柱状图，用垂直条形以表示向量或矩阵中的值 bar(x)：x 为向量时，为 x 中每一个元素画出柱状图；x 为矩阵时，将其分解为几个行向量，来画出柱状图 bar(x,y)：以严格单增的 x 向量为横坐标，将矩阵 y 分解成行向量，在指定的横坐标处画出，要求 x 的长度与 y 的行数相同 bar(x,&#39;stacked&#39;)：以累计式绘出柱状图图 bar(x,&#39;grouped&#39;)：以分组式绘出柱状图 123456789101112131415161718192021&gt;&gt; figure&gt;&gt; subplot(2,3,1)&gt;&gt; x=rand(1,5);&gt;&gt; bar(x)&gt;&gt; subplot(2,3,2)&gt;&gt; x=rand(3,5);&gt;&gt; bar(x)&gt;&gt; subplot(2,3,3)&gt;&gt; x=0:2;&gt;&gt; y=rand(3,5);&gt;&gt; bar(x,y)&gt;&gt; subplot(2,3,4)&gt;&gt; x=rand(3,5);&gt;&gt; bar(x,'stacked')&gt;&gt; subplot(2,3,5)&gt;&gt; x=rand(3,5);&gt;&gt; bar(x,'grouped') 饼图matlab 中利用 pie() 来绘制饼图，pie3() 来绘制 3D 饼图 pie(x)：绘制参数为 x 的饼图 pie(x,pos)：绘制参数为 x 的饼图，pos 为与 x 同维的矩阵，若其中有非 0 元素，则对应的扇区向外移一些 pie3(x)：绘制参数为 x 的 3D 饼图 pie3(x,pos)：绘制参数为 x 的 3D 饼图，pos 为与 x 同维的矩阵，若其中有非 0 元素，则对应的扇区向外移一些 123456789101112131415161718&gt;&gt; figure&gt;&gt; subplot(2,2,1)&gt;&gt; x=[1,2,3;4,5,6];&gt;&gt; pie(x)&gt;&gt; subplot(2,2,2)&gt;&gt; x=[1,2,3,4,5,6];&gt;&gt; pos=[1,0,1,0,0,0];&gt;&gt; pie(x,pos)&gt;&gt; subplot(2,2,3)&gt;&gt; x=[1,2,3;4,5,6];&gt;&gt; pie3(x)&gt;&gt; subplot(2,2,4)&gt;&gt; x=[1,2,3,4,5,6];&gt;&gt; pos=[1,0,1,0,0,0];&gt;&gt; pie3(x,pos) 频数直方图matlab 中利用 hist() 绘制二维条形直方图 hist(y)：将 y 中元素放在等距的 10 个条形中，且返回每个条形中的元素个数，当 y 为矩阵时，按列进行分解处理 hist(y,x)：以向量 x 为横轴，将 y 中元素放到 length(x) 个由 x 中元素指定的位置为中心的条形中 1234567891011121314151617&gt;&gt; subplot(2,2,1)&gt;&gt; y=randn(1,5);&gt;&gt; hist(y)&gt;&gt; subplot(2,2,2)&gt;&gt; y=randn(3,5);&gt;&gt; hist(y)&gt;&gt; subplot(2,2,3)&gt;&gt; x=-2:2;&gt;&gt; y=randn(1,500);&gt;&gt; hist(y,x)&gt;&gt; subplot(2,2,4)&gt;&gt; x=-2:2;&gt;&gt; y=randn(3,500);&gt;&gt; hist(y,x) 【三维图形】曲线图在二维平面上，绘制曲线利用 plot() 函数，而在三维空间中，绘制曲线利用 plot3() 函数，该函数与 plot() 用法类似 plot3(X,Y,Z) X、Y、Z 为同维向量时，绘制以 X、Y、Z 为 x、y、z 坐标的三维曲线 X、Y、Z 为同维矩阵时，绘制以 X、Y、Z 的对应列元素为 x、y、z 坐标的三维曲线 plot3(X1,Y1,Z1,X2,Y2,Z2)：绘制以 X1、Y1、Z1 和 X2、Y2、Z2 为 x、y、z 坐标的三维曲线 注：关于线型、标记、颜色等，见 3.二维图形 123456789101112131415&gt;&gt; figure&gt;&gt; subplot(2,2,1)&gt;&gt; X=0:.1*pi:2*pi;&gt;&gt; Y=cos(X);&gt;&gt; Z=sin(X);&gt;&gt; plot3(X,Y,Z)&gt;&gt; subplot(2,2,2)&gt;&gt; X=[0:.1*pi:2*pi;0:.1*pi:2*pi];&gt;&gt; Y=cos(X);&gt;&gt; Z=sin(X);&gt;&gt; plot3(X,Y,Z,'o')&gt;&gt; subplot(2,2,3)&gt;&gt; plot3(0,0,0,4,5,6,'o') 网格图对于函数 $z=f(x,y)$ 其三维网格图绘制过程如下： 确定自变量 x、y 的取值范围：x=x1:dx:x2,y=y1:dy:y2 构成 xoy 平面上的自变量采样格点矩阵： 利用格点矩阵原理生成：X=ones(size(y))*x,Y=y*ones(size(x)) 利用 meshgrid() 函数生成：[X,Y]=meshgrid(x,y) 计算自变量采样格点上的函数值 $Z=f(x,y)$ 利用 mesh() 函数绘图 mesh(X,Y,Z)：以向量 X、Y 和矩阵 Z 绘制网格图 mesh(Z)：以矩阵 Z 的列下标为 x 轴自变量，行下标为 y 轴自变量绘制网格图 注：关于线型、标记、颜色等，见 3.二维图形 1234567891011&gt;&gt; figure&gt;&gt; subplot(2,1,1)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; mesh(X,Y,Z)&gt;&gt; subplot(2,1,2)&gt;&gt; [x,y,z]=peaks(25);&gt;&gt; mesh(Z) 曲面图对于函数 $z=f(x,y)$ 其三维曲面图与上述 4.2 网格图的绘制 相似，唯一的不同在于，网格图的绘制利用的是 mesh() 函数，而曲面图的绘制利用的是 surf() 函数 surf(X,Y,Z)：以向量 X、Y 和矩阵 Z 绘制曲面图 surf(Z)：以矩阵 Z 的列下标为 x 轴自变量，行下标为 y 轴自变量绘制曲面图 1234567891011&gt;&gt; figure&gt;&gt; subplot(2,1,1)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; surf(X,Y,Z)&gt;&gt; subplot(2,1,2)&gt;&gt; [X,Y,Z]=peaks(25);&gt;&gt; surf(Z) 光照图在某些情况下，光照图能使图形表面差异更容易看到，其一般与曲面图组合使用 在 matlab 中，利用 camlight 等命令来设置光照 camlight left：设置光源在左侧 camlight rightt：设置光源在右侧 lighting phong：细化表面，使得光照效果更加平滑 在设置光照后，有时视角并不好，可以利用 view(a,b) 来改变视角，其中 a 代表方位角，b 代表仰角 12345678910111213141516171819&gt;&gt; figure&gt;&gt; subplot(2,1,1)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; surf(X,Y,Z,'FaceColor','red','EdgeColor','none')&gt;&gt; camlight left&gt;&gt; lighting phong&gt;&gt; subplot(2,1,2)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; surf(X,Y,Z,'FaceColor','red','EdgeColor','none')&gt;&gt; camlight left&gt;&gt; lighting phong&gt;&gt; view(2,50) 等值图等值图即等高线图，在 matlab 中利用 contour() 命令即可完成绘制： contour(X,Y,Z)：以向量 X、Y 和矩阵 Z 绘制等值图 contour(Z)：以矩阵 Z 的列下标为 x 轴自变量，行下标为 y 轴自变量绘制等值图 contour(X,Y,Z,n)：以向量 X、Y 和矩阵 Z 绘制等值图，n 为等值线条数 contour(Z,n)：以矩阵 Z 的列下标为 x 轴自变量，行下标为 y 轴自变量绘制等值图，n 为等值线条数 contour(Z,v)：以矩阵 Z 的列下标为 x 轴自变量，行下标为 y 轴自变量绘制等值图，v 为向量，向量长度为等值线条数，值为对应元素值 1234567891011121314151617181920212223242526272829&gt;&gt; figure&gt;&gt; subplot(2,2,1)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; contour(X,Y,Z)&gt;&gt; subplot(2,2,2)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; contour(X,Y,Z,50)&gt;&gt; subplot(2,2,3)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; v=[1,2,3,4,5,6,7,8,9,10];&gt;&gt; contour(Z,v)&gt;&gt; subplot(2,2,4)&gt;&gt; x=-10:0.1:10;&gt;&gt; y=-10:0.1:10;&gt;&gt; [X,Y]=meshgrid(x,y); &gt;&gt; Z=X.^2+Y.^2;&gt;&gt; contour(Z,50) 【四维图形】囿于人类的局限性，对于四维图形难以想象，但在 matlab 中，可以用颜色来代表第四维，从而绘制四维图形 用 mesh() 和 surf() 绘制的图形，未给出颜色参数的情况下，其是沿着 z 轴变化的，但由于 z 轴已经存在，其不能提供新的信息，因此考虑利用颜色来描绘不受 3 个轴影响的某些属性。 123456789&gt;&gt; figure&gt;&gt; subplot(2,1,1)&gt;&gt; [X,Y,Z]=peaks(25);&gt;&gt; surf(X,Y,Z,Z)&gt;&gt; subplot(2,1,2)&gt;&gt; [X,Y,Z]=peaks(25);&gt;&gt; R=X.^2+Y.^2;&gt;&gt; surf(X,Y,Z,R) 【文字说明】无论何种图形，均需要文字说明，图形窗口中常见的文字说明有：标题、坐标轴名、图例 标题与坐标轴名 title(str,&#39;FontSize&#39;,num)：图片标题设为 str，字体大小为 num，默认为 11 xlabel(str,&#39;FontSize&#39;,num)：x 坐标轴名设为 str，字体大小为 num，默认为 11 ylabel(str,&#39;FontSize&#39;,num)：y 坐标轴名设为 str，字体大小为 num，默认为 11 zlabel(str,&#39;FontSize&#39;,num)：z 坐标轴名设为 str，字体大小为 num，默认为 11 1234567&gt;&gt; figure&gt;&gt; [X,Y,Z]=peaks(25);&gt;&gt; surf(X,Y,Z)&gt;&gt; title('peak')&gt;&gt; xlabel('x')&gt;&gt; ylabel('y')&gt;&gt; zlabel('z','FontSize',20) 图例在 matlab 中，生成的图例利用 legend() 函数，其与绘制的图形一一对应，并且默认处于右上角位置 legend(str1,str2,...)：依次生成图例 str1、str2、…、strn legend(str1,str2,...,strn,&#39;Location&#39;,pos)：依次生成图例 str1、str2、…、strn，并将图例至于 pos 位置 legend off：关闭图例 关于 str 的说明：当需要在图例中输出下标、希腊字母等特殊符号时，利用 latex 语法即可 关于 pos 的说明： 参数字符串 含 义 参数字符串 含 义 North 放置在图形的最上端 NorthEast 放置在图形的右上角，默认位置 South 放置在图形的最下端 NorthWest 放置在图形的左上角 East 放置在图形的最右端 SouthEast 放置在图形的右下角 West 放置在图形的最左端 SouthWest 放置在图形的左下角 NorthOutside 放置在图形外的最上端 NorthEastOutside 放置在图形外的右上角 SouthOutsi 放置在图形外的最下端 NorthWestOutside 放置在图形外的左上角 EastOutside 放置在图形外的最右端 SouthEastOutside 放置在图形外的右下角 WestOutside 放置在图形外的最左端 SouthWestOutside 放置在图形外的左下角 12345678&gt;&gt; figure&gt;&gt; hold on&gt;&gt; x=0:0.5:5;&gt;&gt; y1=log(x);&gt;&gt; y2=sin(x);&gt;&gt; plot(x,y1)&gt;&gt; plot(x,y2)&gt;&gt; legend('y=log(x)','y=sin(x)','Location','NorthEastOutside') 【坐标轴】有时需要对坐标轴范围进行调整，可利用以下函数： xlim([a,b])：查看 x 轴的范围 ylim([a,b])：查看 y 轴的范围 zlim([a,b])：查看 z 轴的范围 set(gca,&#39;xtick&#39;,[a:step:b])：调整的 x 轴的刻度范围 set(gca,&#39;ytick&#39;,[a:step:b])：调整的 y 轴的刻度范围 set(gca,&#39;ztick&#39;,[a:step:b])：调整的 z 轴的刻度范围 axis auto：采取坐标轴默认设置 asis on：打开坐标轴标签 asis off：关闭坐标轴标签 注： 在设置刻度时，可以一并将坐标轴的范围改变：set(gca,&#39;xlim&#39;,[a,b],&#39;xtick&#39;,[a:step:b]) 对于柱状图来说，想改变其 x 轴下标，利用 set(gca,xtick&#39;,[a,b,c,...]) 即可 123456789&gt;&gt; figure&gt;&gt; hold on&gt;&gt; x=0:0.5:5;&gt;&gt; y1=log(x);&gt;&gt; y2=sin(x);&gt;&gt; plot(x,y1)&gt;&gt; plot(x,y2)&gt;&gt; ylim([-1,1.5])&gt;&gt; set(gca,'xtick',[0:0.5:5]) 【其他】鼠标交互matlab 中提供了允许鼠标与图形交互的指令：ginput、gtext、zoom 除了 ginput 只能用于二维图形外，其他两个适用于所有图形 在二维图形中，一般将 ginput 与 zoom 混合使用，以得到较为准确的数据 [x,y]=ginput(n)：用鼠标从二维图形中获得 n 个点的数据坐标。在该命令执行后，会将图像调到前台，光标变为十字，通过移动鼠标来定位，通过点击来获取数据，待取完 n 个点后，图形会自动切回后台 运行效果 运行结果 gtext(str)：用鼠标将字符串或元胞字符数组放置到图形中，作为文字说明。在该命令执行后，会将图像调到前台，光标变为十字，通过使用鼠标定位，定位到待放置区域后，右击即可完成放置 运行效果 运行结果 zoom：用于设定图形缩放 zoom xon：规定当前图形的 x 轴可进行缩放 zoom yon：规定当前图形的 y 轴可进行缩放 zoom on：规定当前图形可进行缩放 zoom off：规定当前图形不可进行缩放 zoom out：返回图形初始状态 特殊坐标轴双坐标轴有时需要将同一自变量不同的两个量纲的变化绘制到同一张图上，此时就需要双坐标轴 plotyy(X1,Y1,X2,Y2)：以左右不同的纵轴分布绘制 X1-Y1 和 X2-Y2 两条曲线 123456&gt;&gt; figure&gt;&gt; x1=0:0.05:5;&gt;&gt; y1=log(x1);&gt;&gt; x2=2:0.05:5;&gt;&gt; y2=exp(x2);&gt;&gt; plotyy(x1,y1,x2,y2) 极坐标利用 polar() 函数可完成极坐标图的绘制 polar(theta,rho)：以 theta 为极角，以 rho 为极径绘制极坐标图形 1234&gt;&gt; figure&gt;&gt; theta=-2*pi:.01:2*pi;&gt;&gt; rho=(1-sin(theta));&gt;&gt; polar(theta,rho) 对数坐标除笛卡尔坐标系、极坐标系外，还有对数坐标系，其可以将处于低次幂的数据清晰显示出来 semilogx(X,Y)：以 X 和 Y 在对数坐标系上来绘制图形，x 轴为对数制，y 轴仍为笛卡尔制 loglog(X,Y)：以 X 和 Y 在对数坐标系上来绘制图形，x 轴、y 轴均为对数制 123456789&gt;&gt; figure&gt;&gt; x=0:0.05:5;&gt;&gt; y=log(x);&gt;&gt; subplot(1,2,1)&gt;&gt; semilogx(x,y)&gt;&gt; subplot(1,2,2)&gt;&gt; loglog(x,y) 表达式绘制函数随着自变量的变化趋势是未知的，如果自变量的离散区间不合理，则无法准确地反应函数的变化趋势 plot() 函数自变量的趋势即是我们所给定的，但有时我们给定的离散区间往往不那么合理，此时可以利用 fplot() 函数，其通过自适应算法，来给出离散区间 fplot(Fun,[a,b])：在区间 [a,b] 内，绘制函数 Fun 的图形 fplot(Fun,[a,b],tol)：在区间 [a,b] 内，绘制函数 Fun 的图形，tol 为相对误差允许范围，默认为 1E6 fplot(Fun,[xmin,xmax],[ymin,ymax])：在二维区间 [xmin,xmax]、[ymin,ymax] 内，绘制函数 Fun 的图形 fplot(Fun,[xmin,xmax],[ymin,ymax],tol)：在二维区间 [xmin,xmax]、[ymin,ymax] 内，绘制函数 Fun 的图形，tol 为相对误差允许范围，默认为 1E6 1234&gt;&gt; figure&gt;&gt; f=@(x)sin(x);&gt;&gt; lim=[-2*pi,2*pi];&gt;&gt; fplot(f,lim)","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"无线自组织网络概述","slug":"wireless-network/10.无线自组织网络概述","date":"2020-04-28T05:34:00.000Z","updated":"2021-11-03T12:56:06.740Z","comments":true,"path":"notes/wireless-network/e07f6111.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/e07f6111.html","excerpt":"【移动无线网络】移动无线网络有两种形式：蜂窝移动通信网络、WLAN 对于蜂窝移动通信网络，其具有以下特点：","text":"【移动无线网络】移动无线网络有两种形式：蜂窝移动通信网络、WLAN 对于蜂窝移动通信网络，其具有以下特点： 移动终端和固定基站间可互相通信 移动终端不具备路由功能 基站负责路由和交换功能，充当接入有线网络的网关 对于 WLAN，其具有以下特点： 移动节点配备无线网网卡 移动节点通过接入点与固定网络连接 WLAN 工作在链路层，对网络层透明 对于网络层，WLAN 是一个单跳网络 依赖于类似基站或接入点的现有网络基础设施 【Ad-Hoc 的起源】在上述的两种移动网络中，均需要网络基础设施的接入 在某些特殊环境、临时会议、军事战场等，会出现无网络设施可用的情况；而某些时候，接入网络服务商会花费大量的时间与成本，这使得用户并不想使用网络设施 为使用户可远离网络基础设施而保持与网络的连接，就需要延伸网络设施的范围，因此有了移动 Ad-Hoc 的出现 Ad-Hoc 是在 IEEE802.11 首次提出的，其是一种自组织、对等式、多跳、临时、无中心网络的无线移动通信网络。其由一组带有无线通信收发装置的移动终端节点组成，不需要现有信息基础网络设施的支持，网络中的每个终端地位相等，都可以自由移动，可以在任何时候、任何地点快速构建起来的移动通信网络 与常规移动通信网络相比，Ad-Hoc 不需要网络通信基础设施支持，也不依赖基站进行通信，数据通信业务为主，网络拓扑结构动态变化 与传统固定网络相比：固定网络中主机位置基本不变，网络结构一般比较复杂，而 Ad-Hoc 网络规模相对较小，网络拓扑结构会快速变换 与分组无线网、无线局域网、红外网络比较：WLAN、红外网络都是单跳网络，不存在路由问题，此外，Ad-Hoc 移动终端的通信是对等的，其研究重点在于以路由协议为核心的网络层设计 【特点】移动 Ad-Hoc 具有以下特点 1.移动通信和计算机网络的结合 Ad-Hoc 具备移动通信网络和计算机网络的特点，其报文交换采用分组交换机制 同时，用户终端是配有无线收发设备的移动便携式终端，终端之间的路由通常通过多个中间节点的转发来完成 2.网络拓扑动态变化 多种因素都会影响 Ad-Hoc 网络拓扑结构，包括：用户终端随意移动、节点的开关机、无线电发送功率变化、无线信道间互相干扰、地形等综合因素 3.多跳组网方式 在 Ad-Hoc 中，接收端和发送端可使用比两者直接通信小得多的功率进行通信 而且中间节点参与分组转发，有效降低了无线传输设备的设计难度和成本，同时扩大了自组网络的覆盖范围 4.有限的无线传输带宽 Ad-Hoc 网络的带宽受多种因素影响，这是因为无线信道能提供的网络带宽比有线信道要低很多 同时，竞争共享无线信道会产生的碰撞，此外，信号衰落、噪声干扰以及信道之间干扰等也会影响带宽 5.移动终端的自主性 Ad-Hoc 网络中，每个终端都是自主的 自组网络的移动终端之间存在某种协同工作关系，同时，每个终端都将承担为其它终端进行分组转发的义务 6.安全性差 无线链路使 Ad-Hoc 网络容易受到链路层的攻击，同时，移动性使得节点之间的信任关系经常变化，这使得节点漫游时缺乏物理保护 除上述特点外，Ad-Hoc 网络还具有网络的可扩展性不强、存在单向的无线信道、生存时间短等特点 【面临问题】在 Ad-Hoc 网络中，其除了动态变化网络拓扑、有限的无线传输带宽、节能问题、安全问题、共享信道外等问题外，还有两个十分尖锐的问题：隐藏终端、暴露终端 1.隐藏终端 隐藏终端是指：$A$ 正在向 $B$ 传输数据，$C$ 也要向 $B$ 发送数据，由于距离太远，而导致一个节点无法检测到介质竞争对手的存在，此时 $C$ 即隐藏终端，其不能侦听到发送端 $A$，但能够干扰接收端 $B$ 2.暴露终端 暴露终端是指：$B$ 正在向 $A$ 传输数据，$C$ 要向 $D$ 发送数据，由于 $C$ 侦听到节点 $B$ 正在发送，而误以为介质忙不能发送，此时 $C$ 即暴露节点，其能够侦听到发送端，但不会干扰接收端","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件编程","slug":"software-engineering/11.软件编程","date":"2020-04-26T23:24:00.000Z","updated":"2022-05-13T04:45:39.873Z","comments":true,"path":"notes/software-engineering/f65cb195.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/f65cb195.html","excerpt":"【概述】软件缺陷是指软件产品中存在的问题，其具体表现为用户所需的功能没有实现，无法满足用户的需求 在软件开发过程的任何阶段都可能引入软件缺陷，而软件测试是发现软件中错误和缺陷的主要手段，其贯穿于整个开发过程","text":"【概述】软件缺陷是指软件产品中存在的问题，其具体表现为用户所需的功能没有实现，无法满足用户的需求 在软件开发过程的任何阶段都可能引入软件缺陷，而软件测试是发现软件中错误和缺陷的主要手段，其贯穿于整个开发过程 软件测试是为了发现错误而执行程序的过程，它并不可能找出所有的 错误，但是却可以减少潜在的错误或缺陷，在长期进行软件测试实践 的过程中，不断地总结出一些软件测试的经验或原则，可供我们参考： 完全测试是不可能的 测试中存在风险 软件测试只能表明缺陷的存在，而不能证明软件产品已经没有缺陷 软件产品中潜在的错误数与已发现的错误数成正比 让不同的测试人员参与到测试工作中 让开发小组和测试小组分立，开发工作和测试工作不能由同一部分人来完成 尽早并不断地进行测试，使测试工作贯穿于整个软件开发的过程中 在设计测试用例时，应包括输入数据和预期的输出结果两个部分，并且，输入数据不仅应该包括合法的情况，还应该包括非法的输入情况 要集中测试容易出错或错误较多的模块 应该长期保留所有的测试用例 【软件测试模型】软件测试模型是指软件测试全部过程、活动或任务的结构框架，一个好的软件测试模型可以简化测试的工作，加速软件开发的进程 常用的软件测试过程模型有 V 模型、W 模型和 H 模型。 V 模型是最具代表意义的测试模型，它是软件开发中瀑布模型的变种 为克服 V 模型开发和测试不能同步的问题，在 V 模型的基础上有了 W 模型，其增加了软件开发阶段中应同步进行的测试活动。 H 模型强调测试的独立性和灵活性，在 H 模型中，软件测试活动完全独立，它贯穿于整个软件产品的生命周期，与其他流程并行进行。当软件测试人员认为测试准备完成，即某个测试点准备就绪时，就可以从测试准备阶段进入到测试执行阶段。 【软件测试分类】软件测试可以从不同的角度划分为多种类型 按照质量因素划分的软件测试分类有： 功能测试：关注于软件产品的功能实现，以软件产品的需求规格说明书为依据，检验最终的软件产品是否实现了需求规格说明书中的所有功能需求 可靠性测试：关注于程序输出结果的准确性，它以需求规格说明书中对系统的可靠性要求为依据，评测最终的软件产品提供准确输出结果的能力 可用性测试：用来衡量处理服务请求时，应用程序的可用频率，它以需求规格说明书中对系统的可用性要求为依据 性能测试：主要针对软件产品各方面的性能因素，可以细分为负载测试、容量测试、压力测试 安全性测试：主要验证系统的安全性、保密性等措施是否能有效地发挥作用，包括用户管理和访问控制、数据备份与恢复、入侵检测等 按照执行测试时是否需要运行程序，软件测试的分类有： 静态测试：以人工测试为主，通过测试人员认真阅读文档和代码，仔细分析其正确性、一致性及逻辑结构的正确性，从而找出软件产品中的错误或缺陷，其对自动化工具的依赖性较小，通过人脑的思考和逻辑判断来查找错误，因而可以更好地发挥人的主观能动性 动态测试：需要通过实际运行被测程序来发现问题，测试人员可以输入一系列的测试用例，通过观察测试用例的输出结果是否与预期相符来检验系统内潜在的问题或缺陷 除以上两种分类外，还有其他的分类方法，不同的分类方法下的测试标准不同，常见的分类有： 配置测试：考察软件系统是否能在多种硬件平台上正常运行 兼容性测试：检测各软件之间是否能正确地交互和共享信息，它主要关注软件的运行平台和应用系统的版本、标准和规范、数据的共享性 安装测试：发现软件在安装过程中存在的错误，验证其与安装手册的内容是否一致，与其相对应的还有卸载测试 文档测试：检验软件产品的文档是否清晰、准确、一致 软件的国际化和本地化测试：这两者是相对应的，其要求软件产品能够支持 Unicode 编码，支持不同时区的设定、显示和切换，消除一些不容易改变的设置等 α 测试和 β测试：属于验收测试的范畴，是在系统测试之后，产品发布之前进行的测试过程的最后一个阶段 【测试用例】测试用例编写测试用例，是指为达到最佳的测试效果或高效的揭露隐藏的错误而精心设计的少量测试数据并执行的过程 简单的说，测试用例就是设计一种情况，软件程序在这种情况下，必须能够正常运行并且达到程序所设计的执行结果 由于不可能进行穷举测试，因此为节省时间和资源，提高测试效率， 必须要从数量极大的可用测试数据中精心挑选出具有代表性或特殊性的测试数据来进行测试 测试用例设计在测试用例设计过程中，有一些经验和方法可循，常见的方法有： 边界值分析方法：在任何情况下都必须选择，用该方法设计的测试用例发现程序错误的能力最强 等价类划分法：在必要时用该方法补充一些测试用例 错误推测法：有时可用该方法来追加一些测试用例 检查逻辑覆盖度：对照程序逻辑，检查已设计出的测试用例的逻辑覆盖度，如果没有达到要求的逻辑覆盖标准，应当再补充足够的测试用例 因果图法：当程序的功能说明中含有输入条件的组合情况时选用从测试用例设计的角度","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"Matlab——数值积分","slug":"19.Matlab-数值积分","date":"2020-04-24T10:36:00.000Z","updated":"2021-08-24T01:41:53.768Z","comments":true,"path":"matlab/3fad1240.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/3fad1240.html","excerpt":"【数值积分】数值积分是数值计算的重要部分，它是求定积分的一种近似方法，具有实际意义 其不同于符号计算给出的符号解，其给出的是一个精确的近似解","text":"【数值积分】数值积分是数值计算的重要部分，它是求定积分的一种近似方法，具有实际意义 其不同于符号计算给出的符号解，其给出的是一个精确的近似解 matlab 提供了自适应辛普森法和自适应洛巴托法两种方法来求积分 【一重积分】自适应辛普森法在 matlab 中，quad 利用自适应辛普森法计算函数的数值积分，适用于精度低，被积函数平滑性差的数值积分。 quad(Fun,a,b)：计算函数 Fun 在区间 (a,b) 上的积分 quad(Fun,a,b,tol)：计算函数 Fun 在区间 (a,b) 上的积分，tol 控制自适应辛普森法的误差，tol 越大计算速度越快精度越低，默认情况下，tol=1e-6 说明：Fun 是函数句柄，一般利用匿名函数 12&gt;&gt; quad(@(x)x.^2,1,2)ans = 2.3333 自适应洛巴托法在 matlab 中，quadl 利用自适应洛巴托法计算函数的数值积分，适用于精度高，被积函数平滑性好的数值积分。 quadl(Fun,a,b)：计算函数 Fun 在区间 (a,b) 上的积分 quadl(Fun,a,b,tol)：计算函数 Fun 在区间 (a,b) 上的积分，tol 控制自适应洛巴托法的误差，tol 越大计算速度越快精度越低，默认情况下，tol=1e-6 说明： Fun 是函数句柄，一般利用匿名函数 与 quad 相比，quadl 耗时更长，但精度更高 12&gt;&gt; quadl(@(x)x.^2,1,2)ans = 2.3333 【多重积分】二重积分 dplquad(Fun,x_min,x_max,y_min,y_max)：计算函数 Fun 在积分限 (x_min,x_max) 和 (y_min,y_max) 上的积分 dplquad(Fun,x_min,x_max,y_min,y_max,tol)：计算函数 Fun 在积分限 (x_min,x_max) 和 (y_min,y_max) 上的积分，tol 控制误差，tol 越大计算速度越快精度越低，默认情况下，tol=1e-6 说明：Fun 是函数句柄，一般利用匿名函数 123&gt;&gt; f=@(x,y)x.*y+x.^2.*y.^2;&gt;&gt; dblquad(f,1,2,3,4)ans = 34.0278 三重积分 triplequad(Fun,x_min,x_max,y_min,y_max,z_min,z_max)：计算函数 Fun 在积分限 (x_min,x_max) 、(y_min,y_max)、(z_min,z_max) 上的积分 triplequad(Fun,x_min,x_max,y_min,y_max,z_min,z_max,tol)：计算函数 Fun 在积分限 (x_min,x_max) 、(y_min,y_max)、(z_min,z_max) 上的积分，tol 控制误差，tol 越大计算速度越快精度越低，默认情况下，tol=1e-6 说明：Fun 是函数句柄，一般利用匿名函数 123&gt;&gt; f=@(x,y,z)x.*y.*z;&gt;&gt; triplequad(f,1,2,2,3,3,4)ans = 13.1250","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——多项式","slug":"18.Matlab-多项式","date":"2020-04-24T07:34:00.000Z","updated":"2021-08-24T01:41:46.764Z","comments":true,"path":"matlab/cc0f2cc.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/cc0f2cc.html","excerpt":"【多项式】多项式：$P(x)=a_0x^n+a_1x^{n-1}+a_2x^{n-2}+…+a_nx^0$ 用系数来表示：$a_0a_1a_2…a_n$","text":"【多项式】多项式：$P(x)=a_0x^n+a_1x^{n-1}+a_2x^{n-2}+…+a_nx^0$ 用系数来表示：$a_0a_1a_2…a_n$ 例如：$2x^4+3x^2+x+1$ 1p=[2 0 3 1 1] poly2sym(A)：A是一个行向量，代表一个多项式的系数，利用该行向量构建一个符号类型的多项式 1234&gt;&gt; p=[2 0 3 1 1];&gt;&gt; poly2sym(p)ans = 2*x^4 + 3*x^2 + x + 1 【多项式的根】roots(A)：A 是一个行向量，代表一个多项式的系数，用于求解该多项式的根 1234567&gt;&gt; p=[2 0 3 1 1];&gt;&gt; roots(p)ans = 0.2459 + 1.1484i 0.2459 - 1.1484i -0.2459 + 0.5496i -0.2459 - 0.5496i poly(A)：A 是一个行向量，代表一个多项式的根，利用根求出该多项式的系数 1234&gt;&gt; r=[1 -2 3]&gt;&gt; poly(r)ans = 1 -2 -5 6 【多项式运算】加减法： 两个多项式阶次相同时，与数组元素加减法相同 两个多项式阶次不同时，低阶的多项式用首 0 填补，使其与高阶多项式有同样的阶次 12345678910function res=add_and_sub(a,b)if nargin~=2 error('参数个数错误')enda=a(:).';b=b(:).';len_a=length(a);len_b=length(b);res=[zeros(1,len_b-len_a) a]+[zeros(1,len_a-len_b) b]; 乘法： conv(A,B)：执行 A,B 两向量的卷积运算 conv(a,b,&#39;shape&#39;)：按形参 ‘shape’ 返回卷积运算，取值如下： full：返回完整的卷积，默认值 same：返回部分卷积，其大小与向量 A 大小相同 valid：只返回无填充 0 部分的卷积，此时输出向量 c 的最大值为 max(length(a) - max(0,length(b) - 1),0) 12345&gt;&gt; A=[1 1];&gt;&gt; B=[2 0];&gt;&gt; conv(A,B)ans = 2 2 0 除法：[q,r] = deconv(A,B)：求多项式 A,B 的除法运算，其中 q 为返回多项式 B 除以 A 的商式，r 为返回 B 除以 A 的余式，即：B*q+r=A 1234567891011&gt;&gt; A=[1 2 3 4 5]A = 1 2 3 4 5&gt;&gt; B=[1 2 3]B = 1 2 3&gt;&gt; [q,r]=deconv(A,B)q = 1 0 0r = 0 0 0 4 5 【多项式导数】 polyder(A)：求多项式 A 的导函数多项式 polyder(A,B)：求多项式 A 与多项式 B 乘积的导函数多项式 [q,d] = polyder(b,a)：求多项式 B 与多项式 A 相除的导函数，导函数的分子存入q，分母存入 d 12345678910111213&gt;&gt; a = [3 6 9];&gt;&gt; b = [1 2 0];&gt;&gt; k = polyder(a,b)k = 12 36 42 18&gt;&gt; K = poly2str(k,'x')K = 12 x^3 + 36 x^2 + 42 x + 18&gt;&gt; [q,d] = polyder(b,a)q = 18 18d = 9 36 90 108 81 【多项式的积分】polyint(p,k)：返回以向量 p 为系数的多项式积分，积分的常数项为 k，k 默认为 0 例如：多项式为 $x^2-x+2$，常数项为 $\\frac{1}{2}$ 有：$\\frac{1}{3}x^3-\\frac{1}{2}x^2+2x+\\frac{1}{2}$ 12345678&gt;&gt; p = [1 -1 2];&gt;&gt; k = 1/2;&gt;&gt; F = polyint(p,k)F = 0.3333 -0.5000 2.0000 0.5000&gt;&gt; df = poly2sym(F)df = x^3/3 - x^2/2 + 2*x + 1/2 【多项式估值】y = polyval(p,x)：p 为多项式的系数向量，x 为矩阵，按数组运算规则来求多项式的值 123456789101112131415161718&gt;&gt; x=[0:0.1:1]x = 1 至 9 列 0 0.1000 0.2000 0.3000 0.4000 0.5000 0.6000 0.7000 0.8000 10 至 11 列 0.9000 1.0000&gt;&gt; f=[1 2 3 4 5]f = 1 2 3 4 5&gt;&gt; polyval(f,x)ans = 1 至 9 列 5.0000 5.4321 5.9376 6.5321 7.2336 8.0625 9.0416 10.1961 11.5536 10 至 11 列 13.1441 15.0000 【有理多项式】matlab 中，有理多项式由它们的分子多项式和分母多项式表示。 有理多项式展开[r,p,k]=redidue(a,b)：对有理多项式 $\\frac{a}{b}$ 进行分式展开，r 为留数行向量，p 为极点行向量，k 为直项行向量，a 为分子多项式，b 为分母多项式 例如：$P(x)=\\frac{x^3+2x^2+3x+4}{4x^3+5x^2+6x+7}$ 分子项：a=[1 2 3 4]，分母项：b=[4 5 6 7] 进行 redidue(a,b)后有： 12345678910111213&gt;&gt; a=[1 2 3 4];&gt;&gt; b=[4 5 6 7];&gt;&gt; [r,p,k]=residue(a,b)r = 0.1341 + 0.0000i 0.0267 - 0.1262i 0.0267 + 0.1262ip = -1.2078 + 0.0000i -0.0211 + 1.2035i -0.0211 - 1.2035ik = 0.2500 那么，$P(x)$可表达为：$P(x)=\\frac{r1}{x+p1}+\\frac{r2}{x+p2}+\\frac{r3}{x+p3}+k$ 即：$P(x)=\\frac{0.1341}{x-1.2078}+\\frac{0.0267 - 0.1262i}{x-0.0211 + 1.2035i}+\\frac{0.0267 + 0.1262i}{x-0.0211 - 1.2035i}+0.25$ 有理多项式展开的逆运算[b,a] = residue(r,p,k)：根据 r 留数行向量，p 极点行向量，k 直项行向量，进行展开的逆运算，得到 a 分子多项式，b 分母多项式 12345678&gt;&gt; r =[0.1341, 0.0267 - 0.1262i, 0.0267 + 0.1262i];&gt;&gt; p =[-1.2078, -0.0211 + 1.2035i, -0.0211 - 1.2035i];&gt;&gt; k = 0.25;&gt;&gt; [a b]=residue(r,p,k)a = 0.2500 0.5000 0.7500 1.0000b = 1.0000 1.2500 1.5000 1.7500","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Hexo 的 LaTeX 渲染","slug":"07.Hexo的LaTeX渲染","date":"2020-04-23T03:54:00.000Z","updated":"2022-06-03T14:49:43.161Z","comments":true,"path":"hexo/79d5219b.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/79d5219b.html","excerpt":"【插件】Hexo 的 markdown 渲染引擎是 hexo-renderer-marked，不支持 LaTeX 语法 要想使用 LaTeX，则需要更换渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上构建的渲染引擎，两者比较接近。","text":"【插件】Hexo 的 markdown 渲染引擎是 hexo-renderer-marked，不支持 LaTeX 语法 要想使用 LaTeX，则需要更换渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上构建的渲染引擎，两者比较接近。 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 【语义冲突】由于 LaTeX 与 Markdown 语法间存在语义冲突，我们需要对配置文件进行相应更改。 在博客根目录下，进入 node_modules\\kramed\\lib\\rules\\inline.js，将第 11 行的escape变量的值做如下修改： 12//escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 同时对第 20 行进行相应修改: 12// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 【配置文件更改】进入到 NexT 主题目录，打开 _config.yml 配置文件，寻找到 mathjax 一项，将 enable 修改为 true，具体如下： 1234mathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"}],"author":"Alex_McAvoy"},{"title":"Matlab——符号方程","slug":"17.Matlab-符号方程","date":"2020-04-22T15:18:00.000Z","updated":"2021-08-24T01:41:38.577Z","comments":true,"path":"matlab/cc665aee.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/cc665aee.html","excerpt":"【概述】方程，是含有未知数的等式，表示两个数学式之间的相等关系。 常见的方程有：","text":"【概述】方程，是含有未知数的等式，表示两个数学式之间的相等关系。 常见的方程有： 代数方程：由多项式组成的方程 按自变量类别分类：整式方程、分式方程、根式方程 按线性关系分类：线性代数方程、非线性代数方程 超越方程：包含超越函数的方程 微分方程：微分方程，是指含有未知函数及其导数的关系式 常微分方程：未知函数是一元函数 偏微分方程：未知函数是多元函数 对于线性代数方程来说，无论是单个方程还是方程组，其只涉及符号对象的代数运算，利用消元法很容易即可得到所有解，相对比较简单。 对于非线性代数方程来说，很难得到精确解，一般利用牛顿迭代法或二分迭代法去求近似解。 对于超越方程来说，对其求解没有一般的公式，难以求得解析解，一般是采用数值方法求数值解 对于微分方程来说，很可能无法得到解析解，甚至无法求解 注： 超越函数：函数 $f(x)$ 不是 $x$ 的多项式时，常见的有对数函数、指数函数、三角函数、反三角函数等 解析解：通过严格的公式所求得的解，给出解的具体形式，就可通过解的表达式来算出任何对应值 数值解：给出一系列的自变量，利用数值分析方法求出的解，只能利用数值计算的结果，不能随意给出自变量求出具体值 【代数方程与超越方程求解】在matlab中，对于代数方程和超越方程，可以直接利用 solve() 函数来求解，当方程不存在符号解又无其他自由参数时，将给出数值解。 s=solve(S)：S 为符号表达式，自变量为默认变量，结果返回 S=0 的解组成的列向量 s=solve(S,var)：S 为符号表达式，var 为指定的自变量，结果返回 S=0 的解组成的列向量 s=solve(S1,S2,...,Sn)：S1,S2,...,Sn 为 n 个符号表达式，自变量为默认变量，结果返回 n 个方程组的解组成的结构体 s=solve(S1,S2,...,Sn,var1,var2,...,varm)：S1,S2,...,Sn 为 n 个符号表达式，var1,var2,...,varm 为指定的 m 个自变量，结果返回 n 个方程组的解组成的结构体 说明：上述的默认变量是 symvar(s) 所返回的变量 123456789101112131415161718192021222324252627282930313233343536&gt;&gt; syms x y z% solve(S)&gt;&gt; solve(x^2+x)ans = -1 0 % solve(S,var)&gt;&gt; solve(x+y,x)ans = -y% solve(S1,S2,...,Sn)&gt;&gt; s=solve(2*x+y,x+2*y-1)s = x: [1x1 sym] y: [1x1 sym]&gt;&gt; s.xans = -1/3&gt;&gt; s.yans = 2/3%solve(S1,S2,...,Sn,var1,var2,...,varm)&gt;&gt; s=solve(2*x+y,x+2*y-z,x,y)s = x: [1x1 sym] y: [1x1 sym]&gt;&gt; s.xans = -z/3&gt;&gt; s.yans = (2*z)/3 【符号微分方程求解】常微分方程在 matlab 中，常用 dsolve() 来求常微分方程的符号解。 格式：dsolve(S1,S2,...,cond1,cond2,...,var) 函数返回由符号表达式 S1,S2,... 指定的以 var 为自变量的常微分方程的符号解，cond1,cond2,...用于指定方程的边界条件或初始条件，若 var 为指定，则默认以 t 为自变量 例1：求 $x^2+y+(x-2y)y’=0$ 的通解 123456&gt;&gt; syms x y(x)&gt;&gt; f=sym(x^2+y+(x-2*y)*diff(y))&gt;&gt; s=dsolve(f)s = x/2 + ((4*x^3)/3 + x^2 + C1)^(1/2)/2 x/2 - ((4*x^3)/3 + x^2 + C1)^(1/2)/2 例2：求 $y’’’-y’’=x$ 在边界条件 $y(1)=8,y’(1)=7,y’’(2)=4$ 下的解 123456789&gt;&gt; syms x y(x)&gt;&gt; dy=diff(y),d2y=diff(y,2),d3y=diff(y,3);&gt;&gt; f=sym(d3y-d2y==x)&gt;&gt; s=dsolve(f,y(1)==8,dy(1)==7,d2y(2)==4)s = x*((exp(-1)*(19*exp(1) - 14))/2 - 1) + 7*exp(-2)*exp(x) - x^2/2 - x^3/6 + (exp(-1)*(19*exp(1) - 14))/2 - (exp(-1)*(25*exp(1) - 21))/3 - 1&gt;&gt; s=simplify(s) % 对结果化简s = (17*x)/2 + 7*exp(x - 2) - 7*x*exp(-1) - x^2/2 - x^3/6 + 1/6 例3：求 $\\left\\{\\begin{matrix}f’’+3g=sinx\\\\g’+f’=cosx\\end{matrix}\\right.$ 的通解与其在边界条件 $f’(2)=0,f(3)=3,g(5)=1$的解 123456789101112131415161718192021&gt;&gt; syms x f(x) g(x)&gt;&gt; df=diff(f),dg=diff(g),d2f=diff(f,2);&gt;&gt; F1=sym(d2f+3*g==sin(x));&gt;&gt; F2=sym(dg+df==cos(x));% 通解&gt;&gt; S1=dsolve(F1,F2);&gt;&gt; simplify(S1.f)ans = C5 + sin(x)/2 + (3^(1/2)*C6*exp(3^(1/2)*x))/3 - (3^(1/2)*C7*exp(-3^(1/2)*x))/3&gt;&gt; simplify(S1.g)ans = sin(x)/2 - (3^(1/2)*C6*exp(3^(1/2)*x))/3 + (3^(1/2)*C7*exp(-3^(1/2)*x))/3% 特解&gt;&gt; S2=dsolve(F1,F2,df(2)==0,f(3)==3,g(5)==1);&gt;&gt; simplify(S2.f)ans = (18*exp(3^(1/2)*(x + 2)) - 6*exp(3^(1/2)*(2*x + 3)) - 6*exp(7*3^(1/2)) + 6*exp(3^(1/2)*(x + 4)) + 6*exp(3^(1/2)*(x + 6)) + 18*exp(3^(1/2)*(x + 8)) + 3*exp(3^(1/2)*(2*x + 3))*sin(5) + 3*exp(3^(1/2)*(x + 2))*sin(x) + 3*exp(3^(1/2)*(x + 8))*sin(x) - 3*exp(3^(1/2)*(x + 2))*sin(3) - 3*exp(3^(1/2)*(x + 4))*sin(5) - 3*exp(3^(1/2)*(x + 6))*sin(5) - 3*exp(3^(1/2)*(x + 8))*sin(3) + 3*exp(7*3^(1/2))*sin(5) + 3^(1/2)*cos(2)*exp(3^(1/2)*(x + 3)) - 3^(1/2)*cos(2)*exp(3^(1/2)*(x + 7)) + 3^(1/2)*cos(2)*exp(10*3^(1/2)) - 3^(1/2)*cos(2)*exp(2*3^(1/2)*x))/(6*(exp(3^(1/2)*(x + 2)) + exp(3^(1/2)*(x + 8))))&gt;&gt; simplify(S2.g)ans = (6*exp(7*3^(1/2)) + 6*exp(3^(1/2)*(2*x + 3)) - 3*exp(3^(1/2)*(2*x + 3))*sin(5) + 3*exp(3^(1/2)*(x + 2))*sin(x) + 3*exp(3^(1/2)*(x + 8))*sin(x) - 3*exp(7*3^(1/2))*sin(5) - 3^(1/2)*cos(2)*exp(10*3^(1/2)) + 3^(1/2)*cos(2)*exp(2*3^(1/2)*x))/(6*(exp(3^(1/2)*(x + 2)) + exp(3^(1/2)*(x + 8))))","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——符号函数与微积分","slug":"16.Matlab-符号函数与微积分","date":"2020-04-22T12:29:00.000Z","updated":"2021-08-24T01:41:10.044Z","comments":true,"path":"matlab/5ff51811.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/5ff51811.html","excerpt":"【符号函数类型(symfun)】广义的符号函数是指对于不带等号的符号表达式。 但实际上，在 matlab 中，符号函数是一个类型，即：symfun，正是有了该类型，才进一步可以对符号表达式进行微积分操作。","text":"【符号函数类型(symfun)】广义的符号函数是指对于不带等号的符号表达式。 但实际上，在 matlab 中，符号函数是一个类型，即：symfun，正是有了该类型，才进一步可以对符号表达式进行微积分操作。 在数学上，对于两个变量 $x$、$y$，若他们存在一定的映射关系，则认为 $x$、$y$ 之间有一种对应关系 $f$，一般来说，我们将 $x$ 记为自变量，$y$ 记为因变量，称：$y=f(x)$ 为函数对应关系，而 y 关于 x 的函数，亦可记为 $y(x)$ 在 matlab 中，我们同样采用上述记法： 12345&gt;&gt; syms x y(x)&gt;&gt; whos Name Size Bytes Class Attributes x 1x1 112 sym y 1x1 112 symfun 需要注意的是，该记法一般仅在涉及到微积分时使用 【符号函数的极限】 limit(F,x,a)：求 $\\lim_{x\\to a}f(x)$ limit(F,a)：求 $\\lim_{x\\to a}f(x)$，采用默认自变量，由 symvar() 给出 limit(F)：求 $\\lim_{x\\to 0}f(x)$，采用默认自变量 ，由 symvar() 给出 limit(F,x,a,flag)：求 $\\lim_{x\\to a^{flag}}f(x)$，flag 取值为 left 或 right，代表左右极限 说明：a 取值为 inf 代表无穷 1234567891011121314151617181920212223&gt;&gt; syms x f(x)&gt;&gt; f(x)=x^3+x^2+1f(x) = x^3 + x^2 + 1&gt;&gt; limit(f,x,1)ans(x) = 3&gt;&gt; limit(f,2)ans(x) = 13&gt;&gt; limit(f)ans(x) = 1&gt;&gt; f(x)=2^xf(x) = 2^x&gt;&gt; limit(f,inf)ans(x) = Inf&gt;&gt; limit(f,-inf)ans(x) = 0&gt;&gt; limit(f,x,0,'left')ans(x) = 1&gt;&gt; limit(f,x,0,'right')ans(x) = 1 【符号函数的微分】 diff(F)：对于符号函数或符号矩阵 F，求对默认变量的一阶微分，默认变量由 symvar() 给出 diff(F,v)：对于符号函数或符号矩阵 F，求对变量 v 的一阶微分 diff(F,n)：对于符号函数或符号矩阵 F，求对默认变量的 n 阶微分，默认变量由 symvar() 给出 diff(F,v,n)：对于符号函数或符号矩阵 F，求对变量 v 的 n 阶微分 jacobian(w,v)：对于符号列向量 w，指定变量 v 所变换的雅克比矩阵，详见附录1：高数相关-4.隐函数求偏导 12345678910111213141516171819202122232425262728&gt;&gt; syms x y f(x)&gt;&gt; f(x)=x^3+2*xf(x) = x^3 + 2*x&gt;&gt; diff(f)ans(x) = 3*x^2 + 2&gt;&gt; diff(f,2)ans(x) = 6*x&gt;&gt; f(x)=x^2+yf(x) = x^2 + y&gt;&gt; diff(f,y)ans(x) = 1&gt;&gt; syms x y z&gt;&gt; f(x)=sym([x^2,y^2+z])f(x) = [ x^2, y^2 + z]&gt;&gt; jacobian(f,x)ans(x) = 2*x 0&gt;&gt; jacobian(f,[x,y])ans(x) = [2*x, 0] [ 0, 2*y]&gt;&gt; jacobian(f,[x,y,z])ans(x) = [2*x, 0, 0] [0 , 2*y, 1] 【符号函数的积分】 int(F)：用默认变量求符号函数 F 的不定积分，默认变量由 symvar() 给出 int(F,v)：用变量 v 求符号函数 S 的不定积分 int(F,a,b)：用默认变量求符号函数 F 在区间 (a,b)的定积分，默认变量由 symvar() 给出 int(F,v,a,b)：用变量 v 求符号函数 F 在区间 (a,b)的定积分 12345678910&gt;&gt; syms x f(x)&gt;&gt; f(x)=3*x^2+2*xf(x) = 3*x^2 + 2*x&gt;&gt; int(f)ans(x) = x^2*(x + 1)&gt;&gt; int(f,1,2)ans = 10&gt;&gt; int(f,1,inf)ans = Inf 【符号函数的级数】级数：将数列的项依次用加号连接起来的函数 symnsum(S,a,b)：求符号表达式 S 中默认变量从 a 到 b 的有限和，默认变量由 symvar() 给出 symnsum(S,v,a,b)：求符号表达式 S 中变量 v 从 a 到 b 的有限和 说明：取值为 inf 代表无穷 12345678910&gt;&gt; syms x y n&gt;&gt; f(x)=sym(x^2)f(x) = x^2&gt;&gt; symsum(f,0,n)ans = (n*(2*n + 1)*(n + 1))/6 &gt;&gt; f(x)=x^2+yf(x) = x^2 + y&gt;&gt; symsum(f,y,0,n)ans(x) = (n + 1)*x^2 + (n*(n + 1))/2 【符号函数的泰勒级数】 taylor(F)：求符号函数 F 默认变量等于 0 处 5 阶的麦克劳林展开式，默认变量由 symvar() 给出 taylor(F,v,a,&#39;Order&#39;,n)：求符号函数 F 变量 v=a 处 n-1 阶的泰勒展开式 1234567891011121314&gt;&gt; syms x f(x)&gt;&gt; f(x)=sin(x)f(x) = sin(x)&gt;&gt; taylor(f)ans(x) = x^5/120 - x^3/6 + x% a=0，麦克劳林展开式&gt;&gt; taylor(f,x,0,'Order',8)ans(x) = - x^7/5040 + x^5/120 - x^3/6 + x% a~=0，泰勒展开式&gt;&gt; taylor(f,x,3,'Order',5)ans(x) = sin(3) - (sin(3)*(x - 3)^2)/2 + (sin(3)*(x - 3)^4)/24 + cos(3)*(x - 3) - (cos(3)*(x - 3)^3)/6 【符号函数的积分变换】傅里叶变换与反傅里叶变换： Fw=fourier(Ft,t,w)：求以 w 为自变量的符号函数 Fw，其是由以 t 为自变量的符号函数 Ft 的傅里叶变换得来的 Ft=ifourier(Fw,w,t)：求以 t 为自变量的符号函数 Ft，其是由以 w 为自变量的符号函数 Fw 的反傅里叶变换得来的 拉普拉斯变换与反拉普拉斯变换： Fs=laplace(Ft,t,s)：求以 s 为自变量的符号函数 Fs，其是以 t 为自变量的符号函数 Ft 拉普拉斯变换得来的 Ft=ilaplace(Fs,s,t)：求以 t 为自变量的符号函数 Ft，其是以 s 为自变量的符号函数 Fs 反拉普拉斯变换得来的 Z 变换与反 Z 变换： Fz=ztrans(Fn,n,z)：求用 z 为变量的符号函数 Fz，其是以变量 n 的符号函数 Fn 的 Z 变换得来的 Fn=iztrans(FZ,z,n)：求用 n 为变量的符号函数 Fn，其是以变量 z 的符号函数 Fz 的反 Z 变换得来的","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"HiperLAN 标准","slug":"wireless-network/09.HiperLAN标准","date":"2020-04-22T11:34:00.000Z","updated":"2021-10-31T14:29:32.236Z","comments":true,"path":"notes/wireless-network/4eb74baf.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/4eb74baf.html","excerpt":"【概述】HiperLAN 标准由欧洲 ETSI 开发，具有如下四种标准： HiperLAN1：用于无线局域网接入 HiperLAN2：用于无线局域网接入 HiperLink：用于室内无线主干系统 HiperAccess：室外接入有线基础设施","text":"【概述】HiperLAN 标准由欧洲 ETSI 开发，具有如下四种标准： HiperLAN1：用于无线局域网接入 HiperLAN2：用于无线局域网接入 HiperLink：用于室内无线主干系统 HiperAccess：室外接入有线基础设施 【HiperLAN1 与 HiperLAN2】HiperLAN1 是高速无线 LAN，HiperLAN 2 无线接入 ATM 或 IP 网络。 对于 HiperLAN1 与 HiperLAN2 来说，他们都具有以下特点： 频带：5GHz 覆盖范围：100米 数据传输速率：23.529Mbps 具有多跳 Ad-Hoc 网络能力 支持实时业务、节能功率管理 此外，HiperLAN2 还具有以下特点： 采用 OFDM 调制技术：高速数据传输，传输率可达 54Mbps 面向连接：AP 和移动终端在传输数据之前建立时分双工连接，有点-点、点-多点、专用广播信道三种方式 QoS：通过面向连接和高数据传输率的特点，可以传输不同类型的数据流 自动频率分配：AP 能根据最小干扰和资源不冲突原则自动选择恰当的无线信道进行数据传输","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"IEEE 802.11 标准","slug":"wireless-network/08.IEEE802.11标准","date":"2020-04-22T09:20:00.000Z","updated":"2021-10-31T14:28:20.433Z","comments":true,"path":"notes/wireless-network/d95d4202.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/d95d4202.html","excerpt":"【IEEE802.11 标准】在计算机网络中的无线局域网与 IEEE 802.11 中，简单介绍了无线局域网与 IEEE 802.11 标准，下面对 IEEE802.11 标准进行详细介绍 IEEE802.11 系列标准，是 IEEE 制定的无线局域网标准，主要针对于网络的物理层和媒质访问控制层进行规定，其中重点是对媒质访问控制层的规定","text":"【IEEE802.11 标准】在计算机网络中的无线局域网与 IEEE 802.11 中，简单介绍了无线局域网与 IEEE 802.11 标准，下面对 IEEE802.11 标准进行详细介绍 IEEE802.11 系列标准，是 IEEE 制定的无线局域网标准，主要针对于网络的物理层和媒质访问控制层进行规定，其中重点是对媒质访问控制层的规定 其由以下三个子标准构成： IEEE802.11a：物理层采用 OFDM 技术（正交频分多路复用），工作频段是 5GHz，数据速率为 54Mbps，54 个频率中 48 个用于数据，4 个用于同步控制。MAC 层与其他 802.11 标准相同 IEEE802.11b：物理层采用 HR-DSSS 技术（高速率直接序列扩频），工作频段是 2.4GHz，数据速率为 1、2、5.5Mbps/11Mbps，覆盖范围是 802.11a 的 7 倍，产品已经发展到第五代，大部分缺陷已经得到解决，1~6Mbps 的吞吐量能满足多种应用的需求 IEEE802.11g：物理层采用 OFDM 技术（正交频分多路复用），工作频段是 2.4GHz，数据速率最大为 54Mbps，兼备 802.11a 和 802.11b 的特点，比 802.11a 的功耗小、传输距离长、穿透力强 【协议栈】协议栈802.11 满足与其他有线 802.x 系列的无缝融合，除了带宽低、接入时间长外，应用程序感觉不到任何不同，而无线节点的高层协议，如应用协议、TCP、IP等，与有线节点的高层协议相同 物理层与 MAC 层在 IEEE 802.11 标准中，MAC 层被逻辑划分为以下两层： MAC 子层：访问机制的实现和分组的拆分和管理 MAC 管理子层：进行电源管理等 物理层也被逻辑划分为以下两层： 物理汇聚层：形成统一格式分组和载波监听分析 物理媒体依赖层：识别相关媒体信号，编码调制 同时，在物理层之下，IEEE 802.11 标准的基本机制有以下三个技术： FHSS：通过调频功能和频移键控调制技术将二进制数据帧转换为适合无线电波传输的信号，或使 FHSS 发送数据帧 DSSS：定义了物理层帧的格式，解释了如何利用 DSSS 发送帧 IR：利用红无线物理层发送帧以及利用调制技术将二进制数转换成合适的红外线光传播信号 【站管理】站管理，是指在物理层和 MAC 层上进行站点和接入点的管理 物理层管理：负责信道转换、物理管理信息库的维护 MAC 层管理：负责站点与接入点的关联、站点漫游，同时进行认证、加密、同步、能量管理等工作，此外，还负责 MAC 管理信息库的维护 【媒体访问控制】概述在无线局域网中，对于基础结构网络来说，采取的是集中接入协议；而对于 AD 网络，采取的是分布接入协议 而在 IEEE 802.11 标准中，对于分组无线 MAC 来说，主要采取分布协调访问（DCF）与点协调访问（PCF） 分布式访问方式（DCF）在有线环境时，媒体访问控制一般采用 CSMA/CD 方式，但在无线环境中该无法使用，为此引入了 RTS/CTS 方式，保证一个数据报的完整传输过程 在 DCF 中，采用 CSMA/CA 协议进行无线介质的共享访问，其基本特点如下： 如果媒体为空，则节点传输帧；如果媒体为忙，则等待直到当前传输完全结束 能降低冲突概率 高负载时采用有效的后退算法 优先级服务 以下是一个 CSMA/CA 的例子： 关于 CSMA/CA 的详细介绍，见：随机访问介质访问控制 中心网络控制方式（PCF）中心网络控制方式是一个无竞争访问协议，适用于节点安装有点控制器（中心控制器）的网络 所有的工作站均服从中心控制器的控制，中心控制器用轮询法询问每个站有没有数据要发送，由于完全控制了各个站的发送顺序，因此不会有冲突产生。 其需要一个集中的轮询站点： 以循环的方式轮询所有配置成 polling 的站点 被询问的站点利用 SIFS 返回响应 如果收到响应则用另一个 PIFS 发出另一个 polling 如果没有收到响应，则 polling 其他站 关于轮询法的详细介绍，见：轮询访问介质访问控制 【帧结构】 基本字段 Frame control：两个字节的控制字段，具有多种用途 Duration/ID：下一个要发送的帧可能要持续的时间 Address 1~4：每个地址的含义由 Frame control 中的 DS 解释 Sequence control：序列号，用来过滤掉重复帧 Data：包含 $0$ 到 $2312$ 字节的数据 Checksum：采用 $4$ 个字节的校验码 帧控制字段 Protocol version：当前版本号是 $0$ Type/Subtype：确定帧的功能，00 用于管理字段，01 用于控制字段，10 用于数据字段，11 作为保留字段 More fragments：$1$ 表示在当前的 MSDU 后面还有另一个fragment Retry：1 表明当前帧是以前帧的重传 Power management：表明站的模式，$1$ 表示站进入节能，$0$ 表示活跃 More data：一般来说该字段指示接受者发送者还有帧要传来 Wired equivalent privacy (WEP)：该字段表明采用 IEEE 802.11 标准的安全机制 Order：$1$ 表示接受者必须严格按照顺序处理该帧 Type/Subtype 字段控制帧： ACK：来自接收端的立即确认，是正确的数据帧，用于管理和处理 Poll 帧的正确接收 RTS/CTS：$4$ 次交换的前两个帧，通知发送端和接收端附近的节点 CF-end：通告无竞争阶段的结束 CF-end + CF-ack：确认 CF-end 数据帧（前 $4$ 个携带用户数据，后 $4$ 个为任意数据）： Data：最简单的数据帧，用于无竞争/有竞争阶段 Data + CF-ack：除了携带数据外，该帧还携带对刚收到数据的确认，仅用于无竞争阶段 Data + CF-poll：被点协调员用来传递数据给移动站，也可用于请求移动站点发送一个可能被缓存的数据帧 Data + CF-ack + CF-poll：把上述功能结合在一个帧中 Null function（no data）：携带能量管理帧中由 AP 指示站点进入节能状态 CF-ack（no data） CF-poll（no data） CF-ack + CF-poll （no data） 管理帧（管理站点与 AP 间的通信）： Association request：连接请求，移动站点向 BSS 内的 AP 请求关联 Association response：连接响应，AP 接受移动站点的关联请求 Re-association request：重连请求，当移动站点离开当前 BSS 而进入另一个 BSS 时必须向新 BSS 的 AP 请求关联，新 AP 据此和老 AP 协商数据帧的转发 Re-association response：解除连接，新 AP 接受移动站点的关联请求 Probe request：侦测请求，用来获取 AP 或者其他站点的信息 Probe response：侦测相应，对上述请求的响应 Beacon：信标，AP 建立时序同步功能而准定期发送的管理帧 Announcement traffic indication message：宣布流量指示标文，通知其他站点有缓存的数据 Authentication：认证，站点之间交换信息和采用多种模式，达到相互认证目标 De-authentication：取消认证，通知其他站点终止当前的安全通信 地址字段 【安全机制】传统上，一个单位通过使用防火墙限制外部访问来保护本单位的计算机网络，但对无线网络，理论上任何人其接收器只要在射频范围内都可以窃听到通信内容 基于服务集识别（SSID）只有知道网络名称或者 SSID 的工作站才可以访问网络 SSID 机制采用 AP 周期性广播信标，信标帧在发送时没有进行任何方式的保护，很容易识别 SSID MAC 地址过滤在每个 AP 中维护一个 MAC 地址名单，只有那些 MAC 地址在该名单中的工作站允许访问网络 由于 MAC 地址必须进行无保护发送，因此攻击者可以很容易监听到 MAC 地址，故而大多数无线网卡可以通过软件改变其 MAC 地址 有线等效协议（WEP）有线等效协议，其目标是提供与有线局域网等价的保密机制，WEP 使用基于 RC4 的加密算法，提供两种安全机制： 认证：防止未授权用户对网络进行访问 加密：防止窃听","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"Matlab——符号表达式","slug":"15.Matlab-符号表达式","date":"2020-04-17T12:33:00.000Z","updated":"2021-08-24T01:41:29.542Z","comments":true,"path":"matlab/7d86f661.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/7d86f661.html","excerpt":"【符号表达式的创建】在创建符号表达式时，分为两种情况： 对于带等号的符号表达式，称为符号方程，利用 sym 创建 对于不带等号的符号表达式，称为符号函数，利用 syms 创建","text":"【符号表达式的创建】在创建符号表达式时，分为两种情况： 对于带等号的符号表达式，称为符号方程，利用 sym 创建 对于不带等号的符号表达式，称为符号函数，利用 syms 创建 1234567891011% 符号方程&gt;&gt; syms x&gt;&gt; e=sym(x^2+2*x==-1)e = x^2 + 2*x == -1% 符号函数&gt;&gt; syms a b c x&gt;&gt; f=a*x^3+b*x^2+c*xf = a*x^3 + b*x^2 + c*x 【符号表达式的显示】在 matlab 中，采用默认的计算机方式对符号表达式进行表达，为了更直观的显示，可以利用 pretty() 函数来将符号表达式显示为符合数学习惯的数学表达式 123456789&gt;&gt; syms a b c d e x&gt;&gt; f=sym(5*a^3+3*b*x^5/c+7*c*x-x^e)f = 7*c*x - x^e + 5*a^3 + (3*b*x^5)/c&gt;&gt; pretty(f) 5 e 3 3 b x7 c x - x + 5 a + ------ c 【符号表达式的展开与合并】对于符号表达式，可以利用 expand() 函数将其展开： expand(S)：将符号表达式 S 中的各项进行展开，若包含超越函数，则利用恒等变形的方法将他们展开，S 可为符号表达式矩阵 1234567&gt;&gt; syms x&gt;&gt; f=sym(x^2+(x-1)^2)f = (x - 1)^2 + x^2&gt;&gt; expand(f)ans = 2*x^2 - 2*x + 1 对于符号表达式，可以利用 collect() 函数将同类项进行合并： collect(S)：将符号表达式 S 中的默认变量的相同幂次的项进行合并，S 可为符号表达式矩阵，默认变量由 symvar() 获得 collect(S,var)：将符号表达式 S 中 var 的相同次幂的项进行合并，S 可为符号表达式矩阵 12345678910&gt;&gt; syms x y z&gt;&gt; f=sym((x^2+y*z+z^2)*x+z)f = z + x*(x^2 + z^2 + y*z)&gt;&gt; collect(f)ans = x^3 + (z^2 + y*z)*x + z&gt;&gt; collect(f,z)ans = x*z^2 + (x*y + 1)*z + x^3 【符号表达式的嵌套与分解】对于符号表达式，可以利用 horner() 函数将其转为嵌套的形式： horner(S)：将符号表达式 S 转换为嵌套的形式，S 可为符号表达式矩阵 1234567&gt;&gt; syms x&gt;&gt; f=sym(x^3+6*x^2+3*x+1)f = x^3 + 6*x^2 + 3*x + 1&gt;&gt; horner(f)ans = x*(x*(x + 6) + 3) + 1 对于符号表达式，可以利用 factor() 函数将其进行因式分解： factor(S)：符号表达式 S 是多项式，会返回该多项式的因子组成的行向量，若 S 不能分解为有理多项式乘积的形式，则会返回 S 本身 ，S 可为符号表达式矩阵或一个数 123456789101112131415161718&gt;&gt; syms x y&gt;&gt; f= x*y + 2*x + y + 2f = 2*x + y + x*y + 2&gt;&gt; factor(f)ans = [ y + 2, x + 1] &gt;&gt; factor(231321216546545)ans = 5 271 17183 9935213 &gt;&gt; f= x*y + 2*x + y*5 + 2f = 2*x + 5*y + x*y + 2&gt;&gt; factor(f)ans = 2*x + 5*y + x*y + 2 【符号表达式的简化】matlab 会根据一定的规则对符号表达式进行简化，简化的函数有： simplify(S)：依照 Maple 化简规则简化，S 可为符号表达式矩阵 【符号表达式的替换】matlab 中提供了符号表达式变量代换的函数，以便利用换元法简化模型。 R=subs(S)：用工作区中的变量值替代符号表达式 S 中的所有符号变量，S 可以是符号表达式矩阵 123456789101112131415161718&gt;&gt; syms x y&gt;&gt; f=sym(x^2+x*y+x)f = x + x*y + x^2&gt;&gt; a=sym(2)a = 2&gt;&gt; x=ax = 2&gt;&gt; subs(f)ans = 2*y + 6&gt;&gt; syms t&gt;&gt; x=1/tx = 1/t&gt;&gt; subs(f)ans = y/t + 1/t + 1/t^2 R=subs(S,New)：用新符号变量 New 来替代符号表达式 S 中的默认变量，默认变量由 symvar() 获得，S 可以是符号表达式矩阵 123456&gt;&gt; ff = x + x*y + x^2&gt;&gt; subs(f,1/t)ans = y/t + 1/t + 1/t^2 R=subs(S,Old,New)：用新符号变量 New 来替代符号表达式 S 中的变量 Old，S 可以是符号表达式矩阵 123456&gt;&gt; ff = x + x*y + x^2&gt;&gt; subs(f,y,1/t)ans = x + x/t + x^2 subexpr(S)：自动寻找符号表达式中重复出现的字符串，将其替换为 sigma，之后返回 sigma 和替换完毕后的符号表达式 12345678910&gt;&gt; syms x y&gt;&gt; f=sym((1*x+2*x^2+3*x^3+4*x^4)*y+(1*x+2*x^2+3*x^3+4*x^4)*y^2+(1*x+2*x^2+3*x^3+4*x^4)*y^3)f = (4*x^4 + 3*x^3 + 2*x^2 + x)*y^3 + (4*x^4 + 3*x^3 + 2*x^2 + x)*y^2 + (4*x^4 + 3*x^3 + 2*x^2 + x)*y &gt;&gt; subexpr(f)sigma = 4*x^4 + 3*x^3 + 2*x^2 + xans = sigma*y^3 + sigma*y^2 + sigma*y 【符号表达式的复合函数与反函数】在数学上，存在复合函数的概念，matlab 中也提供了相应的函数： compose(f,g)：返回 f=f(x) 与 g=g(y) 的复合 f(g(y))，x、y 是 symvar() 给出的默认符号变量 compose(f,g,&#39;t&#39;)：返回 f=f(x) 与 g=g(y) 的复合 f(g(y))，并将自变量改为 t 12345678910111213141516171819&gt;&gt; syms x y&gt;&gt; f=sym(2*x+1)f = 2*x + 1&gt;&gt; g=sym(y^2)g = y^2&gt;&gt; compose(f,g)ans = 2*y^2 + 1&gt;&gt; compose(g,f)ans = (2*x+1)^2&gt;&gt; syms t&gt;&gt; compose(f,g,t)ans = 2*t^2 + 1 在数学上，存在反函数的概念，matlab 中也提供了相应的函数： finverse(f)：返回 f 的反函数，自变量为 symvar() 给出的默认符号变量 finverse(f,y)：返回 f 的反函数，自变量为 y，要求 f 中不止一个变量 123456789101112131415161718&gt;&gt; syms x y&gt;&gt; y=2*x+1y = 2*x + 1&gt;&gt; finverse(y)ans = x/2 - 1/2&gt;&gt; syms x y f&gt;&gt; f=x^2+1+y^2+2*x*yf = x^2 + 2*x*y + y^2 + 1&gt;&gt; finverse(f,y)ans = (y - 1)^(1/2) - x&gt;&gt; finverse(f,x)ans = (x - 1)^(1/2) - y","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——符号类型","slug":"14.Matlab-符号类型","date":"2020-04-17T10:21:00.000Z","updated":"2021-08-18T11:54:12.389Z","comments":true,"path":"matlab/544af7cf.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/544af7cf.html","excerpt":"【符号类型(sym)】符号类型是一种数据结构，封装了存储代表符号表达式的类型，符号表达式可以是单独的变量，也可以是变量和常量的组合，甚至可以是一个函数。 var=sym(A,flag)： 关于 var：var 是符号对象的名，命名规则与普通变量相同，只是不能超过 31 位 关于 A： A 是标量、矩阵、数值表达式：var 将是 A 转换成的符号对象 A 是字符串：var 将是该字符串转换成的符号对象 关于 flag：转换成的符号对象应该符合的格式 A 为数值时： &#39;r&#39;：默认值，最接近的有理表示形式 &#39;d&#39;：最接近的十进制浮点精确表示 &#39;e&#39;：带误差估计的有理表示 A 为字符串时： &#39;real&#39;：限定 A 为实型符号变量 &#39;positive&#39;：限定 A 为正的实型符号变量 说明：由于版本更新问题，日后的版本将移除掉 A 为字符串的情况，因此不建议使用字符串的方式来创建符号变量 syms a b c ... flag：创建多个符号对象 a b c ... 创建多个符号对象时，中间用空格间隔 符号对象 a b c ... 只是符号，没有值 格式标志 flag 与 sym(A,flag) 相同","text":"【符号类型(sym)】符号类型是一种数据结构，封装了存储代表符号表达式的类型，符号表达式可以是单独的变量，也可以是变量和常量的组合，甚至可以是一个函数。 var=sym(A,flag)： 关于 var：var 是符号对象的名，命名规则与普通变量相同，只是不能超过 31 位 关于 A： A 是标量、矩阵、数值表达式：var 将是 A 转换成的符号对象 A 是字符串：var 将是该字符串转换成的符号对象 关于 flag：转换成的符号对象应该符合的格式 A 为数值时： &#39;r&#39;：默认值，最接近的有理表示形式 &#39;d&#39;：最接近的十进制浮点精确表示 &#39;e&#39;：带误差估计的有理表示 A 为字符串时： &#39;real&#39;：限定 A 为实型符号变量 &#39;positive&#39;：限定 A 为正的实型符号变量 说明：由于版本更新问题，日后的版本将移除掉 A 为字符串的情况，因此不建议使用字符串的方式来创建符号变量 syms a b c ... flag：创建多个符号对象 a b c ... 创建多个符号对象时，中间用空格间隔 符号对象 a b c ... 只是符号，没有值 格式标志 flag 与 sym(A,flag) 相同 【符号运算中的运算符】算术运算符符号运算中的算术运算符与数值运算中的算术运算符操作方法相同 详见：矩阵基础操作-7.矩阵运算与数组运算的对比 关系运算符在符号运算中，关系运算符只有两个： ==：对运算符两边的符号对象进行比较，若相等返回 1，若不等返回 0（相等比较） ~=：对运算符两边的符号对象进行比较，若不相等返回 1，若相等返回 0（不相等比较） 注：在脚本中使用 逻辑运算符符号运算中的算术运算符与数值运算中的算术运算符操作方法基本相同： 对于符号方程来说，会返回逻辑值 FALSE 或 TRUE 对于符号表达式来说，会返回包含逻辑值的符号表达式 1234567891011% 符号方程&gt;&gt; a=sym(1),b=sym(2)&gt;&gt; a &amp; bans = TRUE% 符号表达式&gt;&gt; syms a b&gt;&gt; a&amp;bans = a &amp; b 【变量确定】对于符号对象来说，其可以表示符号变量和符号常量，当需要查找一个符号表达式中的符号变量时，可以利用以下方法： symvar(S)：返回符号表达式 S 中的所有符号变量 symvar(S,n)：返回符号表达式 S 中距离符号 x 或 X 最接近的 n 个符号变量（最近是依据 ASCII 码来判断的） 1234567891011121314151617&gt;&gt; syms a b x y&gt;&gt; f=sym(a^4+b^3+x^2+y)&gt;&gt; symvar(f)ans = [ a, b, x, y] &gt;&gt; symvar(f,1)ans = x &gt;&gt; symvar(f,2)ans = [x, y] &gt;&gt; symvar(f,3)ans = [x, y, b] 【精度计算】符号类型最大特点是计算过程中不会出现舍入误差，因此可以得到任意精度的数值解。 在希望计算结果精确时，可以牺牲计算时间与存储空间，利用符号运算来获得足够高的计算精度。 符号运算的结果从形式上来看是数值，但变量类型本质上是字符串，因此要从精确解中得到任意精度的解，需要利用以下函数，来进行精度计算改变默认精度，获得所需精度的数值解。 digits(n)：调用该函数后，近似解的精度会变为 d 位有效数字，默认值为 32 vpa(A,d)：将符号解 A 的精度设为有效 d 位有效数字，默认值为 32 double(A)：将符号变量 S 转为双精度矩阵 123456789101112131415161718&gt;&gt; syms x&gt;&gt; f=sym('2*x^2+3*x-4')&gt;&gt; vpa(f)ans = 2.0*x^2 + 3.0*x - 4.0&gt;&gt; s=solve(f)s = - 41^(1/2)/4 - 3/4 41^(1/2)/4 - 3/4&gt;&gt; digits(4);&gt;&gt; vpa(s)ans = -2.351 0.8508&gt;&gt; vpa(s,6)ans = -2.35078 0.850781","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——函数","slug":"13.Matlab-函数","date":"2020-04-15T10:19:00.000Z","updated":"2021-08-24T01:41:57.710Z","comments":true,"path":"matlab/2e83118e.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/2e83118e.html","excerpt":"脚本与函数脚本特点：","text":"脚本与函数脚本特点： 工作区所有变量保存在 base 工作区中，除非使用 clear 命令或关闭 matlab，否则将一直保存在 base 工作区 脚本不能返回输出变量，但创建的变量都保存在工作区中 函数特点： 若 M 文件的第一个可执行语句为 function，该文件为一函数文件 函数文件内定义的变量为局部变量，只在文件内部起作用，函数文件执行完毕后，内部变量将被清除 构成： 定义行：必须为文件第一行，function 引导，指明是一个函数文件，并定义函数名、输入参数、输出参数 H1 行：帮助文本第一行，函数定义下的第一个注释行，供 lookfor 查询使用 帮助文本：H1 行后，连续的注释行，起解释、查询的作用，以帮助用户建立自己的 help 在线查询信息 函数体：用于计算、输出等工作，其中语句可以是顺序、控制、循环语句，也可以是调用函数，还可以是交互式I/O、赋值、计算、注释、空行等 123456function num=cal(n)if n&gt;10 num=n*10;else num=n;end 说明： 函数定义名与文件名应一致，当两者不一致时，将忽视文件首行定义名，以保存文件名为准 函数文件名要满足变量命名规则，与变量命名不同的是，其不能超过 31 个字符 从文件结构来看，脚本文件与函数相比，只是少了一个函数声明，此外，两者语法与架构相同。 控制权return 指令：当被调用指令执行完毕后，matlab 会自动将控制权转回主函数或命令窗口，若在被调用函数中插入 return 语句，可以强制 matlab 结束执行并将控制权让出 pause 指令：pause(a) 表示程序暂停 a 秒后继续执行，但有时候也存在这种情况,程序中只有 pause，并没有参数 a，这样的意思是程序暂停，按任意键程序继续执行 子函数 多个函数可以写在同一个函数文件中，其中，第一个函数为主函数，其他所有函数为子函数 在一个函数文件中，子函数只能被主函数调用 每个子函数的第一行为定义行 子函数顺序可以任意改变 子函数通过函数名来调用 同一个函数文件中，主函数、子函数的工作区的独立的 123456789101112function num=cal(n)if n&gt;10 num=sub_fun1(n);else num=sub_fun2(n);endfunction temp1=sub_fun1(n)temp1=n*n;function temp2=sub_fun2(n)temp2=n+n; 匿名函数 不是函数文件，没有函数名，通过函数句柄调用 匿名函数只有表达式与参数 格式：函数名=@(参数1,参数2,...)表达式 1234fun=@(a,b)a*a+b*b;x=1;y=2;disp(fun(x,y)); 函数重载可变数量参数 varargin：可变数量输入参数元胞数组 varargout：可变数量输出参数元胞数组 nargin：在函数体内获得实际的输入变量 nargout：在函数体内获得实际的输出变量 narginchk(n,m)：在函数体内检查输入参数，当个数小于 n 或大于 m 时会报错 函数重载是什么： 函数名相同，参数个数或参数类型不同 通过函数参数的不同，来处理不同的情况 在 matlab 中，严格重载是指输入变量数量相同但变量类型不同时的重载，具体实现过于繁琐，不再赘述。 以下实现是通过对变量的合理运用，来实现函数重载的功能，并非严格意义上的函数重载。 123456789101112function num=test1(varargin) % 输入为可变参数narginchk(2,3); % 检测参数个数if nargin==2 % 如果参数个数为 2 a=varargin&#123;1&#125;; b=varargin&#123;2&#125;; num=max([a,b]);elseif nargin==3 % 如果参数个数为 3 a=varargin&#123;1&#125;; b=varargin&#123;2&#125;; c=varargin&#123;3&#125;; num=max([a,b,c]);end 跨空间变量传递与赋值工作区空间在 matlab 中，除基本工作区外，不同的脚本与函数是具有不同工作空间的。 在调用某个函数 fun 时，工作区的取值有两个： base：主调函数的工作区 caller：被调函数的工作区 跨空间变量传递 evalin(工作区,表达式) 当工作区为 base，表达式计算 eval(表达式) 时，从基本工作区获取变量值 当工作区为 caller，表达式计算 eval(表达式) 时，从主调函数基本工作区获取变量值 evalin(工作区,表达式1,表达式2)：首先从当前所在的工作空间获取变量值，并用 eval(表达式1) 来计算，若计算失败，则从工作区指定的工作区来获取变量值，并用 eval(表达式2) 来计算 跨空间变量赋值assignin(&#39;工作区&#39;,y,x)：将当前工作区中的变量 x 的值，赋给 工作区 中的指定变量 y","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"无线局域网概述","slug":"wireless-network/07.无线局域网概述","date":"2020-04-15T07:14:00.000Z","updated":"2021-10-31T14:04:56.877Z","comments":true,"path":"notes/wireless-network/644e78aa.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/644e78aa.html","excerpt":"【无线局域网】无线局域网（WLAN），是计算机网络与无线通信技术相结合的产物，通常指采用无线传输介质的计算机局域网，在距离有限区域内实现无线通信 其中，无线通信是指两台计算机之间能传输数据，无线网络是指以无线方式相连的计算机能共享资源，具有有线网络系统所支持的各种功能","text":"【无线局域网】无线局域网（WLAN），是计算机网络与无线通信技术相结合的产物，通常指采用无线传输介质的计算机局域网，在距离有限区域内实现无线通信 其中，无线通信是指两台计算机之间能传输数据，无线网络是指以无线方式相连的计算机能共享资源，具有有线网络系统所支持的各种功能 由于距离的差异，数据传输的范围也有所不同，这导致网络具体设计和实现方面有所区别，目前采用的是 IEEE 802.11x 标准与 HiperLAN 标准 无线局域网具有可移动、灵活性强、可伸缩性高、小型化、价格低等优点，但受制于带宽与系统容量，其可靠性、兼容性与共存性较差，覆盖范围较小，同时易受到干扰 根据频段、业务类型、拓扑结构进行分类，无线局域网可分为以下类型： 划分依据 类型 频段 自由频段、专用频段 业务类型 面向连接、非面向连接 拓扑结构 点对点式、基础结构式 【相关组织和标准】Wi-Fi （Wireless Fidelity）联盟，是一个非盈利组织，该组织致力于 802.11 WLAN 发展和实现，通过促进使用标准化 IEEE802.11 技术来鼓励全球 Wi-Fi 促进和推广家庭，小型办公和企业使用 Wi-Fi 产品，同时负责测试和保证以 Wi-Fi 的产品质量 WAPI 是中国无线网络产品国标中安全机制的标准，包括无线局域网鉴别（WAI）和保密基础结构（WPI）两部分 【组成】无线局域网由以下结构组成： 站/主机/终端（STA），是无线局域网的最基本组成单元，其包括终端用户设备、无线网络接口、网络软件等元素 无线接入点（AP），是无线局域网核心，其是移动计算机用户进入有线网络的接入点，主要用于宽带家庭、大楼内部以及园区内部，典型距离覆盖几十米至上百米 分布式系统 扩展业务区 无线介质（WM），是无线局域网传播的介质，目前常用的有无线电波和红外线 分布式系统（DS），是建立在网络之上的软件系统，具有高度的内聚性和透明性 【技术模式】基础结构网络基础结构无线网络是最基础的一种无线局域网结构，在该结构中，无线站点处于相对固定的位置，通过接入点来进行桥接，基本服务群（BSS）包含至少一个 AP 和两台移动设备 该网络由于其集中的特性，具有安全性、可扩展性较好，运作范围较大等特点，但路由简单，抗毁能力差 基础结构无线网络在拓展后称为扩展服务集合（ESS），其是由多个 BSS 组成的多区网，通过分布式系统链接组成的 无线自组织网络无线自组织网络（Ad-Hoc），其采用的是对等模式，设备间可直接通信，无需接入点支持，每个节点都有从一个节点转发到另一个节点的能力，具备独立的基本服务集 其应用于无接入点建立全无线网络和作为基础机构方案备份的可桥接的有线网络，在实际应用中，其常见于会议室、汽车上的临时笔记本会议、个人设备的互连等等 【服务】STA 服务STA 服务即站服务，其提供以下三种功能： 1.认证 有线网用物理接口来授权接入，无线介质无精确边界，考虑认证服务控制接入，所有站均认证获取其它站身份 两站间未建立交互式认证则无法建立连接，站间认证可为链路级认证，也可为端到端或用户到用户的认证 2.解除认证 欲终止已存在认证，解除认证服务，认证是连接的先决条件，因此解除认证将使站解除连接，解除认证服务可由任一连接实体唤醒 3.保密 有线 LAN 中只有物理连接站可侦听通信，无线共享介质中任何符合标准的站均可侦听其覆盖范围内所有物理层通信，无保密通信严重影响 WLAN 的安全性能 DS 服务DS 服务即分发系统服务，其提供以下五种功能： 1.关联 对给定站，DSS需知道接入哪个 AP，信息由关联提供给 DS，支持 BSS 切换移动，站通过AP发送数据前，先关联至 AP 欲建立关联，先唤醒关联服务，提供站到 DS 的 AP 映射，DS 使用该信息完成其消息分布业务 同时，在任一瞬间，一个站仅和一个 AP 关联 2.重新关联 BSS 切换移动需重新关联，即当前关联从一个 AP 移动到另一 AP，保持了 AP 与站间的当前映射 3.解除关联 终止一个已有关联时，会唤醒解除关联 4.分布 来自或发送到工作在 ESS 中的 WLAN 站每个数据消息唤醒，分布借助于 DSS 完成 5.集成 如果 DS 确定消息接收端为集成 LAN 成员，则 DS 输出点是端口而非 AP，分发到端口消息使 DS 唤醒集成功能，完成消息从 DSM 到集成 LAN 介质和地址空间变换 【主要标准】IEEE 802.11 标准IEEE802.11 标准包括多个子标准，如常见的 IEEE 802.11g、IEEE 802.11n、IEEE 802.11ac 等，WiFi 是其商业名称 子标准介绍如下： IEEE802.11g：采用补码键控（CCK）、OFDM、分组二进制卷积码（PBCC）等，可达 54Mbps 速率 IEEE 802.11n：进一步使用 MIMO/OFDM，速率提升至 300M 甚至 600Mbps IEEE 802.11ac：配置 1/2/4/8 天线 AP 的传输速率最高可达 867M/1.69G/3.39G/6.77Gbps HiperLAN 标准HiperLAN 由欧洲 ETSI 开发，具有如下四种标准： HiperLAN1：用于无线局域网接入 HiperLAN2：用于无线局域网接入 HiperLink：用于室内无线主干系统 HiperAccess：室外接入有线基础设施","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"面向对象设计","slug":"software-engineering/10.面向对象设计","date":"2020-04-13T02:13:00.000Z","updated":"2022-05-13T04:44:40.063Z","comments":true,"path":"notes/software-engineering/90bd4e06.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/90bd4e06.html","excerpt":"【概述】设计阶段的任务，是及时把分析阶段得到的需求转变成符合各项要求的系统实现方案 面向对象的方法不强调需求分析和软件设计的严格区分，实际上，面向对象的需求分析和面向对象的设计活动是一个反复迭代的过程，从分析到设计的过渡，是一个逐渐扩充、细化和完善分析阶段所得到的各种模型的过程","text":"【概述】设计阶段的任务，是及时把分析阶段得到的需求转变成符合各项要求的系统实现方案 面向对象的方法不强调需求分析和软件设计的严格区分，实际上，面向对象的需求分析和面向对象的设计活动是一个反复迭代的过程，从分析到设计的过渡，是一个逐渐扩充、细化和完善分析阶段所得到的各种模型的过程 严格的意义上来讲，从面向对象分析到面向对象设计不存在转换问题，而是同一种表示方法在不同范围的运用 面向对象设计也不仅仅是对面向对象分析模型进行细化。面向对象分析建立系统的问题域对象模型，而面向对象设计是建立求解域的对象模型 【面向对象设计的过程】面向对象的设计过程一般进行以下几个步骤： 建立软件体系结构环境图 软件体系结构设计 对各个子系统进行设计 对象设计及优化 建立软件体系结构环境图在软件体系结构设计开始的时候，设计应该定义与软件进行交互的外部实体以及交互的特性 一般在分析建模阶段可以获得这些信息，并使用软件体系结构环境图对环境进行建模，描述系统的出人信息流、用户界面和相关的支持处理 一旦建立了软件体系结构的环境图，描述出所有的外部软件接口，软件架构师就可以通过定义和求精实现软件体系结构的构件来描述系统的结构 这个过程可一直迭代，直到获得一个完善的软件体系结构。而在设计的初始阶段，系统设计师用系统环境图对软件与外部实体交互的方式进行建模 软件体系结构设计软件构环境图建立之后，对所有的外部软件接口进行了描述，就可以进行软件体系结构设计 软件体系结构设计可以自底向上进行，先为系统中最底层细节编程，然后逐步在更高层累计细节直至最终满足系统需求，如将关系紧密的对象组织成子系统或层 也可以自顶向下进行，通过分解功能来解决问题，尤其是使用设计模式或遗留系统时，会从子系统的划分入手 还可以自中向上下进行，先开始做系统中看来容易做的，再向相应的高层或底层扩展 对各个子系统进行设计大多数系统的面向对象设计模型，在逻辑上都由 4 大部分组成，这 4 大部分对应于组成目标系统的 4 个子系统： 问题域子系统 人—机交互子系统 任务管理子系统 数据管理子系统 在不同的软件系统中，这 4 个子系统的重要程度和规模可能相差很大，规模过大的在设计过程中应该进一步划分成更小的子系统，规模过小的可合并在其他子系统中 对象设计及优化对象设计是细化原有的分析对象，确定一些新的对象、对每一个子 系统接口和类进行准确详细的说明。 【面向对象设计的原则】面向对象的设计原则基本遵循传统软件设计应该遵循的基本原理，同时还要考虑面向对象的特点 设计原则具体有： 模块化 抽象化 信息隐藏 低耦合 高内聚 复用性 在长期的基于面向对象思想的软件开发实践中，遵循面向对象设计原则，人们总结出来一些经验，有利于提高开发人员进行软件设计的质量 启发规则具体如下： 设计结果应该清晰易懂：用词一致、使用已有的协议、避免模糊的定义 类等级深度应该适当：继承层次不要太深 尽量设计简单的类：避免包含过多属性、简化对象间的合作关系、不提供太多的方法 使用简单的协议 使用简单的操作 把设计的变动减至最小 【系统设计】一般来说，常用的系统设计步骤如下： 将系统分解为子系统 设计问题域子系统 设计人机交互子系统 设计任务管理子系统 设计数据管理子系统 系统分解把系统分解成若干个比较小的部分，然后再分别设计每个部分，这 样做不仅能降低设计的难度，还有利于软件开发人员的分工协作、维护人员对系统理解和维护。 系统的主要组成部分称为子系统，通常根据所提供的功能来划分，各个子系统之间接口应尽可能简单、明确，同时减少子系统彼此间的依赖性 问题域子系统问题域子系统的设计基础是在分析阶段精确问题域模型，通过从实现角度补充、修改问题域模型来完成该阶段的设计任务 可能做出的补充或修改如下： 调整需求：用户需求或外部环境变化、分析模型不完整或不准确 复用已有的类：将从类库或其他来源的既存类增加到问题解决方案中 把问题域类组合在一起：设计时，在类库中引进一个根类，作为包容类，将所有与问题域有关的类关联到一起，建立类的层次 增添一般化类：所有的类组织在一起提供全系统通用的协议，比如创建、复制、删除等操作 调整继承层：在建立的对象模型中可能包含多继承关系，但实现时使用程序设计语言可能只有单继承，需对分析结果进行修改 人机交互子系统人机交互子系统强调人如何命令系统，以及系统如何向用户提交信息， 人们在使用计算机过程中的感受直接影响其对系统的接受程度、评价 在现在的大型软件系统中，人机交互对象通常是窗口或报告，软件设计者至少要考虑以下 3 种窗口： 安全/登录窗口，其是用户访问系统的必经之路 设置窗口，其具有以下功能： 创建或初始化系统运行必需的对象 系统管理功能 启动或关闭设备 业务功能窗口，这种窗口用来帮助完成那些由信息系统和其用户所进行的业务交互所必要的功能 任务管理子系统在实际系统中，许多对象之间往往存在相互依赖关系，设计工作的一项重要内容就是，确定哪些是必须同时动作的对象，哪些是相互排斥的对象，进一步设计任务管理子系统 设计任务管理子系统，包括确定各类任务并把任务分配给适当的硬件或软件去执行，其前置工作是分析并发性 并发对象有两种，一种是无交互行为的对象，另一种是同时接受事件的对象 在找出并发对象后，检查各个对象的状态图，找出未并发对象的路径（控制线），之后，通过分离出控制线设计任务 任务有多种类型： 事件驱动型任务：这类任务可能主要完成通信工作，如与设备、屏幕窗口、其他任务、子系统、另一个处理器或其他系统通信 时钟驱动型任务：某些任务每隔一定时间间隔就被触发以执行某些处理，如某些设备需要周期性地获得数据或通信 优先任务：优先任务可以满足高优先级或低优先级的处理需求 关键任务：关键任务是有关系统成功或失败的关键处理，这类处理都有严格的可靠性要求 协调任务：当系统中存在 3 个以上任务时，就应该增加一个任务，用它作为协调任务 在确定任务类型后，需要进行以下工作： 审查每个任务：对任务的性质进行仔细审查，去掉人为的、不必要的任务，使系统中包含的任务数保持到最少 确定资源需求：设计者在决定到底采用软件还是硬件的时候，必须综合权衡一致性、成本、性能等多种因素，还要考虑未来的可扩充性和可修改性 定义任务：说明任务的名称，描述任务的功能、优先级，包含此任务的服务、任务与其他任务的协同方式以及任务的通信方式 最后综合考虑，确定哪些任务硬件实现，哪些任务软件实现 数据管理子系统数据管理子系统是系统存储或检索对象的基本设施，它建立在某种数据存储管理系统之上，并且隔离了数据存储管理模式的影响，但实现细节集中在数据管理子系统中 这样既有利于软件的扩充、移植和维护，又简化了软件设计、编码和测试的过程。 设计数据管理子系统的核心在于设计数据格式，数据格式与数据存储管理模式密切相关： 文件系统：达到第一范式，减少文件数，编码减少文件中的属性值 关系型数据库：达到第三范式，满足性能和存储需求 面向对象数据库：达到第三范式，满足性能和存储需求 【对象设计】概述对象设计以问题域的对象设计为核心，其结果是一个详细的对象模型 经过多次反复的分析和系统设计之后，设计者通常会发现有些内容没有考虑到，这些没有考虑到的内容，会在对象设计的过程中被发现 这个设计过程包括标识新的解决方案对象、调整购买到的商业化构件、对每个子系统接口的精确说明和类的详细说明等 面向对象分析得出的对象模型，通常并不详细描述类中的服务；面向对象设计则是扩充、完善和细化面向对象分析模型的过程，设计类中的服务、实现服务的算法是面向对象设计的重要任务，还要设计类的关联、接口形式以及设计的优化 对象设计的内容包括： 对象中对属性和操作的详细描述 对象之间发送消息的协议 类之间的各种关系的定义 对象之间的动态交互行为 设计类的服务在功能模型的数据处理中，当一个处理涉及多个对象时，可参考如 下规则帮助确定服务的归属类 对于被修改的类，如果处理影响或修改了一个对象，则最好把该处理与处理目标联系在一起 对于关联中心的类，考查处理涉及的对象类以及这些类之间的关联，找到处于中心地位的类 设计类的关联使用关联有两种可能的方式：单向遍历和双向遍历，单向遍历相对简单，仅需考虑一方到另一方；双向遍历较为复杂，要考虑双方的关系 对于关联对象来说，有以下三种情况： 一对一：与任一个对象合并，如学生证和准考证 一对多：与多端合并，如学生和班级 多对多：使用独立的关联类，如学生和选修课 对象设计优化系统的各项质量指标并不是同等重要的，设计人员必须确定各项质量指标的相对重要性，此外，优化目标之间还可能存在冲突，因此要确定质量指标优先级 可以采用增加冗余关联、调整查询次序、保留派生属性等方法来提高效率 此外，建立良好的继承关系是优化设计的一项重要内容，为保证继承关系的清晰性，经常需要调整以下三个方面： 抽象与具体：归纳和具体化是一个持续不断的演化过程 提高继承程度：确保现有类的协议不变的情况下，不违背领域知识和常识 利用委托实现行为共享：把一类对象作为另一类对象的属性，从而在两类对象之间 建立组合关系的一种方法","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"Matlab——循环结构","slug":"12.Matlab-循环结构","date":"2020-04-11T11:10:00.000Z","updated":"2021-08-24T01:42:12.740Z","comments":true,"path":"matlab/5f7532dd.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/5f7532dd.html","excerpt":"【循环结构】循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构，其根据循环体中的条件来判断继续执行某个功能还是退出循环。 循环结构可以看做一个条件判断语句与一个转向语句的组合，其三要素是：循环变量、循环体、循环终止条件。","text":"【循环结构】循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构，其根据循环体中的条件来判断继续执行某个功能还是退出循环。 循环结构可以看做一个条件判断语句与一个转向语句的组合，其三要素是：循环变量、循环体、循环终止条件。 依据判断条件，循环结构分为当型循环和直到型循环 当型循环：先判断再执行，直到条件不成立时退出循环（for 语句、while 语句） 直到型循环：先执行，后判断（do-while 语句，matlab中没有，若想使用，需将 while 与 if 语句结合构建） 【for 语句】语句结构： 123for 循环条件 语句序列end 流程图： 实例： 12345sum=0;for i=1:100 sum=sum+i;enddisp(sum); 说明： 循环条件是切片表达式 start:step:end，用于指定循环体的执行次数，该次数由切片表达式所创建的数组的列数来确定 语句序列被称为循环体，其可以是一条命令、多条命令(顺序结构)、控制结构、循环结构 依靠缩进来识别代码块 语句以end结尾 for 语句执行次数是确定的，执行次数为：$\\frac{end-start}{step}$ 【while 语句】语句结构： 123while 循环条件 语句序列end 流程图： 实例： 1234567sum=0;i=1;while i&lt;=100 sum=sum+i; i=i+1;enddisp(sum); 说明： 循环条件是一个关系表达式或逻辑表达式，通过表达式来控制循环体执行的次数 语句序列被称为循环体，其可以是一条命令、多条命令(顺序结构)、控制结构、循环结构 依靠缩进来识别代码块 语句以end结尾 表达式的值一般都是标量值，但若表达式为数组且所有元素逻辑值为真时，while 语句依然会照样执行循环，但不推荐将数组作为表达式使用，若表达式为空数组时，默认值为假，结束循环 与 for 语句的区别：while 语句执行次数不确定，for 语句执行次数确定 【do-while 语句】由于 for 语句和 while 语句都是当型循环，而 matlab 中并没有提供直到型循环，因此若想使用直到型循环，需要自己进行构建。 语句结构： 123456while 1 语句序列 if 循环条件 break; endend 流程图： 实例： 12345678910sum=0;i=1;while 1 sum=sum+i; i=i+1; if i==101 break endenddisp(sum); 【continue 与 break】continue 语句continue 语句会将控制权传给下一个循环的迭代，忽略该次循环剩下的语句。 在循环嵌套中，在内层循环中使用 continue 会把控制权传给本次外层循环中，下一个内层循环所嵌套的迭代。 简单来说，使用 continue 后，直接结束本层循环，前往下一层循环。 在实际应用中，常通过 if 语句来控制是否执行 continue 实例： 12345678910sum=0;i=1;while i&lt;=100 i=i+1; if mod(i,10)==0 continue end sum=sum+i;enddisp(sum); break 语句在循环语句中，有时不需要运行到最后一次循环，即可得到所需的结果，那么后续的循环过程不仅浪费了运行时间，还占据了内存。 利用 break 语句，可以立即终止循环结构。 在实际应用中，常通过 if 语句来控制是否执行 break 实例： 12345678910sum=0;i=1;while i&lt;=100 i=i+1; sum=sum+i; if i==11 break; endenddisp(sum); 【循环下的数组与结构体】数组预分配空间：a=[]*n，n 是分配的空间数 将多个数据输入到数组： 方法一：循环输入 12345n=input('n=');a=[]*n;for i=1:n a(i)=input('a=');end 方法二：一次性输入，循环解析 1234567n=input('n=');a=[]*n;str=input('str=','s');str=strsplit(str,' '); % 按空格分割字符串，返回值是一元胞数组for i=1:n a(i)=str2num(str&#123;i&#125;);end 循环访问数组： 123for i=1:n disp(a(i));end 结构体数组定义： 1234for i=1:n people(i).name=input('name:','s'); people(i).age=input('age:');end 访问： 123for i=1:n disp(people(i).name);end","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——选择控制结构","slug":"11.Matlab-选择控制结构","date":"2020-04-10T10:07:00.000Z","updated":"2021-08-24T01:41:42.765Z","comments":true,"path":"matlab/4c19daf0.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/4c19daf0.html","excerpt":"【选择控制结构】选择控制结构又称为分支结构，当程序执行到控制分支的语句时，首先判断条件，根据条件表达式的值选择相应的语句执行，并放弃另一部分语句的执行。 其既可以与顺序结构组合来构建简单的程序，也可以与顺序、循环结构组合构建复杂的程序。","text":"【选择控制结构】选择控制结构又称为分支结构，当程序执行到控制分支的语句时，首先判断条件，根据条件表达式的值选择相应的语句执行，并放弃另一部分语句的执行。 其既可以与顺序结构组合来构建简单的程序，也可以与顺序、循环结构组合构建复杂的程序。 【if 语句】单分支结构(if 表达式)语句结构： 123if 条件表达式 语句序列 % 条件表达式为真时，执行end 流程图： 实例： 12345a=rand(1)*10;disp(a);if a&gt;=5 disp('a&gt;=5');end 二分支结构(if-else 表达式)语句结构： 12345if 条件表达式 语句序列1 % 条件表达式为真时，执行else 语句序列2 % 条件表达式为假时，执行end 流程图： 实例： 1234567a=rand(1)*10;disp(a);if a&gt;=5 disp('a&gt;=5');else disp('a&lt;5');end 多分支结构(if-elseif-else 表达式)语句结构： 12345678910if 条件表达式1 语句序列1 % 条件表达式1为真时，执行elseif 条件表达式2 语句序列2 % 前1个条件表达式为假，条件表达式2为真时，执行elseif 条件表达式3 语句序列3 % 前2个条件表达式为假，条件表达式3为真时，执行...else 语句序列n % 前n-1个条件表达式均为假时，执行end 流程图（以存在 3 个条件表达式的分支结构为例）： 实例： 1234567891011a=rand(1)*10;disp(a);if a&lt;=3 disp('a&lt;=3');elseif a&lt;=6 disp('3&lt;a&lt;=6');elseif a&lt;=9 disp('a&lt;6&lt;=9');else disp('a&gt;9');end 【switch-case 语句】使用作用：根据表达式的值，使流程跳转到不同的语句 语句结构： 12345678910111213switch 表达式 case 常量1 % 表达式=标量1 语句序列1 % 执行语句序列1 case 常量2 % 表达式=标量2 语句序列2 % 执行语句序列2 case 常量3 % 表达式=标量3 语句序列3 % 执行语句序列3 ... case 常量n % 表达式=标量n 语句序列n % 执行语句序列n otherwise % 表达式不等于上面的 n 个值 语句序列n+1 % 执行语句序列n+1end 流程图（以 3-case 语句为例）： 12345678910a=ceil(rand(1)*10);disp(a);switch a case 1 disp('a=1'); case 2 disp('a=2') otherwise disp('a&gt;2')end 与 if 语句的比较 if 语句 switch 语句 嵌套的 if 语句可读性弱 可读性强 比较字符串时，使用 strcmp() 函数进行比较 比较字符串时，自动调用strcmp()进行比较 可检测连续值、离散值 只能检测离散值 【try-catch 语句】作用：捕获异常并处理 语句结构： 12345try 语句序列1 % 首先执行该序列，若执行过程中未出现错误，结束；若执行过程中出现错误，执行语句序列2catch 语句序列2 % 语句序列1出错时，执行end 流程图： 123456789try a=1; b=[1,2;1]; a=2catch b=1enddisp(a);disp(b); 【说明】共性： 三种语句结构最后必须以 end 结尾 依靠缩进来识别代码块 语句序列中可以是一条命令、多条命令(顺序结构)、控制结构、循环结构 建议在语句序列中的代码结尾加上分号 ;，负责会将该语句执行完毕后的值输出 if 语句： 在 if 语句中嵌套 if 语句时： 嵌套时，if、elseif、else 以缩进进行匹配 在 if-else 中嵌套一个 if-else，本质上与 if-elseif-else 相同 在实际编程时，应适当控制嵌套层数，建议不超过 3 层 switch-case 语句： 要求 n 个标量不能相同 switch-case 语句 的表达式要求为标量或字符串 当表达式为标量时，会执行 表达值==检测值 i 来比较 当表达式为字符串时，会执行 strcmp(表达式,检测值i) 来比较 try-catch 语句： try-catch 语句只提供两个可供选择的语句序列，在实际应用中，往往嵌套使用 对于语句序列 1 来说，在其执行过程中，若某条语句出错，该语句之上的运行结果依然保留，只是该语句之后的语句不再执行 常用的错误或警告指令有： lasterr：显示上一次错误信息，并终止程序 lastwarn：显示上一次警告信息，并继续运行程序 errortrap：错误发生后，控制程序是否继续执行 error(&#39;message&#39;)：显示上一次出错信息 message，并终止程序 lastwarn(&#39;message&#39;)：显示上一次警告信息 message，并继续运行程序","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——顺序结构","slug":"10.Matlab-顺序结构","date":"2020-04-08T10:04:00.000Z","updated":"2021-08-24T01:39:36.855Z","comments":true,"path":"matlab/a0138224.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/a0138224.html","excerpt":"【顺序结构】顺序结构最简单的一种程序设计结构，按照解决问题的顺序写出相应的语句，自上而下依次执行 顺序结构既可以单独使用来构建一个简单的程序，也可以和控制结构、循环结构组合使用来构建程序","text":"【顺序结构】顺序结构最简单的一种程序设计结构，按照解决问题的顺序写出相应的语句，自上而下依次执行 顺序结构既可以单独使用来构建一个简单的程序，也可以和控制结构、循环结构组合使用来构建程序 顺序结构三个模块：输入、计算、输出（缺一不可） 三大模块缺一不可的原因：计算机是执行输入、计算、输出的机器（计算机的定义） 没有输入：不能凭空产生东西，必须有一个数据源 没有计算：必须要对数据进行处理，否则等同于电线（输入-&gt;输出） 没有输出：处理后不输出，等同于一个堆积信息的垃圾箱 【输入】input 数值类型：num=input(str)，str 是一个字符串，会打印出来，展示给用户 数组/元胞类型：A=input(str)，要求输入格式必须是数组格式 逻辑类型：logical_num=logcial(input(str)) 扩展1：是否所有的输入都可以进行强制转换？是 扩展2：强制转换会怎么样？带来精度损失 字符类型：a=input(str,&#39;s&#39;)，&#39;s&#39;是强制要求的，必须要带 文件输入详见 I/O 操作 【输出】Disp(x)最简单的一种输出，直接将变量 x 的变量值输出 Format作用：控制输出格式 特点：利用format控制格式后，所有输出都会按照格式进行输出 用法： 12format 格式控制符变量名 优点：可以批量控制格式 缺点：若想不再按控制格式输出，需要再次使用 format 来终止格式控制 因此，一般用法为： 123format 格式控制符变量名format 关于 format 格式控制符详见：格式控制符 fprintf特点：可以控制格式输出，仅一次，类似 C/C++ 中的 printf 用法：fprintf(&#39;%d&#39;,a) 优点：可以结合 fopen 输出到文件中 缺点：无法输出数组 常用的控制符： %d：数 %c：单个字符 %s：字符串 \\n：换行符 \\t：tab 字符 文件输出见 I/O 操作","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——变量、关键字与注释","slug":"09.Matlab-变量、关键字与注释","date":"2020-04-08T10:02:00.000Z","updated":"2021-08-24T01:39:41.292Z","comments":true,"path":"matlab/a63138db.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/a63138db.html","excerpt":"【变量是什么】变量，在数学层面表示数字的字母字符，具有任意性和未知性 计算机层面，是一个能储存计算结果、能表示值的抽象概念，其本质是是一段具有可操作性的内存，即内存的符号化表示","text":"【变量是什么】变量，在数学层面表示数字的字母字符，具有任意性和未知性 计算机层面，是一个能储存计算结果、能表示值的抽象概念，其本质是是一段具有可操作性的内存，即内存的符号化表示 当在程序中需要使用内存时，可以定义一个变量，编译器根据变量的数据类型分配一定的空间，程序即可通过变量名来访问对应的内存 系统定义的关键字，有特殊用途，可在命令行中用 iskeyword查看 【变量命名】命名规则 大小写敏感 必须以字母开头，其后是任意字母、数字、下划线，不能有中文字符、标点、空格 不能使用关键字作为变量，例如：if、else 变量名长度不超过63个字符，第64个字符开始，其与其之后的字符会被忽略 变量名一般具有一定的含义，便于可读、可维护 命名方法（下划线命名法）目的：命名规范，便于集体协作，使程序可读可维护性强 命名规则： 局部变量：小写字母+下划线，例如：cup_width_size 全局变量：大写字母+下划线，例如：CUP_WIDTH_SIZE 【变量类型】局部变量每一函数都有自己的局部变量，存储在属于函数的独立工作区中（堆栈），与其他函数、主工作区变量分开存储，调用结束后随之删除。 命名：一般用小写字母+下划线表示 定义格式：变量名=变量值，若不想指定值，可以设为空矩阵 [] 全局在定义该变量的全部工作区中有效，在一个工作区中改变变量的值，其余工作区的值也改变，设置目的是减少参数传递 命名：一般用大写字母+下划线表示 定义格式：global X 永久只允许声明该变量的函数使用，当声明他的函数退出时，不会将其从内存中删除，不推荐使用 定义格式：presistent a 默认特设函数默认特设函数是 matlab 中内部设置的变量 ans：默认用于保存运算结果 pi：圆周率 i、j：虚数单位 无穷大与不定数：inf、NaN beep：使操作系统发出声音，常用于异常抛出时使用 【注释】说明代码用途，不参与程序运行 使用：% 特点：以 % 开头，到行尾结束的部分，可以在程序任何位置，也可以单起一行","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——矩阵进阶","slug":"08.Matlab-矩阵进阶","date":"2020-04-06T09:58:00.000Z","updated":"2021-08-24T01:40:07.916Z","comments":true,"path":"matlab/fa60ea29.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/fa60ea29.html","excerpt":"【范数】定义：$||x||_p=(\\sum_{i=1}^n|x_i|^p)^{\\frac{1}{p}}$，p 阶范数，记做 $L_p$ 根据 x 是矩阵还是向量，分为向量范数、矩阵范数，其中矩阵范数是由向量范数推导过来的，含义相近","text":"【范数】定义：$||x||_p=(\\sum_{i=1}^n|x_i|^p)^{\\frac{1}{p}}$，p 阶范数，记做 $L_p$ 根据 x 是矩阵还是向量，分为向量范数、矩阵范数，其中矩阵范数是由向量范数推导过来的，含义相近 对于常用的向量范数有： 当 p=0 时：$L_0=(\\sqrt[0]{\\sum_{i=1}^n|x_t|^0})=i|x_i\\neq 0$，即向量中非 0 个数 当 p=1 时：$L_1=\\sum_i|x_i|$，即向量中所有元素的绝对值的和 当 p=2 时：$L_2=\\sqrt{\\sum_i x_i^2}$，即向量的元素平方和 当 $p=\\infty$ 时：$L_\\infty=max\\{x_i\\}$，即向量的元素最大值 当 $p=-\\infty$ 时：$L_{-\\infty}=min\\{x_i\\}$，即向量的元素最小值 对于常用的矩阵范数有： 当 p=1 时：$L_1$ 为矩阵中列元素的绝对值的和的最大值，等价于 max(sum(abs(a))) 当 p=2 时：$L_2$ 为矩阵的最大奇异值 当 $p=\\infty$ 时：$L_\\infty$ 为矩阵的转置的列元素绝对值和的最大值，等价于 max(sum(abs(a&#39;))) 当 $p=-\\infty$ 时：$L_{-\\infty}$为转置矩阵与矩阵乘积取对角后的和的开方，等价于 sqrt(sum(a&#39;*a)) 在 matlab 中，利用 norm() 求范数： norm(x,p)：返回 x 的 p 阶范数，默认 p=2 12&gt;&gt; norm([1:6],2)ans = 9.5394 由于矩阵的二阶范数并不好计算，有时会花费过长的时间，当只需给一个近似范数值时，利用 normest() 来计算二阶范数 normest(x)：计算矩阵 x 的二阶范数 normest(x,tol)：计算矩阵 x 的二阶范数，相对误差为 tol 123&gt;&gt; a=[1,2,3;3,4,5;7,8,9];&gt;&gt; normest(a)ans = 16.02158 【矩阵的秩】行秩：矩阵中线性无关的行向量 列秩：矩阵中线性无关的列向量 在 matlab 中，利用 rank() 来求矩阵的秩 rank(A)：以默认误差来计算 A 的秩，默认误差为：max(size(a))*eps(norm(a)) rank(A,tol)：以 tol 指定相对误差来计算 A 的秩 123&gt;&gt; a=magic(3);&gt;&gt; rank(a)ans = 3 【行列式】在 matlab 中，利用 det(A) 来求矩阵的行列式 123&gt;&gt; a=magic(5);&gt;&gt; det(a)ans = 507000 【矩阵的迹】定义：矩阵对角元素和 在 matlab 中，利用 trace() 来计算矩阵的迹 123&gt;&gt; a=magic(5);&gt;&gt; trace(a)ans = 65 【矩阵的化零矩阵】定义：对于非满秩矩阵 A，若存在矩阵 B 使 AB=0，且 BB‘=I，则称矩阵 B 为矩阵 A 的化零矩阵 在 matlab 中，利用 null() 求矩阵的化零矩阵，若不存在返回空矩阵 12345678910&gt;&gt; a=magic(3);&gt;&gt; null(a)ans = 空矩阵: 3×0&gt;&gt; a=[1,2,3;4,5,6;7,8,9];&gt;&gt; null(a)ans = -0.4082 0.8165 -0.4082 【矩阵的正交空间】定义：矩阵 A 的正交空间 Q，具有 Q’Q=I 的性质，且 Q 的列向量构成的线性空间与 A 的列向量构成的线性空间相同，同时，Q 与 A 具有相同的秩 在 matlab 中，利用 orth() 来求正交空间 123456&gt;&gt; a=[1,2,3;4,5,6;7,8,9];&gt;&gt; orth(a)ans = -0.2148 0.8872 -0.5206 0.2496 -0.8263 -0.3879 【约化行阶梯形式】在 matlab 中，利用 rref() 来将矩阵转为约化行阶梯形式 123456&gt;&gt; a=[1,2,3;4,5,6;7,8,9];&gt;&gt; rref(a)ans = 1 0 -1 0 1 2 0 0 0 【矩阵夹角】在 matlab 中，利用 subspace() 来求矩阵空间的夹角 1234&gt;&gt; a=[1,2,3;4,5,6;7,8,9];&gt;&gt; b=magic(3);&gt;&gt; subspace(a,b)ans = 6.8286e-16 【矩阵分解】矩阵分解，是将一个复杂的矩阵分解为几个较简单的矩阵连乘的形式 矩阵分解，是将一个复杂的矩阵分解为几个较简单的矩阵连乘的形式 在 matlab 中，各种调用方式均相似，以对称正定矩阵 Cholesky 分解为例： R=chol(A)：返回对称正定矩阵 X 的上三角矩阵 R，使得 R’R=X 函数 作用 cholinc 稀疏矩阵的不完全 Cholesky 分解 lu 矩阵 LU 分解 luinc 稀疏矩阵的不完全 LU 分解 qr QR 分解 svd 奇异值分解 gsvd 一般奇异值分解 schur 舒尔分解 123456789101112131415&gt;&gt; a=pascal(3)a = 1 1 1 1 2 3 1 3 6&gt;&gt; r=chol(a)r = 1 1 1 0 1 2 0 0 1&gt;&gt; r'*rans = 1 1 1 1 2 3 1 3 6 【特征向量与特征值】在 matlab 中，利用 eig() 来求矩阵的特征向量 d=eig(A)：求 A 的特征值向量 d [x,d]=eig(A)：求满足 ax=xd 的矩阵 x、d 12345678910111213141516&gt;&gt; a=magic(3);&gt;&gt; eig(a)ans = 15.0000 4.8990 -4.8990 &gt;&gt; [x,d]=eig(a)x = -0.5774 -0.8131 -0.3416 -0.5774 0.4714 -0.4714 -0.5774 0.3416 0.8131d = 15.0000 0 0 0 4.8990 0 0 0 -4.8990 【稀疏矩阵】由于稀疏矩阵的特性，其按列存储的方式过于占用存储空间，因此在 matlab 中，以 (行,列) 值 的方式对稀疏矩阵存储 sparse(A)：生成稀疏矩阵 A，若 A 已经为一个稀疏矩阵，返回 A 本身 full(A)：将稀疏矩阵 A 转为满矩阵 1234567891011&gt;&gt; sparse([1,2,3;0,0,0;0,1,0])ans = (1,1) 1 (1,2) 2 (3,2) 1 (1,3) 3&gt;&gt; full(ans)ans = 1 2 3 0 0 0 0 1 0","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——特殊矩阵","slug":"07.Matlab-特殊矩阵","date":"2020-04-06T09:39:00.000Z","updated":"2021-08-24T01:40:15.303Z","comments":true,"path":"matlab/aa01d998.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/aa01d998.html","excerpt":"【概述】在 matlab 中，我们经常会对矩阵进行测试，为了便于测试，matlab 中给出了一些常用的测试矩阵，其满足一些性质 常见的特殊矩阵有：魔方矩阵、随机矩阵、希尔伯特矩阵、范德蒙矩阵、托普利兹矩阵、帕斯卡矩阵","text":"【概述】在 matlab 中，我们经常会对矩阵进行测试，为了便于测试，matlab 中给出了一些常用的测试矩阵，其满足一些性质 常见的特殊矩阵有：魔方矩阵、随机矩阵、希尔伯特矩阵、范德蒙矩阵、托普利兹矩阵、帕斯卡矩阵 【魔方矩阵】 特征：当 $n\\geq 2$ 时，每行、每列、两对角线元素和相等 创建：magic(n) 【随机矩阵】普通随机矩阵： rand(n)：生成矩阵元素为 0~1 的 $n*n$ 方阵 rand(n,m,p,...q)：生成矩阵元素为 0~1 的 $n*m*p*…*q$ 的矩阵 满足正态分布的随机矩阵： randn(n)：生成矩阵元素为 0~1 之间满足正态分布的 $n*n$ 方阵 rand(n,m,p,...q)：生成矩阵元素为 0~1 之间满足正态分布的 $n*m*p*…*q$ 的矩阵 应用： 若想生成一个 1~10 的 $3*3$ 的方阵，可以将rand(n)与乘法、取整函数组合使用，即：ceil(10\\*rand(3)) 【希尔伯特矩阵】 特征：$H(i,j)=\\frac{1}{(i+j-1)}$、条件数差矩阵、关于主对角线对称 创建：hilb(n) 逆希尔伯特矩阵：inhilb(n) 【范德蒙矩阵】 特征：$A(i,j)=v(i)^{(n-j)},n=length(v)$ 生成：vander(v) 【托普利兹矩阵】 特征：主对角线元素相等，平行于主对角线的元素相等，关于次对角线对称 创建： toeplitz(v)：利用向量 v 生成一个托普利兹矩阵 toeplitz(k,r)：非对称托普利兹矩阵，第一列为向量 k，第一行为向量 r，其余元素等于其左上角元素 【帕斯卡矩阵】 特征：杨辉三角表形成的矩阵，二次项展开的系数 创建： Pascal(n)：n 阶对称正定帕斯卡矩阵 Pascal(n,1)：由下三角的 Cholesky 因子组成的帕斯卡矩阵，是对称的，自己是自己的逆 Pascal(n,2)：返回 Pascal(n,1) 的转置和交换形式","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"面向对象分析","slug":"software-engineering/09.面向对象分析","date":"2020-04-06T02:28:00.000Z","updated":"2022-05-13T04:43:30.772Z","comments":true,"path":"notes/software-engineering/d33b4cf1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/d33b4cf1.html","excerpt":"【面向对象分析流程】面向对象分析过程分为以下几步： 获取需求 整理需求 建立模型 需求规格说明书 复审","text":"【面向对象分析流程】面向对象分析过程分为以下几步： 获取需求 整理需求 建立模型 需求规格说明书 复审 在获取需求阶段，可以通过以下方法来获取需求： 与用户交谈，向用户提问题 参观用户的工作流程，观察用户的操作 向用户群体发调查问卷 与同行、专家交谈，听取他们的意见 分析已经存在的同类软件产品，提取需求 从行业标准、规则中提取需求 在整理需求阶段，需要书写需求陈述，需求陈述内容包括问题范围、功能需求、性能需求、应用环境及假设条件。 面向对象分析模型由三个独立模型组成： 对象模型：描述静态结构，用类图和对象图表示 动态模型：描述交互过程，用状态图和顺序图表示 功能模型：指明系统数据之间的依赖关系，有关数据处理的功能，用数据流图表示 【对象模型】概述大型系统的对象模型通常由：主题层、类与对象层、结构层、属性层和服务层，这 5 个层次组成 这 5 个层次对应着在面向对象分析过程中建立对象模型的 5 项主要活动：划分主题、确定类与对象、识别结构、确定属性、确定服务。 划分主题主题是把一组具有较强联系的类组织在一起而得到的类的集合 对于小系统来说，不需引入主题；对于中等系统来说，需要标识类及对象和关联，从而划分主题；对于大系统，先粗略识别对象和关联初步划分主题，通过分析，进一步修改和精炼主题 主题的划分有以下两种方式： 自底向上，先建立对象类，然后把对象类中关系较密切的类组织为一个主题。如果主题数量仍然很多，则可进一步将联系较强的小主题组织为大主题，直到系统中最上层主题数不超过 7 个，适用于小型系统或中型系统 自顶向下，先分析系统，确定几个大的主题，每个主题相当于一个子系统，将这些子系统再分别进行面向对象分析，建立各个子系统中的对象类，最终可将各个子系统合并为一个大的子系统，适用于大型系统 在划分主题时，可以利用以下技巧来进行划分： 把类图中每个结构作为一个主题 通过实例连接互相联系的类可划分到一个主题 不属于任何结构，也没有实例连接的类作为一个主题 上述的主题划分的最终结果能够形成一个完整的对象类图和一个主题图 主题图一般有如下表示方式： 展开方式：将关系较密切的对象类画在一个框内，框的每个角标上主题号，框内是详细的对象类图，标出每个类的属性和服务以及类之间的详细关系 压缩方式：将每个主题号及主题名分别写在一个框内 半展开方式：将每个框内主题号、主题名及该主题中所含的对象类全部列出 主题图的展开方式是为了表明系统的详细情况，压缩方式是为了表明系统的总体情况，半展开方式是两者的结合。 确定类与对象建立对象模型首先要确定对象、类，需要列出所有候选类和对象，然后从候选类与对象中筛选掉不正确的或不必要的 识别类与对象的技巧有： 建立候选类列表 结合需求陈述中的名词确定 根据用例确定（边界类、控制类） 而筛选类与对象的依据有： 冗余：去除重复的描述，保留一个，例如，储户与用户，现金兑换卡与磁卡及副本等 无关：去除与本系统无关的对象，将密切相关类放进目标系统，例如，街道、营业厅等 笼统：去除掉无需记忆的笼统陈述，使其更具明确性，例如，软件、信息、网络等 属性：去掉为其它对象属性的名词，例如，现金、支票、余额等 操作：既为名词又为动词的，应慎重考虑 实现：去除与实现相关的类 识别结构识别结构，又称确定关联，在经过初步确定关联后，经过筛选，进一步完善 在初步确定中，有如下技巧： 直接提取动词与动词短语 从需求陈述中寻找隐含的关联 与用户及领域专家讨论补充，根据问题域知识得出关联 初步确认后，需要进行筛选，技巧有： 在确定类与对象中，若已删除某候选类，那么与这个类有关的关联也应删去 删除与问题无关或与实现密切相关的关联 删除瞬时事件 三个或三个以上对象关联，可分解为二元关联或限定关联 在筛选完成后，需要通过以下步骤来进一步完善： 正名：给出容易理解的名字 分解补充：将一个综合功能的事务分解为两个单一功能的事务 标明阶数：标明这个对象或类跟多少个其它对象或类有关联 确定属性属性是对象的数据特性，确定属性的过程分为分析与选择两个阶段 在分析阶段中，可根据需求陈述中的名词和形容词、借助领域知识和常识、问题域、目标系统的任务来确定属性 在选择阶段中，需要筛出不重要的或者不正确的属性，筛选的原则有以下几个： 该属性是否提供了系统中有用的信息 该属性是否描述这个对象本身的特征 该属性是否破坏了对象特征的原子性 该属性是否可以通过继承得到 是否可以从其它属性直接导出该属性 标识一个属性的启发性准则如下： 按一般常识这个对象应该有哪些属性 在当前的问题域中，对象应该有哪些属性 根据系统责任的要求，对象应具有哪些属性 建立对象是为了保存和管理哪些信息 对象为了在服务中实现其功能，需要增设哪些属性 对象有哪些需要区别的状态，是否需要增加一个属性来区别这些状态 确定服务对象，是由描述其属性的数据以及可以对这些数据施加的操作（方法或服务），封装在一起构成的独立单元 因此，为建立完整的对象模型，既要确定类中应该定义的属性，又要确定类中应该定义的服务 但是，需要等到建立了动态模型和功能模型之后，才能最终确定类中应有的服务，因为这两个模型更明确地描述了每个类中应该提供哪些服务 实际上，在确定类中应有的服务时，既要考虑该类实体的常规行为，又要考虑在本系统中特殊需要的服务 【动态模型】动态模型的建立可分为三步： 编写典型交互行为脚本 从脚本中提取事件及相关对象，用 UML 顺序图表达 确定对象状态及状态间转换关系，用状态图描绘 在建立动态模型过程中，脚本是系统执行某个功能的一系列事件，脚本描述用户与目标系统之间的一个或多个典型的交互过程，以便对目标系统的行为有更具体的认识 编写脚本是为保证不遗漏系统功能中重要的交互步骤，有助于确保整个交互过程的正确性和清晰性 脚本通常起始于一个系统外部的输入事件，结束于一个系统外部的输 出事件，它可以包括发生在这个期间的系统所有的内部事件，包括正常情况脚本、异常情况脚本、错误情况脚本 在脚本编写完成后，从脚本提取所有外部事件，以确定每类事件发送和接收对象，并针对系统中的典型功能，画出 UML 顺序图 此后，利用一张状态图描绘类的行为，集中考虑具有交互行为类 【功能模型】功能模型表明了系统中数据之间的依赖关系，以及有关的数据处理 功能，它由一组数据流图组成。数据流图中的处理对应于状态图中的活动或动作，数据流对应于对象图中的对象或属性 建立功能模型的步骤如下： 确定输入和输出 画数据流图 定义服务 一般来说，数据流图中的输入和输出值是系统与外部之间进行交互的事件的参数。 在面向对象方法中，数据源往往是主动对象，它通过生成或使用数据来驱动数据流；数据终点接收数据的输出流；数据流图中的数据存储是被动对象，本身不产生任何操作，只响应存储和访问数据的要求；输入箭头表示增加、更改或删除所存储的数据；输出箭头表示从数据存储中查找信息。 类的服务与对象模型中的属性和关联的查询有关，与动态模型中的事件、功能模型的处理有关 通过分析，可以把这些服务添加到对象模型中去，类的服务有以下几种： 对象模型中的服务 从事件导出的服务 来自状态动作和活动的服务 与数据流图中处理框对应的操作","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"Matlab——矩阵基础操作","slug":"06.Matlab-矩阵基础操作","date":"2020-04-05T15:11:00.000Z","updated":"2021-08-24T01:39:45.588Z","comments":true,"path":"matlab/1e9e7202.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/1e9e7202.html","excerpt":"【矩阵与数组】矩阵与数组的区别： 数学概念：矩阵 计算机概念：数组","text":"【矩阵与数组】矩阵与数组的区别： 数学概念：矩阵 计算机概念：数组 矩阵与数组的联系：matlab 中，矩阵是以数组形式体现的 【矩阵构造】基本构造利用：[] , ; 来构造 12345678910111213141516171819&gt;&gt; [1,2,3] % 行向量ans = 1 2 3&gt;&gt; [1;2;3] % 列向量ans = 1 2 3&gt;&gt; [1,2,3;4,5,6;7,8,9] % 矩阵ans = 1 2 3 4 5 6 7 8 9&gt;&gt; [] % 空矩阵ans = [] 特殊矩阵全 1 矩阵与全 0 矩阵 ones(n)：构造一个 n*n 的全 1 矩阵 zeros(n)：构造一个 n*n 的全 0 矩阵 ones(n,m)：构造一个 n*m 的全 1 矩阵 zeros(n,m)：构造一个 n*m 的全 0 矩阵 ones(n,m,...,p)：构造一个 n*m*…*p 的全 1 矩阵 zeros(n,m,...,p)：构造一个 n*m*…*p 的全 0 矩阵 ones(size(A))：构造一个与矩阵 A 相同大小的全 1 矩阵 zeres(size(A))：构造一个与矩阵 A 相同大小的全 0 矩阵 单位矩阵 eye(n)：构造一个 n*n 的单位矩阵 eye(n,m)：构造一个 n*m 的单位矩阵（前 n 行 n 列是一个单位矩阵，后面的 m-n 列全是0） eye(size(A))：构造一个与 A 相同大小的单位矩阵 12345&gt;&gt; eye(3,7)ans = 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 上三角矩阵与下三角矩阵 triu(A)：A 的上三角矩阵 tril(A)：A 的下三角矩阵 triu(A,k)：以第 k 条对角线为轴的 A 的上三角矩阵，k 可取负数 triu(A,k)：以第 k 条对角线为轴的 A 的下三角矩阵，k 可取负数 对角矩阵 diag(A) A 为矩阵时，获取该矩阵的主对角线，返回以列向量的形式 A 为向量时，构造一个以该向量为主对角线的对角矩阵 diag(A,k)： A 为矩阵时，获取该矩阵的第 k 条对角线，返回以列向量的形式，k 可取负数 A 为向量时，构造一个以该向量为第 k 条对角线的对角矩阵，k 可取负数 块对角矩阵 blkdiag(A,B,C...)：将 A、B、C… 依次合并，构造一个块对角矩阵 1234567891011121314&gt;&gt; A=ones(2);&gt;&gt; B=ones(3);&gt;&gt; C=ones(4);&gt;&gt; blkdiag(A,B,C)ans = 1 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 1 【矩阵信息】矩阵结构 isempty(A)：检查 A 是否为空矩阵 issparse(A)：检查 A 是否为稀疏矩阵 isvector(A)：检查 A 是否为向量 isscalar(A)：检查 A 是否为标量 矩阵维度 size(A)：获取 A 的各维度长度 length(A)：获取 A 的最长维度 numel(A)：获取 A 的元素个数 【矩阵访问】双索引(数学形式)连续访问： 基本形式：A(i:j,p:q) 从第 i 行到第 j 行，从第 p 列到第 q 列，访问组成范围内的所有元素，并生成一个新的矩阵 考虑步长：A(i:step1:j,p:step2:q) 从第 i 行到第 j 行，每次步长为 step1 的所有行，从第 p 列到第 q 列，每次步长为 step2 的所有列，访问组成范围内的所有元素，并生成一个新的矩阵 注意事项： 行范围或列范围可以省略不写，例如：要访问 A 的第 2 列到第 4 列，可以写为 A(:,2:4) 由于步长可以为负，因此当步长为负时，用 end 来表示最后一个元素，例如：要将 A 进行翻转时，可以写为 A(end:-1:1) 选取访问： 基本形式：A([row1 row2 ...],[col1 col2 ...]) 选取由 row1、row2、… 这些行，与由 col1、col2、… 这些列组成范围内的所有元素，生成一个新的矩阵 与连续访问组合使用： 行组合：A([row1 row2 ...],p:q) 列组合：A(i:j,[col1 col2 ...]) 单索引(计算机存储形式)在 matlab 中，矩阵是以数组来体现的，而数组在内存中以列优先的形式存储。 因此，要想访问矩阵中的某个元素，可以按列优先的形式，将该元素的双索引转为单索引，再进行访问。 例如：对于一个 3*3 的矩阵 A，要访问 A 中的第 2 行第 3 列的元素时，其双索引形式是 A(2,3)，其单索引形式为 A(8) 双索引 A(1,1) A(2,1) A(3,1) A(1,2) A(2,2) A(3,2) A(3,1) A(3,2) A(3,3) 单索引 1 2 3 4 5 6 7 8 9 A(:)：将矩阵按列优先的方式，组织成列向量 A(i:j)：选取单索引从 i 到 j 的元素组织成行向量 A(i:step:j)：选取单索引从 i 到 j 步长为 step 的元素组织成行向量 A([ele1 ele2 ...])：选取单索引为 ele1、ele2、… 的元素组织成行向量 单双索引转换 双索引转单索引：ind=sub2ind(size(A),row,col) 单索引转双索引：[row col]=ind2sub(size(A),index) 【矩阵基本操作】 元素赋值：访问要赋值的元素，利用 = 赋值 删除矩阵：A=[] 将矩阵 A 整体赋值为空矩阵 [] 删除矩阵某个元素：访问要删除的元素，将其赋值为空矩阵 [] 矩阵合并： 按行合并（竖直方向）：vertcat(A,B) 、cat(1,A,B) 两者等价 按列合并（水平方向）：horzcat(A,B) 、cat(2,A,B) 两者等价 复制构造：repmat(A,i,j) 将矩阵 A 水平复制 i 个，竖直复制 j 个，生成一个新的矩阵 【矩阵基本运算】加减操作(+、-) 要求：维度相同，均为 n*m 运算规则： 无标量：对应元素逐个加减 有标量：各元素逐个加减标量 运算律： 交换律：A+B=B+A 结合律：A+（B+C）=（A+B）+C 零元运算：A+0=0+A=A 乘法运算(*) 标量与矩阵：各元素逐个乘标量 矩阵与矩阵： 要求：m*n 与 n*p 得到 m*p 结果：A 中的第 i 行乘以 B 中的第 j 列得到 C 中的第（i，j）个元素 运算律: 分配律：A*（B+C）=A*B+A*C 结合律：A*（B*C）=（A*B）*C 存在性：A*E=E*A=A 除法运算(/、\\) 说明：矩阵没有除法，对于 A/B，其本质是对矩阵 A 求逆然后乘以 B 运算符区别： 左除：A/B 时，要求 A、B 列数相同 右除：A\\B时，要求 A、B 行数相同 幂运算(^) 要求：矩阵是一个方阵 本质：$A^n=A*A*…*A$（n 个 A 相乘） 运算符：$A^n$，A 是一个方阵，n 是一个标量 【矩阵运算与数组运算的对比】加减操作 运算符：+、- 运算结果：数组、矩阵运算结果相同 乘法运算 标量与数组：.*、*作用相同，均是各元素逐个乘以标量 数组与数组： .*：两数组中对应元素相乘 *：即矩阵乘法 扩展：两矩阵 A、B 的点积为 dot(A,B) 或 sum(A.*B) 除法运算 ./与.\\： 标量与数组：对数组中的元素逐个进行操作 数组与数组：对两数组中对应元素进行操作，要求两数组维度一致 /与\\： 标量与数组： 标量为除数：与 ./与.\\一致 标量为除数：对数组中元素逐个进行操作 数组与数组：即矩阵除法 幂运算 .^： 标量与数组：对数组中的每个元素进行操作 数组与数组：对两数组中对应元素进行操作，要求两数组维度一致 ^：即矩阵的幂运算","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——元胞类型","slug":"05.Matlab-元胞类型","date":"2020-04-04T15:25:00.000Z","updated":"2021-08-24T01:39:51.420Z","comments":true,"path":"matlab/10119ec1.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/10119ec1.html","excerpt":"【创建】赋值语句利用赋值语句与 {} 即可创建元胞类型的变量","text":"【创建】赋值语句利用赋值语句与 {} 即可创建元胞类型的变量 123&gt;&gt; a=&#123;123,[1,2,3],'hello world',12.5&#125;a = [123] [1x3 double] 'hello world' [12.5000] 构造函数利用 cell(n,m) 构造函数，会创建一个 $n*m$ 的元胞数组，其中每个元素都是一个空数组 []，需要逐个进行赋值 12345&gt;&gt; a=cell(3,4)a = [] [] [] [] [] [] [] [] [] [] [] [] 【访问】单元外标识单元外标识利用 () 可以访问元胞数组中的相应单元 123456789101112&gt;&gt; a=&#123;123,[1,2,3];'hello world',12.5&#125;a = [ 123] [1x3 double] 'hello world' [ 12.5000]&gt;&gt; a(1,2)ans = [1x3 double]&gt;&gt; a(2,1)ans = 'hello world' 单元内编址利用 {} 可以访问元胞数组中相应单元的内容 12345678910111213&gt;&gt; a=&#123;123,[1,2,3];'hello world',12.5&#125;a = [ 123] [1x3 double] 'hello world' [ 12.5000]&gt;&gt; a&#123;1,2&#125;ans = 1 2 3&gt;&gt; a&#123;2,1&#125;ans = hello world 【基本操作】合并可以利用 {} 将元胞类型进行合并 12345678910111213141516&gt;&gt; a=&#123;123,[1,2,3]&#125;a = [123] [1x3 double]&gt;&gt; b=&#123;'hello world',12.5&#125;b = 'hello world' [12.5000]&gt;&gt; &#123;a,b&#125;ans = &#123;1x2 cell&#125; &#123;1x2 cell&#125;&gt;&gt; &#123;a;b&#125;ans = &#123;1x2 cell&#125; &#123;1x2 cell&#125; 删除删除元胞：直接将要删除的元胞赋值为空数组 [] 即可 删除元素：由于元胞类型的存储特性，无法删除元胞中的元素，因此当想要删除元胞中的某个元素时，将其赋值为空数组 [] 即可 改变维度对于一个 $n*m$ 的元胞数组，可以利用 reshape() 改变其维度 12345678910&gt;&gt; a=&#123;123,[1,2,3],456;'hello world',12.5,456&#125;a = [ 123] [1x3 double] [456] 'hello world' [ 12.5000] [456]&gt;&gt; reshape(a,3,2)ans = [ 123] [12.5000] 'hello world' [ 456] [1x3 double] [ 456] 数据类型判断 isnumeric(A)：判断 A 是否是一个数值型元胞数组 islogical(A)：判断 A 是否是一个逻辑型元胞数组 isstruct(A)：判断 A 是否是结构体元胞数组 isfloat(A)：判断 A 是否为浮点型元胞数组","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——数组","slug":"04.Matlab-数组","date":"2020-04-03T05:36:00.000Z","updated":"2021-08-24T01:40:27.225Z","comments":true,"path":"matlab/6b2ce8b1.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/6b2ce8b1.html","excerpt":"【数组创建】基本方式利用 [] , ; 组合定义数组","text":"【数组创建】基本方式利用 [] , ; 组合定义数组 12345678910111213141516171819&gt;&gt; [1,2,3] % 行向量ans = 1 2 3&gt;&gt; [1;2;3] % 列向量ans = 1 2 3&gt;&gt; [1,2,3;4,5,6;7,8,9] % 矩阵ans = 1 2 3 4 5 6 7 8 9&gt;&gt; [] % 空矩阵ans = [] 说明：由于数组的存储特性，无法删除数组中的元素，因此当想要删除数组中的某个元素时，将其赋值为空数组 [] 即可 等差方式生成数组 a:b：生成从 a 开始，到 b 结束，公差为 1 的等差数组 a:step:b ： 生成从 a 开始，到 b 结束，公差为 step 的等差数组 linspace(a,b)：生成从 a 到 b 之间，具有 100 个元素的等差数组，公差自动计算 linspace(a,b,k)：生成从 a 到 b 之间，具有 k 个元素的等差数组，公差自动计算 等比方式生成数组生成方式： logspace(a,b)：生成从 $10^a$ 到 $10^b$ 之间，具有 100 个元素的等比数组，公比自动计算 logspace(a,b,k)：生成从 $10^a$ 到 $10^b$ 之间，具有 k 个元素的等比数组，公比自动计算 应用：由于 logspace() 的范围，因此在实际生成数组时，常与 log10() 函数共同使用 123&gt;&gt; logspace(log10(1),log10(15),5)ans = 1.0000 1.9680 3.8730 7.6220 15.0000 【数组运算】数值运算详见 矩阵基础操作 中的矩阵运算与数组运算的对比 关系运算 关系运算符：==、~=、&gt;、&lt;、&gt;=、&lt;= 数值对数组：依据关系表达式，返回该数值与数组对应元素相运算的逻辑结果 数组对数组： 要求：两数组维度必须一致 返回值：依据关系表达式，数组对应元素相运算的逻辑结果 逻辑运算 逻辑运算符： |：或，左右两端存在一个为真即为真，否则为假 &amp;：与，左右两端全为真才为真，否则为假 ~：非，A 若为真，非 A 为假；A 若为假，非 A 为真 数值对数组：依据逻辑表达式，返回该数值与数组对应元素相运算的逻辑结果 数组对数组： 要求：两数组维度必须一致 返回值：依据逻辑表达式，数组对应元素相运算的逻辑结果 逻辑函数 xor(A,B)： 异或：左右两端不同为真，相同为假 A 或 B 中存在标量：返回该标量与数组元素逐个异或后，组成的行向量 A 或 B 是维度相同的两数组：返回两数组对应元素异或后，组成的数组 any(A)： A 是向量：若所有的元素存在非零，则返回 1，如果所有元素为零，则返回 0 A 是矩阵：如果某一列中全为零，则该列返回 1，如果某一列中存在一个元素为非零，则该列返回 1，由此构成一个行向量 all(A)： A 是向量：若所有的元素都是非零，则返回 1，如果有一个元素为零，则返回 0 A 是矩阵：如果某一列中有一个元素为零，则该列返回 0，如果某一列中全为非零，则该列返回 1，由此构成一个行向量 any(A,k)： k=1 时：等价于 any(A) k=2 时： A 是向量：等价于 any(A) A 是矩阵：如果某一行中全为零，则该列返回 1，如果某一行中存在一个元素为非零，则该列返回 1，由此构成一个列向量 all(A,k)： k=1 时：等价于 all(A) k=2 时： A 是向量：等价于 all(A) A 是矩阵：如果某一行中有一个元素为零，则该列返回 0，如果某一行中全为非零，则该列返回 1，由此构成一个列向量","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"VLAN 配置","slug":"network-system-integration/10.VLAN配置","date":"2020-04-02T15:34:00.000Z","updated":"2021-08-24T13:47:57.437Z","comments":true,"path":"notes/network-system-integration/5f3214c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/5f3214c.html","excerpt":"【VLAN 配置】创建 VLAN在进入全局配置模式 (config)# 后，即可使用有效的 ID 号创建一个 VLAN，然后指定标识 VLAN 服务的唯一名称即可。","text":"【VLAN 配置】创建 VLAN在进入全局配置模式 (config)# 后，即可使用有效的 ID 号创建一个 VLAN，然后指定标识 VLAN 服务的唯一名称即可。 分配端口在创建完 VLAN 后，需要进入接口配置模式 (config-if)# ，将接口设为接入模式后，再将端口分配给 VLAN 删除端口若要删除端口，在接口配置模式 (config-if)# 下重置该端口并删除即可。 删除 VLAN若要删除 VLAN，在全局配置模式 (config)# 下利用 no vlan vlan-id 命令即可删除与 vlan-id 相应的 vlan 此外，还可在特权模式 # 下执行 delete flash:vlan.dat 命令来删除 vlan.dat 文件。 检验 VLAN检验 VLAN 一般用 show vlan 命令和 show interfaces 命令，相关语法如下： 中继重置当需要配置中继链路时，只需要将中继重置为默认状态即可。 进入接口模式 (config)# 将 TRUNK 设置为允许所有 VLAN，并将本地 VLAN 设为默认值。 【VLAN 故障排除】IP 错误将 VLAN 和 IP 网络相关联是非常普遍的做法，由于不同 IP 网络只通过路由器通信，因此，VLAN 中的所有设备必须属于同一 IP 网络才能进行通信。 下图显示的是 PC1 由于配置了错误的 IP 地址，而无法与服务器通信的情况。 VLAN 缺失如果解决所有的 IP 地址不匹配问题后设备仍不能连接，则需要检查交换机中是否存在 VLAN。 中继故障中继问题通常由错误配置导致，最常见的中继配置错误类型有： 如果检测到中继问题，按照以下顺序排除即可：","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"VLAN","slug":"network-system-integration/09.VLAN","date":"2020-04-02T03:30:00.000Z","updated":"2021-08-24T13:46:56.609Z","comments":true,"path":"notes/network-system-integration/389ad80b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/389ad80b.html","excerpt":"【概述】在交换机组成的交换网络中，所有的主机都处于同一个广播域，当主机数量极多时，可能会造成网络风暴，并影响到网络整体的传输性能。 虚拟局域网(VLAN,Virtual LAN)，属于第二层网络的逻辑分区，是使用路由器分割的广播域，同一个 VLAN 中的用户间通信就和在一个局域网内一样。","text":"【概述】在交换机组成的交换网络中，所有的主机都处于同一个广播域，当主机数量极多时，可能会造成网络风暴，并影响到网络整体的传输性能。 虚拟局域网(VLAN,Virtual LAN)，属于第二层网络的逻辑分区，是使用路由器分割的广播域，同一个 VLAN 中的用户间通信就和在一个局域网内一样。 每一个 VLAN 都是一个广播域，通常使用自己的 IP 网络，这使得广播只有 VLAN 中的成员才能收到，不会传输到其他的 VLAN 中去，从而能够控制不必要的广播风暴的产生。 同时，VLAN 之间相互隔离，数据包只能通过路由器在不同 VLAN 之间传递，以此提高了不同工作组之间的信息安全性。 根据特定用户分组实施访问和安全策略，网络管理员根可根据功能、项目组或应用等因素划分 VLAN，而不考虑用户或设备的物理位置。 【VLAN 种类】根据 VLAN 划分要求的不同，VLAN 可分为以下几类： 基于端口的 VLAN：针对交换机的端口进行 VLAN 的划分，不受主机的变化影响 基于协议的 VLAN：在一个物理网络中针对不同的网络层协议进行安全划分 基于 MAC 地址的 VLAN：基于主机的 MAC 地址进行 VLAN 划分，主机可以任意在网络移动而不需要重新划分 基于组播的 VLAN：基于组播应用进行用户的划分 基于 IP 子网的 VLAN：针对不同的用户分配不同子网的 IP 地址，从而隔离用户主机，一般情况下结合基于端口的 VLAN 进行应用 而根据 VLAN 的作用，又有如下的划分方法： 数据 VLAN：用户生成的流量 本地 VLAN：用于未标记的流量，默认情况下，本地 VLAN 是 VLAN1 默认 VLAN：在配置交换机之前，所有交换机端口都是此 VLAN 的一部分，默认情况下，所有的端口都分配给 VLAN 1，通过 show vlan brief 命令即可查看 管理 VLAN：用于访问交换机管理功能的 VLAN，默认情况下，管理 VLAN 是管理 VLAN1，而如要创建管理 VLAN，要将该 VLAN 的交换机虚拟接口(SVI)将分配 IP 地址和子网掩码，使交换机通过 HTTP、Telnet、SSH 或 SNMP 进行管理 【VLAN 中继】VLAN 中继是传输多个 VLAN 流量的点对点链路，由于 VLAN 中继通常在交换机之间建立，因此，即使物理连接至不同交换机，同一 VLAN 的设备也可以通信。 VLAN 中继不与任何 VLAN 相关联，用于建立中继链路的中继端口也不与任何 VLAN 相关联。 交换机通过标记帧，来确定它们所属的 VLAN，一般均支持 IEEE802.1Q 的 VLAN 中继协议，该协议是一个标记协议，定义了添加到帧的标记报头的结构。 该协议在将 VLAN 标记放入中继链路前，交换机会将 VLAN 标记添加到帧(帧标记)，而且，通过非中继端口转发帧之前会删除标记。 一旦正确标记，帧可以通过中继链路经过任意数量的交换机，并且仍在目的地的正确 VLAN 中进行转发。 需要注意的是，发送到本地 VLAN 上的控制流量不应添加标记，收到的无标记帧将保持无标记，而且，在转发时会放在本地 VLAN 中。 如果没有与本地 VLAN 相关联的端口，也没其他中继链路，那么将丢弃无标记帧，因此，在交换机上配置交换机端口时，要将设备配置为不发送本地 VLAN 上的有标记帧。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"面向对象方法与 UML","slug":"software-engineering/08.面向对象方法与UML","date":"2020-04-01T06:34:00.000Z","updated":"2022-05-13T04:35:03.434Z","comments":true,"path":"notes/software-engineering/e2985ffb.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/e2985ffb.html","excerpt":"【面向对象方法】基本概念对象，现实世界中各种各样的实体，既可以指具体的事物，也可以指抽象的事物。","text":"【面向对象方法】基本概念对象，现实世界中各种各样的实体，既可以指具体的事物，也可以指抽象的事物。 类，具有相似内部状态和运动规律的实体的集合，类的内部状态是指类集合中对象的共同状态，类的运动规律是指类集合中对象的共同运动规律。 类是对象的抽象，对象是类的实例 消息，是对象间相互联系和相互作用的方式 继承，是不同抽象级别类之间的关系，面向对象方法学是按照子类与父类的关系，把若干个类组成一个层次结构的软件系统 子类是抽象出来的特殊类，父类是抽象级别更高的一般类，子类可以继承父类的所有内部状态和运动规律 封装，把数据和实现操作的代码集中起来放在内部，对象之间不用过多的了解对方内部的具体状态或运动规律，只需要通过调用接口来进行消息传递 多态，同名的方法在不同的类中具有不同的运动规律 重载，类的同名方法在给其传递不同参数时具有不同的运动规律 包，现实世界中不同对象间的相互联系和相互作用构成了不同的系统，不同系统间的相互联系和相互作用构成了更庞大的系统 特征 把数据和操作封装在一起，形成对象，对象是构成软件系统的基本构件 把特征相似的对象抽象为类 类之间可以存在继承或被继承的关系，形成软件系统的层次结构 对象之间通过发送消息进行通信 将对象的私有信息封装起来，外界不能直接访问对象的内部信息，而必须是发送相应的消息后，通过有限的接口来访问 面向对象的方法的最重要的特点就是把事物的属性和操作组成一个整体，从问题域中客观存在的事物出发来识别对象并建立由这些对象所构成的系统。 实施步骤首先，进行面向对象分析，从问题陈述入手，分析和构造所关心的现实世界问题域的模型，并用相应的符号系统表示，模型必须是简洁、明确地抽象目标系统必须做的事，而不是如何做，分析步骤如下： 确定问题域，包括定义论域，选择论域，根据需要细化和增加论域 - 区分类和对象，包括定义对象、定义类、命名 区分整体对象以及组成部分，确定类的关系以及结构 定义属性，包括确定属性、安排属性 定义服务，包括确定对象状态、确定所需服务、确定消息联结 确定附加的系统约束 其次，进行面向对象设计，其与传统的以功能分解为主的设计有所不同，具体设计步骤如下： 应用面向对象分析，对用其他方法得到的系统分析的结果进行改进和完善 设计交互过程和用户接口 设计任务管理，根据前一步骤确定是否需要多重任务，确定并发性，确定以何种方式驱动任务，设计子系统以及任务之间的协调与通信方式，确定优先级 设计全局资源，确定边界条件，确定任务或子系统的软、硬件分配 - 对象设计 再次，进行面向对象实现，使用面向对象语言实现面向对象的设计相对比较容易，如果用非面向对象语言实现面向对象的设计时，特别需要注意和规定保留程序的面向对象结构。 最后，进行面向对象测试，对实现的程序进行测试，包括模型测试、类测试、交互测试、系统测试、验收测试等 【统一建模语言 UML】概述统一建模语言（UML，Unified Modeling Language）是一种通用的可视化建模语言，可以用来描述、可视化、构造和文档化软件密集型系统的各种构件，是目前最流行的面向对象建模语言 UML 是一种标准的图形化建模语言，它是面向对象分析与设计的一种标准表示，可以用来捕获系统静态结构和动态行为的信息，其是独立于过程的，适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具 UML 不是一种程序设计语言，但用 UML 描述的模型可以和各种编程语言相联系 特点UML 具有以下几个特点： 统一标准 面向对象 可视化，表达能力强大 独立于过程 容易掌握使用 利用某些编程语言可以根据 UML 自动生成代码框架 应用范围UML 以面向对象的方式来描述系统，最广泛的应用是对软件系统进行建模，但它同样适用于许多非软件系统领域的系统 理论上来说，任何具有静态结构和动态行为的系统都可以使用 UML 进行建模 当 UML 应用于大多数软件系统的开发过程时，它从需求分析阶段到系统完成后的测试阶段都能起到重要作用 图形表示UML 主要用图来表达模型的内容，而图又由代表模型元素的图形符号组成 UML 的主要内容可以由下列 9 种图来表示： UML 用模型来描述系统的静态特征结构及动态特征行为，从不同的角度为系统建模，从而形成不同的视图，因此上述的 9 种图可分为以下 5 类视图： 建模机制UML 建模机制分为以下三种： 静态建模机制：用例图、类图、对象图、包图 动态建模方式：顺序图、协作图、状态图、活动图 物理架构机制：构件图、部署图 静态建模机制，关心的是类与对象间的关系；动态建模机制，关心的是系统的动态行为；物理架构机制关心的是系统该如何实现 【用例图】概述用例图属于静态建模方式，是从用户的角度描述系统的功能，用例建模用于描述系统需求，主要元素有： 用例：对一组动作序列的描述，系统通过执行这一组动作序列为参与者产生一个可观察的结果 参与者：外部用户或外部实体在系统中扮演的角色 关系连线：参与者执行用例的关系、参与者与参与者之间的关系、用例与用例之间的关系 建立模型顺序建立用例模型的顺序是： 确定谁会直接使用该系统,这些都是参与者 选取其中一个参与者 定义该参与者希望系统做什么，参与者希望系统做的每件事成为一个用例 对每件事来说，何时参与者会使用系统，通常会发生什么，即用例的基本过程 描述该用例的基本过程 考虑一些可变情况，把他们创建为扩展用例 复审不同用例的描述，找出其中的相同点，抽出相同点作为共同的用例 重复步骤 2~7 找出每一个用例 用例关系用例之间存在关系 3 种关系： 如果系统用例较多，不同的用例之间存在共同行为，可以将这些共同行为提取出来，单独组成一个用例，当其他用例使用这个用例之时，它们就构成了包含关系 在用例的执行过程中，可能出现一些异常行为，也可能会在不同的分 支行为中选择执行，这时可将异常行为与可选分支抽象成一个单独的 扩展用例，这样扩展用例与主用例之间就构成了扩展关系 用例之间的泛化关系描述用例的一般与特殊关系，不同的子用例代 表了父用例的不同实现 【类图与对象图】概述类图属于静态建模方式，使用类和对象描述系统的结构，展示了系统中类的静态结构，即类与类之间的相互关系，一个系统有多幅类图，一个类也可以出现在几幅类图中 类之间有多种联系方式： 关联：相互连接 依赖：一个类依赖于或使用另一个类 泛化：一个类是另一个类的特殊情况 对象图是类图的实例，它展示了系统在某一时刻的快照，对象图使用与类图相同的符号，只是在对象名下面加上下划线 表示在 UML 中，类用具有 3 个分隔线的矩形表示，顶层分隔表示类或对象的名字，中间表示属性，底层表示操作 类属性的语法为：[可见性] 属性名[：类型][=初值]，其中可见性有： 公有(+)：可被外部对象访问 私有(-)：不可为外部对象访问，只能为本类对象使用 保护(#)：可为本类对象和子类对象访问 类操作的语法为：[可见性]操作名[（参数列表）] [：返回类型] 类的版型类的版型是在建立对象模型时来区分实体类、边界类和控制类，以便更好地理解系统： 实体类：用于对必须存储的信息和相关行为建模的类 边界类：位于系统与外界的交界处，例如：窗体、对话框、直接与外部设备交互的类 接口类：描述一个类或构件服务的操作集，不含属性，只包含方法的声明 控制类：每个用例通常有一个控制类，控制用例中的事件顺序，控制类也可以在多个用例间共用 类间关系在类与类之间，具有不同的关系，比如：关联、依赖、泛化和实现等。 关联关系关联是模型元素间的一种语义关系，是对具有共同的结构特性、行为特性、关系和语义的链的描述 UML 中使用一条直线表示关联关系，直线两端上的数字表示重数，重数表示关联链的条数，链的两端的 数字 1 和 符号 * 表示的就是重数 重数可以是一个任意的自然数集合，但实际使用中，大于 1 的重数常常 用 * 代替，所以实际使用的重数多为 0、1、* 在不同关联中，两端的重数不同： 一对一关联的两端重数都是 1 一对多关联的一端的重数是 1，另一端是 * 多对多关联的两端重数都是 0~n，常表示为 * 若一端是 1…* 则表示这一端有 1 到多个对象 关联类是一种充当关联关系的类，和类一样具有自己的属性和操作，使用虚线连接自己和关联符号，关联类依赖于连接类，没有连接类时，关联类不能单独存在。任何关联类都可以表示成一个类和简单关联关系，但常常采用关联类的表示方式，以便更加清楚地表示关联关系 常见的关联类型有： 二元关联：两个类之间的关联 多元关联：一对多或多对多的关联 三元关联：使用菱形符号连接关联类 受限关联：用于一对多或多对多的关联，如果关联时需要从多重数的端中指定一个对象来限定，可以通过使用限定符来指定特定对象 聚合关系与组合关系聚合与组合其实都是关联的特例，都是整体和部分的关系 他们的区别在于聚合的两个对象之间是可分离的，他们具有各自的生命周期，组合往往表现为一种唇齿相依的关系 聚合关系：一种容纳或包含的关系，如同机场和飞机，汽车和轮胎的关系 组合关系：也可称之为强聚合，整体和部分是不可分的，整体的生命周期结束时也就是部分的生命周期到头时，比如桌子和桌子腿的关系 依赖关系依赖关系，表示的是两个元素之间语义上的连接关系 对于两个元素 X 和 Y，如果元素 X 的变化会引起对另一个元素 Y的变化，则称元素 Y 依赖于 X 依赖关系使用一个指向提供者的虚线箭头来表示 泛化关系泛化关系，描述类的一般-特殊关系，是更一般描述与更特殊描述之间的一种分类学关系，特殊描述常常是建立在一般描述基础上的 特殊类是一般类的子类，而特殊类还可以是另一个特殊类的子类，泛化的这种特点构成泛化的分层结构 实现关系实现关系，是指一个类描述了另一个类保证实现的合约 子类与父类关系是泛化，类与接口关系是实现 【包图】包图属于静态建模方式，可视为类图的另一种表现方式 包是一种对元素进行分组的机制，如果系统非常复杂，常常包含大量的模型，为了利于理解以及将模型独立出来用于复用，对这些元素进行分组组织，从而作为一个个集合进行整体命名和处理 包中的元素需要与其它包或类中的元素进行交互，交互过程的可访问性包括： 公有访问（+）：包中元素可以被其他包的元素访问 私有访问（-）：包中元素只能被同属于一个包的内含元素访问 保护访问（#）：包中的元素只能被此包或其继承包内的元素访 问 包的一些特征如下： 包是包含和管理模型内容的一般组织单元，任何模型元素都可以包含其中 一个模型元素只能存在于一个包中，包被撤销时，其中的元素也被撤销 包可以包含其他包，构成嵌套层次结构 包只是一个概念化的元素，不会被实例化，在软件运行中不会有包存在其中 【顺序图】概述顺序图属于动态建模机制，描述了一组对象的交互方式，它表示完成某项行为的对象和这些对象之间传递消息的时间顺序 顺序图由对象、生命线、控制焦点、消息等组成： 生命线：一条垂直的虚线，表示对象的存在时间 控制焦点：一个细长的矩形，表示对象执行一个操作所经历的时间段 消息：作用于控制焦点上的一条水平带箭头的实现，表示消息的传递 消息类别消息是所有动态建模机制的核心，对象间的交互是通过消息传递的，常见类别有： 简单消息：没有描述通信的细节 同步消息：调用者发出消息后等待消息返 回后再继续执行 异步消息：调用者发出消息后不等待消息返回就继续执行 返回消息：代表从过程调用的返回 建模步骤顺序图建模步骤为： 根据系统的用例或场景确定角色的工作流程 确定工作流程中涉及的对象，从左到右将对象放在顺序图上方，重要角色放置在左边 为每个对象画上生命线 为某一工作流程进行建模，使用各种消息将这些对象连接起来 【协作图】协作图，属于动态建模机制，又称通信图、合作图，用于显示系统的动作协作，类似顺序图中的交互片段，但协作图也显示对象之间的上下文关系 实际建模中，顺序图和协作图的选择需要根据工作的目标而定，两者都显示对象之间的交互，如果重在时间或顺序，那么选择顺序图，如果重在上下文关系，那么选择协作图。 协作图显示多个对象及它们之间的关系，对象间的箭头显示消息的流向，消息上也可以附带标签，表示消息的其他信息，如发送顺序、显 示条件、迭代和返回值等 【状态图】状态图，属于动态建模机制，由状态机扩展而来，用来描述对象对外部对象响应的历史状态序列，即描述对象所有可能的状态，以及哪些事件将导致状态的改变 此外，还可以描述对象在各个不同状态间的跳转以及这些跳转的外部触发事件，即从状态到状态的控制流 状态图侧重于描述某个对象的动态行为，是对象的生命周期模型，并不是所有的类都需要画状态图，有明确意义的状态、在不同状态下行为有所不同的类才需要画状态图。 创建状态图的步骤为： 标识出建模实体 标识出实体状态 创建相关事件和转换 【活动图】活动图，属于动态建模机制，其中的活动是展示整个计算步骤的控制流及其操作数的结点和流的图，执行的步骤可以是并发的或顺序的 活动图可以看作特殊的状态图，用于对计算流程和工作建模，工作建模可视为对对象的状态建模 状态图着重描述对象的状态变化以及触发状态变化的事件，活动图着重描述各种活动的执行顺序。 活动图的开始结点和结束结点与状态图相同，活动图中的状态称为动作状态（活动），使用平滑的圆角矩形表示 动作状态之间使用箭头连接，表示动作迁移，箭头上可以附加警戒条件、发送子句和动作表达式 活动图是状态图的变形，根据对象状态的变化捕获动作和它们的结果，从而表示各动作及其间的关系 【构件图】构件图，属于物理架构机制，其展现了一组构件的类型、内部结构和它们之间的依赖关系 构件图中的构件可以是源代码构件、二进制构件或者可执行构件，构件包含了其实现的一或多个逻辑类信息，因此也就创建了从逻辑视图到构件视图的映射 根据构件视图中构件之间的关系，可以轻易地看出当某一个构件发生变化时，哪些构件会受到影响 【部署图】部署图，属于物理架构机制，描述了系统硬件和软件物理配置情况和系统体系结构，显示系统运行时刻的结构 一个系统模型只有一个部署图，可以显示计算节点的拓扑结构和通信路径、结点上运行的软构件等 部署图常常帮助理解分布式系统，一般由体系结构设计师、网络工 程师、系统工程师来描述 部署图里面主要的就是节点，节点就是存在于运行时并代表一项计算 资源的物理元素，一般至少拥有一些内存，而且通常具有处理能力 在 UML 中，节点用一个立方体来表示，节点名放在立方体的左上角，节点间的连线称为连接，表示系统之间进行交互的通信线路，通信类型用构造型表示，写在表示连接的线旁，以指定所用的通信协 议或网络类型","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"Matlab——常用运算函数","slug":"03.Matlab-常用运算函数","date":"2020-03-30T22:39:00.000Z","updated":"2021-08-24T01:39:32.069Z","comments":true,"path":"matlab/dd52b765.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/dd52b765.html","excerpt":"【取整】 floor()：向下取整 ceil()：向上取整 round()：四舍五入 fix()：去掉小数部分 123456789101112131415161718192021&gt;&gt; a=2.5;b=-2.5;&gt;&gt; floor(a)ans = 2&gt;&gt; floor(b)ans = -3&gt;&gt; ceil(a)ans = 3&gt;&gt; ceil(b)ans = -2&gt;&gt; round(a)ans = 3&gt;&gt; round(b)ans = -3&gt;&gt; fix(a)ans = 2&gt;&gt; fix(b)ans = -2","text":"【取整】 floor()：向下取整 ceil()：向上取整 round()：四舍五入 fix()：去掉小数部分 123456789101112131415161718192021&gt;&gt; a=2.5;b=-2.5;&gt;&gt; floor(a)ans = 2&gt;&gt; floor(b)ans = -3&gt;&gt; ceil(a)ans = 3&gt;&gt; ceil(b)ans = -2&gt;&gt; round(a)ans = 3&gt;&gt; round(b)ans = -3&gt;&gt; fix(a)ans = 2&gt;&gt; fix(b)ans = -2 【取绝对值 abs】12345678&gt;&gt; abs('a') %字符类型返回ASCII码ans = 65&gt;&gt; abs(-3.5) %数值类型返回绝对值ans = 3.5&gt;&gt; abs(3+4i) %复数类型返回复数的模(幅值),即a、b平方的和的开根号ans = 5 【三角函数与反三角函数】 sin(x)：x 为弧度，返回结果为数 cos(x)：x 为弧度，返回结果为数 tan(x)：x 为弧度，返回结果为数 asin(x)：x 为数，返回结果为弧度 acos(x)：x 为数，返回结果为弧度 atan(x)：x 为数，返回结果为弧度 【log 函数】 exp(n)：返回e的n次方（数学中的 $e^n$） log(x)：以e为底（数学中的 $lg(x)$） log10(x)：以10为底（数学中的 $lg(x)$） 【统计函数】 mean(A)：返回数组 A 中的平均值 median(A)：返回数组 A 中的中位数 max(a,b)：返回 a、b 中的最大值 max(A)：返回数组 A 中的最大值 min(a,b)：返回 a、b 中的最小值 min(A)：返回数组 A 中的最小值 【sort 函数】形式：sort(A,k,mode） 关于 A： A为向量：按 mode 所指定的排序方法进行排序 A为矩阵：按 mode 所指定的方法以列进行排序 关于 k：A 为矩阵，若 A 为向量，则 k 无意义，可以省略 k=1 时：按 mode 所指定的排序方法进行列排序，等价于 sort(A) k=2 时：按 mode 所指定的排序方法进行行排序 关于 mode：默认为 &#39;ascend&#39;，升序排序；降序排序为&#39;descend&#39; 关于返回值： 若为A=sort(A)形式：A 是排序好的数组 若为 [A index]=sort(A) 形式：A 是排序好的数组，index 是 A 中对应元素在排序前的位置索引 【取模】 mod： 格式：mod(x,y) 作用：求 x 关于 y 的模 rem： 格式：rem(x,y) 作用：求整除 $\\frac{x}{y}$ 的余数 对比： x、y 符号相同：mod(x,y)=rem(x,y) x、y 符号不同：mod(x,y)=rem(x,y)+y 应用： 正数与正数取模时，取模用哪个均可 正数与负数取模时 若希望得到的余数符号与除数 x 一样：用 rem(x,y) 若希望得到的余数符号与被除数 y 一样：用 mod(x,y) 【计算阶乘】 factorial(n)：计算 n 的阶乘 prod(1:n)：矩阵元素求积，即计算 n 的阶乘 循环： 12345value=1;for i=1:n value=value*i;enddisp(value); 【矩阵元素查找】应用：与逻辑运算、关系函数结合使用 ind=Find(a)：返回A中的非零元素单索引组成的列向量 [row,col]=Find(a)：返回A中的非零元素双索引组成的两个列向量row、col 与逻辑运算符、关系函数的结合使用： 逻辑运算符：例如 ind=find(a&gt;=5) 关系函数：例如 ind=find(isprime(a)) 【矩阵元素求和】sum(A,k)参数说明： 关于A： A是向量时：默认k=2 A是矩阵时：默认k=1 关于k： k=1时：按列求和 k=2时：按行求和 返回值：按列求和返回行向量，按行求和返回列向量 应用：对矩阵A的所有元素求和 sum(sum(A)) cumsum(A,k)参数说明： 关于A： A是向量时：默认k=2 A是矩阵时：默认k=1 关于k： k=1时：按行求和 k=2时：按列求和 返回值： k=1时：第 i 行的第 j 个元素为前 i 行的第 j 个元素的和 k=2时：第 i 行的第 j 个元素为前 j 列的第 i 个元素的和 【矩阵元素求积】prod(A,k)参数说明： 关于A： A是向量时：默认k=2 A是矩阵时：默认k=1 关于k： k=1时：按列求积 k=2时：按行求积 返回值：按列求积返回行向量，按行求积返回列向量 cumprod(A,k)参数说明： 关于A： A是向量时：默认k=2 A是矩阵时：默认k=1 关于k： k=1时：按行求积 k=2时：按列求积 返回值： k=1时：第 i 行的第 j 个元素为前 i 行的第 j 个元素的积 k=2时：第 i 行的第 j 个元素为前 j 列的第 i 个元素的积 【矩阵元素差分】差分：一行（列）元素与上一行（列）元素对应的差值，依次排列在上一行（列）元素对应的位置，第一行与第一列不做差分 函数：diff(A,n,k) 关于A：A是一个矩阵 关于n：n代表阶数，即对A进行几阶差分 关于k：默认k=1，代表计算各列差分，k=2时，计算各行差分 说明：当n&gt;=size(A,k)时，返回值为空矩阵","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——基本数据类型","slug":"02.Matlab-基本数据类型","date":"2020-03-30T05:58:00.000Z","updated":"2021-08-24T01:40:21.650Z","comments":true,"path":"matlab/9785d852.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/9785d852.html","excerpt":"【数值数据与逻辑数据】 数值型： 整型：int32、int64等 浮点型：single、double 复数型：3+2i、4+5j 逻辑型： 逻辑变量：0、1 逻辑表达式的返回值 其他数据类型转换：logical() 【inf 与 NaN】","text":"【数值数据与逻辑数据】 数值型： 整型：int32、int64等 浮点型：single、double 复数型：3+2i、4+5j 逻辑型： 逻辑变量：0、1 逻辑表达式的返回值 其他数据类型转换：logical() 【inf 与 NaN】 inf：说明溢出，超出或低于最大存储范围，在matlab中常用于代表无穷，分正负 NaN：Not a Number，结果不是一个数，说明计算出现错误 【字符与字符串】 ASCII码：字符编码方式 构造：单行 &#39;&#39;、多行 [] 与 {} 含有 &#39; 时如何表达：&#39;&#39; 常用操作（说明：大多数操作均支持正则表达式）： 合并：[str1,str2]、strcat(str1,str2) 比较： str1==str2：要求str1、str2长度相同，返回一与两字符串长度相同的逻辑数组，1代表对应元素相同，0代表对应元素不同 strcmp(str1,str2)：str1、str2长度可以不同，如果两字符串相同返回1，不同返回0 查找：findstr(str,&#39;要找的字符串&#39;) 返回要找的字符串的位置，没有返回[] 字符串分割：strsplit(str,&#39;分割元素&#39;)，返回元胞数组 分割元素：字符串，以该字符串进行分割 分割元素：元胞字符数组，适用于分割多个字符串，在分割匹配时，会按顺序从前到后匹配元胞中的元素进行分割 替换： str1=&#39;新字符串&#39;：str1与新字符串长度必须一致 strrep(str1,&#39;被替换的字符串&#39;,&#39;新字符串&#39;)：被替换的串与新串长度可以不同 常用函数： 大小写转换： 小写转大写：str1=upper(str1) 大写转小写：str1=lower(str1) 字符与数值： 字符转数：num1=str2num(str1)返回str1所描述的数，不能转换的返回[] 数转字符：str1=num2str(num1)将num1转为字符 取ASCII码：abs(str1)返回一个长度与str1相同的数组，每个元素是对应字符的ASCII码 【结构体】 赋值方法： 123结构体名.属性1=属性值1;结构体名.属性2=属性值2; ... 构造函数：结构体名=struct(属性1,属性值1,属性2,属性值2,...) 【map】 创建：mp=containers.Maps({k1,k2,...},{v1,v2,...}) 属性： 查看元素个数：mp.Count 查看键类型：mp.KeyType 查看值类型：mp.ValueType 访问键值： 查看所有键：keys(mp) 查看所有值：values(mp) 基本操作： 增：mp(新键)=新值 删：remove(mp,&#39;键名&#39;) 改： 改值：mp(&#39;键名&#39;)=新键值 改键：先删后添，保证键名相同即可 查：mp(键名)","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"Matlab——概述","slug":"01.Matlab-概述","date":"2020-03-29T09:56:00.000Z","updated":"2021-08-24T01:39:55.168Z","comments":true,"path":"matlab/990b6c41.html","link":"","permalink":"https://alex-mcavoy.github.io/matlab/990b6c41.html","excerpt":"【命令】 清屏：clc 清除变量：clear 显示变量或字符串：disp 查看文件内容：type 查看当前工作区变量信息：whos 光标移动一个字符：←、→ 光标移动一个单词：ctrl+←、ctrl+→ 调用之前执行过的代码：↑ 【命令行与 m 文件】","text":"【命令】 清屏：clc 清除变量：clear 显示变量或字符串：disp 查看文件内容：type 查看当前工作区变量信息：whos 光标移动一个字符：←、→ 光标移动一个单词：ctrl+←、ctrl+→ 调用之前执行过的代码：↑ 【命令行与 m 文件】使用情景： 命令行：当要完成的运算较简单时 m 文件：当要完成的运算较复杂时使用 特点： 命令行：每输入一条命令立即显示该命令结果，实时性、交互性较好，不可重用 m 文件：几十上百乃至上千行命令组成的脚本文件，实时性、交互性较差，可重用 【P 码文件】当一个 M 文件第一次被调用的时候，会将其翻译成汇编或二进制，即 P 码文件(.p)，放入内存中 【变量识别】在 matlab 中，数值对象、符号对象、字符串等是常用的数据类型，他们的外形有时及其相似，但实际遵循着不同的运算法则，为管理使用方便，matlab 提供了识别不同数据对象的函数。 数据类型： 数据类型 描述 数据类型 描述 double 双精度浮点数组 int8 8位有符号整型数组 single 单精度浮点数组 uint8 8位无符号整型数组 logical 逻辑数组 int16 16位有符号整型数组 char 字符数组 uint16 16位无符号整型数组 cell 单元数组 int32 32位有符号整型数组 struct 结构体数组 uint32 32位无符号整型数组 sym 符号数组 int64 64位有符号整型数组 function_handle 函数句柄 uint64 64位无符号整型数组 类别识别函数： class(变量名)：判断变量的数据类型 isa(变量名,&#39;变量类型&#39;)：判断变量是否为&#39;变量类型&#39;的变量，变量类型取值见上表 whos：列出当前工作区的变量名与详细信息 Name：变量名 Size：大小 Bytes：字节 Class：数据类型 Attributes：对变量的描述，例如complex 表示该变量是一个复数类型","categories":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/categories/matlab/"}],"tags":[{"name":"Matlab","slug":"matlab","permalink":"https://alex-mcavoy.github.io/tags/matlab/"}],"author":"Alex_McAvoy"},{"title":"无线个域网技术","slug":"wireless-network/06.无线个域网技术","date":"2020-03-27T07:23:42.000Z","updated":"2021-10-31T13:53:26.666Z","comments":true,"path":"notes/wireless-network/5169ef7e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/5169ef7e.html","excerpt":"【概述】在无线个域网概述中，介绍了无线个域网有五种类型：蓝牙、IrDA、HomeRF、UWB、ZigBee 其中，蓝牙在蓝牙技术中进行了介绍，下面将简单介绍其他四种 WPAN 技术","text":"【概述】在无线个域网概述中，介绍了无线个域网有五种类型：蓝牙、IrDA、HomeRF、UWB、ZigBee 其中，蓝牙在蓝牙技术中进行了介绍，下面将简单介绍其他四种 WPAN 技术 【红外技术 IrDA】概述为了建立一个统一的红外数据通讯的标准，1993 年，由 HP、COMPAQ、INTEL 等二十多家公司发起成立了红外数据协会（Infrared Data Association，IRDA），1993 年 6 月 28 日，来自 50 多家企业的 120 多位代表出席了红外数据协会的首次会议，并就建立统一的红外通讯标准问题达成了一致 IR 工作原理红外技术采取二极管和 IR 接收机进行工作 其中，二极管（LED）可以发射光源或者光束，并对其进行编码；IR 接收机是一种光感应设备，可以感应光源并对其携带信息译码 IR 具有两种联网方式： 直射式：发射机和接收机在直接的视距上，仅限于连接两台设备，可靠切安全 漫射式：信号扩展到了更宽的角度（180°），在封闭空间内各表面上可以反射信号。 在利用红外线进行通信，最高通信速率 115.2kbps，无需申请频率使用权，通信成本低廉，且体积小、功耗低、连接方便、简单易用 体系架构IrDA 数据协议由物理层、链路接入层、链路管理层三个基本层协议组成 此外，为满足各层上的应用的需要，IrDA 栈支持 IrLAP、IrLMP、IrIAS、IrIAP、IrLPT、IrCOMM、IrOBEX、IrLAN 等 需要说明的是，IrIAS、IrLPT、IrCOMM、IrOBEX、IrLAN 是建立在 IrLAP 之上的应用 在 IrDA 红外串行物理层协议中，将数据通信按发送速率分为三类： SIR：串行红外，其速率覆盖了 RS-232 端口，通常支持的速率为 9600bps～1152Kbps MIR：MIR 可支持0.576Mbps和1.152Mbps的速率 FIR：高速红外，常用于 4Mbps 的速率，有时也可用于高于 SIR 的所有速率 IrLAP 红外链路接入协议，与 OSI 模型的数据链路层对应，其基于 HDLC 协议和 SDLC 协议，定义了链路初始化、设备地址发现、建立连接、数据交换、切断连接、链路关闭以及地址冲突解决等操作过程 IrLMP 红外链路管理协议，是 IrLAP 之上的一层链路管理协议，主要用于管理 IrLAP 所提供的链路连接中的链路功能和应用程序以及评估设备上的服务，并管理如数据速率、BOF 的数量及连接转换向时间等参数的协调、数据的纠错传输等 【家庭射频技术 HomeRF】HomeRF 工作组是由美国家用射员会领导于 1997 年成立的，其主要工作任务是为家庭用户建立具有互操作性的话音和数据通信网 HomeRF 借用了 802.11 规范中支持 TCP/IP 传输的协议，在语音传输性能方面借用了 无绳电话 DECT 标准 HomeRF 具有以下特点： 工作频率：2.4GHz 传输距离：40m 数据传输速率：100Mbps 无线以太网传输规范子集 集成了语音和数据传送技术 在 WLAN 的安全性方面主要考虑访问控制和加密技术 【超宽带技术 UWB】超宽带技术（Ultra Wideband，UWB），是一种无载波通信技术，利用纳秒至微微秒级的非正弦波窄脉冲传输数据 其是无线电领域的一次革命性进展，有人认为它将成为未来短距离无线通信的主流技术 UWB 具有如下特点： 工作频率：3.1～10.6GHz 传输距离：10m 数据传输率：100Mbps 复用方式：时分复用 优点：低功耗，宽频谱，不会干扰其他系统 相对于蓝牙系统来讲，UWB 技术要简单的多，而且在传输速率、成本上有巨大优势 【ZigBee】Zigbee 是 IEEE 802.15.4 协议的代名词，这是一种短距离、低功耗的无线通信技术，用于个人区域网和对等网络。 ZigBee 具有如下特点： 工作频率：2.4GHz 传输距离：30m，在扩展模式下可达 134m 数据传输率：20Kbps、40Kbps、250Kbps 优点：节能","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"交换机配置","slug":"network-system-integration/08.交换机配置","date":"2020-03-26T15:28:00.000Z","updated":"2021-08-24T13:46:22.028Z","comments":true,"path":"notes/network-system-integration/e0896859.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/e0896859.html","excerpt":"【交换机配置】交换机管理访问配置交换机管理访问的基本过程如下：","text":"【交换机配置】交换机管理访问配置交换机管理访问的基本过程如下： 利用控制台电缆将 PC 连接到交换机的控制台端口以便进行配置 要将 IP 地址、子网掩码、网关分配给交换机虚拟接口(SVI) 如果从远程网络管理交换机，还必须配置默认网关 相关命令如下： 交换机端口工作模式与接口速率在配置交换机端口时，是在物理层上配置的，要设置接口工作模式是全双工还是半双工，还要设置端口速度。 相关命令如下： Auto-MDIX由于在物理层连接设备时，需要特定类型的直通或交叉电缆，为解决该问题，可以使用自动专用媒体接口交叉(Auto-MDIX)功能。 启用 Auto-MDIX 后，接口会自动检测并正确配置连接，需要注意的是，在接口上使用 Auto-MDIX 时，必须将接口速度和双工设置为自动。 相关命令如下： 接口检验在配置完接口后，可以利用下列命令进行检验。 故障排除在交换机配置完毕后，可能会出现问题，此时我们要在接入层上进行故障排除。 【交换机安全】远程加密连接在远程访问交换机时，采用安全外壳(SSH)来为设备提供基于命令行的安全连接。 SSH 其加密功能十分强大，一般替代 Telnet 来管理连接，默认情况下，SSH 使用 TCP 端口 22，Telnet 使用 TCP 端口 23，如果要启用交换机上的 SSH，需要包含加密功能和能力的 IOS 软件版本。 配置 SSH 的过程如下： show ip ssh 命令检验 SHH 支持 配置 IP 域 生成 RSA 密钥对 配置用户身份验证 配置 vty 线路 启用 SSH 第 2 版 端口安全为保证端口安全，一般会使用 shutdown 命令来禁用未使用的端口。 同时，配置安全 MAC 地址，即：允许合法设备的 MAC 地址进行访问，而拒绝其他 MAC 地址，任何通过未知 MAC 地址进行连接的其他尝试都会导致安全违规问题。 配置安全 MAC 地址有以下方式： 静态安全 MAC 地址：利用 switchport port-security mac-address mac-address 命令手动配置并添加到运行的配置中 动态安全 MAC 地址：交换机重新启动时移除 粘性安全 MAC 地址：利用 switchport port-security mac-address sticky 接口配置模式命令，进入后将 MAC 地址添加到运行的配置并动态获知 违规模式在 CAM 中添加了该接口最大数量的安全 MAC 地址，MAC 地址不在地址表中的站点尝试访问接口的情况下，IOS 考虑安全违规。 检测到违规时，可以采取以下三种措施： 保护：未收到通知 限制：收到安全违规通知 关闭：在接口配置模式中关闭 安全违规模式包括保护、限制、关闭，具体内容如下：","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"交换网络与交换机","slug":"network-system-integration/07.交换网络与交换机","date":"2020-03-26T07:05:00.000Z","updated":"2021-08-24T13:45:56.719Z","comments":true,"path":"notes/network-system-integration/561999c1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/561999c1.html","excerpt":"【概述】随着网络复杂性不断增加，为了支持协作，网络采用融合解决方案，旨在只需要管理一个网络，节省安装和管理独立语音、视频和数据网络所需的大量费用，从而对 IT 进行管理。 此后，思科提出了无边界交换网络，这是一种允许组织随时随地在任何设备上与任何人实现安全、可靠、无缝连接的网络架构，旨在应对 IT 和业务方面的挑战，例如：支持融合网络、更改工作模式等，其设计的指导原则有：分层、模块化、恢复能力、灵活性。","text":"【概述】随着网络复杂性不断增加，为了支持协作，网络采用融合解决方案，旨在只需要管理一个网络，节省安装和管理独立语音、视频和数据网络所需的大量费用，从而对 IT 进行管理。 此后，思科提出了无边界交换网络，这是一种允许组织随时随地在任何设备上与任何人实现安全、可靠、无缝连接的网络架构，旨在应对 IT 和业务方面的挑战，例如：支持融合网络、更改工作模式等，其设计的指导原则有：分层、模块化、恢复能力、灵活性。 交换技术对网络设计至关重要，其允许流量在大部分情况下仅在需要时使用快捷的方式发送，核心设备是交换机。 【MAC 表】交换机根据入口和目的端口做出决策，根据帧的目的 MAC 地址转发以太网帧，即帧转发。 在传输帧之前，交换机必须首先获知每个端口上存在哪些设备，当交换机获知端口与设备的关系后，就会构建一个 MAC 地址表或内容可寻址内存(CAM)表，用于发送帧。 CAM 是一种特殊类型的内存，用于高速搜索应用程序，当交换机收到具有 CAM 表中未列出的 MAC 地址的传入帧时，交换机会利用泛洪法来将其泛洪至除接受该帧外的所有端口。 【交换机转发方法】交换机的转发方法有两种：存储转发交换、直接交换。 存储转发交换接收整个帧，并通过 FCS 校验和执行 循环冗余校验 CRC 进行校验，当校验无误后，再去查找目的 MAC 地址，根据目的 MAC 来决定外发接口，从而进行转发，整个过程中执行自动缓冲，但由于要接收整个帧并且要进行校验，存储转发交换过程较慢。 直通交换允许交换机在接收到帧的目的 MAC 后就开始转发，没有 FCS 检查错误，也没有自动缓存，整个转发过程较快。 依据交换机的转发方法的不同，交换机也分为存储转发交换机、 直通交换机两种。 【交换域】在同一个网络上，两个设备同时进行传输引发竞争，则会产生冲突，那么该网络就是一个冲突域。 对于以太网交换机端口来说，如果它在半双工模式下运行，则每个网段都位于自己的冲突域，而在全双工模式下运行可消除冲突。 默认情况下，当相邻设备也可在全双工模式下运行时，它将自动协商全双工。 广播域是网络的扩展，在此扩展中可收到广播帧，交换机会将广播帧转发到所有端口，因此，交换机不会划分广播域。 交换机的所有端口都视为同属一个广播域，如果连接两台或多台交换机，则将广播转发到除最初接收广播的端口外的所有交换机的所有端口。 综上，交换机会采用以下方式来缓解网络拥塞： 促使 LAN 网段分为单独的冲突域 提供设备之间的全双工通信 缓冲大型帧 使用高速端口 利用其快速内部交换过程 【交换机引导顺序】交换机是交换网络的核心设备，其开机后引导过程如下： 加电自检(POST) 运行引导加载程序软件 引导加载程序执行低级 CPU 初始化 引导加载程序初始化 Flash 系统 引导加载程序并将默认的 IOS 操作系统软件映像加载到内存中，并将对交换机的控制权转交给 IOS 当系统崩溃时，无法加载 IOS，此时可采用以下方式通过控制台连接访问引导加载程序： 通过控制台电缆将 PC 连接到交换机控制台端口 拔下交换机电源线，再将电源线重新连接到交换机并按住 “模式” 按钮 系统的 LED 迅速变为琥珀色，然后变为纯绿色，释放 “模式” 按钮 需要说明的是，在交换机上的每个端口都有状态 LED 指示灯，默认情况下，这些指示灯反映端口活动，但也可以通过 “模式” 按钮来提供有关交换机的信息。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"蓝牙技术","slug":"wireless-network/05.蓝牙技术","date":"2020-03-26T04:11:23.000Z","updated":"2021-10-31T13:36:41.989Z","comments":true,"path":"notes/wireless-network/c97f57a3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/c97f57a3.html","excerpt":"【蓝牙】蓝牙由爱立信公司于 1994 年提出，用于建立个域网 PAN，目的是实现短距离小资料的传输，1998 年蓝牙 SIG 成立，负责制定技术标准，蓝牙也由此开始逐渐成为一种无线技术规范 其通过 2.4GHz 无需授权的 ISM 频段的微波传输信号，传输距离在 10 米左右，用于连接便携式和固定设备，采取点对点、点对多点模式，采取电路交换技术进行同步，速率为 64kps，采取分组交换技术进行异步，对称时时 433.9kbps，非对称时 723.2kbps","text":"【蓝牙】蓝牙由爱立信公司于 1994 年提出，用于建立个域网 PAN，目的是实现短距离小资料的传输，1998 年蓝牙 SIG 成立，负责制定技术标准，蓝牙也由此开始逐渐成为一种无线技术规范 其通过 2.4GHz 无需授权的 ISM 频段的微波传输信号，传输距离在 10 米左右，用于连接便携式和固定设备，采取点对点、点对多点模式，采取电路交换技术进行同步，速率为 64kps，采取分组交换技术进行异步，对称时时 433.9kbps，非对称时 723.2kbps 蓝牙常于红外相提并论，他们的对比如下： 蓝牙 红外 距离 10 米左右，可不对准 1~2 米，需对准 通信数目 最大链接 7 个 单对单链接 速度 较快 较慢 安全 可加密 无区别 成本 400~800 元 几元~几十元 【联网方式】蓝牙的联网模式有三种： 1.点对点模式 点对点模式用于两个蓝牙设备直接通信，其将两个设备分为主机与访客 主机设备是具有用户界面的设备，多数连接设置都将从此进行，一个设备可以是另一个设备的主机，也可以作为其它设备的访客 例如：手机与无线耳机配对时，该手机就是主机，但是，手机与计算机配对时，计算机就是主机 2.微微网（Piconet） 微微网，通过共享相同信道进行通信，最多支持 8 个蓝牙设备可在小型网络内 其中 1 个 Master 节点控制通信的同步，7 个 Slave 节点进行通信 3.散网（Scatternet） 散网，是时间和空间层叠的多个微微网组成的，多个微微网的主设备可以成为微微网的从设备 对于每个微微网的从设备来说，又是该微微网主设备的从属设备，最多可由 256 个微微网来连接成更大的网络 【蓝牙协议栈】协议栈对于蓝牙系统来说，其核心是蓝牙技术规范，在其中分为两部分，一部分是蓝牙技术操作，另一部分是协议体系结构，即蓝牙协议栈 蓝牙系统的概要是蓝牙应用规范，即 profile 文档，其定义了一组使用模式，每个 profile 说明了支持该特定使用模式的协议及协议特性 蓝牙的基本架构如下： 相较于 OSI 模型与 IEEE 802 模型，蓝牙协议栈要复杂的多，下图是三者的对比： 重要协议层1.RF 层 RF 层即无线电层，是蓝牙底层硬件模块，相当于 OSI 模型中的 PHY 层，其主要作用是在主站与从站间发送比特 RF 层采取跳频扩频技术，共有 79 个信道，每个信道 1MHz 2.BaseBand 层 BaseBand 层即基带层，组合了电路交换和分组交换的功能 同时，为同步分组传输预留了时间槽，每个分组以不同跳频进行发送，主要作用是对信道进行管理 3.Link Manager 层 Link Manager 层即链路管理规范层，用于对蓝牙链路进行管理 其主要功能有：信道控制、提供安全服务（认证、加密、分发秘钥）、Master-Slave 结点的切换、微微网的管理等 4.L2CAP 层 L2CAP 层即逻辑链路控制与自适应协议层，其为上层提供面向连接和无连接的数据封装服务 该层采用了多路技术、分割和重组技术、组提取技术等，以进行协议复用、分段和重组、认证服务质量、组管理等 5.SDP 层 SDP 层即服务发现协议层，是蓝牙技术框架至关重要一层，是所有应用模型的基础 该层采取动态的查询设备信息和服务类型，建立一条对应的服务通信通道，为上层提供发现可用的服务类型和属性协议信息 6.RFCOMM 层 RFCOMM 层即串口仿真协议层，实现了仿真 9 针 RS232 串口功能，实现设备间的串行通信","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"无线个域网概述","slug":"wireless-network/04.无线个域网概述","date":"2020-03-25T02:16:12.000Z","updated":"2021-10-31T13:51:38.901Z","comments":true,"path":"notes/wireless-network/576caf10.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/576caf10.html","excerpt":"【个域网与无线个域网】个域网（Personal Area Network，PAN），是一种范围较小的计算机网络，其通信范围往往仅几米，被看作是 “最后一米” 的解决方案 无线个域网（Wireless PAN，WPAN） 是一种采用无线连接的个域网，利用无线介质代替传统有线电缆，实现个人信息终端的互联，从而组建个人信息网络，是典型的对等式拓扑结构，价格便宜、体积小、易操作、功耗低","text":"【个域网与无线个域网】个域网（Personal Area Network，PAN），是一种范围较小的计算机网络，其通信范围往往仅几米，被看作是 “最后一米” 的解决方案 无线个域网（Wireless PAN，WPAN） 是一种采用无线连接的个域网，利用无线介质代替传统有线电缆，实现个人信息终端的互联，从而组建个人信息网络，是典型的对等式拓扑结构，价格便宜、体积小、易操作、功耗低 WPAN 是为了实现活动半径小、业务类型丰富、面向特定群体的连接而提出的新型无线网络技术，其与无线广域网（WWAN）、无线城域网（WMAN）、无线局域网（WLAN）并列但覆盖范围更小，他们之间的对应关系如下图： 【无线个域网类型】WPAN 按传输速率分为低速、高速和超高速三类： 常见的 WPAN 有以下五种： 蓝牙技术（BlueTooth）：作为 RS232 数据线的无线连接，通过 2.4GHz 无需授权的 ISM 频段的微波，实现数据位流的过滤和传输，采用分散式网络结构、快速跳频和短包技术、时分双工传输方案，支持点对点及点对多点的通信 红外技术（IrDA）：利用红外线进行通信，最高通信速率 115.2kbps，主要优点是无需申请频率使用权，通信成本低廉，且体积小、功耗低、连接方便、简单易用 家庭射频技术（HomeRF）：数字无绳电话技术与 WLAN 技术融合发展的产物，采用共享无线连接协议 SWAP，工作在 2.4GHz ISM 频段 超宽带技术（UWB）：基于 IEEE 802.15.3 的超高速、短距离无线接入技术，较宽频谱上传输极低功率信号通信范围在 10 米范围内，能实现每秒数百兆位的数据传输率，具有抗干扰性强、传输速率高、带宽大、消耗电能低、保密性好等优势 紫蜂技术（ZigBee）：短距离、低功率、低速率无线接入技术，工作在 2.4GHz ISM 频段，速率 20~250kbps，传输距离 10~100m 【IEEE802.15 标准】1998年，IEEE 802.15 工作组成立, 专门从事 WPAN 标准化工作，其任务是开发一套适用于短程无线通信的标准，通常称之为无线个人局域网（WPANs） IEEE 802.15 工作组分为以下四个任务组： 任务组 TG1：制定 IEEE 802.15.1 标准，又称蓝牙无线个人区域网络标准，是一个中等速率、近距离的 WPAN 网络标准，通常用于手机、PDA 等设备的短距离通信 任务组 TG2：制定 IEEE 802.15.2 标准，研究 IEEE 802.15.1 与 IEEE 802.11（无线局域网标准）的共存问题 任务组 TG3：制定 IEEE 802.15.3 标准，研究高传输速率无线个人区域网络标准，该标准主要考虑无线个人区域网络在多媒体方面的应用，追求更高的传输速率与服务品质 任务组 TG4：制定 IEEE 802.15.4 标准，针对低速无线个人区域网络制定标准，该标准把低能量消耗、低速率传输、低成本作为重点目标，旨在为个人或者家庭范围内不同设备之音的低速互连提供统一标准 简单来说，四个任务组可概括为下表： 任务组 标准 领域 TG1 IEEE 802.15.1 无线 PAN TG2 IEEE 802.15.2 PAN 的共存 TG3 IEEE 802.15.3 高数据速率 PAN TG4 IEEE 802.15.4 Zigbee 低数据速率 PAN","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"动态路由与 RIP 协议的配置","slug":"network-system-integration/06.动态路由与RIP协议的配置","date":"2020-03-19T08:21:00.000Z","updated":"2021-08-24T13:43:12.417Z","comments":true,"path":"notes/network-system-integration/666b0912.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/666b0912.html","excerpt":"【动态路由】在全局配置模式下，使用 router 命令，即可确定 IOS 支持哪些协议，目前最常用的是 RIP 协议 对于动态路由协议来说，均具有以下三个要素：","text":"【动态路由】在全局配置模式下，使用 router 命令，即可确定 IOS 支持哪些协议，目前最常用的是 RIP 协议 对于动态路由协议来说，均具有以下三个要素： 数据结构：路由协议通常使用路由表或数据库来完成路由过程。此类信息保存在内存中 路由协议消息：路由协议使用各种消息找出邻近的路由器，交换路由信息，并通过其他一些任务来获取和维护准确的网络信息 算法：路由协议使用算法促进路由信息以确定最佳路径 动态路由协议的用途包括： 发现远程网络 维护最新路由信息 选择通往目标网络的最佳路径 当前路径无法使用时找出新的最佳路径 【RIP 协议】概述路由信息协议（RIP，Routing Information Protocols）是应用较早、使用较普遍的内部网关协议，适用于小型同类网络，是典型的距离矢量协议，因此 RIP 协议又被称为距离矢量路由选择协议，其是基于 UDP 协议，使用 520 端口的应用层协议。 RIP 协议只需要了解自身接口的网络地址，以及能够通过其邻居到达的远程网络地址，不需要了解网络拓扑结构。 RIP 协议版本RIP 协议有两个版本，RIPv1 与 RIPv2，目前最常用的是 RIPv2。 他们的对比如下： RIPv1 RIPv2 有类路由协议，不支持 VLSM 无类路由协议，支持 VLSM 以广播的形式发送更新报文 以组播的形式发送更新报文 不支持认证 支持明文和 MD5 的认证 工作流程 RIP 启动时，初始 RIP Database 仅包含本路由器声明的路由 RIP 协议启动后，会向各个接口广播或组播一个 REQUEST 报文 邻居路由器的 RIP 协议从某接口收 REQUEST 报文，根据自己的 RIP Database，形成 Update 报文向该接口对应的网络广播 RIP 接收邻居路由器回复的包含邻居路由器 RIP Database 的 Update 报文，形成自己的 RIP Database RIP 的度量值以跳数为计算标准，最大有效跳数为 15跳，当超过 15 跳时，统一设为 16，代表无穷大，即两终端间不可达 信息更新RIP 协议依托于时间周期的更新，依赖三种定时器维护其数据库： 更新定时器：每 30 秒将更新发送至其所有邻居 路由失效定时器：每 180 秒判断一次路由器是否失效，即判断 180 秒内对应的路由是否发送数据到该路由 清除路由条目定时器：每 240 秒清空一次路由条目 需要注意的是，即使拓扑结构不发生变化，RIP 协议也会进行更新操作。 【路由算法】概述距离矢量协议的核心是路由算法，路由算法用于计算最佳路径并将该信息发送给邻居，不同的协议采取不同的路由算法。 RIP 协议是一个典型的距离矢量协议，其适用 Bellman-Ford 算法作为路由算法。 路由算法定义了以下过程： 发送和接收路由信息的机制 计算最佳路径并将路由添加到路由表的机制 检测并响应拓扑结构变化的机制 不同的路由协议使用不同的算法将路由添加到路由表中、将更新发送给邻居以及确定路径 Bellman-Ford 算法假设路由器收到相邻路由器(地址为 X)的一个 RIP 报文，其会执行以下步骤： 1）修改此 RIP 报文中的相关字段：把 “下一跳” 中的地址都改为 X，并把所有的 “距离” 加 1，目的网络不变 2）对修改后的 RIP 报文中的每一个项目，重复以下步骤： ① 若项目中的目的网络不在路由表中，则把该项目添加到路由表中，否则，执行 ② ② 若下一跳字段给出的 IP 地址是同样的，则把收到的项目替换原路由表中的项目，否则，执行 ③ ③ 若收到项目中的距离小于路由表中的距离，则进行更新，否则，执行 ④ ④ 什么也不做 3）若 180 秒内没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达，即将距离设置为 16 4）返回到 1） 对于上述过程的步骤 2） 来说，可以采用以下方法进行记忆： 新路由添加 一下跳相同则替换 不同下一跳跳数小则替换 不同下一跳跳数一样或更大则不变 【路由环路】概述路由环路，是指数据包在一系列路由器之间不断传输却始终无法到达其预期目的网络的一种现象。 造成路由环路的常见原因有： 静态路由配置错误 路由重分布配置错误 发生了改变的网络中收敛速度缓慢，不一致的路由表未能及时地得到更新 错误配置或添加了丢弃的路由 距离矢量路由协议的工作方式比较简单，其简单性导致它容易存在路由环路之类的缺陷，在链路状态路由协议中，路由环路非常少见，但在个别特殊情况下也会发生。 解决方法常见的解决路由环路问题有以下方法： 定义最大值：利用 IP 数据包首部的生存时间 TTL 纠错 定义最大跳数：最大 15 跳，16 被认为不可达 水平分割：路由器向外发布某网段路由信息后不再接受从反方向发布回来的同一网段的路由更新信息 毒化反转：路由器从某个接口上接收到某个网段的路由信息之后，并不是不往回发送信息了，而是发送，只不过是将这个网段的跳数设为无限大，再发送出去（本质上一种改进的水平分割） 触发更新：当网络发生故障或得知网络拓扑结构发生改变时，路由器不再等待下一次的例行更新，而是立即通告更新后的全部路由表 抑制更新时间：如果一条路由更新的跳数大于路由表已记录的该路由的条数，那么将会引起该路由进入 180 秒的抑制状态阶段。在抑制计时器超时前，路由器不再接收关于这条路由的更新信息。 【RIP 的配置】RIP 启动与停止在配置模式 (config)# 中，利用 router rip 命令可以启动 RIP 协议配置模式，该命令实际上不直接启动 RIP 进程，而是提供了对路由器配置模式的访问。 利用 no router rip 命令可以停止 RIP 进程并清除现有的 RIP 配置 指定版本号在路由器模式 (config-router)# 中，利用 version 1 或 version 2 来指定 RIP 协议的版本号。 在配置了 RIP 进程的路由器上，默认运行 RIPv1，尽管路由器只发送 RIPv1 消息，但它可以同时处理 RIPv1 和 RIPv2 消息，实际上，RIPv1 路由器会忽略路由条目中的 RIPv2 字段 通告网络在路由器模式 (config-router)# 中，利用 network ip-address 来通告网络，其具有以下功能： 在指定网络地址所属的所有接口上启用 RIP 相关接口就开始发送和接收 RIP 更新 在每 30 秒一次的 RIP 路由更新中，向其它路由器通告该指定的网络地址 需要注意的是，ip-address 必须是与该路由器直连的有类网络地址，同时，如果输入子网地址，IOS 会自动将其转换为有类网络地址。 路由自动汇总在 RIPv2 版本中，禁用了路由自动汇总功能，而使用了手工汇总功能。 自动汇总不支持不连续的网络地址，但其使发送和接收的路由更新较少，从而使路由器之间的路由更新占用更少的带宽，减少路由表条目，加快路由表查找过程。 当使用 RIPv1 时，路由器总是在边界路由器上将网络总结为有类地址（自动汇总），默认情况下，RIPv2 像 RIPv1 一样在主网边界上自动总结网络，在关闭自动汇总功能后，RIPv2 在其路由更新中包含所有子网以及相应掩码。 在路由器模式 (config-router)# 中，利用 no auto-summary 命令可以禁用自动汇总功能。 在接口模式 (config-if)# 中，利用 ip summary-address rip subnet-mask 命令，可以将相同子网掩码进行自动汇总。 配置被动接口在默认情况下，通过所有启用了 RIP 的接口转发 RIP 更新，但实际上，只需要通过连接在其它也启用了 RIP 的路由器的接口发送 RIP 更新即可。 在路由器模式 (config-router)# 中，利用 passive-interface 接口名 命令可以进行配置。 该命令可阻止通过路由器接口广播或组播 RIP 路由更新，但是仍然允许其它接口将对应网络通告至其它路由器，此命令通常配合neighbor 命令使用。 【RIP 的验证】在特权模式 Router# 中，可以进行 RIP 的验证，常用的有以下命令： 清除路由表：clear ip route * 查看路由表：show ip route [rip] 查看路由协议配置：show ip protocols 在控制台显示 RIP 的调试状态：debug ip rip 在控制台显示 RIP 的调试状态：undebug ip rip、undebug all、no debug ip rip、no debug all","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"无线扩频技术","slug":"wireless-network/03.无线扩频技术","date":"2020-03-18T13:08:00.000Z","updated":"2021-10-31T13:22:08.890Z","comments":true,"path":"notes/wireless-network/ceddd871.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/ceddd871.html","excerpt":"【概述】随着无线带宽的要求越来越高，无线通信面临一个难题：在互不干扰的前提下，该如何增加无线带宽？ 为解决该问题，提出了扩频通信传输，即无线扩频技术，其最早应用于军事领域，实际目的是为了阻止敌人接收、译码并检测和干扰军队的无线通信","text":"【概述】随着无线带宽的要求越来越高，无线通信面临一个难题：在互不干扰的前提下，该如何增加无线带宽？ 为解决该问题，提出了扩频通信传输，即无线扩频技术，其最早应用于军事领域，实际目的是为了阻止敌人接收、译码并检测和干扰军队的无线通信 扩频技术的特性，能够承受严重的干扰，同时对敏感通信可以提供非常好的保密性，避免中途被截获，此外还具有良好的操作保密性，即使他人拥有技术与设备，并且准确了解所用频带，但仍然不能对传输信号干扰或者译码 【通信系统的两个指标】在通信系统中，存在两个基本问题： 有效性：通信系统传输信息效率的高低 可靠性：通信系统可靠地传输信息的能力 有效性可以理解为给定信道内所传送信息量的大小，显然，有效性越高系统的性能越好 可靠性是用来衡量收到的信息和发出的信息之间的符合程度的，其取决与通信息系统的抗干扰能力 简单来说，追求有效性，就是追求通信数据的数量，追求可靠性，就是追求通信数据的质量 【理论基础】扩频技术的理论依据是香农公式： C=W*log_2(\\frac{S}{N})其中，$C$ 为信道容量，它是信道可能传输的最大信息速率，$W$ 为信道带宽，$S$ 为有用信号的平均功率，$N$ 为白噪声的平均功率，$\\frac{S}{N}$ 是信噪比 依据香农公式，在给定的传输速率 $C$ 不变的条件下，频带宽度 $W$ 和信噪比 $\\frac{S}{N}$ 是可以互换的，即可通过增加频带宽度的方法，在较低的信噪比情况下，传输信息 扩展频谱换取信噪比要求的降低，正是扩频通信的重要特点，由此为扩频通信的应用奠定了基础。 【扩展频谱的原理】扩频通信技术是一种信息传输方式，其信号所占有的频带宽度远大于所传信息必需的最小带宽 频带的扩展是通过一个独立的码序列来完成，用编码及调制的方法来实现的，与所传信息数据无关，在接收端则用同样的码进行相关同步接收、解扩及恢复所传信息数据 这就使得在同一个频道内可以将几十个乃至几百个电路和发射机互相堆积，共同使用非常宽的频道，在这个过程中，通过系统自动平衡、自我调节来进行调整 其一般性描述如下： 【实现方式】扩频技术有两种实现方式： 直接序列扩频（DSSS）：为实现保密话音通信而提出，使用调幅技术，合并数据信号与载波信号的波形 跳频扩频（FHSS）：作为反干扰策略提出，不断的在频道之间切换载波信号来发射信号 直接序列扩展频谱（DSSS）DSSS 是将两个数字信号加到一起得到第三个实际传输比特流： 第一个信号是信息信号，即信号源 第二个信号是由随机序列产生器产生的随机伪噪声比特流 得到的第三个混合信号的比特流的速率与第二个信号相同 直接序列扩频技术为共享频谱提供了可能，使用扩频技术能够实现码分多址，即在多用户通信系统中所有用户共享同一频段，但是通过给每个用户分配不同的扩频码实现多址通信 每个比特由扩展码的多个比特表示，扩展码信号占更宽的频率，但扩展码与所用的比特成比例，例如：$10$ 比特扩展码将信号扩展到 $10$ 倍宽的频道 最常用的一种方法是将输入信号与扩展码进行异或操作，即输入比特 $1$ 时将扩展码反转，输入比特 $0$ 时不改变扩展码，这仅改变了比特流，数据率与原始的扩展码速率相同 以下是一个发送 010010111 比特流的实例： 跳频扩展频谱技术（FHSS）跳频扩频技术通过不断的在频道之间切换载波信号来发射信号，确切的说，跳频系统应该叫做多频、选码和频移键控通信系统 其是用二进制伪随机码序列去控制射频载波震荡器输出信号的频率，使发射信号的载波频率随伪随机码的变化而跳变 频率跳变系统可供随机选取的载波频率数通常是几千到几万个离散频率，在众多的离散频率中，每次输出哪一个由伪随机码决定 在频率跳变系统中，信号在一串随机序列的频率上广播，接收者以与发送者同步的方式跳转频率，跳频能克服噪声干扰和多径效果，使得干扰仅影响某个频率上的有限的几个比特，不仅没有传统意义上的阻塞，还会令窃听者窃听到的信息难以理解 一个好的跳频图案应具备以下几点： 图案本身的随机性要好, 要求参加跳频的每个频率出现的概率相同，因为随机性越好, 抗干扰能力就就强 图案的密钥量要大, 要求跳频图案的数目要足够多，这样抗破译的能力强 各图案之间出现频率重叠的机会要尽量的小, 要求图案的正交性要好，这样有利于组网通信和多用户的码分多址","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件结构化设计","slug":"software-engineering/07.软件结构化设计","date":"2020-03-18T06:35:00.000Z","updated":"2022-05-13T04:28:07.622Z","comments":true,"path":"notes/software-engineering/f999a535.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/f999a535.html","excerpt":"【概述】结构化软件设计的任务是从软件需求规格说明书出发，设计软件系统的整体结构（总体设计）、确定每个模块的实现算法以及编写具体的代码（详细设计），形成软件的具体设计方案，解决 “怎么做” 的问题","text":"【概述】结构化软件设计的任务是从软件需求规格说明书出发，设计软件系统的整体结构（总体设计）、确定每个模块的实现算法以及编写具体的代码（详细设计），形成软件的具体设计方案，解决 “怎么做” 的问题 要进行结构化的设计，必须依据结构化分析的结果，结构化设计与结构化分析的关系如图所示。图的左边是用结构化分析方法所建立的模型，图的右边是用结构化设计方法所建立的设计模型 【软件结构图形工具】层次图与 HIPO 图通常使用层次图来描绘软件的层次结构，在层次图中一个矩形框代表一个模块，框间的连线表示调用关系 每个方框可以带编号，带编号的层次图称为 HIPO 图 结构图结构图是描绘软件结构的图形工具，图中一个方框代表一个模块，框内注明模块的名字或主要功能，方框之间的箭头或直线表示模块的调用关系 利用菱形和带箭头的弧线，还可以表示选择调用和循环调用 依据结构图中使用循环调用的的不同，可以分为扇入和扇出，加之深度与宽度，这四者称为结构图的形态特征 在结构图中通常还用带注释的箭头表示模块调用过程中来回传递的信息，如果希望进一步标明传递的信息是数据还是控制信息，则可以利用注释箭头尾部的形状来区分，尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息 层次图与结构图的异同层次图和结构图都可用来表示软件的结构层次，描述模块间的调用关系 但结构图不仅能表示模块间接口传递的数据信息、控制信息，还能表示选择调用和循环调用 【结构化设计方法】概述结构化设计方法分为总体设计和详细设计 总体设计是面向数据流的设计方法，依据对数据处理的不同，分为变换型数据流和事务型数据流 详细设计是面向数据结构的设计方法，最流行的是 Jackson 方法 总体设计概述面向数据流的设计方法是常用的结构化设计方法，多在概要设计阶段使用，依据一定的映射规则，将需求分析阶段得到的数据描述从系统的输入端到输出端所经历的一系列变换或处理的数据流图转换为目标系统的结构描述 在数据流图中，数据流分为变换型数据流和事务型数据流两种 变换，是指把输入的数据处理后转变成另外的输出数据，信息沿输入路径流入系统，在系统中经过加工处理后又离开系统，当信息流具备这种特征时就是变换流 事务，是指非数据变换的处理，它将输入的数据流分散成许多数据流，形成若干个加工，然后选择其中一个路径来执行 变换型数据流对于变换型数据流图的设计可以分为以下几步： 复审、精化数据流图 确定输入数据、变换中心、输出数据，并在数据流图上用虚线标明分界线 得到系统的初始化结构图 对系统结构图进行优化 事务型数据流对事务型数据流图设计可以分为以下几步： 复审、精化数据流图 确定事务中心、接收数据、处理路径 得到系统的初始化结构图 分解和细化接收分支和处理分支 详细设计概述详细设计是面向数据结构的设计方法，最流行的是 Jackson 方法 其是将数据结构转换为程序结构的一种设计方法 Jackson 方法Jackson 方法绘出的 Jackson 图便于表示层次结构，而且是对结构进行自顶向下分解的有力工具，其形象直观可读性好，既能表示数据结构也能表示程序结构 Jackson 方法将数据结构分为 3 种基本类型：顺序型结构、选择 型结构和循环型结构 在顺序型结构中，数据由一个或多个元素组成，每个元素按照确定的次序出现一次。如下图图示，数据 A 由 B、C、D 这 3 个元素顺序组成。 在选择型结构中，数据包含两个或多个元素，每次使用该数据时，按照一定的条件从罗列的多个数据元素中选择一个。如下图图示，数据 A 根据条件从 B 或 C 或 D 中选择一个，元素右上方的符号 ° 表示从中选择一个 在循环型结构中，数据根据使用时的条件由一个数据元素出现零次或多次构成。如下图图示，数据 A 根据条件由元素 B 出现零次或多次组成，元素后加符号 * 表示重复 Jackson 结构程序设计方法的步骤如下： 分析并确定输入数据和输出数据的逻辑结构，并用 Jackson 图描绘这些数据结构 找出输入数据结构和输出数据结构中有对应关系的数据单元 按照一定规则从描绘数据结构的 Jackson 图导出描绘程序 结构的 Jackson 图 列出所有操作和条件，并且把它们分配到程序结构图的适当位置 用伪代码表示程序 【接口设计】软件系统结合业务、功能、部署等等因素将软件系统逐步分解到模块，那么模块与模块之间就必须根据各模块的功能定义对应的接口 总体设计中的接口设计主要用于子系统/模块之间或内部系统与外部系统进行各种交互 接口设计的内容应包括功能描述、接口 的输入输出定义、错误处理等 软件系统接口的种类以及规范很多，可以有 API、服务接口、文件、数据库等等，所以设计的方法也有很大的差异。但总体来说，接口设计的内容应包括通讯方法、协议、接口调用方法、功能内容、输入输出参数、错误/例外机制等 从成果上来看，接口一览表以及详细设计资料是必须的资料。 接口设计一般包括 3 个方面： 用户接口：用来说明将向用户提供的命令和它们的语法结构以及软 件回答信息 外部接口：用来说明本系统同外界的所有接口的安排包括软件与硬件之间的接口、本系统与各支持软件之间的接口关系 内部接口：用来说明本系统之内的各个系统元素之间的接口的安排 【过程设计】概述任何程序总可以用三种结构化构成元素来设计和实现： 顺序结构：任何算法规约中的核心处理步骤 条件结构：允许根据逻辑情况选择处理的方式 循环结构：提供了循环过程 过程设计工具可以分为以下三类： 图形设计符号：流程图、N-S 图、PAD 图等 表格设计符号：判定表等 程序设计语言：PDL 等 流程图流程图是对过程、算法、流程的一种图形表示，它对某个问题的定义、分析或解法进行描述，用定义完善的符号来表示操作、数据、流向等概念 流程图分为数据流程图、程序流程图、系统流程图、程序网络图和 系统资源图 程序流程图也称为程序框图，是一种比较直观、形象地描述过程的控制流程的图形工具，其符号简单规范，画法简单，结构清晰，逻辑性强，便于描述，容易理解，但不利于逐步求精的设计，不易于表示系统中所含的数据结构，同时，由于图中可用箭头随意地对控制进行转移，这与结构化程序设计精神相悖 程序流程图包含 5 种基本的控制结构：顺序型、选择型、先判定型循环、后判定型循环和多分支选择型 程序流程图的基本符号如下图： N-S 图N-S 图又被称为盒图，是一种符合结构化程序设计原则的图形工具 N-S 图用类似盒子的矩形以及矩形之间的嵌套来表示语句或语句序列，图内没有箭头，因此，它所表示的控制流程不能随便进行转移，这有利于严格的结构化程序设计，同时可以很方便地确定一个特定控制结构的作用域，以及局部数据和全局数据的作用域，嵌套关系以及模块之间的层次关系也十分容易表示 N-S 图的基本符号如下： PAD 图PAD 图，也叫问题分析图，用二维树形结构的图来表示程序的控 制流及逻辑结构 在PAD图中，一条竖线代表一个层次，最左边的竖线是第一层控制结构，随着层次的加深，图形不断地向右展开 PAD 图为常用的高级程序设计语言的各种控制语句提供了对应的图形符号，其所表示的程序结构的执行顺序是自最左边的竖线的上端开始，自上而下，自左向右，这使得所表示的程序片断结构清晰、层次分明，故而其不仅可以表示程序逻辑，还能表示数据结构，但其只能用于结构化的设计 PAD图的基本符号如下： 结构化语言结构化语言 PDL，又称程序设计语言、伪代码，其是用正文形式表示数据和处理过程的设计工具，是一种笼统的名称，现在有许多种不同的程序设计语言在使用 PDL 具有严格的关键字外语法，用于定义控制结构和数据结构，同时它的表示实际操作和条件的内语法又是灵活自由的，可以使用自然语言的词汇，但其不如图形工具形象直观，当描述复杂的条件组合与动作间的对应关系时，也不如判定表清晰简单 PDL 可以作为注释直接插在源程序中间,这样做能促使维护人员在修改程序代码的同时也相应地修改 PDL 注释，有助于保持文档和程序的 一致性，提高了文档的质量。同时，PDL 可以使用普通的正文编辑程序或文字处理系统，能够很方便地完成 PDL 的书写和编辑工作 当已经有自动处理程序存在时，而且可以自动由 PDL 生成程序代码 下图使用 PDL 语言描述了在数组 A[1] 到 A[10] 中寻找最大的数","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"软件设计","slug":"software-engineering/06.软件设计","date":"2020-03-16T08:08:00.000Z","updated":"2022-05-13T04:24:04.738Z","comments":true,"path":"notes/software-engineering/492e1209.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/492e1209.html","excerpt":"【概述】软件设计是所有软件工程活动和随后的软件支持活动的基础，其是一个迭代的过程，通过设计过程，需求被变换为用于构建软件的蓝图 McGlaughlin 提出了可以指导评价良好设计演化的 3 个特征：","text":"【概述】软件设计是所有软件工程活动和随后的软件支持活动的基础，其是一个迭代的过程，通过设计过程，需求被变换为用于构建软件的蓝图 McGlaughlin 提出了可以指导评价良好设计演化的 3 个特征： 设计必须实现所有包含在分析模型中的明确需求，而且必须满足用户期望的所有隐含需求 对于程序员、测试人员和维护人员而言，设计必须是可读的、可理解的指南 设计必须提供软件的全貌，从实现的角度说明数据域、功能域和行为域 【软件设计分类】软件设计可以从活动任务观点和工程管理观点分别对其分类 活动任务观点从活动任务来看，软件设计是对软件需求进行设计： 数据设计：数据设计创建在高抽象级别上表示的数据模型和信息模型。然后，数据模型被精化为越来越多和实现相关的特定表示，即基于计算机的系统能够处理的表示 体系结构设计：体系结构设计为我们提供软件的整体视图，定义了软件系统各主要成份之间的关系 接口设计：接口设计告诉我们信息如何流入和流出系统以及被定义为体系结构一部分的构件之间是如何通信的 构件设计：构件设计完整的描述了每个软件构件的内部细节，为所有本地数据对象定义数据结构，为所有在构件内发生的处理定义算法细节，并定义允许访问所有构件操作的接口 部署设计：部署设计指明软件功能和子系统如何在支持软件的物理计算环境内分布 工程管理观点从工程管理角度来看，软件设计分为概要设计和详细设计，前期进行概要设计，得到软件系统的基本框架。后期进行详细设计，明确系统内部的实现细节 概要设计确定软件的结构以及各组成部分之间的相互关系，其以需求规格说明书为基础，概要地说明软件系统的实现方案 概要设计包括目标系统的总体架构、每个模块的功能描述、数据接口描述及模块之间的调用关系、数据库、数据定义和数据结构等 其中，目标系统的总体架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素之间的相互作用、指导元素集成的模式以及这些模式的约束组成 详细设计确定模块内部的算法和数据结构，产生描述各模块程序过程的详细文档。它对每个模块的功能和架构进行细化，明确要完成相应模块的预定功能所需要的数据结构和算法，并将其用某种形式描述出来 详细设计的目标是得到实现系统的最详细的解决方案，明确对目标系统的精确描述，从而在编码阶段可以方便地把这个描述直接翻译为用某种程序设计语言书写的程序 在进行详细设计的过程中，设计人员的工作涉及到的内容有过程、数据和接口等。过程设计主要是指描述系统中每个模块的实现算法和细节，数据设计是对各模块所用到的数据结构的进一步细化，接口设计针对的是软件系统各模块之间的关系或通信方式以及目标系统与外部系统之间的联系 【数据库结构设计】数据库结构设计包括概念结构设计、逻辑结构设计和物理结构设计 概念结构是系统中各种数据模型的共同基础，它描述了系统最基础的数据结构，独立于特定的数据库系统 逻辑结构提供了比较接近数据库内部构造的逻辑描述，它能够为数据库物理结构的创建提供便利 物理结构是指数据库的物理数据模型，它包括数据库服务器物理空间上的表、存储过程、字段、视图、触发器、索引等，与特定的数据库系统密切相关 【用户界面设计】概述用户界面设计是接口设计的一个组成部分 对于交互式系统来说，用户界面设计和数据设计、体系结构设计、过程设计一样重要，用户界面的设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命，因此，必须对用户界面设计给予足够重视 设计活动是基于一定的目的与流程的，它明确设计活动的最终方向，并保证设计活动的正确性和高效率 设计驱动开发作为应用程序开发者，在设计应用程序的过程中必须遵循同类软件乃至其所运行的操作系统的使用习惯，只有这样才能避免过高的学习和适应成本，给用户带来 “熟悉感”，从而让用户获得更好的使用体验 软件界面设计的好坏通常不仅仅是美观与否的问题，一个精良的设计往往能让应用程序本身变得更加高效和易于使用，相反，一个糟糕的设计则完全可能让开发者在应用上的其他努力付诸东流 因此，在现代应用程序的开发过程中，用户界面设计所占的地位越来越重要。对于开发者来说，用户界面设计并不仅仅是图像或美学设计，而是应用一系列简单而实用的准则或策略来改善软件易用性的一个步骤 目标用户群体为了帮助用户更好地在对一个新的软件产品做需求分析和功能设计之前，必须要明确软件所针对的用户群体，以及用户群的具体特征，只有这样才能设计并开发出对用户有价值的功能 用户本身的技能、个性、性别、年龄、所受教育以及文化背景上的差异，用户的基础计算机操作水平，用户在相关领域的专业知识，都可能导致用户对界面的需求的不同 用户界面作为应用程序和用户交互的核心途径，必须将不同用户对界面的不同需求考虑在其中，这样才能给用户提供最好的使用体验。否则，即使软件内部的功能十分强大，如果界面使用起来体验非常糟糕，用户也不会选择使用它 简洁与清晰在界面设计中，应当仔细斟酌每个界面元素的作用、重要性和交互方式，将重要的界面元素放置在显著位置，不太重要的界面元素则降级到相对次要的位置，并凸显界面元素之间的层次感和逻辑感，避免对空间进行罗列和堆叠 此外，对于展示实际用户内容的界面，不应使得软件工具栏和其他辅助控件过多地占用用户实际内容的屏幕空间，或干扰用户正常浏览应用所展示的内容 实现模型与心智模型从程序开发人员的角度出发，开发一个应用程序所需要用到的技术解决方案，称之为这个程序的实现模型 例如：在开发一个在线的物品交易平台时，使用 Python 作为后端语言，HTML、CSS、JavaScript 等作为前端语言，MySQL 作为数据库引擎，这些都属于实现模型 实现模型往往包含了复杂艰深的理论、技术、算法等内容，这些内容在开发过程中对开发者来说是至关重要的，但是却不会被大多数用户所了解 与实现模型不同，软件的真实用户对该软件用法和运作方式的个人理解，则称之为心智模型，心智模型有助于用户理解自己使用软件的过程，预测某个操作的结果，并应对出乎意料的情况 设计的规范性大多数主流操作系统都有一套专门的设计规范，以供开发者和程序设计人员参考 例如：对于 macOS，苹果公司发布过官方的人机界面指南，其完整版本在苹果开发者网站即可找到 应用程序的开发者和设计人员在设计一个应用程序时，应当通读、理解并严格遵守相关设计指南中的设计要求 设计的可用性和易用性在设计和开发中，可用性是衡量一个应用程序用户体验好坏的重要标准之一 具有良好的可用性，要求应用具有：容易学习掌握、高效、令人愉悦这 3 个特性 没人喜欢使用复杂、晦涩、难以掌握的应用程序，为获得良好的可用性，在设计和开发的每个步骤和每一轮迭代中，开发人员都应该将软件的目标用户作为核心，在实际使用环境中，以真实用户的需求、偏好和习惯为导向，对产品的设计进行不断优化 设计的一致性在界面以及交互设计中，追求一致性是非常重要的，它允许用户将先前已经建立的使用习惯和知识带入到一个全新的应用程序中 根据一致性的范围，可将其大致分为两类： 外部一致性：每个操作系统都有其固有的操作模式及标准的用户界面元素，一个设计良好的应用应当遵循这些惯例 内部一致性：在一个应用内部应该保持统一，不应产生歧义或自相矛盾 此外，在界面的样式设计上，一个应用也应当具有一个统一的风格，包括颜色搭配和使用、控件样式，字体、动画、阴影等各种设计元素的运用 设计的容错性良好的容错性允许用户大胆地探索一个应用程序的所有功能，因为绝大部分操作都是可逆的、非破坏性的 如果用户确信他们可以大胆地尝试每个按钮的用途而不用担心他们的操作系统或数据被损坏，应用程序的用户体验会大大提高 此外，良好的容错性也会让应用程序显得更加稳定、可靠，如果用户发现在一个应用程序中并不会因为无意中的操作就造成严重错误，他们自然会更加信任这一应用程序","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"软件设计原则","slug":"software-engineering/05.软件设计原则","date":"2020-03-16T07:04:00.000Z","updated":"2022-05-13T04:22:34.936Z","comments":true,"path":"notes/software-engineering/fe11691e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/fe11691e.html","excerpt":"【概述】软件设计在软件开发过程中处于核心地位，它是保证质量的关键步骤，其提供了可以用于质量评估的软件表示，是能将用户需求准确地转化为软件产品或系统的唯一方法 为提高软件开发的效率及软件产品的质量，在长期的软件开发实践中总结出一些软件设计的原则","text":"【概述】软件设计在软件开发过程中处于核心地位，它是保证质量的关键步骤，其提供了可以用于质量评估的软件表示，是能将用户需求准确地转化为软件产品或系统的唯一方法 为提高软件开发的效率及软件产品的质量，在长期的软件开发实践中总结出一些软件设计的原则 【模块与模块化】模块模块是数据说明、可执行语句等程序对象的集合，是构成程序的基本构件，可以被单独命名并通过名字来访问 在面向过程的设计中，过程、函数、子程序、宏都可以作为模块，在面向对象的设计中，对象、对象中的方法也是模块 模块具有三个属性： 功能：指定该模块要完成的任务 逻辑：描述模块为了完成任务内部需要怎么做 状态：表明使用该模块时的环境与条件 模块化模块化就是把系统或程序划分为独立命名并且可以独立访问的模块，每个模块完成一个特定的子功能。模块集成起来可以构成一个整体，完成特定的功能，进而满足用户需求 模块独立性是良好设计的关键，其是指软件系统中每个模块只涉及软件要求的具体的子功能，与软件系统中的其他模块没有太多联系 模块独立性使模块容易组合、可以复用，有助于并行开发，并减少错误的影响，同时有助于系统的测试与维护 模块独立性有两个定性标准度量： 耦合：衡量不同模块之间的互连程度，耦合强弱取决于模块间接口的复杂程度、通过接口的数据等，耦合性越强，模块独立性就越弱。 内聚：衡量模块内部各元素间结合的紧密程度，内聚性越高，就意味着模块内部各个元素是为了完成一个功能而存在的。 内聚和耦合是密切相关的，模块内的高内聚，往往意味着模块间的松耦合 在模块化的过程中，要注意以下几点： 模块的规模要适中：随着模块数目的增加，软件成本与模块接口成本不断增加 提高模块的独立性：随着模块独立性的提高，使得模块低耦合，高内聚 加强模块的保护性：当一个模块内部出现异常时，其负面影响应该尽量局限在该模块内部，从而保护其他模块不受影响，降低错误的影响范围 【抽象】抽象是抽出事务的本质特征而暂时不考虑他们的细节，主要是为了降低问题的复杂度，以得到问题领域中较简单的概念，好让人们能够控制其过程或以宏观的角度来了解许多特定的事态 其是人们认识复杂的客观世界时所使用的一种思维工具，在软件开发过程中起着非常重要的作用 一个庞大、复杂的系统可以先用一些宏观的概念构造和理解，然后再逐层地用一些较微观的概念去解释上层的宏观概念，直到最底层的元素 在软件开发过程中，每一个过程都涉及到抽象： 可行性分析：把需要解决问题抽象为一个解 需求分析：把需要解决的解抽象为功能 总体设计：把系统抽象为结构 详细设计：把结构抽象为每个模块的处理过程 编码阶段：把处理过程抽象为机器能够执行的程序 【逐步求精】在面对一个新问题时，开发人员可暂时忽略问题非本质的细节，而关注于与本质相关的宏观概念，集中精力解决主要问题，这种认识事物的方法就是逐步求精 逐步求精是抽象的逆过程，开发人员认识问题时逐步求精的过程，同时也是抽象程度逐渐降低的过程 按照逐步求精的思想，程序的体系结构是按照层次结构，逐步精化过程细节而开发出来的，可见，求精就是细化，它与抽象是互补的概念 【信息隐藏】信息隐藏是指一个模块内包含的信息，对于不需要这些信息的模块来说，是不能访问的，即该模块相对应其他模块是隐藏的 信息隐藏的目的，是为了提高模块的独立性，加强了外部对模块内部信息进行访问的限制，使得模块的局部错误尽量不影响其他模块 通常，模块的信息隐藏可以通过接口来实现，模块通过接口与外部进行通信，而把模块的具体实现细节隐藏起来 一般来说，一个模块具有有限个接口，外部模块通过调用相应的接口来实现对目标模块的操作 【复用性设计】软件复用就是将已有的软件成分用于构造新的软件系统 可以被复用的软件成分一般称作可复用构件，无论对可复用构件原封不动地使用还是作适当的修改后再使用，只要是用来构造新软件，则都可称作复用 软件复用不仅仅是对程序的复用，它还包括对软件生产过程中任何活动所产生的制成品的复用，例如：软件开发计划、可行性研究报告、分析模型、设计模型、源程序、测试用例等等 如果是在一个系统中多次使用一个相同的软件成分，则不称作复用，而称作共享 对一个软件进行修改，使它运行于新的软硬件平台也不称作复用，而称作软件移值 【灵活性设计】灵活性设计，是软件在面对需求修改时的随机应变能力，可以体现在修改程序代码的工程量等方面 抽象是软件设计的关键因素。设计模式、软件架构等可以用来实现更高抽象层次的编程，以达到软件的灵活性 在设计中引入灵活性的方法如下： 提高模块独立性：降低耦合并提高内聚 建立抽象：创建有多态操作的接口和父类 不要将代码写死：消除代码中的常数 抛出异常：由操作的调用者处理异常 复用设计：使用并创建可复用的代码","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"静态路由与默认路由","slug":"network-system-integration/05.静态路由与默认路由的配置","date":"2020-03-13T05:27:00.000Z","updated":"2021-08-24T13:41:20.262Z","comments":true,"path":"notes/network-system-integration/639d7cdd.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/639d7cdd.html","excerpt":"【静态路由类型】标准静态路由：用于连接到末节网络。","text":"【静态路由类型】标准静态路由：用于连接到末节网络。 默认静态路由：与所有数据包都匹配的路由，在没有获取的路由或静态路由的情况下，默认路由用于识别发送所有 IP 数据包的网关 IP 地址，简单来说，就是 0.0.0.0/0 表示所有路由。 总结静态路由：为减少路由表大小，如果多条静态路由可以总结成一条静态路由，那么可以使用总结静态路由，要求符合以下条件： 目的网络可以总结成一个网络地址 多条静态路由都使用相同的送出接口或下一跳 IP 地址 浮动静态路由：在前缀和掩码相同时，AD 值小的才会加入路由表，但 AD 值大的那条路由并非被丢弃了，而是沉入水中，等待时机，一旦路由表中的那条路由出问题不能用了，才浮出水面被加入进路由表。 【静态路由与默认路由的配置】静态路由使用 ip route network-address subnet-mask {ip-address | exit-intf} 命令可以进行静态路由配置。 在配置时，下一跳可以通过 IP 地址、送出接口或两者结合进行识别，根据如何指定目标，路由分为以下三种类型： 下一跳路由：仅指定下一跳 IP 地址 直连静态路由：仅指定路由器送出接口 完全指定静态路由：指定下一跳 IP 地址和送出接口 默认路由当需要进行默认路由配置时，使用 ip route 0.0.0.0 0.0.0.0 {ip-address | exit-intf} 即可。 【静态路由和默认路由问题故障排除】在配置静态路由与默认路由时，一般存在两种问题：缺失路由故障、连接故障。 缺失路由故障排除对于缺失路由故障，我们可以利用以下命令进行测试，从而排除： ping ip-address：检测当前设备与目的 ip 的网络连通情况 traceroute ip-address：定位当前设备与目的 ip 之间的所有路由器 show ip route：查看路由表 show ip interface brief：查看当前设备上当前状态下所有接口的 ip 简单配置信息 show cdp neighbors detail：查看 CDP 邻居的详细信息，以查看邻居的管理 IP 地址 连接故障排除对于连接故障，可以按照以下步骤进行排除： 使用 ping 或 traceroute 命令来确认无法到达的目的地 使用 show ip route 命令来检查路由表，查找缺失或配置错误的路由 值得注意的是，错误的静态路由是导致路由问题的一种常见原因。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"路由表分析","slug":"network-system-integration/04.路由表分析","date":"2020-03-12T14:11:00.000Z","updated":"2021-08-24T13:44:52.484Z","comments":true,"path":"notes/network-system-integration/77da1160.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/77da1160.html","excerpt":"【路由表路由源】路由表存储在 RAM 中，包含直连路由和远程路由两种信息 使用 show ip route 命令可显示路由表路由源的内容：","text":"【路由表路由源】路由表存储在 RAM 中，包含直连路由和远程路由两种信息 使用 show ip route 命令可显示路由表路由源的内容： 本地路由接口 ：接口配置完成后会添加到路由表中 直连接口：当接口已配置并处于活动状态时会添加到路由表中 静态路由：当路由已手动配置且退出接口处于活动状态时添加 动态路由协议：在使用 EIGRP 或 OSPF 协议，并且网络已识别的情况下添加该协议 以 L 开头的条目表示本地路由，以 C 开头的表示直连路由，其解释如下： 以 D 开头的条目代表一个远程网络的路由条目，其解释如下： 需要注意的是，新部署的路由器不含任何配置接口，其使用空的路由表 【静态路由与动态路由】路由器可通过两种方式获知远程网络，一种是利用静态路由将远程网络手动输入到路由表中，另一种是利用动态路由协议自动获取远程路由 静态路由静态路由是手动配置的，将直连接口添加至路由表即可使用，定义了两个网络设备之间的明确路径，如果拓扑发生变化，则必须手动更新静态路由，使用静态路由不仅更加安全，也可以更好地掌控资源 静态路由相对于动态路由有以下优势： 静态路由不通过网络通告，从而能够提高安全性。 静态路由比动态路由协议使用更少的带宽，且不需要使用 CPU 周期计算和交换路由信息 静态路由用来发送数据的路径已知 静态路由通常在以下情景使用： 在小型网络中，使用静态路由便于维护路由表 为末节网络提供最后选用网关，末节网络是由单个路由访问的网络，而且路由器没有其他邻居 通过将多个连续网络汇总为一个静态路由，减少通告的路由数 如果主路由链路发生故障，则创建备份路由 如果某个网络在路由表中找不到更匹配的路由条目，则可使用默认路由作为通往该网络的路径 动态路由动态路由是路由器使用动态路由协议自动维护的，其共享了有关远程网络连通性和状态的信息，可以自动发现网络，并维护路由表，路由器在完成交换和路由表更新后已经聚合 在全局配置模式下，使用 router 命令，即可确定 IOS 支持哪些协议，目前最常用的是 RIP 协议 其优缺点如下：","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"路由决策","slug":"network-system-integration/03.路由决策","date":"2020-03-12T01:36:00.000Z","updated":"2021-08-24T13:40:57.843Z","comments":true,"path":"notes/network-system-integration/490b2cdc.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/490b2cdc.html","excerpt":"【路由决策流程】在不同网络间交换数据包时，是利用数据包转发决策来进行交换的，其流程图如下：","text":"【路由决策流程】在不同网络间交换数据包时，是利用数据包转发决策来进行交换的，其流程图如下： 【最近路径的选择】在路径决定的过程中，需要确定最佳路径。 路由协议利用值或度量确定到达某个网络的距离，从而选择最佳路径： 度量是用于衡量到达特定网络的距离的值 度量值最低的路径是到达网络的最佳路径 动态路由协议通常使用其自身的规则和度量来建立和更新路由表： 路由信息协议(RIP)：根据跳数进行度量 开放式最短路径优先(OSPF)：基于从源到目的地的累积带宽的成本进行度量 增强型内部网关路由协议(EIGRP)：基于带宽、延迟、负载和可靠性进行决定 【负载均衡】当路由器有两个或多个路径通往目的地的成本度量都相等时，路由器会同时使用两条路径转发数据包，此时称为等价负载均衡，其可以提升网络性能。 等价负载均衡可根据需求来配置使用动态路由协议或静态路由。 【管理距离】如果路由器上配置有多条到达目的地的路径，安装在路由表中的路径则是具有最低管理距离(AD)的路径。 例如：AD 为 1 的静态路由比 EIGRP 发现的 AD 为 90 的路由更为可靠；AD 为 0 的直连路由比 AD 为 1 的静态路由更为可靠。 【实例】下面给出一个在网络之间交换数据包的实例。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"软件结构化分析","slug":"software-engineering/04.软件结构化分析","date":"2020-03-09T06:36:00.000Z","updated":"2022-05-13T04:21:19.729Z","comments":true,"path":"notes/software-engineering/ba1fa7c2.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/ba1fa7c2.html","excerpt":"【概述】结构化分析方法（SA，Structured Analysis）是一种考虑数据和处理的需求分析方法，其基于分解和抽象的基本思想，逐步建立目标系统的逻辑模型，进而描绘出满足用户要求的软件系统 其是一种面向数据流的需求分析方法，适用于数据处理类型软件的需求分析，利用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止","text":"【概述】结构化分析方法（SA，Structured Analysis）是一种考虑数据和处理的需求分析方法，其基于分解和抽象的基本思想，逐步建立目标系统的逻辑模型，进而描绘出满足用户要求的软件系统 其是一种面向数据流的需求分析方法，适用于数据处理类型软件的需求分析，利用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止 分解是指对于一个复杂的系统，为将复杂性降低到可以掌握的程度，可以把大问题分解为若干个小问题，然后再分别解决 抽象是指在逐层分解的过程中，起初不考虑细节问题，关注的是系统的本质属性，随着分解向下进行，逐步考虑越来越具体的细节 如下图，最顶层描述了整个目标系统 X；中间层将目标系统划分为若干模块，每个模块完成一定的功能；最底层是对每个模块的细节性描述 【结构化分析方法】结构化分析实质上是一种创建模型的活动，其建立的分析模型如下图所示： 模型的核心是数据字典，其描述软件使用或产生的所有数据对象，围绕着这个核心有 $3$ 种不同的图： 实体-关系图：又称 E-R 图，描绘数据对象之间的关系，用于数据建模 数据流图：又称 DFD 图，指出当数据在软件系统中移动时怎样被变换，以及描绘变换数据流的功能和子功能，用于功能建模 状态转换图：指明了作为外部事件结果的系统行为，用于行为建模 【数据字典】概述数据字典以一种系统化的方式定义在分析模型中出现的数据对象及控制信息的特性，给出它们的准确定义，包括数据流、数据存储、数据项、数据加工，以及数据源点、数据汇点等 数据字典是分析模型中的 3 种模型黏合在一起的黏合剂，是分析模型的核心 一般将其作为数据流图的补充，对数据流图中的所有元素作详细的文字说明 采用符号 符号 含义 实例 = 等价于/定义为 x=a + 与/连接 x=a+b [｜] 或/选择 x=[a｜b] m{}n 重复 m…n 次 x=1{a}5 () 可选 x=a+(b) “” 基本数据元素 x=”0” .. 范围 x=”1”..”9” 【功能模型】概述功能建模的思想就是用抽象模型的概念，按照软件内部数据传递和变换的关系，自顶向下逐层分解，直到找到满足功能要求的可实现的软件为止 功能模型用数据流图来描述，数据流图就是采用图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法 组成数据流图通过外部实体、数据流、数据变换、数据存储四种元素来进行模型表示： 外部实体：数据的源点或终点，是系统之外的实体，可以是人、物或其他系统，可以用来明确系统和环境的界限，同一个外部实体可以在一张数据流程图中出现若干次 数据流：表示数据和数据的流动方向，由一项或一组固定成分的数据组成，其可以从数据变换流向数据变换、从数据变换流向数据存储、从数据存储流向数据变换 数据变换：对数据进行加工或处理，例如对数据的算法分析与科学计算 数据存储：输入或输出文件，可以是计算机系统的外部、内容文件，也可以是表、账单等 上述四种元素的符号有 Yourdon 和 Gane 两种方式表示： 如下图，是一个简单的 $0$ 层数据流图： 环境图环境图也称系统顶层数据流图（零层数据流图），其仅包括一个数据处理过程，也就是要开发的目标系统 环境图的作用是确定系统在其环境中的位置，通过确定系统的输人和输出与外部实体的关系确定其边界 基本加工在对数据流图的分解中，位于最底层的数据流图的数据处理，称为基本加工 对于每一个基本加工都需要进一步说明，这称为加工规格说明，其主要是为了表达 “做什么”，一般可以用伪代码、判定表、判定树来表达 伪代码和真正的程序代码已经十分接近了，因此使用伪代码来描述加工规格说明，一般推迟到结构化设计中进行 当某个数据处理的执行可能依赖多个逻辑条件的取值时，一般利用判定表来处理 判定树是判定表的变种，其能清晰地表达复杂条件组合与应做动作间的关系 【数据模型】概述数据建模是在较高的抽象层次（概念层）上对数据库结构进行建模，其用实体-关系图（E-R 图）来描述 E-R 图可以明确描述待开发系统的概念结构数据模型，对于较复杂的系统，通常要先构造出各部分的 E-R 图，然后将各分 E-R 图集合成总的 E-R 图，并对 E-R 图进行优化，以得到整个系统的概念结构模型 组成数据模型包含 3 种相互关联的信息： 数据对象：又称实体，是对软件必须理解的复合信息的表示，常用矩形框来表示 属性：定义数据对象的性质，常用椭圆形、圆角矩形来表示实体的属性，并用无向边把实体与其属性连接起来 关系：又称联系，是数据对象彼此之间相互连接的方式，常用菱形框来表示，其也可能有属性，表示方法、连接形式与实体与其属性的表示方法相同。 数据对象是由若干个属性组成的，每个属性都代表了实体的某些特征，关系根据实际情况，可分为一对一联系（1：1）、一对多联系（1：N）、多对多联系（N：N） 如下图，是一个简单的教学管理系统的 E-R 图： 【行为模型】概述系统对内部或外部事件响应的模型称为行为模型，常用状态转换图来表示 其描述了系统状态和事件，事件引发系统在不同状态间进行转换，这种模型尤其适合用来描述实时系统，因为这类系统多是由外部环境的激励而驱动的 组成状态是任何可被观察到的系统行为模式，一个状态代表系统的一种行为模式，其规定了系统对事件的响应方式 系统对事件的响应，既可以是一个或一系列动作，也可以是仅改变系统本身的状态，还可以是既改变状态又做动作 在状态转换图中，状态分为三部分：初始状态、最终状态、中间状态，除中间状态允许有多个外，初始状态与最终状态只能有一个 事件是在某个特定时刻发生的事情，它是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象，例如：观众使用电视遥控器，用户移动鼠标、点击鼠标等都是事件 简而言之，事件就是引起系统做动作或转换状态的控制信息 事件表达式的语法为：事件说明[守卫条件]/动作表达式 事件说明的语法为：事件名（参数表），常见的事件名有：entry、exit、do 等 守卫条件是一个布尔表达式，如果同时使用守卫条件和事件说明，则当且仅当事件发生且布尔表达式成立时，状态转换才发生。如果只有守卫条件没有事件说明，则只要守卫条件为真，状态转换就发生 动作表达式是一个过程表达式，当状态转换开始时执行该表达式 如下图，是一个图书馆系统的模型状态转换图： 【图形工具】除上述的数据流图、ER 图、状态图、数据字典、加工规格说明外，在结构化分析中，以下三种图形工具也经常被使用 层次方框图层次方框图由树形结构的一系列多层次矩形组成，用于描述数据的层次结构，上下层之间、模块与模块之间，只是表示数据的组成关系 顶层用于描述数据结构的整体，中间各层表示数据的子集，最底层表示这个数据不能再分割的元素 Warnier 图warnier 图和层次方框图类似，也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段 Warnier 图可以表明信息的逻辑组织，也就是说，它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的 IPO 图IPO 图是输入、处理、输出图的简称，它是由美国 IBM 公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"路由器配置基础","slug":"network-system-integration/02.路由器配置基础","date":"2020-03-06T09:33:00.000Z","updated":"2021-08-24T13:37:45.353Z","comments":true,"path":"notes/network-system-integration/accdf835.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/accdf835.html","excerpt":"【概述】路由器是一种特殊的计算设备，负责网络间流量的路由，简单来说，就是当数据在不同网络传输时，负责选择路径。","text":"【概述】路由器是一种特殊的计算设备，负责网络间流量的路由，简单来说，就是当数据在不同网络传输时，负责选择路径。 路由器实质是一种特殊的计算机，具有 CPU、OS、内存和存储（RAM、ROM、NVRAM、闪存等），其要求 CPU 和内存临时或永久存储数据，以便执行操作系统的 IOS(Internetwork Operating System) 指令，例如：系统初始化、路由功能和交换功能等。 【路由器的组成】基本部件路由器的基本部件有以下 5 个： CPU：执行操作系统 IOS 指令，例如：系统初始化、路由功能和交换功能等 RAM：提供各种应用程序和进程的临时存储，包括 IOS、运行配置文件、各种表格(IP 路由表、以太网 ARP 表等)以及数据包缓冲区 ROM：启动说明、基本诊断软件和有限的 IOS，以防止路由器无法加载功能完整的IOS NVRAM：启动配置文件（startup-config） Flash：提供 IOS 和其它系统文件，当路由器启动时，会把 IOS 从闪存复制到 RAM，相当于硬盘 常见端口与接口管理、配置路由器的方法有两种： 带外管理：通过路由器专用配置线缆使 PC 机与路由器的 Console 端口直接相连 带内管理：PC 机通过网络与路由器远程互联，常见的方法有：Telnet/SSH 远程登录、Web 远程管理、TFTP 服务器配置、SNMP 网管工作站进行管理、AUX 和 MODEM 端口远程管理路由器 由此，根据两种管理方式，路由器的端口分为带外路由端口和带内路由接口两类。 路由器的端口称为带外路由器端口，又称为管理端口，分为两类： 控制台端口：Console 端口，使用低速串行或 USB 连接提供直接连接，这是一种带外管理访问思科设备的方法 辅助端口：AUX 端口，用于通过拨号电话线和调制解调器远程访问路由器 其接口称为带内路由器接口，同样分为两类： LAN 接口：以太网接口，用于连接 LAN 设备上的电缆（例如：计算机和交换机），还可用于路由器之间的相互连接 WAN 接口：串行接口，用于将路由器连接到外部网络，一般在地理位置较远时使用 路由器上的 LED在路由器上，LED 不同的颜色与显示方式有着不同的含义。 下图以 思科 1941 为例进行说明： 【路由器功能】实现网络互联利用路由器，可以将不同网络进行互联。 在进行连接时，设备必须配置以下 IP 地址信息，才能具备网络访问能力： IP 地址：标识本地网络中的唯一一台主机 子网掩码：标识该主机的网络子网 默认网关：当目的地址不在同一本地网络子网时，确定数据包需发送到的路由器 同时，需要网络文档来记录网络寻址，网络文档在拓扑图和寻址表中至少应包含：设备名称、接口、IP 地址与子网掩码、默认网关这些信息。 此外，需要在主机上启用 IP，分配方式有两种形式： 静态分配：为主机手动分配 IP 地址、子网掩码和默认网关，以识别特定网络资源（例如：网络服务器和打印机），常用于主机数量很少的超小型网络 动态分配：服务器使用动态主机配置协议(DHCP)动态分配 IP 信息，大部分主机都通过 DHCP 获取其 IP 地址信息 数据包转发随着路由器的发展，数据包转发机制也在不断变化： 进程交换：老式数据包转发机制，当通过路由器交换报文的时候，IOS 进程会将报文复制到 CPU 缓存，并在 IP 路由表中进行查找，查到后进行一些管理性处理，包括修改 TTL，重新计算 CRC等，整个过程由 CPU 进行监控，没有其他的硬件帮助 快速交换：常用的数据包转发机制，其会创建一张按需转发表，对于去往每个目的地的一个报文实行进程交换，通过 CPU 来完成，然后创建一个 IP 快速交换路由缓存，这个缓存不是永久的，它有一些计时器管理，只要有报文转发，这些条目就会存在，如果经过一段时间没有报文转发，条目将被删除以释放空间 选择最佳路径路由器使用静态路由和动态路由协议获知远程网络，并建立内部路由表。 之后，通过路由表来确定发送数据包的最佳路径。 最后，路由器对数据包进行封装，并将其转发至路由表中显示的接口。 【启动过程】路由器在启动过程包含以下四个主要阶段： 执行 ROM 中的加电自检(POST)程序：对硬件进行诊断，包括 CPU、RAM、NVRAM 加载并执行 bootstrap 程序：查找 IOS 并将其加载到 RAM 中 bootstrap 程序定位并加载执行 IOS 映像：如果在 Flash 中未找到 IOS 映像，则路由器可使用 TFTP 服务器进行查找，如果仍未找到完整的 IOS 映像，则会从 ROM 中将精简版的 IOS 复制到 RAM，这种精简版的 IOS 也可用于将完整的 IOS 加载到 RAM bootstrap 依次加载并执行保存于 NVRAM 或 TFTP 服务器中的启动配置文件：如果找不到该启动配置文件，则路由器进入设置模式 【路由器配置模式】路由器具有多种配置模式，不同模式下权限不同，详细说明如下： 模式名称 提示符 进入命令 退出命令 说明 用户模式 &gt; 只能查看路由器的一些基本状态，不能进行设置 特权模式 # enable disable 用户可以用 show 与 debug 进行配置检查，不能修改配置 配置模式 (config)# configure terminal exit 或 end 处于全局设置状态，可以修改路由器全局配置参数 接口模式 (config-if)# Interface 接口名 exit 或 end 处于局部设置状态，可以对具体端口进行配置 子接口模式 (config-subif)# Interface 子接口名 exit 或 end 处于局部设置状态，可以对具体子端口进行配置 线路模式 (config-line)# Line 线路名 exit 或 end 处于局部设置状态，可以对线路进行配置 路由器模式 (config-router)# Router 协议名 exit 或 end 处于局部设置状态，可以对路由器模式进行设置 【路由器基本配置命令】编辑技巧在路由器配置时，可以使用以下技巧来进行编辑： 支持命令简写：例如 exit 简写为 ex 按 TAB 键：补全命令 输入?：显示该模式下所有的命令 输入命令+空格+?：显示命令参数并对其解释说明 输入字符+? 显示以该字符开头的所有命令 输入 no+原配置命令：关闭功能或撤销动作 输入 show history：显示最近执行的 20 条命令 按 ↑ 或 ↓ 键：显示上一条命令、下一条命令 基本配置命令基本配置命令如下：","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"无线传输技术基础","slug":"wireless-network/02.无线传输技术基础","date":"2020-03-04T09:57:00.000Z","updated":"2021-10-31T13:19:23.669Z","comments":true,"path":"notes/wireless-network/963c2c46.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/963c2c46.html","excerpt":"【无线传输媒体】概述传输媒体可分为引导性媒体和非引导性媒体两类。引导性媒体是线缆媒体，利用固态媒体传播电磁波，例如：金属导体、玻璃等；非引导性媒体是无线媒体，不加以引导的传输电磁信号，例如：大气层、外层空间等","text":"【无线传输媒体】概述传输媒体可分为引导性媒体和非引导性媒体两类。引导性媒体是线缆媒体，利用固态媒体传播电磁波，例如：金属导体、玻璃等；非引导性媒体是无线媒体，不加以引导的传输电磁信号，例如：大气层、外层空间等 在通信中，不同信号所利用的频率不同，电磁频谱如下： 传播特性在无线传输中，常利用无线电波来进行信号传输，不同的频率范围传播特性不同： 频率范围 频段 传播特性 低频 300KHz 贴近地面，因为地球曲率会引起衍射 高频 1000KHz 不能贴近地面传播 短波 3~30MHz 可以被电离层反射回地面，能够远距离传播 甚高频 100MHz 视距传播，但是传播距离可超出视距 极高频 1GHz 视距传播，但是传播距离可超出视距 常用的无线电波无线电电视、移动电话、无线网络和业余无线电，都使用无线电波来传递信息 无线电的频率范围在 10KHz~1GHz 之间，波长在几百米到几厘米之间，射频信号的能量由天线和收发器决定，即可全方向广播，也可定向广播，不受雪、雨天气的干扰，能穿透墙壁，可到达普遍网络线无法到达的地方 VLF、LF、MF 波段的无线电波沿着地面传播，HF、VHF 波段无线电波被电离层折射回来 为了便利大众能够和谐地共同使用无线电波为传递信息的媒介，政府会采取频率分配制度来规划管理无线电波频域。 微波微波是频率较高的无线电波，其电磁频谱较低，属于 GHz 级频率 微波按照直线传播，发射端和接收端的天线必须精确地对准，并且其不能很好地穿透建筑物，多用于定向传播 红外线红外光波属于电磁频谱的 THz 范围，利用发光二极管或激光二极管来发射信号，利用光电管来接收信号 其易受强烈光源的影响，且不能穿透墙壁等固体物体，适用于短距离通信，例如：TV、DVD、音响等，在不同房间内的红外系统互不干扰，且其防窃听安全性比无线电系统好 【无线传输方式】无线信号从天线出发，有地面波、天空波、直线传播三种传输方式 地面波地面波沿地球轮廓线进行传播，其频率高达 2MHz，最大的优点是传播距离远，最常见的利用地面波进行传播的技术是 AM 调频无线电 天空波天空波通过大气电离层和地球表面之间的反射进行传输，反射效果由折射引发，其传播距离比地面波范围还要远，业余无线电传输就是利用天空波来进行的 直线传播直线传播又称视距传播，要求传输天线和接收天线必须在视线内，传播距离一般为 20~50 km 【无线传输损伤】衰退（fading）：传输媒体或者路径使得接收信号的能量发生的损伤。在固定环境下，容易因大气层的变化而受到影响；在移动环境下，障碍物的相对位置随时间发生变化，造成复杂的传输效果 反射（Reflection）：当信号遇到表面大于信号波长的障碍物导致信号的相位发生漂移 衍射（Diffraction）：当信号遇到大于波长的不可穿透物的边缘而出现的损伤，使得即使没有来自发送器的视线信号也可接收到信号 散射（Scattering）：当入境信号遇到波长小的物体就发散成几个弱的出境信号 多径传播（Multipath）：障碍物反射信号，使得接收端收到多个不同延迟的信号 当一个信号的多个拷贝以不同的相位到达：会造成相位破坏性地叠加，则相对噪声来说信号的强度就会下降，即信噪比减小，导致接收端检测困难。 当一个脉冲的一个或多个延迟的拷贝在一个比特时间内到达，会导致信号串扰。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件可行性研究与需求分析","slug":"software-engineering/03.软件可行性研究与需求分析","date":"2020-03-02T07:03:00.000Z","updated":"2022-05-13T03:59:21.878Z","comments":true,"path":"notes/software-engineering/703acc6d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/703acc6d.html","excerpt":"【可行性研究】引入项目立项包括项目发起、项目论证、项目审核、项目立项四个阶段，其中，项目论证就属于可行性研究，项目论证的目的不是解决问题，而是确定问题是否值得去解决","text":"【可行性研究】引入项目立项包括项目发起、项目论证、项目审核、项目立项四个阶段，其中，项目论证就属于可行性研究，项目论证的目的不是解决问题，而是确定问题是否值得去解决 进行可行性研究，不能依靠主观猜测，而是要根据客观情况进行分析，因此，可行性研究可以看做是一个压缩简化的分析设计的过程 评估方向可行性研究需要从多个方面进行评估： 战略可行性：从战略的角度来看，从整体考虑项目是否可行 操作可行性：新系统安装后，是否有人抵触系统、是否足够的人力资源来运行系统 计划可行性：项目能否按计划来完成 技术可行性：考虑技术的成熟程度、现有技术的发展趋势与前景等 社会可行性：是否满足项目涉及者的利益、是否满足法律要求 市场可行性：分析市场的发展趋势、同类产品的价格对比、所占份额等 经济可行性：对系统成本与效益进行分析 风险可行性：考虑项目过程中的各种风险因素出现的几率与造成的影响 可行性研究步骤进行可行性研究的步骤不是固化的，而是根据项目的性质、特点、开发团队的能力有所区别 一个典型的可行性研究的步骤可归为以下几步： 明确系统目标 分析研究现行系统 设计新系统的高层逻辑模型 获得并比较可行的方案 撰写可行性研究报告 经过可行性研究后，对于值得开发的项目，就要制定软件开发计划，写出软件开发计划书 【需求分析】引入如果说可行性分析是关于 “做不做”、”是否值得做” 的问题，那么需求分析，就是关于 “做什么” 的问题 需求分析是一个迭代的过程，其应该贯穿于系统的整个生命周期，随着项目的深入而不断变化，而非仅属于软件生命周期早期的一项工作 为方便评审与后续设计，需求的表述应该具体、清晰，并且是可测量、可实现的，最好能对需求进行适当的量化 需求分析可以具体地分为以下三个方面的需求： 首先，要确定系统的运行环境需求，其包括系统运行时的硬件需求、软件环境需求 之后，确定系统的功能性需求与非功能性需求。功能性需求是指为用户和系统要完成的功能、提供的服务；非功能性需求是指必须遵循的标准、外部界面的细节、实现的约束条件等 最后，要与用户进行有效的需求分析。需要注意的是，由于用户通常对需求的陈述不完备、不准确、不全面，并且可能在不断变化，因此要与用户及时、有效地沟通 阶段需求分析可分为以下两个阶段： 建模阶段：在充分了解需求的基础上，建立起系统的分析模型 描述阶段：把需求文档化，用软件需求规格说明书的方式将需求表达出来 要注意的是，软件需求规格说明书，是需求分析阶段的输出，其全面、清晰地描述了用户需求，是开发人员进行后续软件设计的重要依据，其具有清晰性、一致性、准确性等特点，是通过严格的需求验证、反复修改的过程后确定的 步骤需求分析可分为以下四个步骤： 需求获取：收集并明确用户需求的过程，常用方法有调查研究、实地操作、开发原型等 分析建模：对开发系统建立各种角度的模型，来使开发人员更好地理解需求 需求描述：系统定义文档（用户需求报告）、系统需求文档（系统需求规格说明书）、软件需求文档（软件需求规格说明书） 需求验证：后续软件开发的基础，对需求文档进行审查，保证需求的一致性、完整性、现实性、有效性。 需求管理为更好的进行需求分析并记录需求结果，需要对需求进行管理 需求管理是一种用于查找、记录、组织、跟踪系统需求变更的系统化方法，可用于获取、组织、记录系统需求，使客户与项目团队在系统变更需求上达成并保持一致 需求分析的方法有很多，常见的有：功能分解方法、结构化分析方法、信息建模方法、面向对象的分析方法等等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"网络系统集成概述","slug":"network-system-integration/01.网络系统集成概述","date":"2020-02-28T11:22:00.000Z","updated":"2021-08-23T13:25:07.744Z","comments":true,"path":"notes/network-system-integration/43ba0482.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/network-system-integration/43ba0482.html","excerpt":"【系统集成】系统集成，是指根据一个复杂的信息系统或子系统的要求，验明多种技术和产品，并建立一个完整的解决方案的过程。 系统集成，通过选择最适合的用户需求、投资规模的产品和技术，来构建一个信息系统，分为以下三部分：","text":"【系统集成】系统集成，是指根据一个复杂的信息系统或子系统的要求，验明多种技术和产品，并建立一个完整的解决方案的过程。 系统集成，通过选择最适合的用户需求、投资规模的产品和技术，来构建一个信息系统，分为以下三部分： 硬件设备：不同产品的接口兼容性 软件产品：不同软件之间数据格式的转换 网络系统：不同系统之间信号交换和路由 简单来说，即有：信息系统＝网络系统+硬件系统+软件系统 【网络工程】概述网络工程就是将工程化的技术和方法应用到计算机网络系统中。 网络工程是一项综合性的技术活动，也是一项综合性的管理和商务活动，是一门研究网络系统规划、设计、管理及维护的综合性学科，它涉及到计算机技术、网络技术、数据库技术、软件工程、管理学以及控制论等多个领域。 网络工程设计与实施的步骤如下： 网络系统集成网络工程利用网络系统集成的方法，根据建设目标和设计原则，经过充分的需求分析和市场调研，通过结构化综合布线系统和计算机网络技术，制定出网络建设方案，并依据方案的步骤，协助工程的投标、设计、实施、管理与维护等的一系列活动。 网络工程层次结构网络工程包括质量管理、网络项目管理与控制、网络工程的方法和工具，网络系统集成是网络工程的核心技术，即：网络工程方法和工具 系统集成所涉及的应用范围也比较广，不仅包括计算机网络通信、语音通信，还包括监控、消防、水电和保安系统等。 而网络系统集成只是整个系统集成的一部分，主要侧重于计算机网络通信。 网络工程的层次结构如下： 【网络设计标准与规范】标准的制定标准是一组规定的规则、条件或要求。 如果没有标准，会导致硬件设备之间的不兼容、应用程序之间数据交换困难等问题，而且不便于不同厂商的产品、服务达到公认的规定品质，为解决上述问题，制定了相关的标准。 标准的制定往往源于利益集团的需求： ITU：联合国官方组织，它制定的标准更多的反映了各国电信运营商的利益 IEEE：民间工程师组织，它制定的标准反映了各个设备制造厂商和用户的利益 常用标准ITU 标准化部门制定了许多通信和网络方面的标准，这些标准称为建议，往往以英文字母 A～Z 开头作为分类。 自 1969 年至 2006 年，IETF 组织共发布了 4560 篇 RFC 文档，这些文档包含了因特网的所有重要标准。 【网络设计方法】设计分类网络设计包括网络物理设计与网络逻辑设计。 其中，网络物理设计包括： 网络设备选型 综合布线设计 系统测试 而网络逻辑设计包括： 用户需求分析：业务需求、用户信息点的地理分布、资金的投入 网络结构设计：拓扑结构设计、链路类型选择、地址规划、路由设计、VLAN设计、园区网与广域网的接入设计 网络性能设计：带宽预算、流量控制、负载均衡、链路聚合、避免网络性能瓶颈、网络性能优化等 网络功能设计：DNS服务、Web服务、FTP服务、E-mail服务、IP电话服务、视频点播服务、VPN服务等 网络物理安全设计：防火墙设计、DMZ（非军事区）设计、IDS（入侵检测系统）设计、IPS（入侵防护系统）设计、网络隔离设计等 网络信息安全设计：数据加密系统、身份认证系统、数字签名系统等 网络可靠性设计：RAID磁盘镜像技术、系统容灾设计、存储网络设计、双机热备份、链路冗余、系统恢复技术等 矛盾分析满足所有要求的设计是一个充满了矛盾的设计。 常见的矛盾指标有： 主流技术与新技术的矛盾 安全性与易用性的矛盾 可靠性与经济性的矛盾 因此，应当在满足少量几个主要指标后，在相互矛盾的指标中做出折中处理。 网络设计基本原则网络设计目前没有一套完整的设计规范，大部分设计原则来源于成功和失败的网络设计经验。 常见的原则有： 通用性原则：不要采用专用性太强的设计方案 核心简单边缘复杂原则：核心层尽量保持简单，边缘层可能情况复杂，需要反复权衡利弊 弱路由原则：尽量减少路由器传输的信息 80/20原则：数据流量的 80% 在该子网内通信，只有 20% 的数据流量发往其它子网 影响最小原则：网络结构改变时受到的影响应限制到最小程度 2用2备2扩原则：主干光缆布线时，2 根使用，2 根备份，2 根保留 技术经济分析原则：成本与性能通常是最基本的设计权衡因素 成本不对称原则：局域网设计时考虑线路成本少，考虑设备性能多 多样性原则：不要过分依赖于某一个设备厂商的产品","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"网络系统集成","slug":"notes/network-system-integration","permalink":"https://alex-mcavoy.github.io/categories/notes/network-system-integration/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络系统集成","slug":"network-system-integration","permalink":"https://alex-mcavoy.github.io/tags/network-system-integration/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"}],"author":"Alex_McAvoy"},{"title":"无线网络概述","slug":"wireless-network/01.无线网络概述","date":"2020-02-26T09:30:00.000Z","updated":"2021-10-31T13:18:51.234Z","comments":true,"path":"notes/wireless-network/4c13dad0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/wireless-network/4c13dad0.html","excerpt":"【从计算机网络到无线网络】协议网络技术中为数据交换而设置的标准、规则和约定的集合称协议，具体某个协议往往关注具体某一层，用于同层实体间通信的相关规则约定的集合","text":"【从计算机网络到无线网络】协议网络技术中为数据交换而设置的标准、规则和约定的集合称协议，具体某个协议往往关注具体某一层，用于同层实体间通信的相关规则约定的集合 协议三要素： 语义：协议控制信息的具体含义 语法：数据和控制信息的格式、编码规则 时序：数据和控制信息的收发同步和排序 网络体系结构各层对等实体间逻辑通信，各种逻辑通信均有对应协议，本层为上层提供服务，也享受下层服务，各层相互独立、功能明确 功能作为分层基础，每一层只需与上下层相关，各司其职，各尽其责 ISO/OSI 模型 TCP/IP 模型 无线网络的协议层次特点无线网络协议体系也基于分层，不同类型无线网络关注的层次不同 许多无线网络需对传统网络协议进行改进。WLAN 一般无路由问题，不涉及网络层，采用传统 IP 协议，鉴于共享访问介质问题，MAC 层协议是许多无线网络关注重点，无线频谱管理复杂性，使物理层协议成为重点，而 MANET 路由问题，关注网络层 无线网络和有线网络特点不同，决定二者传输机制和协议设计不同 有线网络当发送方检测到丢包发生时，一般认为网络拥塞，降低发送速率。而无线网络出现丢包，发送方可尽力重发 无线网络目标是提供更便捷的通信服务，应用层协议并非重点，解决了无线网络连接和可靠性，各种应用都可直接使用无线网络 【无线网络分类】覆盖范围从覆盖范围来说，无线网络可分为以下几类： 无线个域网 WPAN，通过短距离无线电，连接 PC 各部件，典型的 WPAN 即蓝牙技术，其可将各种 PC 部件，手机、相机、耳机、音箱、扫描仪、打印机等连接到 PC 无线局域网 WLAN，按有无固定基础设施分为两大类： 固定基础设施：预先建立且能覆盖一定范围的固定基站 无固定基础设施：移动自组织网络 无线城域网 MAN，单个基站覆盖范围可达几十公里，传输速率接近无线局域网，具有移动性、高效切换等功能特点 无线广域网 WAN，蜂窝移动通信网络是地面上最大的无线广域网，而卫星通信网络也开始大量用于传输数字信息，卫星网络堪称覆盖范围最大的无线广域网 应用目的从应用目的来说，可进行以下分类： 互联接入：WLAN、WMAN、卫星网络等，主要是为用户访问因特网提供信息服务 物联传感：物联网、无线传感网、WPAN、无线体域网等，主要是为了将网络触角延伸到传统社会信息之外的自然界、环境、物体、人体等，传输更为丰富多样的信息","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"无线网络","slug":"notes/wireless-network","permalink":"https://alex-mcavoy.github.io/categories/notes/wireless-network/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"无线网络","slug":"wireless-network","permalink":"https://alex-mcavoy.github.io/tags/wireless-network/"}],"author":"Alex_McAvoy"},{"title":"软件过程","slug":"software-engineering/02.软件过程","date":"2020-02-23T07:23:00.000Z","updated":"2022-05-13T03:58:26.123Z","comments":true,"path":"notes/software-engineering/a80f496a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/a80f496a.html","excerpt":"【概述】软件过程，是指软件的诞生和生命周期，其是为开发软件产品或完成软件工程项目而需要完成的有关软件工程的活动，每一项活动又分为一系列的工程任务 通常，使用生命周期模型简洁地描述软件过程，生命周期模型规定了将生命周期划分为哪些阶段与各阶段执行顺序，因此又称为过程模型","text":"【概述】软件过程，是指软件的诞生和生命周期，其是为开发软件产品或完成软件工程项目而需要完成的有关软件工程的活动，每一项活动又分为一系列的工程任务 通常，使用生命周期模型简洁地描述软件过程，生命周期模型规定了将生命周期划分为哪些阶段与各阶段执行顺序，因此又称为过程模型 【软件生命周期】软件生命周期，是指从设计产品的构想开始，到最终被市场淘汰的全过程，其时间角度将软件开发和维护的复杂过程，分解为若干阶段，每个阶段都完成特定的相对独立的任务 在传统的软件工程中，软件产品分为六个周期： 可行性研究：用最小的代价在最小的时间内确定目标系统能否解决要解决的问题 需求分析：将可行性研究期间建立的软件可行性分析细化，对目标系统提出完整、准确、清晰、具体的要求 软件设计：根据需求分析阶段确定的功能，来设计目标系统的整体结构、划分功能模块、确定每个模块的实现算法，形成软件的具体设计方案 编码：根据软件设计方案，通过程序设计语言编写目标系统源代码 软件测试：根据目标系统实际输出与预期输出之间进行审核、比较 软件维护：在软件产品发布后，因修正错误、提升性能或其他属性而进行的软件修改 【传统软件过程模型】在软件工程中，通过建立抽象的软件开发模型，将软件生命周期中的各个活动或步骤安排到一个框架中，将软件开发的全过程直观地表达出来 瀑布模型瀑布模型是一种基于文档驱动的线性开发模型，具有不可回溯性 开发人员必须等待前一阶段任务完成后，才能开始进行后一阶段的工作，并且前一阶段的输出往往是后一阶段的输入 由于其不可回溯性，如果在软件生命周期的后期发现需要更改的前期的内容，那么需要付出很高的代价 为解决上述问题，提出了待反馈的瀑布模型，其可以通过反馈来在后期对前期内容进行更改 瀑布模型过程简单，容易执行，但无法适应变更，其适用于需求不发生或很少发生变化的模型，软件项目风险低，不具有完善的风险控制机制，对软件开发人员要求较高，需要具有丰富的经验 快速原型模型原型，是一个部分开发的产品，是一个能让用户进行测试的原型系统 快速原型的本质是快速，原型内部系统的结构并不重要，重要的是迅速的构建原型，然后根据用户反馈意见不断地修改原型。因此，开发人员应尽可能的建造出原型系统，以加速软件开发过程，节约开发成本 快速模型适用于已有产品或样品，只需要客户化的工程项目或进行产品移植和升级的软件 增量模型增量模型是将待开发的软件系统模块化，将每个模块作为一个增量组件，分批次地进行分析、设计、编码、测试 增量模型的开发过程是递增式的过程，相对于瀑布模型而言，开发人员不需要一次性地将软件产品提交给用户，而是可以采用分批次地进行提交 增量模型最大特点就是将软件系统模块化、组件化，开发顺序灵活，可以对构件的实现顺序激进型优先级排序，先完成需求稳定的核心组件，同时可以分批次地提交软件产品，使用户可以及时了解项目进展，此外，还降低了软件开发的风险，一个开发周期内的错误不会影响到整个软件系统 螺旋模型螺旋模型是一种用于风险较大的大型软件项目开发的过程模型，该模型将瀑布模型和快速原型模型结合起来，并加入了这两种模型忽略了的风险分析 其将开发过程分为 4 种活动：制定计划、风险分析、实施工程、客户评估 螺旋模型适用于风险较大的、需求不明确的大型软件的开发，其将风险分析扩展到各个阶段当中，大幅降低了软件开发风险，但这种模型控制、管理复杂，可操作性不强，对开发人员要求较高 喷泉模型喷泉模型是一种过程模型，体系了面向对象软件开发过程不同阶段的相互重叠，这明确表示两个活动间没有明显阶段，存在交迭 在面向对象的方法中，分析模型和设计模型采用相同的符号体系，各阶段间没有明显界限，常常重复、迭代地进行，主要适用于面向对象的软件项目的开发 【现代软件过程模型】基于组件的开发模型组件，是系统中模块化、可更换的、实现特定功能的部分，其对实现进行封装，暴露一组接口，常见的组件有：动态链接库、浏览器插件 基于组件的开发模型使用现有的组件与系统框架进行产品开发，充分的体现了软件复用的思想，降低了开发成本与风险，并加快了产品开发 统一软件开发过程模型统一软件开发过程模型（RUP，Rational Unified Process），是基于 UML 的一种面向对象的软件开发模型 其解决了螺旋模型的可操作性问题，采用迭代和增量递进的开发策略，并以用例驱动为特点，集成了多个软件开发模型的优点 如上图，描述了 RUP 的过程，竖向来看，是有九个工作的工作流；横向来看，整个 RUL 分为四个阶段： 初始化：又称先启，进行项目计划、评估风险 细化：设计系统架构、确定资源需求 构建：开发出所有组件与应用程序，集成并进行详尽测试 产品化：将产品移交给用户 在整个过程中，每个阶段在相应的工作流中根据侧重不同，不断通过迭代来进行完善 敏捷过程开发模型敏捷过程是一种快速、小文档、轻量型的软件工程模型，相对于传统的软件工程方法，其更强调软件开发过程中各种变化的必然性，通过团队成员间充分交流、沟通以及合理的机制来有效地相应变化 其不是一种模型方法，而是一类实践方法，包括：极限编程 XP、自适应软件开发 ASD、动态系统开发方法 DSDM、特征驱动开发 FDD 等 最常用的方法模型方法是极限编程（XP，eXtreme Programmaing），其是一种实践性较强的规范化的软件开发方法，它强调用户需求和团队合作工作，特别适用于软件需求模糊、容易改变、开发团队人数较少的场合 【模型选择技巧】 瀑布模型：前期需求明确 快速原型模型：用户无使用经验 增量模型或螺旋模型：不确定因素很多、很多东西无法提前计划 增量模型：资金、成本无法一次到位 全新系统开发：在总体设计完成后再进行增量开发或并行开发 开发人员经验较少时：尽量不采用敏捷模型","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"软件工程概述","slug":"software-engineering/01.软件工程概述","date":"2020-02-23T06:23:00.000Z","updated":"2022-05-13T03:56:04.002Z","comments":true,"path":"notes/software-engineering/1c3f10da.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/software-engineering/1c3f10da.html","excerpt":"【软件】概述软件是计算机中与硬件相互依存的部分，其是程序、数据、相关文档的集合","text":"【软件】概述软件是计算机中与硬件相互依存的部分，其是程序、数据、相关文档的集合 程序：按事先设计的功能和性能要求执行的指令序列 数据：使程序能正确处理信息的数据结构 文档：与程序开发、维护、使用有关的图文资料 软件是一个逻辑实体，依赖于硬件和 OS，在运行维护期间，不会像硬件一样出现磨损与老化，只会出现退化问题 软件的开发以人工开发为主，不仅成本高、风险高，还受到社会因素的影响，在生产过程中，软件开发与硬件流水线式开发不同 分类软件的分类有以下几种方式： 按功能：系统软件、支撑软件、应用软件 按服务对象：通用软件、定制软件 按规模：小型软件、中型软件、大型软件 按工作方式：实时软件、分时软件、交互式软件、批处理软件 其中，系统软件是指控制计算机与外设并支撑应用软件开发和运行的系统，支撑软件是指支持其他软件开发和维护的一种工具性的软件，应用软件是指与系统软件相对应的用各种程序设计语言编制的应用程序 软件危机随着应用软件的规模越来越大，越来越复杂，动辄数百万行代码已是常见现象，不可避免地就出现了软件危机 软件危机是指在开发和维护软件过程中遇到的一系列的问题，常见的表现有：开发过程中无法按时完成、产品质量无法保证、开发经费严重超支、开发完成后软件表现强差人意，软件无法维护等等 对软件产品认识不足与对软件开发的内在规律存在理解偏差是出现软件危机的根本原因 开发者在开发过程中存在的不当开发方法，是软件危机的主观原因，其通过正确的引导即可解决，常见的主观原因有： 忽视软件开发前提调研与需求分析 缺乏软件开发经验与有关数据积累，忽视与用户的有效沟通 开发过程缺乏统一规范的方法论指导，没有完善的质量保证体系 文档资料不规范、不准确，开发者失去工作基础，管理者失去管理依据 忽视了软件测试重要性，同时不重视软件维护 【软件工程】概述IEEE 对软件工程定义为：将系统化、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件 软件工程研究的内容分为两部分： 软件开发技术：主要研究软件开发方法、过程、工具以及环境 软件开发过程管理：主要研究软件工程经济学和软件管理学 具体来说，软件工程，是借鉴传统工程的原则、方法，以提高质量，降低成本为目的的指导计算机软件开发和维护的工程学科 软件工程的发展经历了四个重要的阶段： 传统软件工程：将软件开发纳入工程化轨道，基本形成了软件工程的概念、框架、技术与方法 对象工程：随着面向对象技术的出现，衍化出了完整的软件开发方法和系统的技术体系 过程工程：为提高软件生产率、保证软件质量，提出了软件开发和维护要有管理和支持的能力 构件工程：基于构件的开发方法，利用可重用的构件来进行开发 层次软件工程是层次化的技术，具体可分为以下三个层次： 工具层：在软件开发过程中，工具提供了自动或半自动化的支持，例如：建模工具 Rational Rose 方法层：方法提供了开发软件在技术上需要的一系列的任务，包括需求分析、编程、测试等 过程层：过程提供了开发的框架，使得软件能够合理、及时的被开发 【软件开发方法】软件开发方法是一种使用定义好的技术集与符号来表示组织软件生产的过程，其目标是在规定时间与成本内，开发出符合用户需求的高质量软件 常见的方法有： 结构化方法：采用 “自顶向下，逐步求精” 的思维，将软件开发分为若干阶段，每个阶段相对独立且复杂性不高，可便于不同的开发人员进行开发 面向数据结构方法：从输入输出的数据入手，导出程序框架结构，再补充程序细节，即可得到一个完整的程序结构图 面向对象方法：以对象建模为基础，将数据和对数据的操作结合起来，是一种可以反复迭代的开发方法 形式化方法：是基于形式化数学变换的软件开发方法，偏向于严密的理论 【软件工程工具】软件工程工具为软件工程中的过程与方法提供自动或半自动的支持，可以帮助软件开发人员进行软件分析、设计、开发、测试、维护、管理等工作 其具有以下三种分类标准： 按功能：可视化建模工具、程序开发工具、自动测试工具、文档编辑工具、配置管理工具、项目管理工具 按支持过程：设计工程、编程工具、维护工具 按支持范围：窄支持工具、宽支持工作台、一般支持环境","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"软件工程","slug":"notes/software-engineering","permalink":"https://alex-mcavoy.github.io/categories/notes/software-engineering/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"软件工程","slug":"software-engineering","permalink":"https://alex-mcavoy.github.io/tags/software-engineering/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 鼠标单击粒子特效","slug":"06.Next7.0+鼠标单击粒子特效","date":"2020-02-15T16:56:00.000Z","updated":"2021-09-23T09:29:13.383Z","comments":true,"path":"hexo/41cb4a84.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/41cb4a84.html","excerpt":"Next 7.0+ 未提供集成的鼠标点击特效，为此特意找了一个合适的特效进行设置 将 Github 仓库 中的源码下载后，放入 /themes/next/source/js/ 中 之后打开 /themes/next/layout/_layout.swig 文件，在 &lt;body&gt; 中的最下方添加如下代码：","text":"Next 7.0+ 未提供集成的鼠标点击特效，为此特意找了一个合适的特效进行设置 将 Github 仓库 中的源码下载后，放入 /themes/next/source/js/ 中 之后打开 /themes/next/layout/_layout.swig 文件，在 &lt;body&gt; 中的最下方添加如下代码： 1234567&lt;body&gt; ... &lt;!-- 鼠标单击粒子特效 --&gt; &lt;script type=\"text/javascript\" src=\"/js/cursor-effects.js\"&gt;&lt;/script&gt;&lt;/body&gt; 效果图 由于 Next 7.0+ 移除了 JQuery，为此在使用该特效前要先导入 JQuery，具体导入方法见：Next 7.0+ JQuery 的导入","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"字符编码对照表","slug":"03.字符编码对照表","date":"2020-01-31T02:03:00.000Z","updated":"2021-10-08T13:30:38.339Z","comments":true,"path":"others/e9e520a4.html","link":"","permalink":"https://alex-mcavoy.github.io/others/e9e520a4.html","excerpt":"在某些 API 中，设置相应字符集时，需要按照其对应代码进行设置 以下是字符集名称及其各自对应代码页的完整列表 名称 代码 us-ascii 20127 utf-8 65001 utf8 65001 utf-16 1200 utf16 1200 ucs-2 1200 ucs2 1200 unicode 1200 unicodefffe 1201 utf-7 65000 utf-32 65005 utf-32be 65006","text":"在某些 API 中，设置相应字符集时，需要按照其对应代码进行设置 以下是字符集名称及其各自对应代码页的完整列表 名称 代码 us-ascii 20127 utf-8 65001 utf8 65001 utf-16 1200 utf16 1200 ucs-2 1200 ucs2 1200 unicode 1200 unicodefffe 1201 utf-7 65000 utf-32 65005 utf-32be 65006 名称 代码 windows-1250 1250 windows-1251 1251 windows-1252 1252 windows-1253 1253 windows-1254 1254 windows-1255 1255 windows-1256 1256 windows-1257 1257 windows-1258 1258 windows-874 874 名称 代码 iso-8859-1 28591 iso-8859-2 28592 iso-8859-3 28593 iso-8859-4 28594 iso-8859-5 28595 iso-8859-6 28596 iso-8859-7 28597 iso-8859-8 28598 iso-8859-9 28599 iso-8859-11 874 iso-8859-13 28603 iso-8859-15 28605 iso-8859-8-i 38598 iso-2022-jp 50220 iso-2022-kr 50225 名称 代码 big5 950 gb2312 936 ks-c-5601-1987 949 shift_jis 932 名称 代码 koi8-r 20866 koi8-u 21866 koi 20866 koi8 20866 koi8-ru 21866 koi8r 20866 名称 代码 unicode-1-1-utf-7 65000 unicode-1-1-utf-8 65001 unicode-2-0-utf-7 65000 unicode-2-0-utf-8 65001 us 20127 utf-16be 1201 utf-16le 1200 utf16be 1201 utf16le 1200 名称 代码 iso-10646-ucs-2 1200 iso-2022-jpeuc 51932 iso-2022-kr-7 50225 iso-2022-kr-7bit 50225 iso-2022-kr-8 51949 iso-2022-kr-8bit 51949 iso-8859-8 28598 iso-ir-100 28591 iso-ir-101 28592 iso-ir-109 28593 iso-ir-110 28594 iso-ir-126 28597 iso-ir-127 28596 iso-ir-138 28598 iso-ir-144 28595 iso-ir-148 28599 iso-ir-149 949 iso-ir-58 936 iso-ir-6 20127 iso646-us 20127 iso-646.irv:1991 20127 iso-8859-1:1987 28591 iso-8859-2:1987 28592 iso-8859-3:1988 28593 iso-8859-4:1988 28594 iso-8859-5:1988 28595 iso-8859-6:1987 28596 iso-8859-7:1987 28597 iso-8859-8:1988 28598 iso-8859-9:1989 28599 iso-2022-jp-1 50221 iso-2022-jp-2 50222 名称 代码 ibm037 37 ibm437 437 ibm500 500 ibm737 737 ibm775 775 ibm850 850 ibm852 852 ibm855 855 ibm857 857 ibm00858 858 ibm860 860 ibm861 861 ibm863 863 ibm864 864 ibm865 865 ibm869 869 ibm870 870 ibm1026 1026 ibm01140 1140 ibm01141 1141 ibm01142 1142 ibm01143 1143 ibm01144 1144 ibm01145 1145 ibm01146 1146 ibm01147 1147 ibm01148 1148 ibm01149 1149 ibm273 20273 ibm277 20277 ibm278 20278 ibm280 20280 ibm284 20284 ibm285 20285 ibm290 20290 ibm297 20297 ibm420 20420 ibm423 20423 ibm424 20424 ibm871 20871 ibm880 20880 ibm905 20905 ibm00924 20924 ibm-thai 20838 ibm01047 1047 ibm037 37 ibm1026 1026 ibm367 20127 ibm437 437 ibm500 500 ibm737 737 ibm775 775 ibm819 28591 ibm862 862 ibm866 866 irv 20105 名称 代码 x-chinese-cns 20000 x-cp20001 20001 x-chinese-eten 20002 x-cp20003 20003 x-cp20004 20004 x-cp20005 20005 x-cp20261 20261 x-cp20269 20269 x-cp20936 20936 x-cp20949 20949 x-cp50227 50227 x-cp1250 1250 x-cp1251 1251 x-cp21027 21027 x-cp50227 50227 名称 代码 x-mac-japanese 10001 x-mac-chinesetrad 10002 x-mac-korean 10003 x-mac-arabic 10004 x-mac-hebrew 10005 x-mac-greek 10006 x-mac-cyrillic 10007 x-mac-chinesesimp 10008 x-mac-romanian 10010 x-mac-ukrainian 10017 x-mac-thai 10021 x-mac-ce 10029 x-mac-icelandic 10079 x-mac-turkish 10081 x-mac-croatian 10082 名称 代码 x-ia5 20105 x-ia5-german 20106 x-ia5-swedish 20107 x-ia5-norwegian 20108 名称 代码 x-iscii-de 57002 x-iscii-be 57003 x-iscii-ta 57004 x-iscii-te 57005 x-iscii-as 57006 x-iscii-or 57007 x-iscii-ka 57008 x-iscii-ma 57009 x-iscii-gu 57010 x-iscii-pa 57011 名称 代码 x-ansi 1252 x-ebcdic-koreanextended 20833 x-ebcdic-japaneseanduscanada 50931 x-ebcdic-koreanextended 20833 x-euc 51932 x-euc-cn 51936 x-euc-jp 51932 x-europa 29001 x-ms-cp932 932 x-sjis 932 x-unicode-1-1-utf-7 65000 x-unicode-1-1-utf-8 65001 x-unicode-2-0-utf-7 65000 x-unicode-2-0-utf-8 65001 x-user-defined 50000 x-x-big5 950 big5-hkscs 950 名称 代码 cp1025 21025 cp1026 1026 cp1250 1250 cp1251 1251 cp1252 1252 cp1253 1253 cp1254 1254 cp1255 1255 cp1256 1256 cp1257 1257 cp1258 1258 cp866 866 cp875 875 cp00858 858 cp00924 20924 cp01140 1140 cp01141 1141 cp01142 1142 cp01143 1143 cp01144 1144 cp01145 1145 cp01146 1146 cp01147 1147 cp01148 1148 cp01149 1149 cp037 37 cp273 20273 cp278 20278 cp280 20280 cp284 20284 cp285 20285 cp290 20290 cp297 20297 cp367 20127 cp420 20420 cp423 20423 cp424 20424 cp437 437 cp500 500 cp50227 50227 cp819 28591 cp850 850 cp852 852 cp855 855 cp857 857 cp858 858 cp860 860 cp861 861 cp862 862 cp863 863 cp864 864 cp865 865 cp869 869 cp870 870 cp871 20871 cp880 20880 cp905 20905 cp930 50930 cp933 50933 cp935 50935 cp937 50937 cp939 50939 名称 代码 csiso2022jp 50220 csascii 20127 csbig5 950 cseuckr 51949 cseucpkdfmtjapanese 51932 csgb2312 936 csgb231280 936 名称 代码 csibm037 37 csibm1026 1026 csibm273 20273 csibm277 20277 csibm278 20278 csibm280 20280 csibm284 20284 csibm285 20285 csibm290 20290 csibm297 20297 csibm420 20420 csibm423 20423 csibm424 20424 csibm500 500 csibm870 870 csibm871 20871 csibm880 20880 csibm905 20905 csibmthai 20838 名称 代码 csiso2022kr 50225 csiso58gb231280 936 csisolatin1 28591 csisolatin2 28592 csisolatin3 28593 csisolatin4 28594 csisolatin5 28599 csisolatin9 28605 csisolatinarabic 28596 csisolatincyrillic 28595 csisolatingreek 28597 csisolatinhebrew 28598 cskoi8r 20866 csksc56011987 949 cspc8codepage437 437 csshiftjis 932 csunicode11utf7 65000 cswindows31j 932 名称 代码 ccsid00858 858 ccsid00924 20924 ccsid01140 1140 ccsid01141 1141 ccsid01142 1142 ccsid01143 1143 ccsid01144 1144 ccsid01145 1145 ccsid01146 1146 ccsid01147 1147 ccsid01148 1148 ccsid01149 1149 名称 代码 chinese 936 cn-big5 950 cn-gb 936 cyrillic 28595 dos-720 720 dos-862 862 din-66003 20106 dos-874 874 名称 代码 ebcdic 37 euc-jp 51932 euc-cn 51936 euc-kr 51949 euc-tw 51950 名称 代码 ebcdic-cp-ar1 20420 ebcdic-cp-be 500 ebcdic-cp-ca 37 ebcdic-cp-ch 500 ebcdic-cp-dk 20277 ebcdic-cp-es 20284 ebcdic-cp-fi 20278 ebcdic-cp-fr 20297 ebcdic-cp-gb 20285 ebcdic-cp-gr 20423 ebcdic-cp-he 20424 ebcdic-cp-is 20871 ebcdic-cp-it 20280 ebcdic-cp-nl 37 ebcdic-cp-no 20277 ebcdic-cp-roece 870 ebcdic-cp-se 20278 ebcdic-cp-tr 20905 ebcdic-cp-us 37 ebcdic-cp-wt 37 ebcdic-cp-yu 870 ebcdic-cyrillic 20880 ebcdic-de-273+euro 1141 ebcdic-dk-277+euro 1142 ebcdic-es-284+euro 1145 ebcdic-fi-278+euro 1143 ebcdic-fr-297+euro 1147 ebcdic-gb-285+euro 1146 ebcdic-is-871+euro 1149 ebcdic-it-280+euro 1144 ebcdic-jp-kana 20290 ebcdic-latin9—euro 20924 ebcdic-no-277+euro 1142 ebcdic-se-278+euro 1143 ebcdic-us-37+euro 1140 名称 代码 ecma-114 28596 ecma-118 28597 elot-928 28597 gb18030 936 gb18030-2000 936 gb2312-80 936 gbk 936 gb-2312-80 936 german 20106 greek 28597 greek8 28597 hz-gb-2312 52936 hebrew 28598 asmo-708 708 ansi-x3.4-1968 20127 ansi-x3.4-1986 20127 arabic 28596 ascii 20127 asmo-449 709 asmo-449+ 709 johab 1361 korean 949 ks-c-5601 949 ks-c5601 949 ksc5601 949 ksc-5601 949 ks-c-5601 949 ks-c-5601-1989 949 名称 代码 l1 28591 l2 28592 l3 28593 l4 28594 l5 28599 l9 28605 名称 代码 latin1 28591 latin2 28592 latin3 28593 latin4 28594 latin5 28599 latin-1 28591 latin-2 28592 latin-3 28593 latin-4 28594 latin-5 28599 latin9 28605 latin-9 28605 logical 28598 名称 代码 macintosh 10000 macroman 10000 macjapanese 10001 macchinesetrad 10002 mackorean 10003 macarabic 10004 machebrew 10005 macgreek 10006 maccyrillic 10007 macchinesesimp 10008 maccentraleurope 10029 macicelandic 10079 macturkish 10081 ms-kanji 932 名称 代码 norwegian 20108 ns-4551-1 20108 shiftjis 932 shift-jis 932 sen-850200-b 20107 sjis 932 swedish 20107 tis-620 874 visual 28598","categories":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/categories/others/"}],"tags":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/tags/others/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 自动展开文章目录","slug":"05.Next7.0+自动展开文章目录","date":"2020-01-07T09:42:00.000Z","updated":"2021-08-20T11:39:24.301Z","comments":true,"path":"hexo/3ad659cd.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/3ad659cd.html","excerpt":"Hexo 的 Next 主题是可以自动展开文章目录的，其在默认情况下并未开启，需要手动开启 大部分博客都是基于之前的配置，因此导致新版本不兼容 下面介绍在 Next7.0+ 版本下的设置","text":"Hexo 的 Next 主题是可以自动展开文章目录的，其在默认情况下并未开启，需要手动开启 大部分博客都是基于之前的配置，因此导致新版本不兼容 下面介绍在 Next7.0+ 版本下的设置 由于 Next 主题更新至 7.0+ 版本后取消了 _custom 文件夹以及 custom.styl 文件 1.修改主题配置文件 _config.yml 打开 next 主题的 _config.yml 文件，搜索 custom_file_path，可以看到如下内容： 1234567891011custom_file_path: #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig #postMeta: source/_data/post-meta.swig #postBodyEnd: source/_data/post-body-end.swig #footer: source/_data/footer.swig #bodyEnd: source/_data/body-end.swig #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl #style: source/_data/styles.styl 修改 style 属性，即取消相应注释 2.创建 _data 文件夹并添加 styles.styl 文件 找到博客所在的根目录下的 source 文件夹，也就是存储 _post 文件夹的目录 之后，创建 _data 目录与其中的 styles.styl 文件 3.修改 styles.styl 文件 在文件中添加如下代码 12345678//文章目录默认展开.post-toc .nav .nav-child &#123; display: block; &#125;//文章目录字体大小调整.post-toc ol &#123; font-size : 13px; &#125; 4.修改主题配置文件 最后，修改主题配置文件 themes/next/_config.yml 搜索 toc 配置项，进行以下更改： 12345678910# 文章目录toc: # 开启文章目录 enable: true # 自动将列表编号添加到 toc number: true # 当设为 true 时，如果标题宽度大于侧边栏宽度，则将文字放在下一行 wrap: true","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+社交小图标设置","slug":"04.Next7.0+社交小图标设置","date":"2020-01-06T12:10:00.000Z","updated":"2021-08-23T14:23:28.783Z","comments":true,"path":"hexo/6bc80129.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/6bc80129.html","excerpt":"Next 主题的侧边栏的社交小图标默认极丑，可在图标库搜索自己喜欢的小图标进行更换。 打开主题配置文件 _config.yml，搜索 social，然后去 FontAwesome 图标库寻找自己喜欢的小图标，将名字复制到配置文件的相应位置 分隔符 || 之前的值是目标链接，分隔符 || 之后的值是 FontAwesome 图标，如果未指定图标，将加载问题图标","text":"Next 主题的侧边栏的社交小图标默认极丑，可在图标库搜索自己喜欢的小图标进行更换。 打开主题配置文件 _config.yml，搜索 social，然后去 FontAwesome 图标库寻找自己喜欢的小图标，将名字复制到配置文件的相应位置 分隔符 || 之前的值是目标链接，分隔符 || 之后的值是 FontAwesome 图标，如果未指定图标，将加载问题图标 例如： 123social: GitHub: https://github.com/Alex-McAvoy || fab fa-github CSDN: https://blog.csdn.net/u011815404 || fas fa-copyright 效果图：","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Next 7.0+ 背景设置","slug":"03.Next7.0+背景设置","date":"2020-01-05T11:54:00.000Z","updated":"2021-08-20T11:38:59.274Z","comments":true,"path":"hexo/cc90ae72.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/cc90ae72.html","excerpt":"由于 Next 主题更新至 7.0+ 版本后取消了 _custom 文件夹以及 custom.styl 文件 大部分博客都是基于之前的配置，因此导致新版本不兼容 下面介绍在 Next7.0+ 版本下的背景图片设置","text":"由于 Next 主题更新至 7.0+ 版本后取消了 _custom 文件夹以及 custom.styl 文件 大部分博客都是基于之前的配置，因此导致新版本不兼容 下面介绍在 Next7.0+ 版本下的背景图片设置 1.修改主题配置文件 _config.yml 打开 next 主题的 _config.yml 文件，搜索 custom_file_path，可以看到如下内容： 1234567891011custom_file_path: #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig #postMeta: source/_data/post-meta.swig #postBodyEnd: source/_data/post-body-end.swig #footer: source/_data/footer.swig #bodyEnd: source/_data/body-end.swig #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl #style: source/_data/styles.styl 修改 style 属性，即取消相应注释 2.创建 _data 文件夹并添加 styles.styl 文件 找到博客所在的根目录下的 source 文件夹，也就是存储 _post 文件夹的目录 之后，创建 _data 目录与其中的 styles.styl 文件 3.修改 styles.styl 文件 在文件中添加如下代码 12345678910// Custom styles.//背景图片body &#123; background:url(/assets/img/background.jpg); background-repeat: no-repeat; //是否重复出现 background-attachment:fixed; //定义背景图片随滚动轴的移动方式 background-position:50% 50%; //设置背景图像的起始位置 background-size:cover; //为可能有助于大分辨率下背景图的显示&#125; 之后，找到合适的背景图片，将其改名为 background.jpg，并将其放在 hexo/assets/img/ 路径下 如果需要使用图床上传的图片，将图片路径改为对应的 url 路径即可，例如： 1234567body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; 此处的 https://source.unsplash.com/random/1600x900 是一个提供随机图片的网站 4.修改不透明度 在 styles.styl 文件中添加如下代码 12345678910111213//透明度设置.header-inner &#123; //菜单栏 background: rgba(255,255,255,0.8);&#125;.sidebar &#123; //侧边栏 opacity: 0.8;&#125;.content-wrap &#123; //文章 opacity: 0.8;&#125;.popup &#123; //搜索框 opacity: 0.8;&#125;","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"},{"name":"NexT主题","slug":"next","permalink":"https://alex-mcavoy.github.io/tags/next/"}],"author":"Alex_McAvoy"},{"title":"Hexo 文件夹大小写问题","slug":"02.Hexo文件夹大小写问题","date":"2020-01-05T11:37:00.000Z","updated":"2021-08-20T11:39:56.248Z","comments":true,"path":"hexo/e64b749d.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/e64b749d.html","excerpt":"【问题】使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404 问题。 例如：Hexo 生成了一个 hexo 的 Category 文件夹，后来将其改为 Hexo ，Hexo 会正确生成，但部署到 Github 上却一直出现 404 问题。","text":"【问题】使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404 问题。 例如：Hexo 生成了一个 hexo 的 Category 文件夹，后来将其改为 Hexo ，Hexo 会正确生成，但部署到 Github 上却一直出现 404 问题。 【原因】git 默认忽略文件名大小写，因此即使文件夹大小写变更，git 也无法检测到。 【解决方法】1.进入到博客项目中的 .deploy_git 文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false 12cd .deploy_gitvim .git/config 2.删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上 123git rm -rf *git commit -m 'clean all file'git push 3.使用 Hexo 再次生成及部署123cd ..hexo cleanhexo deploy -generate","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"}],"author":"Alex_McAvoy"},{"title":"Hexo 链接永久化","slug":"01.Hexo链接永久化","date":"2020-01-04T12:24:00.000Z","updated":"2021-08-20T11:39:48.061Z","comments":true,"path":"hexo/be6aef5a.html","link":"","permalink":"https://alex-mcavoy.github.io/hexo/be6aef5a.html","excerpt":"【概述】Hexo 初始化的 URL 是年月日+标题，即：:year/:month/:day/:title/ 这样的 URL 层数太多，不仅不便于管理本地博文，而且由于标题中可能存在中文，会出现乱码问题。","text":"【概述】Hexo 初始化的 URL 是年月日+标题，即：:year/:month/:day/:title/ 这样的 URL 层数太多，不仅不便于管理本地博文，而且由于标题中可能存在中文，会出现乱码问题。 此外，一旦修改了标题，就会导致 URL 进行改变，使得之前分享给他人的 URL 无法定位资源。 本文采用的方案是将 URL 改为：分类+addrlink 的形式，这样不仅便于管理本地博文，而且可以实现链接永久化。 效果图： 【步骤】步骤一：下载 addrlink 插件 1npm install hexo-abbrlink --save 步骤二：在 _config.yml文件中修改 permalink 12345permalink: :category/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hexpermalink_defaults: 步骤三：配置 categroy_map 将中文分类映射为英文，从而使得出现中文分类时也不会出现中文乱码 例如： 12345# Category &amp; Tagdefault_category: uncatalogcategory_map: Hexo配置: hexotag_map: 1 P.S.关于 abbrlink 链接为 undefined 的问题，执行 hexo clean 清除掉之前文章的缓存，再执行 hexo g 重新渲染即可。 【关于abbrlink插件】abbrlink 是一个 Hexo 博客链接永久化的解决方案，其支持使用不同的算法和进制对文章链接进行转换。 算法 进制 生成链接 crc16 hex https://alex-mcavoy.github.io/mfc/3ab2.html crc16 dec https://alex-mcavoy.github.io/mfc/12345.html crc32 hex https://alex-mcavoy.github.io/mfc/9a8b6c4d.html crc32 dec https://alex-mcavoy.github.io/mfc/1690090958.html GitHub：https://github.com/Rozbo/hexo-abbrlink","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://alex-mcavoy.github.io/tags/hexo/"}],"author":"Alex_McAvoy"},{"title":"Git 的使用","slug":"02.Git的使用","date":"2020-01-04T11:35:00.000Z","updated":"2021-10-08T13:32:06.629Z","comments":true,"path":"others/32f13400.html","link":"","permalink":"https://alex-mcavoy.github.io/others/32f13400.html","excerpt":"【概述】Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 Git 参考文档：https://book.git-scm.com/docs","text":"【概述】Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 Git 参考文档：https://book.git-scm.com/docs 其工作流程如下： 【工作区、暂存区与版本库】Git 的工作区域分为三个模块： 工作区：在 PC 端本地的工作目录，用于添加、编辑、修改文件 暂存区：存放在 .git 目录中的 index 文件，该文件又称索引文件，暂存已经修改的文件，最后统一提交到版本库中 版本库：存储由暂存区提交过来的最终确定文件，形成一个新版本 如图，左侧为工作区，右侧为版本库，版本库中的 index 区域为暂存区，master 区域是 master分支 所代表的目录树 HEAD 是指向 master 分支的一个游标，因此图示命令中出现 HEAD 的地方均可用 master 来替换 objects 标识的区域为 Git对象库，位于 .git/objects 目录下，其中包含了创建的各种对象及内容 对工作区的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区的文件内容将被写入到对象库中的一个新的对象中，而该 对象ID 会被记录在暂存区的 index 文件中 当执行 git commit 命令时，暂存区的目录树写到版本库中，master 分支会做相应的更新，其指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但工作区不受影响 当执行 git rm --cached &lt;file&gt; 命令时，会直接从暂存区删除文件，工作区则不做出改变 当执行 git checkout . 或 git checkout -- &lt;file&gt; 命令时，会用暂存区全部或指定的文件替换工作区的文件，这个操作会清除工作区中未添加到暂存区的改动 当执行 git checkout HEAD . 或者 git checkout HEAD &lt;file&gt; 命令时，会用 HEAD 指向的 master分支 中的全部或者部分文件替换暂存区和以及工作区中的文件，其不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动 【创建仓库】Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，因此 git init 是使用 Git 的第一个命令 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变 若使用当前目录作为 Git 仓库，只需要将其初始化：git init，当前目录下会出现一个 .git 目录 若使用指定目录作为 Git 仓库，则需要加上路径：git init &lt;newrepo&gt;，初始化后，会在 newrepo 目录下会出现一个 .git 目录 【拷贝项目】在初始化仓库后，使用 git clone 从现有 Git 从仓库中拷贝项目 命令格式：git clone &lt;repo&gt; &lt;directory&gt; repo：Git 仓库 directory：本地目录 例如：要克隆 Ruby 语言的 Git 代码仓库 Grit 可以用下面的命令：git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含 .git 目录，包含下载下来的所有版本记录 如果想自定义新建的项目目录，在末尾加上 &lt;directory&gt; 参数即可 【基本命令】利用 git add &lt;filename&gt; 命令可将文件添加到缓存区 利用 git commit -m &quot;代码提交信息&quot; 命令，以实际提交改动，此时改动已经提交到了 HEAD 中，还未上传到远端仓库 利用 git status 命令查看上次提交后是否有修改，相应的可利用 git diff 命令查看执行 git status 的结果的详细信息 当利用 git commit -m &quot;代码提交信息&quot; 命令将改动提交到本地仓库的 HEAD 中后，可利用 git push origin &lt;branch&gt; 命令推送到想推送的分支，&lt;branch&gt; 是要推送到的分支，一般推送到开发主分支 master 中 【分支管理】分支是用来将特性开发绝缘开来的，当创建仓库的时，master 是默认的开发主分支 可以利用 git branch &lt;branchname&gt; 创建一个分支，利用 git checkout &lt;branchname&gt; 进行切换分支，从而在其他分支上进行开发，完成后再利用 git merge &lt;branchname&gt; 命令将分支合并到主分支上 需要注意的是，除非利用 git push origin &lt;branchname&gt; 将分支推送到远端仓库上，不然新建的分支是他人不可见的 除了上述命令外，还可利用 git branch 命令列出本地分支，git branch -d &lt;branchname&gt; 命令删除分支 【技巧】在将改动推送到远端仓库时，有时会出现 Your branch is up-to-date with &#39;origin/master&#39;的问题 此时是版本分支出了问题，可按如下步骤解决： 1.新建一个分支：git branch newbranch 2.检查分支是否创建成功：git branch * 代表当前所在的工作分支 3.切换到新分支：git checkout newbranch 4.将改动提交到新分支上： 12git add *git commit -m &quot;update&quot; 5.检查改动是否成功：git status 6.切换到主分支：git checkout master 7.将新分支提交的改动合并到主分支上：git merge newbranch 8.推送到远端仓库：git push origin master 9.删除新建分支：git branch -d newbranch","categories":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/categories/others/"}],"tags":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/tags/others/"}],"author":"Alex_McAvoy"},{"title":"Win10 更改用户名","slug":"01.Win10更改用户名","date":"2020-01-03T12:11:00.000Z","updated":"2021-10-08T13:31:33.161Z","comments":true,"path":"others/5119dfe.html","link":"","permalink":"https://alex-mcavoy.github.io/others/5119dfe.html","excerpt":"在 win10 系统下，设置账户一段时间后，处于种种原因，可能想将账户用户名更换。 如下图，红线框出位置即为当前账户的用户名","text":"在 win10 系统下，设置账户一段时间后，处于种种原因，可能想将账户用户名更换。 如下图，红线框出位置即为当前账户的用户名 假设要将账户 A 改名为 B，首先需要用另一个管理员账户 C 登录系统。 利用管理员账户 C 执行以下操作： 在控制面板-&gt;用户账户中，将用户 A 改名为 B； 打开 C:/Users 或用户文件夹，将文件夹 A 重命名为 B； 利用 win+R 快捷键，打开运行窗口，输入 regedit 打开注册表编辑器 在注册表编辑器中，定位到路径： HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/ProfileList 在 ProfileList 文件夹下，分别点击名字较长的字符串的文件夹，查看窗口右侧的 ProfileImagePath 键的内容，找到路径为 C:/Users/A 的键 双击该 ProfileImagePath 键，将其内容改为：C:/User/B 完成上述操作后，注销管理员账户 C，重新登陆账户 B，用户配置文件已经变成了 B。","categories":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/categories/others/"}],"tags":[{"name":"杂项","slug":"others","permalink":"https://alex-mcavoy.github.io/tags/others/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——消息处理函数","slug":"08.Sniffer-消息处理函数","date":"2019-12-31T05:20:00.000Z","updated":"2021-08-31T11:48:22.176Z","comments":true,"path":"mfc/486a9243.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/486a9243.html","excerpt":"【概述】至此，程序基本完成，只剩下控制控件更新的消息处理函数的编写 其可分为开始按钮、结束按钮、保存按钮、读取按钮、列表更新、列表项颜色变换这六个部分","text":"【概述】至此，程序基本完成，只剩下控制控件更新的消息处理函数的编写 其可分为开始按钮、结束按钮、保存按钮、读取按钮、列表更新、列表项颜色变换这六个部分 【开始按钮】1234567891011121314151617181920212223//开始按钮void CSnifferDlg::OnBnClickedButton1() &#123; //若已有数据，提示保存数据 if (this-&gt;m_localDataList.IsEmpty() == FALSE) if (MessageBox(\"确认不保存数据？\", \"警告\", MB_YESNO) == IDNO) this-&gt;Sniffer_saveFile(); //清空数据 this-&gt;packetNum = 1; //重新计数 this-&gt;m_localDataList.RemoveAll(); this-&gt;m_netDataList.RemoveAll(); memset(&amp;(this-&gt;packetCount), 0, sizeof(struct packet_count)); this-&gt;Sniffer_updatePacket(); if (this-&gt;Sniffer_startCap() &lt; 0) return; this-&gt;m_listCtrl.DeleteAllItems(); this-&gt;m_treeCtrl.DeleteAllItems(); this-&gt;m_edit.SetWindowText(\"\"); this-&gt;m_buttonStart.EnableWindow(FALSE); this-&gt;m_buttonStop.EnableWindow(TRUE); this-&gt;m_buttonSave.EnableWindow(FALSE);&#125; 【结束按钮】1234567891011121314//结束按钮void CSnifferDlg::OnBnClickedButton2() &#123; if (this-&gt;m_ThreadHandle == NULL) return; if (TerminateThread(this-&gt;m_ThreadHandle, -1) == 0) &#123; MessageBox(\"线程关闭错误，请稍后重试\"); return; &#125; this-&gt;m_ThreadHandle = NULL; this-&gt;m_buttonStart.EnableWindow(TRUE); this-&gt;m_buttonStop.EnableWindow(FALSE); this-&gt;m_buttonSave.EnableWindow(TRUE);&#125; 【保存按钮】12345//保存按钮void CSnifferDlg::OnBnClickedButton3() &#123; if (this-&gt;Sniffer_saveFile() &lt; 0) return;&#125; 【读取按钮】1234567891011121314151617181920//读取按钮void CSnifferDlg::OnBnClickedButton4() &#123; //清空数据 this-&gt;m_listCtrl.DeleteAllItems(); this-&gt;packetNum = 1; this-&gt;m_localDataList.RemoveAll(); this-&gt;m_netDataList.RemoveAll(); memset(&amp;(this-&gt;packetCount), 0, sizeof(struct packet_count)); //打开文件对话框 char szFilter[] = \"lix文件(*.lix)|*.lix||\"; CFileDialog FileDlg(TRUE, \".lix\", 0, 0, szFilter); FileDlg.m_ofn.lpstrInitialDir = \"D:\\\\\"; if (FileDlg.DoModal() == IDOK) &#123; int ret = this-&gt;Sniffer_readFile(FileDlg.GetPathName()); if (ret &lt; 0) return; &#125;&#125; 【列表更新】1234567891011//列表更新void CSnifferDlg::OnLvnItemchangedList1(NMHDR *pNMHDR, LRESULT *pResult) &#123; LPNMLISTVIEW pNMLV = reinterpret_cast&lt;LPNMLISTVIEW&gt;(pNMHDR); POSITION pos = m_listCtrl.GetFirstSelectedItemPosition(); int index = m_listCtrl.GetNextSelectedItem(pos); //获取列表控件当前选择的行号 if (index != -1) &#123; this-&gt;Sniffer_updateEdit(index);//更新对应行的编辑框 this-&gt;Sniffer_updateTree(index);//更新对应行的树形框 &#125; *pResult = 0;&#125; 【列表项颜色变换】考虑到抓包过程中协议众多，在列表控件中无法直观看出协议，因此考虑将不同协议的包的列表项设置为不同的颜色 12345678910111213141516171819202122232425262728293031323334353637//列表项颜色变换void CSnifferDlg::OnNMCustomdrawList1(NMHDR *pNMHDR, LRESULT *pResult) &#123; LPNMLVCUSTOMDRAW pNMCD = (LPNMLVCUSTOMDRAW)pNMHDR; *pResult = 0; if (CDDS_PREPAINT == pNMCD-&gt;nmcd.dwDrawStage) *pResult = CDRF_NOTIFYITEMDRAW; else if(CDDS_ITEMPREPAINT == pNMCD-&gt;nmcd.dwDrawStage) &#123; POSITION pos = this-&gt;m_localDataList.FindIndex(pNMCD-&gt;nmcd.dwItemSpec); struct data_packet * localData = (struct data_packet *)this-&gt;m_localDataList.GetAt(pos); char buffer[10]; memset(buffer, 0, sizeof(buffer)); strcpy(buffer, localData-&gt;type); COLORREF crText; if (!strcmp(buffer, \"ARP\")) crText = RGB(226, 238, 227); if (!strcmp(buffer, \"IPv4\")) crText = RGB(255, 182, 193); if (!strcmp(buffer, \"IPv6\")) crText = RGB(111, 224, 254); if(!strcmp(buffer, \"UDP\")) crText = RGB(194, 195, 252); if(!strcmp(buffer, \"TCP\")) crText = RGB(230, 230, 230); if(!strcmp(buffer, \"ICMPv4\")) crText = RGB(49, 164, 238); if(!strcmp(buffer, \"ICMPv6\")) crText = RGB(189, 254, 76); if (!strcmp(buffer, \"HTTP\")) crText = RGB(238, 232, 180); pNMCD-&gt;clrTextBk = crText; *pResult = CDRF_DODEFAULT; &#125;&#125;","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——GUI数据更新函数","slug":"07.Sniffer-GUI数据更新函数","date":"2019-12-30T07:13:00.000Z","updated":"2021-08-31T11:48:06.863Z","comments":true,"path":"mfc/7d5e25c9.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/7d5e25c9.html","excerpt":"【概述】GUI 数据更新函数，是对 GUI 的各控件进行更新数据所使用的 每调用相关函数一次，就对相关的控件进行数据更新","text":"【概述】GUI 数据更新函数，是对 GUI 的各控件进行更新数据所使用的 每调用相关函数一次，就对相关的控件进行数据更新 具体可分为：保存文件、读取文件、更新编辑框、编辑框格式化显示、更新树形框这五部分 【保存文件】1234567891011121314151617//保存文件int CSnifferDlg::Sniffer_saveFile() &#123; CFileFind find; if (find.FindFile(CString(filePath)) == NULL)&#123; MessageBox(\"保存文件遇到未知意外\"); return -1; &#125; //保存文件对话框 char szFilter[] = \"lix文件(*.lix)|*.lix||\"; CFileDialog openDlg(FALSE, \".lix\", 0, 0, szFilter); openDlg.m_ofn.lpstrInitialDir = \"D:\\\\\"; if (openDlg.DoModal() == IDOK) CopyFile(CString(filePath), openDlg.GetPathName(), TRUE); return 1;&#125; 【读取文件】123456789101112131415161718192021222324252627282930313233343536373839404142//读取文件int CSnifferDlg::Sniffer_readFile(CString path) &#123; //处理路径 int len = path.GetLength() + 1; char* charPath = (char *)malloc(len); memset(charPath, 0, len); if (charPath == NULL) return -1; for (int i = 0; i &lt; len; i++) charPath[i] = (char)path.GetAt(i); //打开文件 pcap_t *fp; if ((fp = pcap_open_offline(charPath, errorBufffer)) == NULL) &#123; MessageBox(\"打开文件错误\" + CString(errorBufffer)); return -1; &#125; struct pcap_pkthdr *data_header;//数据包头 const u_char *pkt_data = NULL;//收到的字节流数据 while (pcap_next_ex(fp, &amp;data_header, &amp;pkt_data) &gt;= 0) &#123; struct data_packet *data = (struct data_packet*)malloc(sizeof(struct data_packet)); memset(data, 0, sizeof(struct data_packet)); if (data == NULL) &#123; MessageBox(\"空间已满，无法接收新的数据包\"); return -1; &#125; //分析出错或所接收数据包不在处理范围内 if (analyse_data_frame(pkt_data, data, &amp;(this-&gt;packetCount)) &lt; 0) continue; //更新各类数据包计数 this-&gt;Sniffer_updatePacket(); this-&gt;Sniffer_updateList(data_header, data, pkt_data); &#125; pcap_close(fp); return 1;&#125; 【更新编辑框】12345678910111213//更新编辑框int CSnifferDlg::Sniffer_updateEdit(int index) &#123; POSITION localPos = this-&gt;m_localDataList.FindIndex(index); POSITION netPos = this-&gt;m_netDataList.FindIndex(index); struct data_packet* localData = (struct data_packet*)(this-&gt;m_localDataList.GetAt(localPos)); u_char * netData = (u_char*)(this-&gt;m_netDataList.GetAt(netPos)); CString buffer; print_packet_hex(netData, localData-&gt;len, &amp;buffer);//数据格式化显示函数 this-&gt;m_edit.SetWindowText(buffer); return 1;&#125; 【编辑框数据格式化显示】123456789101112131415161718192021222324//编辑框数据格式化显示void CSnifferDlg::print_packet_hex(const u_char* packet, int packet_size, CString *buffer) &#123; for (int i = 0; i &lt; packet_size; i += 16) &#123; //将数据以16进制形式显示 buffer-&gt;AppendFormat(\"%04x: \", (u_int)i); int row = (packet_size - i) &gt; 16 ? 16 : (packet_size - i); for (int j = 0; j &lt; row; j++) buffer-&gt;AppendFormat(\"%02x \", (u_int)packet[i + j]); if (row &lt; 16)//不足16时，用空格补足 for (int j = row; j &lt; 16; j++) buffer-&gt;AppendFormat(\" \"); //将数据以字符形式显示 for (int j = 0; j &lt; row; j++) &#123; u_char ch = packet[i + j]; ch = isprint(ch) ? ch : '.'; buffer-&gt;AppendFormat(\"%c\", ch); &#125; buffer-&gt;Append(\"\\r\\n\"); if (row &lt; 16) return; &#125;&#125; 【更新树形框】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303//更新树形框int CSnifferDlg::Sniffer_updateTree(int index) &#123; this-&gt;m_treeCtrl.DeleteAllItems(); POSITION localPos = this-&gt;m_localDataList.FindIndex(index); struct data_packet* localData = (struct data_packet*)(this-&gt;m_localDataList.GetAt(localPos)); CString str; str.Format(\"第%d个数据包\", index + 1); HTREEITEM root = this-&gt;m_treeCtrl.GetRootItem(); HTREEITEM data = this-&gt;m_treeCtrl.InsertItem(str, root); /****************链路层****************/ HTREEITEM frame = this-&gt;m_treeCtrl.InsertItem(\"链路层\", data); str.Format(\"源MAC：\"); for (int i = 0; i &lt; 6; i++) &#123; if (i &lt;= 4) str.AppendFormat(\"%02x-\", localData-&gt;ethh-&gt;src[i]); else str.AppendFormat(\"%02x\", localData-&gt;ethh-&gt;src[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, frame); str.Format(\"目的MAC：\"); for (int i = 0; i &lt; 6; i++) &#123; if (i &lt;= 4) str.AppendFormat(\"%02x-\", localData-&gt;ethh-&gt;dest[i]); else str.AppendFormat(\"%02x\", localData-&gt;ethh-&gt;dest[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, frame); str.Format(\"类型：0x%02x\", localData-&gt;ethh-&gt;type); this-&gt;m_treeCtrl.InsertItem(str, frame); /****************网络层****************/ //ARP头 if (localData-&gt;ethh-&gt;type == PROTO_ARP) &#123; HTREEITEM arp = this-&gt;m_treeCtrl.InsertItem(\"ARP头\", data); str.Format(\"硬件类型：%d\", localData-&gt;arph-&gt;hard_type); this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"协议类型：0x%02x\", localData-&gt;arph-&gt;pro_type); this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"硬件地址长度：%d\", localData-&gt;arph-&gt;hard_len); this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"协议地址长度：%d\", localData-&gt;arph-&gt;pro_len); this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"操作码：%d\", localData-&gt;arph-&gt;oper); this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"发送方MAC：\"); for (int i = 0; i &lt; 6; i++) &#123; if (i &lt;= 4) str.AppendFormat(\"%02x-\", localData-&gt;arph-&gt;src_mac[i]); else str.AppendFormat(\"%02x\", localData-&gt;arph-&gt;src_mac[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"发送方IP：\"); for (int i = 0; i &lt; 4; i++) &#123; if (i &lt;= 2) str.AppendFormat(\"%d.\", localData-&gt;arph-&gt;src_ip[i]); else str.AppendFormat(\"%d\", localData-&gt;arph-&gt;src_ip[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"接收方MAC：\"); for (int i = 0; i &lt; 6; i++) &#123; if (i &lt;= 4) str.AppendFormat(\"%02x-\", localData-&gt;arph-&gt;dest_mac[i]); else str.AppendFormat(\"%02x\", localData-&gt;arph-&gt;dest_mac[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, arp); str.Format(\"接收方IP：\"); for (int i = 0; i &lt; 4; i++) &#123; if (i &lt;= 2) str.AppendFormat(\"%d.\", localData-&gt;arph-&gt;dest_ip[i]); else str.AppendFormat(\"%d\", localData-&gt;arph-&gt;dest_ip[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, arp); &#125; //IPv4头 if (localData-&gt;ethh-&gt;type == PROTO_IP_V4) &#123; HTREEITEM ip = this-&gt;m_treeCtrl.InsertItem(\"IPv4头\", data); str.Format(\"版本：%d\", localData-&gt;ip4h-&gt;version); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"IP头长：%d\", localData-&gt;ip4h-&gt;ihl); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"服务类型：%d\", localData-&gt;ip4h-&gt;tos); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"总长度：%d\", localData-&gt;ip4h-&gt;total_len); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"标识：0x%02x\", localData-&gt;ip4h-&gt;id); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"段偏移：%d\", localData-&gt;ip4h-&gt;frag_off); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"生存期：%d\", localData-&gt;ip4h-&gt;ttl); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"协议：%d\", localData-&gt;ip4h-&gt;proto); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"头部校验和：0x%02x\", localData-&gt;ip4h-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"源IP：\"); struct in_addr in; in.S_un.S_addr = localData-&gt;ip4h-&gt;src_addr; str.AppendFormat(CString(inet_ntoa(in))); this-&gt;m_treeCtrl.InsertItem(str, ip); str.Format(\"目的IP：\"); in.S_un.S_addr = localData-&gt;ip4h-&gt;dest_addr; str.AppendFormat(CString(inet_ntoa(in))); this-&gt;m_treeCtrl.InsertItem(str, ip); /****************传输层****************/ //ICMPv4头 if (localData-&gt;ip4h-&gt;proto == V4_PROTO_ICMP_V4) &#123; HTREEITEM icmp = this-&gt;m_treeCtrl.InsertItem(\"ICMPv4头\", data); str.Format(\"类型:%d\", localData-&gt;icmp4h-&gt;type); this-&gt;m_treeCtrl.InsertItem(str, icmp); str.Format(\"代码:%d\", localData-&gt;icmp4h-&gt;code); this-&gt;m_treeCtrl.InsertItem(str, icmp); str.Format(\"序号:%d\", localData-&gt;icmp4h-&gt;seq); this-&gt;m_treeCtrl.InsertItem(str, icmp); str.Format(\"校验和:%d\", localData-&gt;icmp4h-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, icmp); &#125; //TCP头 if (localData-&gt;ip4h-&gt;proto == V4_PROTO_TCP) &#123; HTREEITEM tcp = this-&gt;m_treeCtrl.InsertItem(\"TCP协议头\", data); str.Format(\" 源端口:%d\", localData-&gt;tcph-&gt;src_port); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 目的端口:%d\", localData-&gt;tcph-&gt;dest_port); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 序列号:0x%02x\", localData-&gt;tcph-&gt;seq); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 确认号:%d\", localData-&gt;tcph-&gt;ack_seq); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 头部长度:%d\", localData-&gt;tcph-&gt;doff); HTREEITEM flag = this-&gt;m_treeCtrl.InsertItem(\" +标志位\", tcp); str.Format(\"cwr %d\", localData-&gt;tcph-&gt;cwr); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"ece %d\", localData-&gt;tcph-&gt;ece); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"urg %d\", localData-&gt;tcph-&gt;urg); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"ack %d\", localData-&gt;tcph-&gt;ack); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"psh %d\", localData-&gt;tcph-&gt;psh); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"rst %d\", localData-&gt;tcph-&gt;rst); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"syn %d\", localData-&gt;tcph-&gt;syn); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"fin %d\", localData-&gt;tcph-&gt;fin); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\" 紧急指针:%d\", localData-&gt;tcph-&gt;urg_ptr); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 校验和:0x%02x\", localData-&gt;tcph-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 选项:%d\", localData-&gt;tcph-&gt;opt); this-&gt;m_treeCtrl.InsertItem(str, tcp); &#125; //UDP头 if (localData-&gt;ip4h-&gt;proto == V4_PROTO_UDP) &#123; HTREEITEM udp = this-&gt;m_treeCtrl.InsertItem(\"UDP协议头\", data); str.Format(\"源端口:%d\", localData-&gt;udph-&gt;sport); this-&gt;m_treeCtrl.InsertItem(str, udp); str.Format(\"目的端口:%d\", localData-&gt;udph-&gt;dport); this-&gt;m_treeCtrl.InsertItem(str, udp); str.Format(\"总长度:%d\", localData-&gt;udph-&gt;len); this-&gt;m_treeCtrl.InsertItem(str, udp); str.Format(\"校验和:0x%02x\", localData-&gt;udph-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, udp); &#125; &#125; //IPv6头 if (localData-&gt;ethh-&gt;type == PROTO_IP_V6) &#123; HTREEITEM ip6 = this-&gt;m_treeCtrl.InsertItem(\"IPv6头\", data); str.Format(\"版本:%d\", localData-&gt;ip6h-&gt;flowtype); this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"流类型:%d\", localData-&gt;ip6h-&gt;version); this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"流标签:%d\", localData-&gt;ip6h-&gt;flowid); this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"有效载荷长度:%d\", localData-&gt;ip6h-&gt;plen); this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"下一个首部:0x%02x\", localData-&gt;ip6h-&gt;next_head); this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"跳限制:%d\", localData-&gt;ip6h-&gt;hop_limit); this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"源地址:\"); for (int i = 0; i &lt; 8; i++) &#123; if (i &lt;= 6) str.AppendFormat(\"%02x:\", localData-&gt;ip6h-&gt;src_addr[i]); else str.AppendFormat(\"%02x\", localData-&gt;ip6h-&gt;src_addr[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, ip6); str.Format(\"目的地址:\"); for (int i = 0; i &lt; 8; i++) &#123; if (i &lt;= 6) str.AppendFormat(\"%02x:\", localData-&gt;ip6h-&gt;src_addr[i]); else str.AppendFormat(\"%02x\", localData-&gt;ip6h-&gt;src_addr[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, ip6); /****************传输层****************/ //IPv6头 if (localData-&gt;ip6h-&gt;next_head == V6_PROTO_ICMP_V6) &#123; HTREEITEM icmp6 = this-&gt;m_treeCtrl.InsertItem(\"ICMPv6协议头\", data); str.Format(\"类型:%d\", localData-&gt;icmp6h-&gt;type); this-&gt;m_treeCtrl.InsertItem(str, icmp6); str.Format(\"代码:%d\", localData-&gt;icmp6h-&gt;code); this-&gt;m_treeCtrl.InsertItem(str, icmp6); str.Format(\"序号:%d\", localData-&gt;icmp6h-&gt;seq); this-&gt;m_treeCtrl.InsertItem(str, icmp6); str.Format(\"校验和:%d\", localData-&gt;icmp6h-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, icmp6); str.Format(\"选项-类型:%d\", localData-&gt;icmp6h-&gt;op_type); this-&gt;m_treeCtrl.InsertItem(str, icmp6); str.Format(\"选项-长度%d\", localData-&gt;icmp6h-&gt;op_len); this-&gt;m_treeCtrl.InsertItem(str, icmp6); str.Format(\"选项-链路层地址:\"); for (int i = 0; i &lt; 6; i++) &#123; if (i &lt;= 4) str.AppendFormat(\"%02x-\", localData-&gt;icmp6h-&gt;op_eth_addr[i]); else str.AppendFormat(\"%02x\", localData-&gt;icmp6h-&gt;op_eth_addr[i]); &#125; this-&gt;m_treeCtrl.InsertItem(str, icmp6); &#125; //TCP头 if (localData-&gt;ip6h-&gt;next_head == V6_PROTO_TCP) &#123; HTREEITEM tcp = this-&gt;m_treeCtrl.InsertItem(\"TCP协议头\", data); str.Format(\" 源端口:%d\", localData-&gt;tcph-&gt;src_port); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 目的端口:%d\", localData-&gt;tcph-&gt;dest_port); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 序列号:0x%02x\", localData-&gt;tcph-&gt;seq); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 确认号:%d\", localData-&gt;tcph-&gt;ack_seq); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 头部长度:%d\", localData-&gt;tcph-&gt;doff); HTREEITEM flag = this-&gt;m_treeCtrl.InsertItem(\"标志位\", tcp); str.Format(\"cwr %d\", localData-&gt;tcph-&gt;cwr); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"ece %d\", localData-&gt;tcph-&gt;ece); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"urg %d\", localData-&gt;tcph-&gt;urg); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"ack %d\", localData-&gt;tcph-&gt;ack); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"psh %d\", localData-&gt;tcph-&gt;psh); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"rst %d\", localData-&gt;tcph-&gt;rst); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"syn %d\", localData-&gt;tcph-&gt;syn); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\"fin %d\", localData-&gt;tcph-&gt;fin); this-&gt;m_treeCtrl.InsertItem(str, flag); str.Format(\" 紧急指针:%d\", localData-&gt;tcph-&gt;urg_ptr); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 校验和:0x%02x\", localData-&gt;tcph-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, tcp); str.Format(\" 选项:%d\", localData-&gt;tcph-&gt;opt); this-&gt;m_treeCtrl.InsertItem(str, tcp); &#125; //UDP头 if (localData-&gt;ip6h-&gt;next_head == V6_PROTO_UDP) &#123; HTREEITEM udp = this-&gt;m_treeCtrl.InsertItem(\"UDP协议头\", data); str.Format(\"源端口:%d\", localData-&gt;udph-&gt;sport); this-&gt;m_treeCtrl.InsertItem(str, udp); str.Format(\"目的端口:%d\", localData-&gt;udph-&gt;dport); this-&gt;m_treeCtrl.InsertItem(str, udp); str.Format(\"总长度:%d\", localData-&gt;udph-&gt;len); this-&gt;m_treeCtrl.InsertItem(str, udp); str.Format(\"校验和:0x%02x\", localData-&gt;udph-&gt;check); this-&gt;m_treeCtrl.InsertItem(str, udp); &#125; &#125; return 1;&#125;","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——数据包接收线程","slug":"06.Sniffer-数据包接收线程","date":"2019-12-29T10:07:00.000Z","updated":"2021-08-31T11:48:40.767Z","comments":true,"path":"mfc/98221520.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/98221520.html","excerpt":"【概述】数据包接收线程，是在已有的GUI上利用多线程技术进行数据接收，同时对GUI进行更新。因此，数据包接收线程，除了利用多线程进行数据接收外，还要在接收后对GUI控件进行更新 为此，需要提前编写一个更新数据包与更新列表的函数","text":"【概述】数据包接收线程，是在已有的GUI上利用多线程技术进行数据接收，同时对GUI进行更新。因此，数据包接收线程，除了利用多线程进行数据接收外，还要在接收后对GUI控件进行更新 为此，需要提前编写一个更新数据包与更新列表的函数 对于更新数据包函数来说，每调用一次该函数，就对 GUI 的统计数据的包计数进行更新 对于更新列表的函数来说，每调用一次该函数，就为新接收到的数据包在 GUI 中的列表控件里新建项 【更新数据包】1234567891011121314151617181920212223242526272829303132333435//更新数据包int CSnifferDlg::Sniffer_updatePacket() &#123; CString str; str.Format(\"%d\", this-&gt;packetNum.num_arp); this-&gt;m_editARP.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_ip4); this-&gt;m_editIPv4.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_ip6); this-&gt;m_editIPv6.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_icmp4); this-&gt;m_editICMPv4.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_icmp6); this-&gt;m_editICMPv6.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_udp); this-&gt;m_editUDP.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_tcp); this-&gt;m_editTCP.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_http); this-&gt;m_editHTTP.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_other); this-&gt;m_editOther.SetWindowText(str); str.Format(\"%d\", this-&gt;packetNum.num_sum); this-&gt;m_editSum.SetWindowText(str); return 1;&#125; 【更新列表】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//更新列表int CSnifferDlg::Sniffer_updateList(struct pcap_pkthdr *data_header, struct data_packet *data, const u_char *pkt_data) &#123; /********************初始化准备*********************/ //建立数据包链表，保存本地化后的数据 u_char *data_packet_list; data_packet_list = (u_char*)malloc(data_header-&gt;len); memcpy(data_packet_list, pkt_data, data_header-&gt;len); this-&gt;m_localDataList.AddTail(data); this-&gt;m_netDataList.AddTail(data_packet_list); //获取长度 data-&gt;len = data_header-&gt;len; //获取时间 time_t local_tv_sec = data_header-&gt;ts.tv_sec; struct tm *ltime = localtime(&amp;local_tv_sec); data-&gt;time[0] = ltime-&gt;tm_year + 1900; data-&gt;time[1] = ltime-&gt;tm_mon + 1; data-&gt;time[2] = ltime-&gt;tm_mday; data-&gt;time[3] = ltime-&gt;tm_hour; data-&gt;time[4] = ltime-&gt;tm_min; data-&gt;time[5] = ltime-&gt;tm_sec; /********************更新控件*********************/ //为新接收到的数据包在列表控件中新建项 CString buffer; buffer.Format(\"%d\", this-&gt;packetNum); int nextItem = this-&gt;m_listCtrl.InsertItem(this-&gt;packetNum, buffer); //时间戳 CString timestr; timestr.Format(\"%d/%d/%d %d:%d:%d\", data-&gt;time[0], data-&gt;time[1], data-&gt;time[2], data-&gt;time[3], data-&gt;time[4], data-&gt;time[5]); this-&gt;m_listCtrl.SetItemText(nextItem, 1, timestr); //长度 buffer.Empty(); buffer.Format(\"%d\", data-&gt;len); this-&gt;m_listCtrl.SetItemText(nextItem, 2, buffer); //源MAC buffer.Empty(); buffer.Format(\"%02X-%02X-%02X-%02X-%02X-%02X\", data-&gt;ethh-&gt;src[0], data-&gt;ethh-&gt;src[1], data-&gt;ethh-&gt;src[2], data-&gt;ethh-&gt;src[3], data-&gt;ethh-&gt;src[4], data-&gt;ethh-&gt;src[5]); this-&gt;m_listCtrl.SetItemText(nextItem, 3, buffer); //目的MAC buffer.Empty(); buffer.Format(\"%02X-%02X-%02X-%02X-%02X-%02X\", data-&gt;ethh-&gt;dest[0], data-&gt;ethh-&gt;dest[1], data-&gt;ethh-&gt;dest[2], data-&gt;ethh-&gt;dest[3], data-&gt;ethh-&gt;dest[4], data-&gt;ethh-&gt;dest[5]); this-&gt;m_listCtrl.SetItemText(nextItem, 4, buffer); //协议 this-&gt;m_listCtrl.SetItemText(nextItem, 5, CString(data-&gt;type)); //源IP buffer.Empty(); if (data-&gt;ethh-&gt;type == PROTO_ARP) &#123; buffer.Format(\"%d.%d.%d.%d\", data-&gt;arph-&gt;src_ip[0], data-&gt;arph-&gt;src_ip[1], data-&gt;arph-&gt;src_ip[2], data-&gt;arph-&gt;src_ip[3]); &#125; else if (data-&gt;ethh-&gt;type == PROTO_IP_V4) &#123; struct in_addr in; in.S_un.S_addr = data-&gt;ip4h-&gt;src_addr; buffer = CString(inet_ntoa(in)); &#125; else if (data-&gt;ethh-&gt;type == PROTO_IP_V6) &#123; for (int i = 0; i &lt; 8; i++) &#123; if (i &lt;= 6) buffer.AppendFormat(\"%02x:\", data-&gt;ip6h-&gt;src_addr[i]); else buffer.AppendFormat(\"%02x\", data-&gt;ip6h-&gt;src_addr[i]); &#125; &#125; this-&gt;m_listCtrl.SetItemText(nextItem, 6, buffer); //目的IP buffer.Empty(); if (data-&gt;ethh-&gt;type == PROTO_ARP) &#123; buffer.Format(\"%d.%d.%d.%d\", data-&gt;arph-&gt;dest_ip[0], data-&gt;arph-&gt;dest_ip[1], data-&gt;arph-&gt;dest_ip[2], data-&gt;arph-&gt;dest_ip[3]); &#125; else if (data-&gt;ethh-&gt;type == PROTO_IP_V4) &#123; struct in_addr in; in.S_un.S_addr = data-&gt;ip4h-&gt;dest_addr; buffer = CString(inet_ntoa(in)); &#125; else if (data-&gt;ethh-&gt;type == PROTO_IP_V6) &#123; for (int i = 0; i &lt; 8; i++) &#123; if (i &lt;= 6) buffer.AppendFormat(\"%02x:\", data-&gt;ip6h-&gt;dest_addr[i]); else buffer.AppendFormat(\"%02x\", data-&gt;ip6h-&gt;dest_addr[i]); &#125; &#125; this-&gt;m_listCtrl.SetItemText(nextItem, 7, buffer); this-&gt;packetNum++;//包计数 return 1;&#125; 【接收线程】1234567891011121314151617181920212223242526272829303132333435363738接收线程函数DWORD WINAPI Sniffer_capThread(LPVOID lpParameter) &#123; CSnifferDlg *pthis = (CSnifferDlg*)lpParameter; if (pthis-&gt;m_ThreadHandle == NULL) &#123; MessageBox(NULL, \"线程句柄错误\", \"提示\", MB_OK); return -1; &#125; int flag; struct pcap_pkthdr *data_header;//数据包头 const u_char *pkt_data = NULL;//收到的字节流数据 while ((flag = pcap_next_ex(pthis-&gt;catchHandle, &amp;data_header, &amp;pkt_data)) &gt;= 0) &#123; /********************预处理判断*********************/ if (flag == 0)//超时 continue; struct data_packet *data = (struct data_packet*)malloc(sizeof(struct data_packet)); memset(data, 0, sizeof(struct data_packet)); if (data == NULL) &#123; MessageBox(NULL, \"空间已满，无法接收新的数据包\", \"Error\", MB_OK); return -1; &#125; //分析出错或所接收数据包不在处理范围内 if (analyse_data_frame(pkt_data, data, &amp;(pthis-&gt;packetCount)) &lt; 0) continue; //将数据包保存到打开的文件中 if (pthis-&gt;dumpFile != NULL) pcap_dump((unsigned char*)pthis-&gt;dumpFile, data_header, pkt_data); /********************更新控件*********************/ pthis-&gt;Sniffer_updatePacket(); pthis-&gt;Sniffer_updateList(data_header, data, pkt_data); &#125; return 1;&#125;","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——数据包解析函数","slug":"05.Sniffer-数据包解析函数","date":"2019-12-28T14:57:00.000Z","updated":"2021-08-31T11:48:35.124Z","comments":true,"path":"mfc/d820c95f.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/d820c95f.html","excerpt":"【概述】数据是从链路层到应用层一层一层装配起来的，因此，对于捕获到的数据包，需要一层一层的进行解析。同时，由于每一层可能有多种协议要工作，因此在解析数据包时，要根据不同的特征来判断上层协议。 在网络层，有 ARP、IPv4、IPv6 这三种情况，在链路层的 MAC 头结构中，定义了一个 type 字段，用于指示网络层的数据包的类型，根据协议栈的规定，有：","text":"【概述】数据是从链路层到应用层一层一层装配起来的，因此，对于捕获到的数据包，需要一层一层的进行解析。同时，由于每一层可能有多种协议要工作，因此在解析数据包时，要根据不同的特征来判断上层协议。 在网络层，有 ARP、IPv4、IPv6 这三种情况，在链路层的 MAC 头结构中，定义了一个 type 字段，用于指示网络层的数据包的类型，根据协议栈的规定，有： ARP包：type=0x0806 IPv4包：type=0x0800 IPv6包：type=0x86dd 在传输层，当下层数据包是 IPv4 包时，有 ICMPv4、TCP、UDP 三种情况，在网络层的 IPv4 头结构中，定义了一个 proto 字段，用来对应指示传输层的数据包类型，根据协议栈规定，有： ICMPv4包：proto=1 TCP包：proto=6 UDP包：proto=17 而当下层数据包是 IPv6 包时，有 ICMPv6、TCP、UDP 三种情况，在网络层的 IPv6 头结构中，定义了 next_head 字段，用来指示对应传输层的数据包类型，根据协议栈规定，有： ICMPv6包：next_head=0x3a TCP包：next_head=0x06 UDP包：next_head=0x11 在应用层，这里只支持 HTTP 协议，因此只要 TCP 头结构中的源端口 src_port 或目的端口 dest_port 是否为 80 端口即可。 流程结构图如下： 根据流程图，将负责解析的函数写到 analysis.h 头文件中，其中包含以下几个模块： 数据链路层：解析数据帧 网络层：解析ARP包 网络层：解析IPv4包 网络层：解析IPv6包 传输层：解析ICMPv4包 传输层：解析ICMPv6包 传输层：解析TCP包（包含解析HTTP包） 传输层：解析UDP包 【数据链路层】123456789101112131415161718192021222324252627282930//数据链路层：解析数据帧int analyse_data_frame(const u_char *packet, struct data_packet *data, struct packet_count *count)&#123; struct eth_header *ethHeader = (struct eth_header*)packet; data-&gt;ethh = (struct eth_header*)malloc(sizeof(struct eth_header)); if (data-&gt;ethh == NULL) return -1; for (int i = 0; i &lt; 6; i++) &#123; //记录源地址与目的地址 data-&gt;ethh-&gt;src[i] = ethHeader-&gt;src[i]; data-&gt;ethh-&gt;dest[i] = ethHeader-&gt;dest[i]; &#125; count-&gt;num_sum++;//包总数+1 data-&gt;ethh-&gt;type = ntohs(ethHeader-&gt;type);//类型转为网络字节顺序 switch (data-&gt;ethh-&gt;type) &#123;//MAC头大小为14字节，因此之后的每个包大小要+14 case PROTO_ARP://ARP包 return analyse_ARP((u_char*)packet + 14, data, count); break; case PROTO_IP_V4://IPv4包 return analyse_IPv4((u_char*)packet + 14, data, count); break; case PROTO_IP_V6://IPv6包 return analyse_IPv6((u_char*)packet + 14, data, count); break; default://其他包 count-&gt;num_other++; return -1; &#125; return 1;&#125; 【网络层】解析ARP包12345678910111213141516171819202122232425262728//网络层：解析ARP包int analyse_ARP(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct arp_header *arph = (struct arp_header*)packet; data-&gt;arph = (struct arp_header*)malloc(sizeof(struct arp_header)); if (data-&gt;arph == NULL) return -1; for (int i = 0; i &lt; 6; i++)&#123;//复制IP与MAC if (i &lt; 4) &#123; data-&gt;arph-&gt;dest_ip[i] = arph-&gt;dest_ip[i]; data-&gt;arph-&gt;src_ip[i] = arph-&gt;src_ip[i]; &#125; data-&gt;arph-&gt;dest_mac[i] = arph-&gt;dest_mac[i]; data-&gt;arph-&gt;src_mac[i] = arph-&gt;src_mac[i]; &#125; //填充其他信息 data-&gt;arph-&gt;hard_len = arph-&gt;hard_len; data-&gt;arph-&gt;hard_type = ntohs(arph-&gt;hard_type); data-&gt;arph-&gt;oper = ntohs(arph-&gt;oper); data-&gt;arph-&gt;pro_len = arph-&gt;pro_len; data-&gt;arph-&gt;pro_type = ntohs(arph-&gt;pro_type); strcpy(data-&gt;type, \"ARP\"); count-&gt;num_arp++; return 1;&#125; 解析IPv4包12345678910111213141516171819202122232425262728293031323334353637383940//网络层：解析IPv4包int analyse_IPv4(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct ipv4_header *iph = (struct ipv4_header*)packet; data-&gt;ip4h = (struct ipv4_header*)malloc(sizeof(struct ipv4_header)); if (data-&gt;ip4h == NULL) return -1; //填充信息 data-&gt;ip4h-&gt;check = iph-&gt;check; data-&gt;ip4h-&gt;src_addr = iph-&gt;src_addr; data-&gt;ip4h-&gt;dest_addr = iph-&gt;dest_addr; data-&gt;ip4h-&gt;frag_off = iph-&gt;frag_off; data-&gt;ip4h-&gt;id = iph-&gt;id; data-&gt;ip4h-&gt;proto = iph-&gt;proto; data-&gt;ip4h-&gt;total_len = ntohs(iph-&gt;total_len); data-&gt;ip4h-&gt;tos = iph-&gt;tos; data-&gt;ip4h-&gt;ttl = iph-&gt;ttl; data-&gt;ip4h-&gt;ihl = iph-&gt;ihl; data-&gt;ip4h-&gt;version = iph-&gt;version; data-&gt;ip4h-&gt;opt = iph-&gt;opt; count-&gt;num_ip4++;//统计个数 int iplen = iph-&gt;ihl * 4;//ip头长度 switch (iph-&gt;proto) &#123; case V4_PROTO_UDP: return analyse_UDP((u_char*)iph + iplen, data, count); break; case V4_PROTO_TCP: return analyse_TCP((u_char*)iph + iplen, data, count); break; case V4_PROTO_ICMP_V4: return analyse_ICMPv4((u_char*)iph + iplen, data, count); break; default: return-1; &#125; return 1;&#125; 解析IPv6包1234567891011121314151617181920212223242526272829303132333435363738//网络层：解析IPv6包int analyse_IPv6(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct ipv6_header *iph6 = (struct ipv6_header*)packet; data-&gt;ip6h = (struct ipv6_header*)malloc(sizeof(struct ipv6_header)); if (data-&gt;ip6h == NULL) return -1; for (int i = 0; i &lt; 16; i++) &#123;//复制源地址与目的地址 data-&gt;ip6h-&gt;src_addr[i] = iph6-&gt;src_addr[i]; data-&gt;ip6h-&gt;dest_addr[i] = iph6-&gt;dest_addr[i]; &#125; //填充其他信息 data-&gt;ip6h-&gt;version = iph6-&gt;version; data-&gt;ip6h-&gt;flowtype = iph6-&gt;flowtype; data-&gt;ip6h-&gt;flowid = iph6-&gt;flowid; data-&gt;ip6h-&gt;plen = ntohs(iph6-&gt;plen); data-&gt;ip6h-&gt;next_head = iph6-&gt;next_head; data-&gt;ip6h-&gt;hop_limit = iph6-&gt;hop_limit; count-&gt;num_ip6++;//统计个数 switch (iph6-&gt;next_head)&#123;//此时包大小为40字节，因此之后的每个包大小要+40 case V6_PROTO_ICMP_V6: return analyse_ICMPv6 ((u_char*)iph6 + 40, data, count); break; case V6_PROTO_UDP: return analyse_UDP((u_char*)iph6 + 40, data, count); break; case V6_PROTO_TCP: return analyse_TCP((u_char*)iph6 + 40, data, count); break; default: return-1; &#125; return 1;&#125; 【传输层】解析ICMPv4包123456789101112131415161718//传输层：解析ICMPv4包int analyse_ICMPv4(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct icmpv4_header* icmph = (struct icmpv4_header*)packet; data-&gt;icmp4h = (struct icmpv4_header*)malloc(sizeof(struct icmpv4_header)); if (data-&gt;icmp4h == NULL) return -1; //填充信息 data-&gt;icmp4h-&gt;check = icmph-&gt;check; data-&gt;icmp4h-&gt;code = icmph-&gt;code; data-&gt;icmp4h-&gt;seq = icmph-&gt;seq; data-&gt;icmp4h-&gt;type = icmph-&gt;type; strcpy(data-&gt;type, \"ICMP\"); count-&gt;num_icmp4++;//统计个数 return 1;&#125; 解析ICMPv6包1234567891011121314151617181920212223//传输层：解析ICMPv6包int analyse_ICMPv6(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct icmpv6_header* icmph6 = (struct icmpv6_header*)packet; data-&gt;icmp6h = (struct icmpv6_header*)malloc(sizeof(struct icmpv6_header)); if (data-&gt;icmp6h == NULL) return -1; //填充链路层地址 for (int i = 0; i &lt; 6; i++) data-&gt;icmp6h-&gt;op_eth_addr[i] = icmph6-&gt;op_eth_addr[i]; //填充其他信息 data-&gt;icmp6h-&gt;check = icmph6-&gt;check; data-&gt;icmp6h-&gt;code = icmph6-&gt;code; data-&gt;icmp6h-&gt;seq = icmph6-&gt;seq; data-&gt;icmp6h-&gt;type = icmph6-&gt;type; data-&gt;icmp6h-&gt;op_len = icmph6-&gt;op_len; data-&gt;icmp6h-&gt;op_type = icmph6-&gt;op_type; strcpy(data-&gt;type, \"ICMPv6\"); count-&gt;num_icmp6++;//统计个数 return 1;&#125; 解析TCP包123456789101112131415161718192021222324252627282930313233343536373839//传输层：解析TCP包int analyse_TCP(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct tcp_header *tcph = (struct tcp_header*)packet; data-&gt;tcph = (struct tcp_header*)malloc(sizeof(struct tcp_header)); if (NULL == data-&gt;tcph) return -1; //填充信息 data-&gt;tcph-&gt;ack_seq = tcph-&gt;ack_seq; data-&gt;tcph-&gt;check = tcph-&gt;check; data-&gt;tcph-&gt;doff = tcph-&gt;doff; data-&gt;tcph-&gt;res1 = tcph-&gt;res1; data-&gt;tcph-&gt;cwr = tcph-&gt;cwr; data-&gt;tcph-&gt;ece = tcph-&gt;ece; data-&gt;tcph-&gt;urg = tcph-&gt;urg; data-&gt;tcph-&gt;ack = tcph-&gt;ack; data-&gt;tcph-&gt;psh = tcph-&gt;psh; data-&gt;tcph-&gt;rst = tcph-&gt;rst; data-&gt;tcph-&gt;syn = tcph-&gt;syn; data-&gt;tcph-&gt;fin = tcph-&gt;fin; data-&gt;tcph-&gt;dest_port = ntohs(tcph-&gt;dest_port); data-&gt;tcph-&gt;src_port = ntohs(tcph-&gt;src_port); data-&gt;tcph-&gt;seq = tcph-&gt;seq; data-&gt;tcph-&gt;urg_ptr = tcph-&gt;urg_ptr; data-&gt;tcph-&gt;window = tcph-&gt;window; data-&gt;tcph-&gt;opt = tcph-&gt;opt; //http解析 if (ntohs(tcph-&gt;dest_port) == 80 || ntohs(tcph-&gt;src_port) == 80) &#123; count-&gt;num_http++; strcpy(data-&gt;type, \"HTTP\"); &#125; else &#123; count-&gt;num_tcp++; strcpy(data-&gt;type, \"TCP\"); &#125; return 1;&#125; 解析UDP包123456789101112131415161718//传输层：解析UDP包int analyse_UDP(const u_char *packet, struct data_packet *data, struct packet_count *count) &#123; struct udp_header* udph = (struct udp_header*)packet; data-&gt;udph = (struct udp_header*)malloc(sizeof(struct udp_header)); if (NULL == data-&gt;udph) return -1; //填充信息 data-&gt;udph-&gt;check = udph-&gt;check; data-&gt;udph-&gt;dport = ntohs(udph-&gt;dport); data-&gt;udph-&gt;len = ntohs(udph-&gt;len); data-&gt;udph-&gt;sport = ntohs(udph-&gt;sport); strcpy(data-&gt;type, \"UDP\"); count-&gt;num_udp++;//统计个数 return 1;&#125;","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——各层网络协议相关数据结构","slug":"04.Sniffer-各层网络协议相关数据结构","date":"2019-12-27T08:58:00.000Z","updated":"2021-08-31T11:48:29.336Z","comments":true,"path":"mfc/482507bc.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/482507bc.html","excerpt":"【基本结构】与网络协议相关的数据结构存放在protocol.h头文件中，该头文件结构如下： 1234567891011121314151617181920212223242526272829303132#ifndef PROTOCOL_H#define PROTOCOL_H#pragma once#include \"pcap.h\"#define PROTO_ARP 0x0806//ARP协议类型#define PROTO_IP_V4 0x0800//IPv4协议类型#define PROTO_IP_V6 0x86dd//IPv6协议类型#define V4_PROTO_ICMP_V4 1//IPv4头结构下的ICMPv4协议类型#define V4_PROTO_TCP 6//IPv4头结构下的TCP协议类型#define V4_PROTO_UDP 17//IPv4头结构下的UDP协议类型#define V6_PROTO_ICMP_V6 0x3a//IPv4头结构下的ICMPv6协议类型#define V6_PROTO_TCP 0x06//IPv4头结构下的TCP协议类型#define V6_PROTO_UDP 0x11//IPv4头结构下的UDP协议类型#define LITTLE_ENDIAN 1234//小端#define BIG_ENDIAN 4321//大端1).MAC头定义2).ARP头定义3).IPv4头定义4).IPv6头定义5).ICMPv4头定义6).ICMPv6头定义7).UDP头定义8).TCP头定义9).包计数定义10).数据包定义#endif","text":"【基本结构】与网络协议相关的数据结构存放在protocol.h头文件中，该头文件结构如下： 1234567891011121314151617181920212223242526272829303132#ifndef PROTOCOL_H#define PROTOCOL_H#pragma once#include \"pcap.h\"#define PROTO_ARP 0x0806//ARP协议类型#define PROTO_IP_V4 0x0800//IPv4协议类型#define PROTO_IP_V6 0x86dd//IPv6协议类型#define V4_PROTO_ICMP_V4 1//IPv4头结构下的ICMPv4协议类型#define V4_PROTO_TCP 6//IPv4头结构下的TCP协议类型#define V4_PROTO_UDP 17//IPv4头结构下的UDP协议类型#define V6_PROTO_ICMP_V6 0x3a//IPv4头结构下的ICMPv6协议类型#define V6_PROTO_TCP 0x06//IPv4头结构下的TCP协议类型#define V6_PROTO_UDP 0x11//IPv4头结构下的UDP协议类型#define LITTLE_ENDIAN 1234//小端#define BIG_ENDIAN 4321//大端1).MAC头定义2).ARP头定义3).IPv4头定义4).IPv6头定义5).ICMPv4头定义6).ICMPv6头定义7).UDP头定义8).TCP头定义9).包计数定义10).数据包定义#endif 【MAC头】123456// MAC头struct eth_header &#123; unsigned char dest[6];//目的地址，6字节 unsigned char src[6];//源地址，6字节 unsigned short type;//类型，两字节&#125;; 【ARP头】123456789101112// ARP头struct arp_header&#123; unsigned short hard_type;//硬件类型，2字节 unsigned short pro_type;//协议类型，2字节 unsigned char hard_len;//硬件地址长度，1字节 unsigned char pro_len;//协议地址长度，1字节 unsigned short oper;//操作码，2字节，1代表请求，2代表回复 unsigned char src_mac[6];//发送方MAC，6字节 unsigned char src_ip[4];//发送方IP，4字节 unsigned char dest_mac[6];//接收方MAC，6字节 unsigned char dest_ip[4];//接收方IP，4字节&#125;; 【IPv4头】1234567891011121314151617181920// IPv4头struct ipv4_header &#123;#if defined(LITTLE_ENDIAN)//小端模式 u_char ihl : 4;//报头长度 u_char version : 4;//版本号#elif defined(BIG_ENDIAN)//大端模式 u_char version : 4;//版本号 u_char ihl : 4;//报头长度#endif u_char tos;//TOS服务类型，1字节 u_short total_len;//包总长，2字节 u_short id;//标识，2字节 u_short frag_off;//片位移 u_char ttl;//生存时间，1字节 u_char proto;//协议，1字节 u_short check;//校验和，2字节 u_int src_addr;//源地址，4字节 u_int dest_addr;//目的地址，4字节 u_int op_pad;//选项等，4字节&#125;; 【IPv6头】1234567891011// IPv6头struct ipv6_header &#123; u_int version : 4,//版本，4位 flowtype : 8,//流类型，8位 flowid : 20;//流标签，20位 u_short plen;//协议长度，2字节 u_char next_head;//下一个头部，1字节 u_char hop_limit;//跳限制，1字节 u_short src_addr[8];//源地址，2字节 u_short dest_addr[8];//目的地址，2字节&#125;; 【ICMPv4头】1234567// ICMPv4头struct icmpv4_header&#123; u_char type;//类型，1字节 u_char code;//代码，1字节 u_char seq;//序列号，1字节 u_char check;//校验和，1字节&#125;; 【ICMPv6头】12345678910// ICMPv6头struct icmpv6_header&#123; u_char type;//类型，1字节 u_char code;//代码，1字节 u_char seq;//序列号，1字节 u_char check;//校验和，1字节 u_char op_type;//选项：类型，1字节 u_char op_len;//选项：长度，1字节 u_char op_eth_addr[6];//选项：链路层地址，1字节&#125;; 【UDP头】1234567// UDP头struct udp_header &#123; u_short sport;//源端口，2字节 u_short dport;//目的端口，2字节 u_short len;//数据报长度，2字节 u_short check;//校验和，2字节&#125;; 【TCP头】12345678910111213141516171819202122232425262728293031323334// TCP头struct tcp_header &#123; u_short src_port;//源端口地址，2字节 u_short dest_port;//目的端口地址，2字节 u_int seq;//序列号，4字节 u_int ack_seq;//确认序列号 ，4字节#if defined(LITTLE_ENDIAN)//小端模式 u_short res1 : 4, doff : 4, fin : 1, syn : 1, rst : 1, psh : 1, ack : 1, urg : 1, ece : 1, cwr : 1;#elif defined(BIG_ENDIAN)//大端模式 u_short doff : 4, res1 : 4, cwr : 1, ece : 1, urg : 1, ack : 1, psh : 1, rst : 1, syn : 1, fin : 1;#endif u_short window;//窗口大小，2字节 u_short check;//校验和，2字节 u_short urg_ptr;//紧急指针，2字节 u_int opt;//选项，4字节&#125;; 【包计数】12345678910111213// 包计数struct packet_count&#123; int num_arp;//ARP int num_ip4;//IPv4 int num_ip6;//IPv6 int num_icmp4;//ICMPv4 int num_icmp6;//ICMPv6 int num_udp;//UDP int num_tcp;//TCP int num_http;//HTTP int num_other;//其他 int num_sum;//总计&#125;; 【数据包】123456789101112131415// 数据包，保存用数据结构struct data_packet &#123; char type[8];//包类型 int time[6];//时间 int len;//长度 struct eth_header *ethh;//MAC头 struct arp_header *arph;//ARP头 struct ipv4_header *ip4h;//IPv4头 struct ipv6_header *ip6h;//IPv6头 struct icmpv4_header *icmp4h;//ICMPv4头 struct icmpv6_header*icmp6h;//ICMPv6头 struct udp_header *udph;//UDP头 struct tcp_header *tcph;//TCP头 void *apph;//应用层包头&#125;;","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"I/O 系统缓冲区的管理","slug":"operating-system/49.IO系统缓冲区的管理","date":"2019-12-27T05:29:37.000Z","updated":"2021-10-29T13:55:45.376Z","comments":true,"path":"notes/operating-system/3f952a3f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/3f952a3f.html","excerpt":"【概述】现代 OS 中，几乎所有的 I/O 设备都在于处理机交换数据时用了缓冲区 缓冲是一个存储区域，其由专门的硬件寄存器组成，但由于硬件的成本较高，一般仅用在速度要求非常高的场合","text":"【概述】现代 OS 中，几乎所有的 I/O 设备都在于处理机交换数据时用了缓冲区 缓冲是一个存储区域，其由专门的硬件寄存器组成，但由于硬件的成本较高，一般仅用在速度要求非常高的场合 在一般情况下，更多的是利用内存作为缓冲区 引入缓冲区的原因有很多，可归结于以下几点： 缓和 CPU 与 I/O 设备间不匹配的矛盾 减少 CPU 的中断频率，放宽 CPU 中断响应时间的限制 解决数据粒度不匹配问题 提高 CPU 与 I/O 设备间的并行性 随着设备速度差距越大，缓冲区容量也就越大，因此使用缓冲区的方式可归结为三类： 单缓冲与多缓冲 循环缓冲 缓冲池 【单缓冲与多缓冲】单缓冲单缓冲的情况下，用户进程每发出一 I/O 请求时，OS 便在主存中为之分配一缓冲区 缓冲区由 CPU 和外设轮流使用，一方处理完后等待对方处理 当字符设备输入时，缓冲区用于暂存用户输入/输出的一行数据；当块设备输入时，缓冲区用于暂存用户输入/输出的一块数据 多缓冲由于缓冲是共享资源，为加快输入和输出速度，提高设备利用率，又引入了双缓冲机制，也称缓冲对换 在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区，此时 OS 可以从第一缓冲中移出数据，并送入用户进程，接着由 CPU 对数据进行计算 【循环缓冲区】当输入输出速度基本匹配时，双缓冲能获得很好的效果，但当输入输出两者速度相差甚远时，双缓冲的效果则不够理想 为进一步协调速度差，可增加缓冲区数量，并将多个缓冲区组织成环形缓冲区的形式 循环缓冲区具有多个大小相同的缓冲区，分为三种类型： 预备装输入数据的空缓冲区 R 装满数据的缓冲区 G 计算进程正在使用的现行工作缓冲区 C 【缓冲池】目前广泛流行的是既可用于输入又可用于输出的公用缓冲池，池中设置了多个可供若干进程共享的缓冲区 缓冲池与缓冲区的主要区别在于：缓冲区仅是一组内存块的链表，缓冲池则是一种用于管理多个缓冲区的管理机制，其包含了一个管理的数据结构和一组操作函数 组成缓冲池管理着多个缓冲区，为管理方便，一般将缓冲池吃中具有相同类型的缓冲区链成队列，因此可形成以下三个队列： 空白缓冲队列 emq：由空缓冲区链成的队列 输入队列 inq：由装满输入数据的缓冲区链成的队列 输出队列 outq：由装满输出数据的缓冲区链成的队列 除上述三个队列外，还应具有以下四类工作缓冲区：用于收容数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收入输出数据的工作缓冲区、用于提取输出数据的工作缓冲区 缓冲池的工作方式缓冲区在缓冲池中有如下四种工作方式： 收容输入：用于完成收容输入数据的工作 提取输入：用于完成提取输入数据的工作 收容输出：用于完成收容输出数据的工作 提出输出：用于完成提取输出数据的工作","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"用户层的 I/O 软件","slug":"operating-system/48.用户层的IO软件","date":"2019-12-26T12:20:43.000Z","updated":"2021-10-29T13:46:54.527Z","comments":true,"path":"notes/operating-system/e0fa1cd5.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/e0fa1cd5.html","excerpt":"【概述】一般而言，大部分的 I/O 软件都放在 OS 内部，但仍有一小部分在用户层中。 主要是分为三部分：","text":"【概述】一般而言，大部分的 I/O 软件都放在 OS 内部，但仍有一小部分在用户层中。 主要是分为三部分： 系统调用：间接调用 OS 中的 I/O 过程 库函数：与用户程序链接在一起 假脱机系统：完全运行于内核之外 【系统调用】为使诸进程能有条不紊的使用 I/O 设备，因此不允许在用户态的应用进程去直接调用运行在核心态的 OS 过程，而应用进程在运行时，又必须取得OS所提供的服务 于是，OS 在用户层中引入了系统调用，应用程序可以通过它，间接调用 OS 中的 I/O 过程，对 I/O 设备进行操作 当应用程序需要咨询某种 I/O 操作时，在应用程序中必须执行相应的系统调用，当 OS 捕获到系统调用命令后，会从用户态转为核心态，执行系统调用。执行完毕后，再返回用户程序 【库函数】在 C 语言以及 UNIX 系统中，系统调用与各系统调用所使用的库函数几乎一一对应 用户通过调用对应的库函数来使用系统调用，这些库函数与调用程序拼接在一起，被嵌入在运行时装入内存的二进制程序中 【假脱机系统】概述假脱机系统（SPOOLing 技术），是指利用程序模拟脱机 I/O 的外围机，来完成设备 I/O 操作，简单来说，就是在引入多道程序后，利用其中一道程序，来模拟脱机输入时的外围控制机的功能 一般进程对独占设备的需求被假脱机模拟到磁盘上，所以实现设备虚拟，多道是前提，还需高速、大容量、可随机存取的外存支持 假脱机系统提高了 I/O 速度，缓和了 CPU 与 I/O 速度不匹配的矛盾，同时将独占设备改造为共享设备，并实现了虚拟设备的功能 组成假脱机系统是对脱机输入/输出系统的模拟，主要由以下四部分组成： 输入井和输出井：在磁盘上开辟两大存储空间，输入井模拟脱机输入的磁盘设备，输出井模拟脱机输出时的磁盘 输入缓冲区和输出缓冲区：为缓解速度矛盾，在内存中开辟两大缓冲空间，输入缓冲区暂存输入设备送来的数据，再送给输入井；输出缓冲区暂存输出井送来的数据，再送输出设备 输入进程和输出进程：用一进程模拟脱机输入时外围设备控制器的功能，把低速输入设备上的数据传送到高速磁盘上；再用另一进程模拟脱机输出时外围设备控制器的功能，把数据从磁盘上传送到低速输出设备上 井管理程序：用于控制作业与磁盘井直接的信息交换。 假脱机系统的使用打印机是最常使用的输出设备之一，其属于独占设备，但利用假脱机技术可以将其改造为多用户共享的打印设备，从而提高设备利用率 用户进程请求打印输出时，假脱机系统同意为它打印输出，但并不真正立即把打印机分配给用户进程，而只为用户做两件事： 由输出进程在输出井中为之请求一个空闲磁盘块区，并将要打印的数据送入其中 输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂在请求打印队列上 这样一来，如果打印机空闲，那么输出进程将从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据，从输出井传送到输出缓冲区，再由打印机进行打印 打印完毕后，输出进程再查看请求打印队列中是否还有等待打印的请求表，如此下去，直至请求打印队列为空,输出进程才将自己阻塞起来，仅当下次再有打印请求时，输出进程才被唤醒","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——WinPcap抓包框架","slug":"03.Sniffer-WinPcap抓包框架","date":"2019-12-26T01:37:00.000Z","updated":"2021-08-31T11:48:12.845Z","comments":true,"path":"mfc/4e7714f4.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/4e7714f4.html","excerpt":"【初始化 WinPcap】编写 Sniffer_initCap() 功能函数，通过调用 pcap_findalldevs() 函数获得网卡接口信息来初始化 WinPcap 123456789// 1.初始化WinPcapint CSnifferDlg::Sniffer_initCap()&#123; devCount = 0; if (pcap_findalldevs(&amp;alldev, errorBufffer) == -1)//获得网卡接口信息 return -1; for (dev = alldev; dev; dev = dev-&gt;next)//记录设备数 devCount++; return 0;&#125;","text":"【初始化 WinPcap】编写 Sniffer_initCap() 功能函数，通过调用 pcap_findalldevs() 函数获得网卡接口信息来初始化 WinPcap 123456789// 1.初始化WinPcapint CSnifferDlg::Sniffer_initCap()&#123; devCount = 0; if (pcap_findalldevs(&amp;alldev, errorBufffer) == -1)//获得网卡接口信息 return -1; for (dev = alldev; dev; dev = dev-&gt;next)//记录设备数 devCount++; return 0;&#125; 【捕获数据包】编写 Sniffer_startCap() 功能函数，用于捕获数据包 该函数框架如下： 1234567891011121314// 捕获数据包int CSnifferDlg::Sniffer_startCap() &#123; 步骤 1：网卡与过滤器设置 步骤 2：获取选中的网卡接口 步骤 3：打开网卡指定接口 步骤 4：检查是否为非以太网 步骤 5：设置子网掩码 步骤 6：编译过滤器 步骤 7：设置过滤器 步骤 8：设置时间 步骤 9：设置数据包存储路径 步骤 10：创建数据包接收线程 return 1;&#125; 网卡与过滤器设置通过控件的 GetCurSel() 函数获取下拉框的选项来进行网卡与过滤器设置 1234567891011//步骤 1：网卡与过滤器设置int netCardIndex = this-&gt;m_comboBoxNetCard.GetCurSel();//网卡接口索引int filterIndex = this-&gt;m_comboBoxFilterRule.GetCurSel();//过滤器索引if (netCardIndex == 0 || netCardIndex == CB_ERR) &#123; MessageBox(\"请选择网卡接口\"); return -1;&#125;if (filterIndex == CB_ERR) &#123; MessageBox(\"过滤器选择错误\"); return -1;&#125; 获取选中的网卡接口1234//步骤 2：获取选中的网卡接口dev = allDevs;for (int i = 0; i &lt; filterIndex - 1; i++) dev = dev-&gt;next; 打开网卡指定接口利用 pcap_open_liive() 函数打开指定网卡接口，若无法打开则释放设备列表 123456789101112//步骤 3：打开网卡指定接口int dataPackageLen = 65536;//捕获数据包长度int overtime = 1000;//读超时时间int flag = 1;//网卡混淆模式设置标志，非0即为混淆模式//针对指定网络接口创建一捕获句柄，用于后续捕获数据devHandle = pcap_open_live(dev-&gt;name, dataPackageLen, flag, overtime, errorBufffer); if (devHandle == NULL) &#123; MessageBox(\"无法打开接口：\" + CString(dev-&gt;description)); pcap_freealldevs(allDevs);//释放设备列表 return -1;&#125; 检查是否为非以太网利用 pcap_datalink() 方法检查是否为以太网，若为非以太网则释放设备列表 123456//步骤 4：检查是否为非以太网if (pcap_datalink(devHandle) != DLT_EN10MB) &#123; MessageBox(\"不适合非以太网的网络\"); pcap_freealldevs(allDevs);//释放设备列表 return -1;&#125; 设置子网掩码123456//步骤 5：设置子网掩码u_int netmask;//子网掩码if (dev-&gt;addresses != NULL) netmask = ((struct sockaddr_in *)(dev-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;else netmask = 0xffffff; 编译过滤器利用 pcap_compile() 方法设置过滤器，若无法设置则释放设备列表 12345678910111213141516171819202122//步骤 6：编译过滤器struct bpf_program fcode;//BPF过滤代码结构if (filterIndex == 0) &#123; char filter[] = \"\"; if (pcap_compile(devHandle, &amp;fcode, filter, 1, netmask) &lt; 0) &#123; MessageBox(\"语法错误，无法编译过滤器\"); pcap_freealldevs(allDevs);//释放设备列表 return -1; &#125;&#125;else &#123; CString str; this-&gt;m_comboBoxFilterRule.GetLBText(filterIndex, str); int len = str.GetLength() + 1; char *filter = (char*)malloc(len); for (int i = 0; i &lt; len; i++) filter[i] = str.GetAt(i); if (pcap_compile(devHandle, &amp;fcode, filter, 1, netmask) &lt; 0) &#123; MessageBox(\"语法错误，无法编译过滤器\"); pcap_freealldevs(allDevs);//释放设备列表 return -1; &#125;&#125; 设置过滤器利用 pcap_setfilter() 方法来设置过滤器，若无法设置则释放设备列表 123456//步骤 7：设置过滤器if (pcap_setfilter(devHandle, &amp;fcode) &lt; 0) &#123; MessageBox(\"设置过滤器错误\"); pcap_freealldevs(allDevs);//释放设备列表 return -1;&#125; 设置时间利用 struct tm 与 time_t 类型，获取当前时间，同时利用 strftime() 函数来格式化本地时间 1234567//步骤 8：设置时间struct tm *localTime;//年月日结构的时间time_t secondTime;//自1970至今多少秒的时间time(&amp;secondTime);localTime = localtime(&amp;secondTime);char realTime[30];//当前时间strftime(realTime, sizeof(realTime), \"%Y%m%d %H%M%S\", localTime);//格式化本地时间 设置数据包存储路径利用 pcap_dump_open() 函数创建一个临时文件，捕获的数据会暂时存放在该临时文件中，在捕获结束后，可选择将此文件存储于指定路径 123456789101112131415//步骤 9：设置数据包存储路径CFileFind file;if (!file.FindFile(\"Data\")) CreateDirectory(\"Data\", NULL);memset(filePath, 0, sizeof(filePath));memset(fileName, 0, sizeof(fileName));strcpy(filePath, \"Data\\\\\");strcat(fileName, realTime);strcat(fileName, \".lix\");strcat(filePath, fileName);dumpFile = pcap_dump_open(catchHandle, filePath);if (dumpFile == NULL)&#123; MessageBox(\"文件创建错误！\"); return -1;&#125; 创建数据包接收线程用 CreateThread() 函数创建接收数据包的线程 123456789//步骤 10：创建数据包接收线程LPDWORD threadCap = NULL;m_ThreadHandle = CreateThread(NULL, 0, Sniffer_capThread, this, 0, threadCap);if (m_ThreadHandle == NULL) &#123; CString str; str.Format(\"创建线程错误，代码为：%d.\", GetLastError()); MessageBox(str); return -1;&#125;","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"与设备无关的 I/O 软件","slug":"operating-system/47.与设备无关的IO软件","date":"2019-12-25T10:04:42.000Z","updated":"2021-10-29T13:35:58.055Z","comments":true,"path":"notes/operating-system/b196f10a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/b196f10a.html","excerpt":"【设备独立性】设备独立性，是指应用程序中所使用的设备不局限于使用某个具体的物理设备。 为了实现设备独立性，在设备驱动程序之上设置一层软件，称为与设备无关的 I/O 软件，或设备独立性软件","text":"【设备独立性】设备独立性，是指应用程序中所使用的设备不局限于使用某个具体的物理设备。 为了实现设备独立性，在设备驱动程序之上设置一层软件，称为与设备无关的 I/O 软件，或设备独立性软件 设备无关软件是 I/O 系统最高层软件，但它和其下的设备驱动程序之间的界限，将随操作系统和设备的不同而有所差异 早期的设备无关软件以物理设备名使用设备，后来引入了逻辑设备名，为实现从逻辑设备名到物理设备名的转换，为每个用户设置了一张逻辑设备表 LUT 逻辑设备表每个表目包含三项：逻辑设备名、物理设备名、设备驱动程序入口地址。在设置逻辑设备表时，有两种方式，一种是为整个系统设置一张 LUT，但会造成同名问题，另一种是为每个用户设置一张 LUT，并记入各自的 PCB 中 【设备分配】在系统中，有两类设备：独占设备、共享设备，为避免诸进程对某独占设备的争夺，须有系统来统一分配，不允许进程自行使用 数据结构为实现独占设备的分配，须在系统中设置相应的数据结构，在数据结构中，记录了对设备或控制器进行控制的所需信息，目前常用的数据结构有： 设备控制表 DCT：每一设备都配备了该表，用于记录设备的情况 控制器控制表 COCT：每一控制器都配备了该表，用于记录控制器情况 通道控制表 CHCT：每一通道都配备了该表，用于记录通道情况 系统设备表 SDT：系统范围的数据结构，记录了系统中全部设备的情况，每个设备独占一个表目 设备分配时考虑因素系统在分配设备时，应考虑：设备固有属性、设备分配算法、设备分配安全性这三个方面 对于设备固有属性来说，其可分为三种，应采取不同的分配策略： 独占设备：将一个设备分配给某进程后，便有该进程独占，直至进程完成或释放该设备 共享设备：可同时分配给多个进程使用，使用时须注意对这些进程访问该设备的先后次序，从而进行合理调度 虚拟设备：属于可共享设备，可以同时分配给多个设备使用 对于设备分配算法，通常采用以下两种算法： 先来先服务：根据诸进程对某设备提出请求的先后次序，排成设备请求队列，总是将设备分配给队首进程 优先级高者优先：在形成设备队列时，按照优先级排序，优先级高者在队首 从设备运行的安全性考虑，设备分配有以下两种方式： 安全分配方式：进程发出 I/O 请求后，进入阻塞状态，直到其 I/O 操作完成时才被唤醒 不安全分配方式：进程发出 I/O 请求后，仍继续运行，需要时再发出下一个 I/O 请求，仅当进程请求设备被另一进程占用时，才进入阻塞状态 独占设备的分配过程对于独占设备来说，当某进程提出 I/O 请求后，其分配过程如下： 分配设备：根据请求设备名，查找 SDT，找到 DCT，进程状态、安全性等因素都可能导致本申请进程阻塞，若阻塞，就挂入 DCT 等待队列中 分配控制器：通过分配设备后，从 DCT 找到 COCT，检查 COCT 状态字，若忙碌，则将进程挂到其等待队列 分配通道：通过分配控制器后，从 COCT 找到 CHCT，检查其状态，若忙碌，则将进程挂到其等待队列 可以看出，系统根据进程对设备的请求进行设备分配的过程是： 设备名->SDT->DCT->COCT->CHCT仅有在设备、控制器、通道三者都分配成功时，设备分配才算成功","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——GUI设计","slug":"02.Sniffer-GUI设计","date":"2019-12-25T03:19:00.000Z","updated":"2021-08-31T11:47:45.988Z","comments":true,"path":"mfc/448dc1ea.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/448dc1ea.html","excerpt":"【GUI 设计】下拉框添加两个下拉框，一个用于选择网卡，一个用于选择过滤规则，同时在属性页将 Type 设为下拉列表（DropList)","text":"【GUI 设计】下拉框添加两个下拉框，一个用于选择网卡，一个用于选择过滤规则，同时在属性页将 Type 设为下拉列表（DropList) 开始与结束按钮添加两个按钮（Button），用于开始和结束 列表控件添加列表（List Control），用于显示接收到的包的信息，同时在属性页将 view 设为 Report，Sort 与 Single Selection 设为 True 树形控件添加树形控件（Tree Control），用于显示每一个包的具体字段信息，同时在属性页将 Full Row Select、Has Buttons、Info Tip、Lines At Root 均设为 True 文本框添加文本框（Edit Control），用于显示数据包的二进制信息，同时在属性页将 Multiline、Read only、Auto V Scroll、Horizon Scroll、Vertical Scroll 均设置为 True 组合框添加若干文本框（Edit Control）和静态框（Static Text），用于显示统计数据，最后再加一个组合框（Group Box），方便使用框内的控件 保存读取按钮添加两个按钮（Button），用于保存和读取捕获的数据包信息 【控件变量】在类向导中，为下拉框、列表、树形框、编辑框等添加控件 添加完后，可在SnifferDlg.h中可看到添加的控件变量，在SnifferDlg.cpp中可看到相应的资源关联 控件变量： 资源关联： 【列表控件设计】列表控件设计：在 SnifferDlg.cpp 的 OnInitDialog() 方法中对列表控件进行初始化设置 12345678910//列表表项初始化设置m_listCtrl.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);m_listCtrl.InsertColumn(0, \"编号\", 2, 130);//1右对齐，2居中，3左对齐m_listCtrl.InsertColumn(1, \"时间\", 2, 150);m_listCtrl.InsertColumn(2, \"长度\", 2, 130);m_listCtrl.InsertColumn(3, \"源MAC地址\", 2, 150);m_listCtrl.InsertColumn(4, \"目的MAC地址\", 2, 150);m_listCtrl.InsertColumn(5, \"协议\", 2, 130);m_listCtrl.InsertColumn(6, \"源IP地址\", 2, 150);m_listCtrl.InsertColumn(7, \"目的IP地址\", 2, 150); 【下拉框设计】在 SnifferDlg.cpp 的 OnInitDialog() 方法中对下拉框控件进行初始化设置 123456789101112131415//下拉框初始化设置m_comboBoxNetCard.AddString(\"请选择网卡接口\");//网卡默认选项m_comboBoxFilterRule.AddString(\"请选择过滤规则\");//过滤规则默认选项if (Sniffer_initCap() &lt; 0) //初始化WinPcap return FALSE;for (dev = allDevs; dev; dev = dev-&gt;next) //将可用网卡添加进网卡候选栏 if (dev-&gt;description) m_comboBoxNetCard.AddString(dev-&gt;description);m_comboBoxFilterRule.AddString(\"TCP\");//将TCP添加进过滤规则候选栏m_comboBoxFilterRule.AddString(\"UDP\");//将UDP添加进过滤规则候选栏m_comboBoxFilterRule.AddString(\"IP\");//将IP添加进过滤规则候选栏m_comboBoxFilterRule.AddString(\"ICMP\");//将ICMP添加进过滤规则候选栏m_comboBoxFilterRule.AddString(\"ARP\");//将ARP添加进过滤规则候选栏m_comboBoxNetCard.SetCurSel(0);//显示默认选项m_comboBoxFilterRule.SetCurSel(0);//显示默认选项 至此，GUI设计完成，点击本地调试，即可得到一个初始化完成后的 GUI","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"设备驱动程序","slug":"operating-system/46.设备驱动程序","date":"2019-12-24T09:04:32.000Z","updated":"2021-10-29T13:33:26.474Z","comments":true,"path":"notes/operating-system/9176b986.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/9176b986.html","excerpt":"【概述】设备驱动程序是 I/O 系统的高层与设备控制器之间的通信程序，其主要任务是将上层软件发来的抽象 I/O 要求转化为具体要求，发送给设备控制器，启动设备去执行。同时，它也将由设备控制器发来的信号，传送给上层软件 为实现 I/O 系统高层与设备控制器间的通信，设备驱动程序应具有以下功能：","text":"【概述】设备驱动程序是 I/O 系统的高层与设备控制器之间的通信程序，其主要任务是将上层软件发来的抽象 I/O 要求转化为具体要求，发送给设备控制器，启动设备去执行。同时，它也将由设备控制器发来的信号，传送给上层软件 为实现 I/O 系统高层与设备控制器间的通信，设备驱动程序应具有以下功能： 接收由与上层设备无关的软件发来的命令和参数，并将命令中的抽象要求，转换为与设备相关的低层操作序列 检查用户 I/O 请求的合法性，了解 I/O 设备的工作状态，传递与 I/O 设备操作有关的参数，设置设备的工作方式 发出 I/O 命令，如果设备空闲，便立即启动 I/O 设备，完成指定的 I/O 操作；如果设备忙碌，则将请求者挂在设备队列上等待 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理 【设备驱动程序特点】设备驱动程序属于低级系统例程，其与一般的应用程序及系统程序不同，其特点如下： 位置：驱动程序是与设备无关的软件和设备控制器之间通信和转换的程序 硬件特性：驱动程序与设备控制器和 I/O 设备的硬件特性，紧密相关 控制方式：驱动程序与I/O设备所采用的I/O控制方式紧密相关 语言：由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言编写 重入：驱动程序应允许可重入，一个正在运行的驱动程序常会在一次调用完成前被再次调用 【设备处理方式】在不同的操作系统中，所采用的的设备处理方式并不完全相同，设备处理方式可分为以下三类： 为每一类设备设置一个进程，专门用于执行这类设备的 I/O 操作 在整个系统中设置一个 I/O 管理进程专门用于执行系统中所有各类设备的 I/O 操作 不设置专门的设备处理进程，只为各类设备设置相应的设备驱动程序，供用户或系统进程调用 【设备驱动程序处理过程】设备驱动程序的主要任务是启动指定设备，完成上层指定的 I/O 工作，但在启动前，应先完成必要的准备工作。在完成所有的准备工作后，才向设备控制器发送一条启动命令 设备驱动程序的处理过程如下： 将抽象要求转换为具体要求 对服务请求进行校验 检查设备状态 传送必要参数 启动 I/O 设备 【对 I/O 设备的控制方式】轮询的可编程 I/O 方式轮询的可编程 I/O 方式，又称忙-等待方式或程序 I/O 方式，其处理过程如下： 处理机向控制器发送一条 I/O 指令，启动输入设备输入数据，同时将状态寄存器置 busy=1 不断循环测试 busy 标志 busy=1 时，表示输入机尚未输完一个字，CPU 继续对该标志测试 busy=0 时，表示数据已输入控制器数据寄存器中 将 CPU 存取控制器中的数据送入内存单元，完成一个字的 I/O 在程序 I/O 方式中，CPU 的绝大部分时间都处于等待 I/O 设备完成数据 I/O 的循环测试中，造成了对 CPU 的极大浪费，这是因为在 CPU 中无中断机构，使 I/O 设备无法向 CPU 报告其已完成了一个字符的输入 使用中断的可编程 I/O 方式该方式利用设备控制器来完成对 I/O 设备的控制，其过程如下： CPU 向相应的设备控制器发送一条 I/O 命令 立即返回继续执行原来的任务 设备控制器按照命令控制指定 I/O 设备，此时 CPU 与 I/O 设备并行运行 在 I/O 设备输入每个数据的过程中，可使 CPU 与 I/O 设备并行工作，仅当输完一个数据时，才需要 CPU 花费极短的时间去做中断处理 这样使得 CPU 和 I/O 都处于忙碌状态，从而提高了整个系统的资源利用率与吞吐量 直接存储器访问方式该方式借助 DMA 控制器完成对 I/O 设备的控制，因此又称为 DMA 方式 该方式的数据传输基本单位是数据块，所传送的数据从设备直接送入内存，或直接从内存进设备，整块数据的传送是在 DMA 控制器的控制下完成的，不需要 CPU 操作，即 CPU 干预进一步减少，仅在传送一个或多个数据块的开始和结束时，才需 CPU 干预 DMA 控制器由三部分组成：主机与 DMA 控制器的接口、DMA 控制器与块设备的接口、I/O 控制逻辑 为实现主机与控制器之间块数据的直接交换，必须设置如下四类寄存器： 数据寄存器 DR：暂存设备到内存或从内存到设备的数据 内存地址寄存器 MAR：存放把数据从设备传送到内存的起始的目标地址或内存原地址 数据计数器 DC：存放本次 CPU 要读或写的字数 命令/状态寄存器 CR：用于接收从 CPU 发来的 I/O 命令或有关控制和状态信息 DMA 方式的工作过程如下： CPU 向磁盘控制器发送一条读命令，同时发送数据读入到内存的起始地址 命令被送到命令寄存器 CR 中，地址被送入内存地址寄存器 MAR 中，要读数据的字数则送入数据计数器 DC 中 将磁盘中的数据原地址直接送入 DMA 控制器的 I/O 控制逻辑上，按设备状态启动磁头到相应位置 启动 DMA 控制器控制逻辑开始进行数据传送： DMA 控制器读入一个数据到数据寄存器 DR 中，然后传到内存 MAR 地址中 接着 MAR+1，DC-1 判断 DC 状态 若 DC=0，控制器发送中断请求，传送完毕 若 DC=1，继续传送 I/O 通道控制方式DMA适用于读一个连续的数据块，若一次读多个数据块到内存的不同区域，那么须由 CPU 分别发送多条 I/O 指令、进行多次 DMA 中断处理 为进一步减少 CPU 的干预，引入了通道方式，CPU 只需发一条 I/O 指令，给出通道程序的首地址及要访问设备即可，这使得 CPU、通道和 I/O 设备三者并行操作，提高整个系统的资源利用率 通道，是一种通过执行通道程序管理 I/O 操作的控制器，它使 CPU、内存与 I/O 操作之间达到更高的并行程度，由于它的任务是管理实现 I/O 操作，提供了一种传送通道，所以将这种部件称作通道 通道，通过执行通道程序，与设备控制器共同实现对 I/O 设备的控制，简单来说，CPU 指令经过设备驱动程序解读后，送往通道程序，通过通道程序的执行来完成通道操作，通道程序由一系列通道指令构成 通道指令一般包含下述信息： 操作码：规定指令所执行的操作 内存地址：标明字符送入内存、从内存取出时的内存首址 计数：表示本指令所要操作的字节数 通道程序结束位 P：表示程序是否结束，P=1 表示本条指令是通道程序的最后一条指令 记录结束标志 R：表示该指令是否与下条指令有关，R=0 表示本通道指令与下一条指令同属一记录；R=1 表示是处理某记录的最后一条指令","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"Sniffer——概述","slug":"01.Sniffer-概述","date":"2019-12-24T07:56:00.000Z","updated":"2021-08-31T11:47:35.500Z","comments":true,"path":"mfc/9303bce6.html","link":"","permalink":"https://alex-mcavoy.github.io/mfc/9303bce6.html","excerpt":"【说明】本项目是一个代码复现项目，旨在学习如何利用 WinPcap 和 MFC 编写 Sniffer 参考文档：https://blog.csdn.net/litingli/article/details/5950962","text":"【说明】本项目是一个代码复现项目，旨在学习如何利用 WinPcap 和 MFC 编写 Sniffer 参考文档：https://blog.csdn.net/litingli/article/details/5950962 GitHub：https://github.com/Alex-McAvoy/Sniffer-based-on-WinPcap-and-MFC 程序运行图： 【概述】Sniffer（嗅探器），是一种利用以太网特性将网络适配卡置为混杂模式状态的工具，一旦将网卡设置为混杂模式，其就能接收传输在网络上的每一个信息包，因此利用 Sniffer 可以监听网络状态、获取数据流动情况、得到网络上传输的信息等 本项目将复现一个基于 WinPcap 与 MFC 结合的软件的 Sniffer，实现的功能包括： 列出监测主机的所有网卡，选择一个网卡，在混杂模式下进行监听； 捕获所有流经网卡的数据包，并利用WinPcap函数库设置过滤规则； 分析捕获到的数据包的包头和数据，按照各种协议的格式进行格式化显示；支持协议：TCP、UDP、ARP、ICMP、HTTP、IPv4、IPv6 可以本地文件的形式来保存、读取已捕获的数据包信息 所需工具： Microsoft Visual Studio 2017 WinPcap V4.1.2 Windows Packet Capture，WinPcap 是 Windows 平台下的数据链路层的网络访问工具，其目的在于为 Windows 应用程序提供访问网络底层的能力，其只能将数据包从网络中抓取过来，并不能修改数据 要使用 WinPcap，要安装其 dll 文件，此外还要下载相关的开发者工具包，包含库文件、头文件、简单示例程序与帮助文件 WinPcap V4.1.2 dll：http://www.winpcap.org/install/bin/WinPcap_4_1_2.exe WinPcap V4.1.2 Developer’s Pack：http://www.winpcap.org/install/bin/WpdPack_4_1_2.zip 【环境配置】将 WinPcap 的开发者工具包解压后，放到合适位置，然后打开 VS2017，新建一个MFC项目 在新建项目的项目-&gt;属性-&gt;VC++目录中，配置包含目录，即将 WinPcap 开发包中的 Include 目录添加进去： 配置完包含目录后，再配置库目录，即将 WinPcap 开发包的 Lib 目录添加进去 然后设置与 WinPcap 有关的预处理定义：在项目-&gt;项目属性-&gt;配置属性-&gt;C/C++-&gt;预处理器页面的预处理器定义中，添加 WPCAP 与 HAVE_REMOTE 最后添加 wpcap.lib 库文件：在项目-&gt;项目属性-&gt;配置属性-&gt;链接器-&gt;命令行页面中的其他选项，添加 wpcap.lib 【步骤】 GUI 设计：点击这里 WinPcap 抓包框架：点击这里 各层网络协议相关数据结构：点击这里 数据包解析函数：点击这里 数据包接收线程：点击这里 GUI 数据更新函数：点击这里 消息处理函数：点击这里","categories":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/categories/mfc/"}],"tags":[{"name":"MFC","slug":"mfc","permalink":"https://alex-mcavoy.github.io/tags/mfc/"},{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"}],"author":"Alex_McAvoy"},{"title":"中断机构与中断处理程序","slug":"operating-system/45.中断机构与中断处理程序","date":"2019-12-23T15:53:17.000Z","updated":"2021-10-29T13:33:21.433Z","comments":true,"path":"notes/operating-system/c1aadd85.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/c1aadd85.html","excerpt":"【中断】概述中断是 I/O 系统最低层，也是设备管理的基础，其在 OS 中有特殊而重要的地位，没有它就不可能实现多道程序","text":"【中断】概述中断是 I/O 系统最低层，也是设备管理的基础，其在 OS 中有特殊而重要的地位，没有它就不可能实现多道程序 中断，是指 CPU 对 I/O 设备发来的中断信号的一种响应，是由外部设备引起的，因此又称外中断 陷入，是指 CPU 内部事件所引起的中断，因此又称内中断 为处理上的方便，通常为每种设备配以相应的中断处理程序，并将该程序的入口地址放在中断向量表的一个表项中，同时为每一个设备的中断请求，规定一个中断号，它直接对应于中断向量表的一个表项中 但实际上，经常会有多个中断信号源，每个中断源对服务要求的紧急程度不同，因此，系统就服务要求的紧急程度为他们规定不同的中断优先级 多中断源的处理对于多中断信号源来说，当处理机正在处理一个中断时，又来了一个新的中断请求，这时有两种处理方式： 屏蔽中断：将所有的中断都按顺序依次处理，当处理机正在处理一个中断时，屏蔽掉所有新到的中断，让它们等待，直到处理机已完成本次中断的处理后，处理机再去检查并处理 嵌套中断：当同时有多个不同优先级的中断请求时，CPU 优先响应最高优先级的中断请求，高优先级的中断请求，可以抢占正在运行低优先级中断的处理机，该方式类似于基于优先级的抢占式进程调度 【中断处理程序】当一个进程请求 I/O 操作时，该进程会被挂起，直到 I/O 设备完成 I/O 操作后，设备控制器便向 CPU 发送一个中断请求，CPU 响应后便转向中断处理程序进行相应处理，处理完后解除相应进程的阻塞状态 因此，中断处理程序的主要工作有：进行进程上下文的切换、对处理中断信号源进行测试、读取设备状态、修改进程状态 其处理流程可分为以下五个步骤： 测定是否有未响应的中断信号 保护被中断进程的 CPU 现场 转入相应的设备处理程序 中断处理 恢复 CPU 现场","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"I/O 设备与设备控制器","slug":"operating-system/44.IO设备与设备控制器","date":"2019-12-23T13:25:00.000Z","updated":"2021-10-29T13:27:08.009Z","comments":true,"path":"notes/operating-system/f1639676.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/f1639676.html","excerpt":"【I/O 设备类型】I/O 设备的类型繁多，常见的分类角度有按使用特性分类、按传输速率分类两种 按使用特性分类：","text":"【I/O 设备类型】I/O 设备的类型繁多，常见的分类角度有按使用特性分类、按传输速率分类两种 按使用特性分类： 传输速率：低速、中速、高速 使用：存储设备、输入输出设备 信息交换的单位： 块设备：有结构、速率高、可寻址、DMA方式控制 字符设备：无结构、速率低、不可寻址、中断方式控制 按设备共享属性分类： 独占：一个时刻只能被一个进程占用，如打印机 共享：一个时刻上仍然是只被一个进程占用，但可寻址、随机访问，如磁盘。 虚拟：使一台独占设备变换为若干台逻辑设备，供给若干用户“同时使用” 【设备控制器】设备与控制器间的接口通常，设备并不是直接与 CPU 通信，而是与设备控制器通信，因此在 I/O 设备中应含有与设备控制器间的接口，其有三种类型： 数据信号线：设备与设备控制器间传送数据信号 控制信号线：由设备控制器向 I/O 设备发送控制信号时的通路 状态信号线：传送指示设备当前状态的信号 设备控制器基本功能设备控制器的主要功能是控制一个或多个 I/O 设备，以实现 I/O 设备和计算机间的数据交换 其是 CPU 与 I/O 设备间的接口，接收从 CPU 发来的命令，去控制 I/O 设备工作，使处理机能够从繁忙的设备控制事务中脱离出来 此外，其还具有接收和识别 CPU 命令、标识和报告设备的状态、数据交换、地址识别、数据缓冲、差错控制等功能 组成设备控制器位于 CPU 与设备间，既要与 CPU 通信，又要与设备通信，还应具有按照 CPU 所发来的命令去控制设备工作的功能，因此，现有的大多数控制器都是由以下三部分组成： 设备控制器与处理机的接口 设备控制器与设备的接口 I/O逻辑 【I/O 通道】概述设备控制器已大大减少 CPU 对 I/O 的干预，但当主机的外设很多时，CPU 的负担仍然很重 为此，可在CPU和设备控制器之间增设一个硬件机构：通道，其主要目的是建立更独立的 I/O 操作，以此来解放CPU 设置通道后，CPU 只需向通道发送一条 I/O 指令即可不再干预后续操作，通道形成通道程序，执行 I/O 操作，完成后向 CPU 发中断信号 实际上 I/O 通道是一种特殊的处理机，其指令类型单一，只用于I/O操作，且没有内存，与 CPU 共享内存 通道类型根据其控制的外围设备的不同类型，信息交换方式也可分为以下三种类型： 字节多路通道：按字节交叉方式工作的通道，不适用连接高速设备 数组选择通道：按数组方式进行数据传送的通道，每次只允许连接一个设备传输数据 数组多路通道：在数组选择通道的基础上进行了改进，允许连接多个设备 瓶颈问题由于通道价格昂贵，致使数量较少，使它成为 I/O 系统的瓶颈，进而造成系统吞吐量的下降，即瓶颈问题 而解决瓶颈问题有效办法就是增加设备到主机间的通路而不增加通道","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"I/O 系统","slug":"operating-system/43.IO系统","date":"2019-12-23T03:31:00.000Z","updated":"2021-10-29T13:00:54.879Z","comments":true,"path":"notes/operating-system/be144f55.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/be144f55.html","excerpt":"【I/O 系统组成】I/O 系统是 OS 的重要组成部分，用于管理 I/O 设备、存储数据等，其是 OS 中最繁杂、与硬件联系最密切的部分 I/O 系统的基本由以下几部分组成：","text":"【I/O 系统组成】I/O 系统是 OS 的重要组成部分，用于管理 I/O 设备、存储数据等，其是 OS 中最繁杂、与硬件联系最密切的部分 I/O 系统的基本由以下几部分组成： 需要用于输入、输出和存储信息的设备 需要相应的设备控制器 控制器与CPU连接的高速总线 有的大中型计算机系统，配置I/O通道 为满足系统与用户的功能，I/O 系统应具备以下功能： 隐藏物理设备细节 实现设备无关性 提高处理机和设备的并行性与利用率 对I/O设备进行控制 确保对设备正确共享 错误处理 【I/O 系统的层次结构】层次结构，是指系统中的设备管理模块分为若干层次 在 I/O 系统中，下层为上层提供服务，完成输入输出功能中的某些子功能，并屏蔽功能实现的细节 I/O 软件的层次通常来说，I/O 软件分为以下四个层次： 用户层软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与 I/O 操作有关的库函数对设备进行操作 设备独立软件：用于实现用户程序与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间 设备驱动程序：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序 中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后再恢复被中断进程的现场后，返回到被中断进程 I/O 系统的分层与上述的 I/O 软件组织的层次结构相对应，I/O 系统本身也可分为下面三个层次： 中断处理程序：处于I/O系统的底层，直接与硬件进行交互 设备驱动程序：处于次底层，是进程和控制器之间的通信程序，其将上层发来的抽象I/O请求，转换为对I/O设备的具体命令和参数，并把它装入到设备控制其中的命令和参数寄存器中 设备独立性软件：包括设备命名、设备分配、数据缓冲等软件 【I/O 系统接口】在 I/O 系统与高层接口中，根据设备类型的不同，又进一步分为若干个接口： 块设备接口：对于块设备来说，数据的存取和传输是以数据块为单位的，而块设备接口是块设备管理程序与高层间的接口，其反映了大部分磁盘存储器和光盘存储器的本质特征，用于控制块设备的输入和输出 流设备接口：对于流设备来说，数据的存取和传输是以字符为单位的，而流设备接口是流设备管理程序与高层间的接口，反映了大部分字符设备的本质特征，用于控制字符设备的输入和输出 网络通信接口：OS 提供相应的网络软件和网络通信接口，使得计算机能通过网络与其他计算机通信","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"Crush","slug":"ego/03.Crush","date":"2019-12-21T18:17:00.000Z","updated":"2021-07-13T04:18:31.329Z","comments":true,"path":"essay/ego/d06d477.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/ego/d06d477.html","excerpt":"我开始意识到，终究还是完美般地预言了命运的悲剧。 于是，便于清醒中看到了一切痛苦的根源，但最终还是选择了义无反顾地冲进了那幻觉中，燃烧着自己的生命。 我们终其一生都在逃离这个吞噬我们的黑洞，但当机会摆在眼前时，为什么又会选择留下呢？","text":"我开始意识到，终究还是完美般地预言了命运的悲剧。 于是，便于清醒中看到了一切痛苦的根源，但最终还是选择了义无反顾地冲进了那幻觉中，燃烧着自己的生命。 我们终其一生都在逃离这个吞噬我们的黑洞，但当机会摆在眼前时，为什么又会选择留下呢？ 大概，是因为那幻觉太美了吧。 那一天终究会到来，但不应该是现在，也不能是现在。 可惜的是，一切不可证伪的东西，都在理性框架所能解决的范围内。 晚安","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Ego","slug":"essay/ego","permalink":"https://alex-mcavoy.github.io/categories/essay/ego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Ego","slug":"ego","permalink":"https://alex-mcavoy.github.io/tags/ego/"}],"author":"Alex_McAvoy"},{"title":"磁盘存储器的性能与调度","slug":"operating-system/42.磁盘存储器的性能与调度","date":"2019-12-20T13:37:00.000Z","updated":"2021-10-29T11:42:01.979Z","comments":true,"path":"notes/operating-system/8992aabf.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/8992aabf.html","excerpt":"【磁盘存储器】磁盘存储器是计算机系统中最重要的存储设备，其中存放了大量的文件 对文件的读写操作都涉及到对磁盘的访问，磁盘 I/O 速度高低和磁盘系统可靠性，直接影响到系统的性能","text":"【磁盘存储器】磁盘存储器是计算机系统中最重要的存储设备，其中存放了大量的文件 对文件的读写操作都涉及到对磁盘的访问，磁盘 I/O 速度高低和磁盘系统可靠性，直接影响到系统的性能 磁盘设备包含一到多个物理盘片，每个盘片分一或两个存储面，每个盘面上有若干磁道，每条磁道由从逻辑上划分了若干扇区（盘块） 为方便处理，每条磁道存储容量相同，由于磁盘密度规定为单位英寸上存储的位数，因此内层磁道的密度较外层磁道的密度要高 对于固定磁头磁盘来说，每磁道具有一磁头；对于移动磁头来说，每磁盘具有一磁头 【磁盘访问时间】磁盘设备在工作时以恒定速率旋转，为了读写，磁头必须能移动到所指定的磁道上，并等待所指定扇区的开始位置旋转到磁头下，然后再开始读写数据 因此，可将对磁盘的访问时间分为以下三部分： 1.寻道时间 寻道时间是将磁头移动到指定磁道上所经历的时间，该事件是启动磁臂的时间 s 与磁头移动 n 条磁道时间的总和 T_s = m * n +s其中，$m$ 是一常数，与磁盘驱动器的速度有关，对于一般磁盘，$m=0.2$，对于高速磁盘，$m \\leq 0.1$ 2.旋转延迟时间 旋转延迟时间是指定扇区移动到磁头下所经历的时间 不同的磁盘类型旋转速度不同，软盘为 $300r/min$，硬盘为 $7200r/min - 15000r/min$，对于旋转延迟时间而言，硬盘的 $T_{\\tau}≈2ms$，软盘的 $T_{\\tau}≈50ms$ 3.传输时间 传输时间是从磁盘读写数据所经历的时间，其大小于每次读写的字节数 b 和旋转速度有关 T_t = \\frac{b}{rN}其中，$r$ 为磁盘每秒的转数，$N$ 为一条磁道上的字节数 当一次读写的字节数相当于半条磁道上的字节数时，$T_{\\tau} = T_t$ 综上，访问时间为： T_a = T_s + \\frac{1}{2r} + \\frac{b}{rN}【磁盘调度算法】为减少对文件的访问时间，应采取一种最佳的磁盘调度算法，以使得各进程对磁盘的平均访问时间最小 先来先服务先来先服务（First Come First Service，FCFS）算法，是最简单的调度算法，其根据进程请求访问磁盘的先后次序进行调度 该算法公平、简单，每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况，但此算法未对寻到进行优化，使得平均寻到时间可能较长 最短寻道时间优先最短寻道时间优先（Shortest Seek Time First，SSTF）算法，每次选择访问磁道与当前磁头所在磁道最近的进程，这样使得每次寻道时间最短，但无法保证平均寻道时间最短 该算法对中间磁道有利，但可能会使得低优先级进程长期处于饥饿状态 扫描算法扫描（Scan）算法是在 SSTF 算法的基础上修改得来的，其可以防止低优先级进程出现饥饿现象 该算法规定磁头移动方向，每次要访问的对象应在磁道之外，又是距离最近的，这样从里向外地访问，直到无更外的磁道需要访问时，才将磁臂自外向里移动 循环扫描算法循环扫描（Cycle Scan，C-SCAN）算法，是在 SCAN 算法的基础上修改得来的 对于 SCAN 算法来说，其具有较好的寻道功能，且可以防止饥饿现象，但当磁头刚从里向外移动越过了某磁道时，恰有一进程要访问该磁道，此时进程必须等待，待磁头继续从从里向外扫描完后再返回来，才能处理该进程的要求，使得该进程的请求被大大地推迟 为减少上述的延迟，C-SCAN 规定磁头单向移动，即当从里向外访问再无更外的磁道时，返回最里的磁道，再次从里向外访问 LOOK 算法与 C-LOOK 算法采用 SCAN 算法和 C-SCAN 算法时，磁头总是严格的从盘面的一端到另一端 在 SCAN 算法和 C-SCAN 算法的基础上，规定磁头移动只需要到达最远端的一个请求即可返回，由此有了 LOOK 算法与 C-LOOK 算法 【磁盘的管理】磁盘初始化一个新的磁盘只是一个含有磁性记录材料的空白盘，在其存储数据前，需要将其分成扇区，以便磁盘控制器能进行读写操作，这个过程被称为低级格式化，即物理分区 之后，为了令磁盘能够存储文件，操作系统还需要将自己的数据结构记录在磁盘上，第一步将磁盘分为由多个柱面组成的分区（C 盘、D 盘等），第二步对物理分区进行逻辑格式化，即创建文件系统 逻辑格式化会令操作系统会将初始的文件系统数据结构存在磁盘上，这些数据结构包括空闲空间、已分配空间、初始为空的目录 引导块计算机启动时，需要运行一个被称为自举程序的初始化程序，其会初始化 CPU、寄存器、设备控制器、内存等硬件，接着启动操作系统 为此，该程序应能够找到磁盘上的操作系统内核，并将其装入内存，同时转移到起始大弟子，从而开始操作系统的运行 自举程序通常保存在 ROM 中，为避免改变自举代码需要改变 ROM 的问题，因此只在 ROM 中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上 拥有启动分区的磁盘就被称为启动磁盘 坏块由于磁盘有移动部件且容错能力错，因此容易导致一个或多个扇区损坏，部分磁盘甚至出厂时就存在坏扇区 根据所使用的磁盘和控制器，对这些坏块有多种处理方式： 简单磁盘（如电子集成驱动器 IDE）：可手工处理，执行逻辑格式化时扫描磁盘检查坏扇区，在 FAT 表上标明，程序不会使用这些坏块 复杂磁盘（如小型计算机系统接口 SCSI）：磁盘控制器维护磁盘坏块链表，其在出厂前的低级格式化时已经初始化，同时在使用过程中不断更新 此外，低级格式化时，会将一些块保留备用，这些块对操作系统透明，磁盘控制器可以使用备用块来逻辑代替坏块，这种方法称为扇区备用","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件存储空间管理","slug":"operating-system/41.文件存储空间管理","date":"2019-12-18T03:43:15.000Z","updated":"2021-10-29T10:35:16.880Z","comments":true,"path":"notes/operating-system/127234bf.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/127234bf.html","excerpt":"【概述】为实现文件组织方式，都需要为文件分配盘块，因此必须知道磁盘上哪些盘块是可用于分配的 故在文件分配磁盘时，除了文件分配表外，系统还应为可分配存储空间设置相应的数据结构，即设置一个磁盘分配表，用于记住可分配的存储空间情况","text":"【概述】为实现文件组织方式，都需要为文件分配盘块，因此必须知道磁盘上哪些盘块是可用于分配的 故在文件分配磁盘时，除了文件分配表外，系统还应为可分配存储空间设置相应的数据结构，即设置一个磁盘分配表，用于记住可分配的存储空间情况 同时，还应提供盘块进行分配和回收的手段，但无论哪种分配和回收方式，存储空间的基本分配单位都是磁盘块 【空闲表法】空闲表法属于连续分配方式，其与内存的动态分配方式雷同，其为每个文件分配一块连续的存储空间 简单来说，系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，其中包括：表项序号、空闲区的第一个盘块号、该区的空闲盘块数等信息，最后将所有空闲区按其起始盘块号递增的次序排序，形成空闲盘块表 与内存的动态分配类似，存储空间的分配和回收同样可采用首次适应算法、循环首次适应算法等 虽然连续分配方式很少采用，但在外存的管理中，由于它具有较高的分配速度，可减少访问磁盘的 I/O 频率，因此它在诸多分配方式中仍占有一席之地 【空闲链表法】空闲链表法是将所有空闲区拉成一条空闲链，根据构成链所用基本元素不同，可以把链表分成两种形式：空闲盘块链、空闲盘区链 对于空闲盘块链来说，其是将磁盘上的所有空闲空间，以盘块为单位拉成一条链，其分配和回收一个盘块的过程十分简单，但为一个文件分配盘块时，可能要重复操作多次 当因创建文件而请求分配空间时，系统从链首依次摘下适当数目的空闲盘块分配给用户 当因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾 对于空闲盘区链来说，其是将所有空闲盘区拉成一条链，每个盘区上含有：指示下一空闲盘区的指针、本盘区大小等信息，其分配和回收的过程较为复杂，但效率较高 【位示图法】位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上的所有盘块都有一个二进制位与之对应，当值为 $0$ 时，表示对应盘块空闲，当值为 $1$ 时，表示对应盘块已分配 根据位示图进行盘块分配时，可分三步进行： 顺序扫描位示图，找到为 $0$ 的二进制位 将所找到的一个或一组二进制位，转换成与之对应的盘块号，进行分配操作 修改位示图 而盘块的回收分为两步： 将回收盘块的盘块号转换成位示图中的行号和列号 修改位示图 位示图的优点在于容易找的一个或一组相邻接的空闲盘块，但限于容量问题，常用于微型机和小型机中 盘块号计算公式为： 盘块号 = 列总数 * (i-1) + j盘块号转换位示图中的行号和列号的公式为： \\begin{cases} i=\\frac{盘块号-1}{列数}+1 \\notag \\\\ j=(盘块号-1)\\:mod\\: 列数+1 \\notag \\end{cases}【成组链接法】空闲表法、空闲链表法都不适用于大型文件系统，因为这会使得空闲表或空闲链表过长，而成组链接法是将上述两种方法结合在一起的方法，其兼备两种方法的优点，且克服了表太长的缺点 该方法将所有盘块按规定大小划分为组，在组间建立链接，组内的盘块借助一个系统栈从而可快速处理，且支持离散分配回收 该方法借助了一个空闲盘块回收栈，用于存放当前可用的一组空闲盘块的盘块号，栈中尚有的空闲盘块号数为 $N$，其中最多含有 $100$ 个号 在分配盘块时，按以下四步进行： 检查空闲盘块号栈是否上锁，如没有，从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格 若该盘块号已是栈底，到达当前栈中最后一个可供分配的盘块号 读取该盘块号所对应的盘块中的信息，即将下一组可用的盘块号入栈 原栈底盘块分配出去，修改栈中的空闲盘块数 在回收盘块时，过程只有两步： 回收盘块号记入栈顶，空闲数 $N+1$ $N$ 达到 $100$ 时，若再回收一块，则将该 $100$ 条信息写入新回收块","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件分配方式","slug":"operating-system/40.文件分配方式","date":"2019-12-17T09:23:32.000Z","updated":"2021-10-29T10:27:16.422Z","comments":true,"path":"notes/operating-system/e7abf730.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/e7abf730.html","excerpt":"【概述】文件分配方式，就是在用户使用逻辑地址操作文件时，OS 负责实现文件从逻辑地址到物理地址的映射 而文件的物理结构与外存的组织方式有关，对于不同的外存组织方式，将形成不同的文件物理结构","text":"【概述】文件分配方式，就是在用户使用逻辑地址操作文件时，OS 负责实现文件从逻辑地址到物理地址的映射 而文件的物理结构与外存的组织方式有关，对于不同的外存组织方式，将形成不同的文件物理结构 因此，不同的外存组织方式就导致了映射的方式不同，目前常用的外存组织方式有： 连续分配方式：为每个文件分配一片连续的磁盘空间，由此形成的物理结构是顺序式的文件结构 链接分配方式：为每个文件分配不连续的磁盘空间，通过链接指针将一个文件的所有盘块链接在一起 索引分配方式：形成索引式文件结构 【连续组织方式】连续组织方式又称连续分配方式，其为每个文件分配一组相邻的盘块，逻辑文件中的记录顺序地存储到邻接的物理块中，使得逻辑文件中的记录顺序与存储器中文件占用盘块的顺序一致 该方式顺序访问相对容易，且速度较快，但要求为一个文件分配连续的存储空间会产生大量的外碎片，严重地降低了外存空间的利用率，且创建文件时要给出文件大小，存储空间利用率不高，不利于文件的动态增加和修改 【链接组织方式】链接方式采用链接组织方式时，将文件分配多个不连续的盘块，再通过盘块上的链接指针，将同属一个文件的多个离散的盘块链接成一个链表，由此形成链接文件 其有两种链接方式： 隐式链接：在文件目录的每个目录项中，包含指向链接文件第一个盘块和最后一个盘块的指针，每个盘块拿出若干字节，记录指向下一盘块号的指针，即链接信息隐含记录在盘块数据中 显示链接：将用于链接各物理块的指针显示地存放在内存的一张链表中，在整个磁盘中仅设置一张 对于隐式链接，其问题在于只能顺着盘块读取，对随机访问是低效的 对于显示链接，由于查记录的过程是在内存中进行的，因此其不仅显著地提高了检索速度，还大大减少了访问磁盘的次数 由于显示链接将分配给文件的所有盘块号都放在该表中，故将该表称为文件分配表（File Allocation Table，FAT） FAT 表的相关计算FAT 表的有关计算与下列三个公式有关： $表项个数 = 盘块个数 = \\frac{容量}{盘块大小}$ 表项大小：与盘块数量编号需要的位数有关 FAT 表大小 = 表项个数 * 表项大小 例如：一个 $1.2M$ 的磁盘，盘块 $512B$，文件系统采用 FAT12 格式，问 FAT 表大小是多少 由于磁盘容量为 $1.2M$，盘块 $512B$，因此，有： 表项个数 = \\frac{1.2*2^{20}}{2^9} = 1.2*2^{11}个采用 FAT12 格式，盘块数量编号所需位数为 $12$ 位 那么，有： FAT = 1.2*2^{11}*12 bit=3.6KB【索引组织方式】对于链接方式来说，其不能支持高效的盘块直接存取，如果要对一个文件进行直接存取，仍需在 FAT 中顺序的查找许多盘块号。因此，FAT 需占用较大的内存空间，当磁盘容量较大时，FAT 可能要占用数 MB 以上的内存空间 因此，在系统运行时，只需要涉及部分文件，FAT 表无需全部调入内存，即对每个文件单独建索引表，记录所有分配给它的盘块号，同时，在建立文件时，分配一定的外存空间用于存放文件盘块索引表信息 索引形式适合大文件，对于中小型文件，需要若干链接即可，若用索引分配方式，用一个盘块存放少量索引信息反而不适用 若文件较大，存放索引表也需要多个盘块，如果索引盘块较多，则需要对索引盘块也采取索引方式管理，即多级索引 也就是说，若采用 $m$ 层索引结构，且顶层索引表未调入内存，那么访问一次数据块要进行 $m+1$ 次读磁盘 【三种方式的对比】三种外存组织方式的对比如下表： 方式 访问第 $n$ 条记录 目录项 优点 缺点 连续组织方式 访问磁盘 $1$ 次 起始块号、文件长度 顺序存取访问快，支持随机访问 有外碎片，不利于文件扩展 隐式链接方式 访问磁盘 $n$ 次 起始块号、结束块号 无外碎片，文件扩展方便 只能顺序访问 显式链接方式 访问磁盘 $1$ 次 起始块号 可通过 FAT 实现随机访问 FAT 占据一定空间 索引组织方式 访问磁盘 $m+1$ 次 链接方式：第一个索引块块号混合方式：顶级索引块块号 支持随机访问，且文件扩展方便 索引表占据一定空间，访问数据前要先读索引块","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件实现与文件的基本操作","slug":"operating-system/39.文件实现与文件的基本操作","date":"2019-12-17T03:38:16.000Z","updated":"2021-10-29T11:10:32.504Z","comments":true,"path":"notes/operating-system/229faee.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/229faee.html","excerpt":"【文件实现】概述在文件系统高层设计时，主要问题是如何将逻辑记录构成一个逻辑文件，而在文件系统低层设计时，主要问题是如何将一个文件存储在外存上，可见，所有的文件都存在以下两种形式的结构：","text":"【文件实现】概述在文件系统高层设计时，主要问题是如何将逻辑记录构成一个逻辑文件，而在文件系统低层设计时，主要问题是如何将一个文件存储在外存上，可见，所有的文件都存在以下两种形式的结构： 文件的逻辑结构：从用户出发所看到的文件形式，独立于文件的物理特性 文件的物理结构：系统将文件存储在外存上所形成的一种存储组织结构，用户不可见 文件实现，是指文件数据从逻辑地址到物理地址的映射，并对物理设备上的文件空间进行组织、管理，其要解决两个问题： 文件分配方式：对磁盘上的非空闲块进行管理，针对文件的逻辑地址 文件存储空间管理：对磁盘上的空闲块进行管理，针对文件的物理地址 文件分配方式磁盘块，是指磁盘中存储单元被划分为一个个的物理块，每块的大小与内存块、页面大小相同，其是内存与磁盘间数据交换的基本单位 对于文件的逻辑地址来说，其结构如下： (逻辑块号,块内地址)对于文件的物理地址来说，其结构如下： (物理块号，块内地址)文件分配方式，就是在用户使用逻辑地址操作文件时，OS 负责实现文件从逻辑地址到物理地址的映射 文件存储空间管理在物理存储设备中，物理磁盘被划分为一个个文件卷 在初始化后，文件卷会被划分为存放 FCB、存储空间管理信息的目录区和存储文件数据的文件区 文件存储空间管理，就是将物理存储设备划分为诸多大小相同的物理块，以块为单位进行管理，因此其又被称为文件盘块分配 【文件的基本操作】概述用户可通过文件系统提供的系统调用实施对文件的操作，最基本的操作有： 创建文件：分配必要的外存空间，并在文件目录中创立一个目录项，记录新文件的文件名、外存地址等属性 删除文件：在外存找到要删除的目录项，使其成为空项，然后回收该文件所占用的存储空间 打开文件：根据文件存放目录，将文件打开，并指示文件操作类型是读操作还是写操作 关闭文件：将打开的文件关闭，并将其在打开文件表项中删除，同时回收该文件的所有资源 创建文件创建文件使用 create 系统调用，需要提供所需外存空间大小、文件存放路径、文件名这三个参数 具体流程如下： 在外存中找到文件所需空间 根据存放路径找到目录文件 在目录文件中创建对应目录项 删除文件删除文件使用 delete 系统调用，需要提供文件存放路径、文件名这两个参数 具体流程如下： 根据存放路径找到相应目录文件 在目录文件中找到相应目录项 根据目录项信息，回收文件占用磁盘块 从目录表中删除对应目录项 打开文件打开文件使用 open 系统调用，需要提供文件存放路径、文件名、对文件操作类型这三个参数 具体流程如下： 根据存放路径找到相应目录文件 在目录文件中找到相应目录项 检查该用户是否有对文件操作的相应权限 将目录项复制到内存打开的文件表中 将对应表的目的编号返回用户 用户通过编号来指明要操作的文件 对于打开文件表来说，其有两种： 系统的打开文件表：记录系统的打开文件，存在打开计数器，记录该文件此时已被几个进程打开 进程的打开文件表：记录进程的打开文件 系统表索引项：记录在系统表中的编号 读写指针项：记录该进程对文件读写操作进行到的位置 访问权限项：表目该进程对文件所具有的权限 关闭文件关闭文件使用 close 系统调用，需要提供文件存放路径、文件名这两个参数 具体流程如下： 将进程打开文件表相应表项删除 回收分配给该文件的资源 系统的打开文件表的打开计数器 $-1$ 当打开计数器值为 $0$ 时，删除该表项","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件共享与文件保护","slug":"operating-system/38.文件共享与文件保护","date":"2019-12-16T14:13:47.000Z","updated":"2021-10-28T14:19:28.515Z","comments":true,"path":"notes/operating-system/cd332164.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/cd332164.html","excerpt":"【文件共享】概述文件共享使多个用户进程共享同一份文件，系统中只需要保留该文件的一份副本即可","text":"【文件共享】概述文件共享使多个用户进程共享同一份文件，系统中只需要保留该文件的一份副本即可 若系统不能提供共享功能，那么每个需要使用该文件的用户都要有各自的副本，这会对存储空间造成极大的浪费 目前，文件共享的范围已经从单机系统发展到多机系统，并通过网络扩展到全球，通过分布式文件系统、远程文件系统等实现，允许多个客户通过 C/S 模型共享网络中的服务器文件 硬链接硬链接又称基于索引结点的共享方式，其常见于树形结构的目录中 在这种共享方式中，文件的物理地址、文件属性等信息，不再存放在目录项中，而是存放在索引结点里，文件目录中只设置文件名及指向相应索引结点的指针 在该方式中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两或多个用户的目录中，以方便找到该文件 因此，在索引结点中，还存在一个链接计数器 count，用于表示链接到该索引结点（该文件）上的用户目录项的数目 当用户 $A$ 创建一个新文件时，其便是该文件的所有者，此时令 count=1，当有用户 $B$ 要共享该文件时，会在用户 $B$ 的目录中增加一个目录项，并设置一个指向该文件索引结点的指针，此时，文件主仍然是用户 $A$，链接计数器 count=2 若用户 $A$ 不再需要该文件，其并不能将该文件直接删除，因为若删除该文件，必然会删除该文件的索引结点，这会导致用户 $B$ 的指针悬空，因此，若 $A$ 不再需要该文件时，只是将该文件的链接计数器 count--，然后删除自己目录中的相应目录项 当某一文件的链接计数器 count=0 时，表示没有用户使用该文件，系统会将删除该文件 软链接软链接又称利用符号链的共享方式，其是借助操作系统自动创建的 LINK 类型的文件来实现的 在该方式中，若用户 $B$ 想共享用户 $A$ 的一个文件 $F$，那么系统会创建一个也取名为 $F$ 的 LINK 类型的文件，并将文件 $F$ 写入用户 $B$ 的目录中，以实现用户 $B$ 的目录与文件 $F$ 的链接，同时，在新文件中，只包含被链接文件 $F$ 的路径名 新文件中的路径名只被看作符号链，当用户 $B$ 要访问被链接的文件 $F$ 且正要读 LINK 类型的新文件时，操作系统会根据新文件中的路径名去读该文件，从而实现用户 $B$ 对文件 $F$ 的共享 在利用该方法实现文件共享时，只有文件的拥有者才拥有指向其索引结点的指针，共享该文件的其他用户只有该文件的路径名，并不拥有指向其索引结点的指针 当文件拥有者将一个共享文件删除后，其他用户通过符号链再去访问，会出现访问失败的情况，此时会将符号链删除，不会出现错误 但当文件拥有者将一个共享文件删除后，另一用户在同一路径下创建一个具有同样名称的文件，那么符号链将仍然有效，但实际上访问的文件已经改变，则会导致访问的文件并不是实际想要访问的文件 静态共享与动态共享硬链接和软链接都是文件系统中的静态共享方法，硬链接就是多个指针指向同一索引结点，保证只要还有一个指针指向该索引结点时，索引结点就不会被删除；软链接就是将到达共享文件的路径记录下来，当要访问文件时，就根据路径去寻找文件 但在文件系统中，还存在着其他的共享需求，即两个进程同时对同一文件进行操作，这种共享被称为动态共享 【文件保护】概述为防止文件共享可能导致的文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题 为此，在文件系统中，建立了相应的文件保护机制，其通过口令保护、加密保护、访问控制等方式实现，其中，口令保护和加密保护是为了防止用户文件被他人窃取，访问控制用于控制用户对文件的访问方式 口令保护口令，是指用户在建立一个文件时要提供口令，系统在为其建立 FCB 时将会附加上该口令，在其他用户请求访问时，必须提供相应口令 该方法的时间、空间开销不大，但口令直接存在于系统内部，不够安全 加密保护密码，是指用户对文件进行加密，当文件被访问时，需要提供密钥来对加密后的文件解密 该方法保密性强，节省了存储空间，但编码、解码需要花费一定的时间 访问控制访问控制最常见的方法是根据用户身份进行控制，其为每个文件和目录增加一个访问控制表（Access Control List，ACL），以规定每个用户所允许的访问类型 使用 ACL 可以制定灵活的访问方法，但长度无法预计且可能导致复杂的空间管理 为此，有了精简的访问列表，其只有三种用户类型： 拥有者：创建文件的用户 组：一组需要共享文件且具有类似访问的用户 其他：系统内的其他用户 这样，只需要使用三个域列出访问表中这三类的访问权限即可","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件的目录结构","slug":"operating-system/37.文件的目录结构","date":"2019-12-16T09:53:00.000Z","updated":"2021-10-26T14:57:08.812Z","comments":true,"path":"notes/operating-system/e95e4811.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/e95e4811.html","excerpt":"【文件目录】为保证对计算机中大量的文件实施有效的管理，必须将他们进行妥善组织，为此有了供检索使用的、标识了系统中的文件和物理地址的数据结构，即文件目录 对文件目录进行管理的要求主要有以下四点：","text":"【文件目录】为保证对计算机中大量的文件实施有效的管理，必须将他们进行妥善组织，为此有了供检索使用的、标识了系统中的文件和物理地址的数据结构，即文件目录 对文件目录进行管理的要求主要有以下四点： 实现按名存取 提高对目录的检索速度 文件共享 允许文件重名 【文件控制块】文件控制块（File Control Block，FCB），是为文件设置的用于描述和控制文件的数据结构，文件与文件控制块一一对应，文件控制块的集合称为文件目录，即一个文件控制块就是一个文件目录表项，通常，一个文件目录也被看为一个文件，即目录文件 在文件控制块中，通常有以下几类信息： 基本信息类：文件名、文件物理位置、文件逻辑结构、文件的物理结构等 存取控制信息类：文件主存取权限、核准用户的存取权限、一般用户的存取权限 使用信息类：建立日期和时间、文件上次修改的日期和时间等 当前使用信息：打开该文件的进程数、是否被进程锁住、是否已修改等 【索引结点】文件目录占用的盘块越大，需进行的磁盘读写开销越大，因此减少实际检索的信息量就是减少移动磁头的开销 目录一般是按名检索，而直到找到正确文件前，只关心文件名，不需要其它的文件描述信息，所以，可以将文件名、文件具体信息分开，使文件描述信息单独形成一个索引结点 简单的来说，索引结点是 FCB 的改进，其在外存和内存中有不同的形式： 磁盘索引结点：存放在磁盘上的索引结点，包含文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间 内存索引结点：文件被打开后，将磁盘索引结点拷贝到内存索引结点中以便使用，在磁盘索引结点的基础上增加了索引结点编号、状态、访问计数、文件所属文件系统的逻辑设备号、链接指针 【目录结构】单级目录单级目录是最简单的目录，其在整个文件系统中只建立一张目录表，每个文件一个目录项，含有文件相关信息 每建立一个文件时，先检索所有的目录项，保证文件名唯一，之后获得一空白目录项，填入相关信息，同时修改状态位 每删除一个文件时，找到对应目录项，回收文件所占用空间，同时清除目录项 单级目录的优点在于简单、能实现目录管理的基本功能，但文件检索时需搜遍整个目录文件，范围大速度慢，且不允许重名，不便于实现文件共享，其在早期单机环境的 OS 中被广泛使用 两级目录为克服单级目录的缺点，有了两级目录，其为每一个用户建立一个单独的用户文件目录 UFD，UFD 由用户所有文件的文件控制块组成 同时，系统建立一个主文件目录 MFD， MFD 中每个用户目录文件都占有一个目录项，其中包括用户名和指向 UFD 的指针 两级目录基本上克服了单机目录的缺点，提高了检索目录速度，并允许在不同的目录中可重名，同时不同用户可以使用相同或不同的文件名来访问系统中的同一个共享文件，其在早期多用户环境的 OS 中被广泛使用 树形结构目录树形目录结构又称多级目录，在如今被广泛使用，其层次结构更清晰，权限管理更灵活，但目录级别太多时会增加路径检索层次，增加磁盘访问时间 主目录称为根目录，数据文件为树叶，其它目录为结点，路径名是从根目录到任何数据文件都只有一条唯一通路，目录文件名和数据文件名依次用 / 连接起来 每个进程还设置一个当前目录，又称工作目录，从当前目录开始，逐级经过中间的目录文件，最后达到要访问的数据文件 从工作路径上的目录和数据文件名用 / 连接成路径名，称为相对路径名，而从根开始的路径名称为绝对路径名 【目录查询技术】当用户要访问一个文件时，要经过以下几步操作： 目录数据调入内存 按名检索，利用提供的文件名对目录进行查询 找该文件控制块 FCB 读取 FCB 或对应索引结点 从文件物理地址换算出文件在磁盘上的物理位置 通过磁盘驱动程序，将所需文件读入内存 目录查询方式通常有以下两种方法： 线性检索法：在单级目录中，通过文件名顺序查找文件目录；在多级目录中，通过路径名，逐层查找文件目录 哈希方法：建立一张哈希索引文件目录，通过文件名变换为索引值，再利用索引值去查找","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件的逻辑结构","slug":"operating-system/36.文件的逻辑结构","date":"2019-12-15T13:11:43.000Z","updated":"2021-10-26T14:56:24.422Z","comments":true,"path":"notes/operating-system/c7b0568b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/c7b0568b.html","excerpt":"【文件逻辑结构类型】用户看到的文件是逻辑文件，其是由一系列的逻辑记录组成的，对用户而言，文件的逻辑记录是能够被存取的基本单位 对于文件的逻辑结构来说，根据其是否有结构，可分为以下两类：","text":"【文件逻辑结构类型】用户看到的文件是逻辑文件，其是由一系列的逻辑记录组成的，对用户而言，文件的逻辑记录是能够被存取的基本单位 对于文件的逻辑结构来说，根据其是否有结构，可分为以下两类： 无结构文件：又称流式文件，其长度以字节为单位，在访问时利用读写指针来指出下一个要访问的字符 有结构文件：又称记录式文件，每个记录都用于描述实体集中的一个实体，各记录着有相同或不同数目的数据项，记录的长度可分为不定长记录、定长记录 其中，定长记录是指文件中所有的记录长度相同，不定长记录是指文件中各记录长度不同 同时，对于有结构文件来说，按照组织方式，可分为以下四类： 顺序文件：由一系列记录按某种顺序排列形成的文件，记录是定长记录还是不定长记录均可 索引文件：为不定长记录文件建立一张索引表，为每一记录建立以表项，以加速对记录的检索速度 索引顺序文件：顺序文件和索引文件结合的产物，在为每个文件建立索引表的同时，为一组记录中的第一个记录建立一个索引表项 哈希文件：通过给定记录的键值或散列函数的键值来直接决定物理地址 关于索引技术的详细介绍见：索引技术分类 【无结构文件】无结构文件是指数据按顺序组织或记录，并进行积累、保存，内部数据是一系列字符流或二进制流 其以字节为存储单位，管理、操作简单，常见于文本文件、源程序文件等 【有结构文件】顺序文件在顺序文件中的记录，可以按照不同的顺序进行排列，一般有两种情况： 串结构：按记录形成的时间顺序串行排序 顺序结构：按关键字排序 由于是顺序排列，因此在检索时，对定长记录来说，可以结合折半查找等算法来提高检索速度；对变长记录来说，只能从第一个记录开始扫描，直到扫描到要检索的关键字标识的记录 顺序文件不方便随机存取某条记录，但适用批量存取的场合，其适合磁带等特殊的存储介质，此外，对于单记录的查找、修改等操作交互性差，增减不方便 索引文件为了方便单个记录的随机存取，为文件建立一个索引表，记录每项记录在文件的逻辑地址及记录长度，同时该索引表按关键字进行排序 索引表中具有三个表项：索引号、长度、记录地址指针，由于是按关键字建立的索引，因此在对索引文件检索时，可根据用户提供的关键字利用二分查找算法去检索，找到对应表项后，利用该表项给出的指向记录的指针去访问所需记录 为方便用户根据不同记录属性检索记录，因此可为顺序文件建立多个索引表，每种能成为检索条件的域都配备一张索引表 索引文件适用于变长记录，其可提高检索速度，实现直接存取，但相应的增加了存储开销 索引顺序文件索引顺序文件是对顺序文件的一种改进，基本上克服了变长记录的顺序文件不能随机访问的问题 其引入了文件索引表，通过该表可以实现索引顺序文件的随机访问，同时增加了溢出文件，用来记录新增、删除、修改的记录 该方式将顺序文件的所有记录分组，并建立索引表，但每个表项记录的是每组第一条记录的键值和地址，在每个组内按照顺序方式检索和使用 在检索记录时，首先计算记录是第几组，然后再检索索引确定组后，在组内顺序查找 同时，可以利用多级索引，进一步提高检索效率 哈希文件哈希文件是目前应用最广泛的一种直接文件，其利用哈希函数将关键字转换为相应记录的物理地址 为了实现文件存储空间的动态分配，通常由哈希函数求得指向某一目录表相应表目的指针，该表目的内容指向相应记录所在的物理块","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"文件与文件系统","slug":"operating-system/35.文件与文件系统","date":"2019-12-15T07:09:13.000Z","updated":"2021-10-26T14:31:38.236Z","comments":true,"path":"notes/operating-system/14ec50a0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/14ec50a0.html","excerpt":"【概述】在现代计算机中，需配置外存，将系统和用户所需的大量程序和数据以文件的形式存放在外存中，需要时再将他们调入内存 如果用户直接管理存放在外存上的文件，不仅要求用户熟悉外存特性，了解各种文件的属性，还要知道他们在外存上的位置，这显然是用户不能胜任的","text":"【概述】在现代计算机中，需配置外存，将系统和用户所需的大量程序和数据以文件的形式存放在外存中，需要时再将他们调入内存 如果用户直接管理存放在外存上的文件，不仅要求用户熟悉外存特性，了解各种文件的属性，还要知道他们在外存上的位置，这显然是用户不能胜任的 为此，OS 中增加了文件管理功能，专门用于管理外存上的文件，主要有以下功能： 存储空间管理：通过分配外存空间，来提高外存的利用率，需要在文件系统中设置相应数据结构来记录文件存储空间的使用情况，此外要有对存储空间分配和回收的功能 目录管理：为文件建立目录项并进行有效组织，来提高文件检索速度 文件读写管理与保护：用于实现文件的读写管理（设置读写指针）与文件的保护功能（提供有效的存取控制功能） 同时，在文件之间，操作系统采取目录结构进行组织，在文件内部，操作系统采取文件逻辑结构进行组织 【数据项、记录与文件】文件系统管理是将其管理的程序和数据通过组织为一系列文件的方式实现的，文件是指具有文件名的若干相关元素的集合，元素通常是记录，而记录是一组有数据项的集合，因此可以将数据组成分为数据项、记录、文件三级 数据项：描述对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位 记录：一组相关数据项集合，描述对象某方面的属性 关键字：一个记录中的一个或几个数据项的集合，用于唯一的标识一个记录 文件：由创建者定义的、具有文件名的一组相关元素的集合 有结构文件：若干相关记录组成 无结构文件：字符流的形式 【文件名和类型】在不同的系统中，对文件名的规定不同，其用于标识一个文件。 在文件名后，通常有一个扩展名（后缀名），用于指示文件的类型。 在大多数系统中，用圆点 . 将文件名和扩展名分离，例如：myfile.txt 为便于管理控制文件，将文件分为若干类型，不同的系统对文件的管理方式不同，常用的文件分类方法有： 按用途：系统文件、用户文件、库文件 按数据形式：源文件、目标文件、可执行文件 按存取控制属性：只执行文件、只读文件、读写文件 按组织和处理方式：普通文件、目录文件、特殊设备文件 【文件系统的层次结构】文件系统的模型可分为三个层次： 最高层：一般为命令接口或系统调用，用于处理用户发出的系统调用请求，是文件系统提供给用户的接口 中间层：从上到下分为文件目录系统、存取验证模块、逻辑文件系统与文件信息缓冲区三层，是文件管理的内核程序 最底层：物理文件系统，将中间层最后一层提供的逻辑地址转换为实际物理地址 对于中间层来说，其是文件管理的内核程序，一般将其分为三个层次： 文件目录系统：根据用户给出路径找到相应 FCB 或索引结点，所有与目录、目录项相关的工作场所都在本层完成 存取验证模块： 用于完成文件保护相关功能 逻辑文件系统与文件信息缓冲区：逻辑文件系统负责根据文件逻辑结构将逻辑记录转换为对应的逻辑地址，文件信息缓冲区负责将索引文件的索引表调入其中以进行查询 此外，在文件物理系统之下，设备之上，还存在两个模块： 辅助分配模块：管理辅存空间，负责分配空闲空间与回收空间 设备程序管理模块：直接与 I/O 设备交互，负责和硬件直接相关的设备管理工作，如分配设备、启动设备、磁盘调度等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"请求分段存储管理方式","slug":"operating-system/34.请求分段存储管理方式","date":"2019-12-11T10:55:16.000Z","updated":"2021-10-25T13:54:14.913Z","comments":true,"path":"notes/operating-system/319b4e16.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/319b4e16.html","excerpt":"【概述】在分页基础上建立的请求分页式虚拟存储器系统，是以页面为单位换入换出的 而在分段基础上建立的请求分段式虚拟存储器系统，是以分段为单位换入换出的","text":"【概述】在分页基础上建立的请求分页式虚拟存储器系统，是以页面为单位换入换出的 而在分段基础上建立的请求分段式虚拟存储器系统，是以分段为单位换入换出的 两者的原理、实现方式以及所需硬件支持都十分相似 【硬件支持】为实现请求分段存储管理，应在系统中配置相应的硬件机构，以支持快速地完成请求分段功能 与请求分页系统相似，请求分段系统中所需的硬件支持有：请求段表机制、缺段中断机构、地址变换机构 请求段表机制在请求分段管理中所需的主要数据结构是请求段表 存取方式 ：用于标识本分段的存取属性 R、W、R/W 访问字段 $A$ ：用于记录本段被访问的频繁程度 修改位 $M$ ：表示该段在调入内存后是否被修改过 存在状态位 $P$ ：指示该段是否已调入内存 增补位 ：特有字段，表示该段运行中是否做过动态增长 外存始址：用于指出该段在外存上的起始地址（盘块号） 缺段中断机构请求分段系统中采用的是请求调段策略，每当发现运行进程要访问的段尚未调入内存时，会执行以下操作： 由缺段中断机构产生一缺段中断信号 进入 OS，由缺段中断处理程序将所需段调入内存 缺段中断与缺页中断相似，同样是在一条指令的执行期间产生和处理中断，一条指令执行可能产生多次缺段中断，但不会出现一条指令被分割在两个分段中或一组信息被分割在两个分段中的情况 地址变换机构请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的 由于被访问的段并非全在内存，因此在地址变换时，若发现要访问的段不在内存，必须先将所缺的段调入内存，并修改段表，才能利用段表进行地址变换 为此，在分段系统地址变换机构的基础上添加了缺段中断请求与处理的功能 【分段共享与保护】共享段表为实现分段共享，需要在系统中配备一张共享段表，所有共享段都在共享段表中占据一个表项，在表项上记录了共享段的段号、段长、内存始址、状态位、外存始址、共享进程计数等信息。 共享进程计数：记录有多少个进程需要共享该分段 存取控制字段：共享段给不同的进程以不同的存取权限 段号：对于一个共享段，不同的进程可用不同的段号 共享段的分配 由于共享段是供多个进程共享的，因此对共享段的分配方法与非共享段的分配方法有所不同： 第一个请求使用该共享段的进程 $A$：系统为该共享段分配一物理区，再把共享段装入该区 将该区的始址填入 $A$ 的段表相应项 在共享段表中增加一表项，填写有关数据，置 count = 1 其他进程 $B$ 也调用该共享段时，无需再为该段分配内存，只需在 B 的段表中增加一表项，填写该共享段的物理地址 在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count++ 操作 共享段的回收当共享此段的某进程不再需要该段时，应将该段释放： 撤消在进程段表中共享段所对应的表项 执行 count-- 操作 如果 count=0，则由系统回收该共享段的物理内存，并取消共享段表中该段所对应的表项 分段保护在分段系统中，由于每个分段在逻辑上是相对独立的，因此较容易实现信息保护，目前常采用以下方法： 越界检查：在进行存储访问时，将段号与段表长度比较，段内地址与段长比较 存取控制检查：段表每个表项都设置存取控制字段，规定该段的访问方式 环保护机构：规定低编号的环具有高优先权，一个程序可以访问驻留在相同环或较低特权环中的数据，可以调用驻留在相同环或较高特权环中的服务","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"抖动与工作集","slug":"operating-system/33.抖动与工作集","date":"2019-12-10T12:36:15.000Z","updated":"2021-10-25T13:48:56.324Z","comments":true,"path":"notes/operating-system/2b1e5cf5.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/2b1e5cf5.html","excerpt":"【抖动】多道程序度由于虚拟存储器系统从逻辑上扩大内存，只需要装入一个进程的部分程序和数据即可运行，为提高处理机的利用率，可采取增加多道程序的方法，即在系统中运行更多的进程","text":"【抖动】多道程序度由于虚拟存储器系统从逻辑上扩大内存，只需要装入一个进程的部分程序和数据即可运行，为提高处理机的利用率，可采取增加多道程序的方法，即在系统中运行更多的进程 如下图，随着进程数目的增加，处理机的利用率也增加，但到增速逐渐减缓，直到达到峰值，之后再进行增加，处理机利用率反而下降，这是因为在系统中已经发生了抖动 抖动抖动，即刚被换出的页很快又要被访问，需要将其重新调入，而此时又需要再选一页调出，置换完毕后，刚被调出的页又被访问，又需要将其调入，频繁地更换页面，使得一个进程在运行过程中将大部分时间都花在了置换工作上 产生抖动的根本原因在于，同时在系统中运行的进程太多，由此分配给每一进程的物理块太小，不能满足进程正常运行的基本要求，从而使得每个进程频繁地出现缺页 而大量的缺页会使得系统中排队等待页面调度的进程数增加，对磁盘的有效访问时间也随之增加，造成每个进程大部分时间都用于页面的换进换出，从而导致处理机利用率急剧下降甚至趋于 $0$ 的情况 抖动的预防为保证系统具有较大的吞吐量，必须防止抖动的产生，常见的预防抖动的方法如下： 采取局部置换策略 将工作集算法融入到处理机调度中，即在页面调入内存前检查各进程的工作集，为缺页率高的增加有限物理块 利用 $L= S$ 准则来调节缺页率，即：当缺页间的平均时间 $L$ 与置换一个页面所需时间 $S$ 相等时，磁盘和处理机可达到他们的最大利用率 抖动发生时，暂停某些进程，从而调节多道程序度 【工作集】进程发生缺页的时间间隔与进程获得的物理块数有关联，缺页率随着分配物理块数的增加明显地减少 基于程序局部性原理可知，程序在运行期间，对页面的访问是不均匀的，因此，若能预知程序在某段时间要访问的页面并全部调入他们，将大大降低缺页率，显著地提供处理机的利用率 由于无法预知程序在不同时刻访问的页面，因此只能像置换算法那样用程序过去某段时间的行为作为程序将来某段时间的行为的近似 工作集，是指在某段时间间隔 $\\Delta$ 中，进程时间所访问页面的集合 具体来说，可以用一个二元函数 $W(t, \\Delta)$ 来表示某进程在执行时刻 t 的工作集，在不同时间 t 的工作集大小不同，所含的页面数也不同，其是窗口尺寸 $\\Delta$ 的非降函数，即： W(t,\\Delta) \\subseteq W(t,\\Delta +1)","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"请求分页存储管理方式的页面置换算法","slug":"operating-system/32.请求分页存储管理方式的页面置换算法","date":"2019-12-09T08:18:36.000Z","updated":"2021-10-25T13:46:47.327Z","comments":true,"path":"notes/operating-system/9e183ad6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/9e183ad6.html","excerpt":"【概述】在进程运行过程中，若访问的页面不在内存，且调入时内存已无空闲空间，那么需要将内存中的一页程序或数据调到外存 页面置换算法就是选择换出哪些页面的算法，其好坏直接影响系统的性能，因此其应具有较低的缺页率","text":"【概述】在进程运行过程中，若访问的页面不在内存，且调入时内存已无空闲空间，那么需要将内存中的一页程序或数据调到外存 页面置换算法就是选择换出哪些页面的算法，其好坏直接影响系统的性能，因此其应具有较低的缺页率 缺页率 = \\frac{缺页次数(页面调入次数)}{页面总使用次数}【最佳置换算法】最佳置换（Optimal，OPT）算法是一种理想化的算法，其具有最好的性能，但实际上无法实现，因此常将最佳置换算法来作为标准，去评价其他置换算法的优劣 最佳置换算法所选择的被淘汰页面将是以后不再使用的页面，或者是在最长时间内不再被访问的页面 由于被淘汰的页面在较长时间内不再被选用，因此可以获得最低的缺页率，但由于无法预知进程未来的运行情况，因此无法实现 【先进先出置换算法】先进先出（First Input First Output，FIFO）算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰 该算法实现简单，只需要将进程调入内存的页面按先后次序组织成一个队列，再设置一个替换指针，使其总是指向队首即可 但与进程实际运行规律不适应，因为较早调入的页往往是经常被访问的页，频繁的对换会造成运行性能的降低 【最近最久未使用置换算法】最近最久未使用（Least Recently Used，LRU）算法，根据页面调入内存后的使用情况进行决策，总是淘汰最近最久未使用的页面 该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 $t$ 访问页面时，若页面在物理块中，当前页面的 $t$ 清零，其他页面的 $t$ 递增；若页面不在物理块中，即需要淘汰一个页面时，选择现有页面中 $t$ 最大的进行淘汰，新进入的页面 $t$ 置为 $0$，其他页面的 $t$ 递增 LRU 算法是利用最近的过去作为最近的将来近似，但页面过去和未来的走向间没有必然的联系，此外，该算法需要较多的硬件支持，利用寄存器或栈来保存哪页是最近最久未使用的页面 【最少使用置换算法】最少使用（Least Frequently Used，LFU）算法，在每页设置访问计数器，每当页面被访问时，该页面的计数器值 $+1$，缺页中断时，淘汰计数值最小的界面，并将所有计数清零 LFU 算法计数的实现类似 LRU 算法，同样可利用移位寄存器 【轮转置换算法】概述虽然 LRU 是一种较好的算法，但由于其要求有较多的硬件支持，使得其实现成本较高，因此在实际应用中，大多采用 LRU 的近似算法。 轮转（Clock）算法，又称最近未使用（Not Recently Used，NRU）算法，是最常用的一种 LRU 的近似算法，通过循环地检查各页面的使用情况来进行页面的置换 简单轮转置换算法简单轮转算法在每页设置一个初始为 $0$ 的访问位，当某页被访问时，将其置为 $1$ 当需要进行页替换时，检查页的标志位： 如果访问位是 $0$：就将该页换出 如果访问位是 $1$：则重新将其置 $0$，暂不换出，给予该页第二次驻留内存的机会 同时，按照 FIFO 算法检查下一个页面，当检查到队列中最后一个页面时，若其访问位仍为 $1$，则返回到队首去检查第一个页面。 改进型轮转置换算法在将一个页面换出时，若该页已被修改过，需将该页重新写回磁盘上，若该页未被修改过，则不必将其写回磁盘 因此，对于修改过的页面，在换出时所付出的开销比未修改过的页面大，简单来说，修改过的页面置换代价大 在改进型的轮转置换算法中，为减少因修改造成的频繁 I/O 操作，每页除了考虑页面的使用情况外，还须考虑置换代价，即除访问位 $A$ 外，再增加一个修改位 $M$ 由访问位 $A$ 和修改位 $M$ 可组合成下面四种类型的页面： $A=0，M=0$ 时：该页最近既未被访问，又未被修改，是最佳淘汰页 $A=0，M=1$ 时：该页最近未被访问，但已被修改，不是很好的淘汰页 $A=1，M=0$ 时：该页最近已被访问，但未被修改，可能再被访问 $A=1，M=1$ 时：该页最近已被访问，且被修改，可能再被访问 在内存中的每个页，必定是这四类页面之一，在进行页面置换时，可采用与简单轮转置换算法相似的操作，差别仅在于需同时检查访问位与修改位，以确定该页是四类页面中的哪一种，执行过程如下： 从指针所指位置开始，扫描循环队列，寻找 $A=0$ 且 $M=0$ 的页面，将所遇到的第一个页面作为被选中的淘汰页，在扫描期间不改变访问位 $A$ 若第一次扫描失败，开始第二次扫描，寻找 $A=0$ 且 $M=1$ 的页面，将所遇到的第一个页面作为被选中的淘汰页，在扫描期间将访问位 $A$ 置为 $0$ 若第二次扫描失败，由于此时所有的访问位 $A$ 都置为 $0$，因此一定存在 $A=0,M=0$ 或 $A=0,M=1$ 的情况，再次重复第一次、第二次扫描过程 【页面缓冲算法】页面缓冲算法（Page Buffering Algorithm，PBA），在不需要硬件的支持的情况下，弥补了 FIFO 可能带来的 I/O 开销 其仍用 FIFO 算法选择被置换页，但不将其马上换入外存，而是根据页面是否被修改，放入相应链表：若页面未被修改，放入空闲页面链表，若页面已被修改，放入已修改页面链表 在需要调入新的物理页时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项从空闲链表摘下 空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面被再次访问，只需较小开销，而被访问的页面可以返还作为进程的内存页 当已修改页面达到一定数目后，再将它们一起调出到外存，然后将它们归入空闲页面链表，从而减少 I/O 操作的次数 【访问内存的有效时间】与基本分页存储管理不同，在请求分页管理方式中，内存有效访问时间不仅要考虑访问页表和访问实际物理地址数据的时间，还要考虑缺页中断处理的时间 在快表机制的请求分页管理中，存在下面三种方式的内存访问操作，其有效访问时间的计算公式也有所不同： 1.被访问页在内存，对应表项在快表中 此时不存在缺页中断情况，内存的有效访问时间 EAT 简单的分为查找快表的时间 $\\lambda$ 与访问实际物理地址的时间 $t$，即： EAT = \\lambda + t2.被访问页在内存中，对应表项不在快表中 此时不存在缺页中断情况，但需要两次访问内存，一次读取页表，一次读取数据，另外还需更新快表。因此，这种情况的内存有效访问时间 EAT 分为查找快表的时间 $\\lambda$、查找页表的时间 $t$、修改快表的时间 $\\lambda$、访问实际物理地址的时间 $t$，即： EAT = \\lambda + t + \\lambda + t = 2(\\lambda + t)3.被访问页不在内存中 当被访问页不在内存中，需要进行缺页中断处理。因此，这种情况的内存有效访问时间 EAT 分为查找快表的时间 $\\lambda$、查找页表的时间 $t$、处理缺页中断的时间 $\\epsilon$ ，修改快表的时间 $\\lambda$、访问实际物理地址的时间 $t$，即： EAT = \\lambda + t + \\epsilon + \\lambda + t = 2(\\lambda + t) + \\epsilon上述的三种情况并没有考虑到快表的命中率与缺页率，设快表的命中率为 $a$，缺页率为 $f$，那么内存有效访问时间为： EAT = \\lambda + at +(1-a)(t+f( \\epsilon + \\lambda + t)+(1-f)(\\lambda+t))若不考虑命中率 $a$，仅考虑缺页率 $f$，即 $\\lambda =0,a=0$ 时，设缺页中断处理时间为 $\\phi$，那么内存有效访问时间为： EAT = t + f(\\phi + t) + (1 - f) t","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"请求分页存储管理方式","slug":"operating-system/31.请求分页存储管理方式","date":"2019-12-08T05:47:49.000Z","updated":"2021-10-25T12:38:06.100Z","comments":true,"path":"notes/operating-system/111b119.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/111b119.html","excerpt":"【概述】请求分页系统是建立在基本分页基础上的，为能支持虚拟存储器的功能，增加了请求调页功能和页面置换功能 相应地，每次调入和换出的基本单位都是长度固定的页面，这使得请求分页系统在实现上要比请求分段系统简单","text":"【概述】请求分页系统是建立在基本分页基础上的，为能支持虚拟存储器的功能，增加了请求调页功能和页面置换功能 相应地，每次调入和换出的基本单位都是长度固定的页面，这使得请求分页系统在实现上要比请求分段系统简单 目前，请求分页系统是最常用的一种实现虚拟存储器的方式 【硬件支持】为实现请求分页，系统须提供一定的硬件支持，除了一定容量的内存与外存，还要有请求页表机制、缺页中断机构、地址变换机构 请求页表机制请求分页系统中，主要数据结构是请求页表，其基本作用仍是将逻辑地址映射为物理地址 为满足页面换进换出的需要，请求分页系统中的页表进行了更改： 状态位 P ：指示该页是否已调入内存 访问字段 A ：置换时考量的参数，用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问 修改位 M ：关系到置换时调出的具体操作，用于记录该页在调入内存后是否被修改过 外存地址：用于指出该页在外存上的地址 缺页中断机构每当要访问的页面不在内存时，便产生一缺页中断，去通知 OS，OS 会将所缺的页调入内存。 作为中断，需经历四个步骤：保护 CPU 环境、分析中断原因、转入缺页中断处理程序、恢复 CPU 环境 缺页中断作为一种特殊中断，与一般中断有明显的区别： 在指令执行期间产生和处理中断信号 一条指令在执行期间，可能产生多次缺页中断 地址变换机构请求分页系统中的地址变化机构是在分页系统地址变化的机构上增加了两个功能：产生与处理缺页中断的功能（请求调入）、从内存中换出一页的功能（置换） 【内存分配】在为进程分配内存时，作业不采用一次装入的方法，而采用部分装入的方法，这就涉及到以下三个问题： 最小物理块数的确定为保证进程能正常运行，所需要的物理块数的确定是十分关键的 随着为每个进程分配的物理块的减少，将使进程在执行中的缺页率上升，从而降低进程的执行速度 为使进程有效地工作，应为其分配一定数量的物理块，而最小物理块数是指能保证进程正常运行所需的物理块的最小数量 当系统为进程分配的物理块数少于此值时，进程将无法运行，而这个最小物理块数的确定，与计算机的硬件结构有关，取决于指令的格式、功能、寻址方式 物理块的分配策略在请求分页系统中，可采用两种内存分配策略： 固定分配，是指为每个进程分配一组固定数目的物理块，在进程运行期间不再改变 可变分配，是指为每个进程分配一定数目的物理块，在进程运行期间，根据情况做适当的增加或减少 在进行置换时，也可采用两种内存置换策略： 全局置换，是指进程在运行中若出现缺页，则将 OS 所管理的空闲物理块队列中，取出一块分配给该进程，将欲装入的页装入 局部置换，是指进程在运行中若出现缺页，只能从分配给该进程的 $n$ 个页面中选出一页换出，以保证分配给该进程的内存空间不变，且不影响其他进程执行 将上述的策略进行组合，可组合出以下三种适用的策略： 固定分配局部置换策略：困难在于难以把握为每个进程分配适量的物理块数 可变分配全局置换策略：当空闲空间不足时，可与其他任何进程页面置换，会使其他进程缺页率提高，影响运行，但易于实现 可变分配局部置换策略：系统会根据缺页率适当地增减进程的物理块数。若频繁缺页中断，会为进程分配若干物理快；若缺页率特别低，会减少分配给该进程的物理块 物理块的分配算法采用固定分配策略时，分配物理块可采用以下几种算法： 平均分配算法：将所有可供分配的物理块平均分配给各进程，这种方法未考虑各进程本身的大小，可能会出现很高的缺页率 考虑优先权的分配算法：将所有可用物理块分两部分， 一部分按比例分配给各进程，另一部分根据各进程优先权，适当地为其增加份额，分配给各进程 按比例分配算法：根据进程的大小按比例分配物理块 设进程中有 $n$ 个进程，每个进程的页面数为 $S_i$，则系统中各进程页面数的总和为： S = \\sum_{i=1}^n S_i假定系统中可用的物理块总数为 $m$，则每个进程所能分到的物理块数为： b_i = \\frac{S_i}{S}*m需要注意的是，此处 $b_i$ 应该取正，其必须大于最小物理块数 【页面调入】页面调入时机为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种策略： 预调页策略：以预测为基础，将预计不久后便会被访问的若干页面，预先调入内存 请求调页策略：运行中需要的页面不再内存时，就立即提出请求，由 OS 将其调入内存 预调页策略的优点在于可一次调入若干页，效率较好，但其预测不一定准确，预先调入的页面可能不会被执行；请求调页策略的优点在于被调入的页一定会被访问，且容易实现，但每次仅调入一页，需花费较大的系统开销，增加了磁盘 I/O 的启动频率 页面调入地点请求分页系统中的外存分为两部分，一部分是采用离散分配方式用于存放文件的文件区，另一部分是采用连续分配方式存放对换页面的对换区 对换区的数据存取速度比文件区要高，因此每当发生缺页时，系统应从何处将缺页调入内存，分成三种情况： 系统拥有足够的对换区空间：进程运行前将所有页面由文件区拷贝到对换区，运行需要的全部页面从对换区调入内存，提高调页速度 系统缺少足够的对换区空间：不会被修改的部分，在文件区操作；可能被修改的部分，在对换区操作 UNIX 方式：与进程有关的文件都存放在文件区，因此未运行过的页面，都从文件区调入；而曾运行过又被换出的页面存放在对换区，因此随着进程的运行，已运行过的页面再次被调用时，直接从对换区调入。由于 UNIX 系统允许页面共享，因此某进程所请求的页面可能已被其他进程调入内存，此时就无需从对换区调入 页面调入过程在开始运行时，预调入一部分页面 在运行过程中，需要的页面不在内存时，向 CPU 发出一缺页中断，中断处理程序开始工作： 保留 CPU 环境 分析中断原因，转入缺页中断处理程序 判断是否置换、页表信息更新 恢复现场，重新操作页面","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"虚拟存储管理的基本概念","slug":"operating-system/30.虚拟存储管理的基本概念","date":"2019-12-07T11:30:07.000Z","updated":"2021-10-25T12:37:37.772Z","comments":true,"path":"notes/operating-system/7d4fecdb.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/7d4fecdb.html","excerpt":"【传统存储管理的问题】对于传统存储器的存储管理方式来说，其具有一次性、驻留性两个特点 所谓一次性，是指将一个作业全部装入内存后才能运行，于是会出现下述的两种情况：","text":"【传统存储管理的问题】对于传统存储器的存储管理方式来说，其具有一次性、驻留性两个特点 所谓一次性，是指将一个作业全部装入内存后才能运行，于是会出现下述的两种情况： 有的作业很大，其要求的内存空间超过了内存总容量，作业不能全部装入内存，使得该作业无法运行 当大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存先运行，将其他大量的作业留在外存等待 而驻留性，是指一旦一个作业被装入内存，其会一直驻留在内存中，直到作业结束，而一段时间内，仅需访问一小部分的数据即可正常运行，而内存中驻留着大量暂时用不到的数据，十分浪费内存资源 传统存储器的存储管理方式出现的问题，都是由于内存容量不够大，一种解决方案是从物理上扩充内存容量，但这种方法无疑增加了系统成本；另一种解决方法是从逻辑上扩充内存容量，即虚拟存储技术要解决的主要问题 【局部性原理】由于一次性与驻留性，使得许多在程序运行中不用或暂时不用的程序或数据占据了大量的内存空间，但实际上，程序在执行时呈现局部性规律 程序执行时，多数情况下是顺序执行 少部分的转移和过程调用指令，会使程序执行由一部分区域转至另一部分区域，但调用深度多数情况下不超过 5 次，这就说明程序会在一定时间内，都局限在这些过程的范围内运行 程序中存在许多由少数指令构成的循环结构，循环结构会被执行多次 对数据结构的处理往往局限于很小的范围内 上述所有的情况都表现出了程序执行的局部性： 时间局限性：被引用过一次的存储器位置很可能在不远的将来再被多次引用，典型情况是程序中存在着大量循环 空间局限性：如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置，典型情况是程序的顺序执行 【虚拟存储器】特征虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统 对于虚拟存储器来说，其具备以下三个特征： 多次性：一个作业被分成多次调入内存运行 对换性：允许在作业的运行过程中进行换进、换出 虚拟性：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量 在虚拟存储管理下，内存逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，每位的成本却接近于外存 工作原理基于局部性原理，程序运行前，不需全部装入内存，仅装入当前要运行的部分页面或段即可，其余部分暂留在外存上 在程序运行时，如果要访问的页或段已调入内存，便可继续执行下去 如果要访问的页或段尚未调入内存（缺页/缺段） ，会发出缺页/缺段中断请求，程序利用 OS 所提供的请求调页/调段功能，将它们调入内存，使程序继续执行 在调入需要的页或段时，如果内存已满，无法再装入新页/新段，那么会通过置换功能将内存中暂时不用的页或段调至外存，腾出足够的内存空间 实现虚拟存储管理允许将一个作业分多次调入内存，离散分配方式是其基础，目前所有的虚拟存储器都是采用下述两种方法之一实现的： 请求分页系统：在分页系统的基础上，增加了请求调页功能和页面置换功能 请求分段系统：在分段系统的基础上，增加了请求调段功能和分段置换功能","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"离散分配存储方式","slug":"operating-system/29.离散分配存储方式","date":"2019-12-06T13:49:01.000Z","updated":"2021-10-24T14:22:59.913Z","comments":true,"path":"notes/operating-system/38664e9a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/38664e9a.html","excerpt":"【概述】连续分配存储方式会形成许多碎片，虽然可通过紧凑的方法将许多碎片拼接成可用的大块空间，但须付出很大的开销 如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存空间，无须再进行紧凑操作","text":"【概述】连续分配存储方式会形成许多碎片，虽然可通过紧凑的方法将许多碎片拼接成可用的大块空间，但须付出很大的开销 如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存空间，无须再进行紧凑操作 基于上述思想，产生了离散分配存储方式，根据离散分配存储方式在分配地址空间的基本单位的不太，可分为三类： 分页存储管理：将用户程序的地址分为若干固定大小的区域（页），再将内存空间划分为同样大小的若干区域，从而将用户程序的任一页放入任一块中 分段存储管理：将用户程序的地址空间划分为若干大小不同的段，每段定义成一组相对完整的信息。在分配时，以段为单位，这些段在内存中可以不相邻 段页式存储管理：分页与分段两种存储方式相结合的产物 【基本概念】页面与物理块分页存储管理将进程的逻辑地址空间划分为若干页，并将各页加以编号，例如：第 0 页，第 1 页等 相应的，也将内存的物理地址空间划分为若干块，也为他们加以编号，例如：0#块，1#块等 需要注意的是，逻辑划分的页大小=物理划分的块大小 在为进程分配内存时，以块为单位，将进程中的若干页分别装入到多个可不相邻的物理块中。 在分页系统中，若页面大小过大，那么会导致进程的最后一页经常装不满一块，从而形成了不可利用的页内碎片；若页面大小过小，那么虽然可以减少页面碎片，提高了利用率，但每个进程的页面数量较多，使得页表过长，反而大量占用内存。 因此，在页面大小应选择适中，且页面大小应为 $2$ 的幂，一般为 1KB~8KB 分页地址的地址结构分页地址的结构包含两部分内容：前一部分为页号 P，后一部分为位偏移量(页内地址) W。 以下图为例，地址长度为 $32$ 位，$0$ 到 $11$ 位为页内地址，即每页大小为 $2^{12}=4K$，$12$ 到 $31$ 位为页号，即地址空间最多运行有 $2^{20}=1M$ 页 若给定一个逻辑地址空间中的地址为 $A$，页面大小为 $L$，则页号 $P$ 和页内地址 $W$ 可按下式求得： \\begin{cases} P&=&INT[\\frac{A}{L}]\\\\ W&=&[A]\\:\\%\\:L \\end{cases}其中，$INT$ 是整除函数 例如，某系统页面大小为 $1KB$，其逻辑地址为 $2170B$，那么有： \\begin{cases} P=INT[\\frac{2170B}{1024B}]=2\\\\ W=2170B\\:mod \\: 1024B=122 \\end{cases}页表在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程能在内存中找到每个页面所对应的物理块，系统为每个进程创建了一张页面映像表，即页表 在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，进程每次执行时，通过查找该表，即可找到每页在内存中的物理块号，简单来说，页表的作用就是实现从页号到物理块号的地址映射 【分页存储管理】地址变换机构作用地址变换机构用于将用户地址空间中的逻辑地址转为内存空间中的物理地址 由于页内地址与物理地址是一一对应的，因此地址变换机构的任务实际上只是将逻辑地址中的页号转为内存中的物理块号，又因为页表的作用就是实现页号到块号的变换，因此，地址变化任务是借助于页表完成的 基本地址变换结构系统中设置了一个页表寄存器(PTR)，在其中存放页表在内存的起始地址和页表的长度 在进程未执行时，页表的起始地址和页表长度存放在本进程的 PCB 里，当调度程序调度到某进程时，将这两个数据装入 PTR 中 每执行一条指令时，根据计算分页得到指令的页号与内部偏移量，然后 CPU 高速访问 PTR 找到对应页表位置 最后查找页表数据，得到指令页号实际对应存放的物理块，完成地址映射计算，最终在内存中找到该指令 具快表的地址变换结构在基本分页机制下，CPU 操作一条指令需访问内存两次，一次访问内存中的页表，以计算指令所在的实际物理地址，一次根据计算出的实际物理地址去进行访问 因此，一次指令需要两次内存访问，虽然分页空间利用率提高，但这使得处理机速度降低了一半 为提高地址变换速度，可在地址变换机构中增设一具有并行查寻能力的高速缓存器，即快表（TLB），以存放当前访问的页表项 在加入快表之后，地址变换过程也有了改变： 在 CPU 给出有效地址后，地址变换机构自动地将页号送入快表，并将此页号与快表中的所有页号进行比较 若有相匹配的页号，表示要访问的页表项在快表中，因此可直接从快表中读出相应的物理块号，并送入物理地址寄存器；若没有相匹配的页表项，则还需访问内存中的页表，找到后将物理号送往物理地址寄存器，同时将该表项送入快表 若快表已满，则 OS 找到一个已被认为不再需要的页表项，进行替换 内存访问有效时间进程发出逻辑地址的访问请求，经过地址变换，到内存中找到对应的实际物理地址单元并取出数据，所需花费的总时间，称为内存有效访问时间（EAT） 在基本地址变换结构中，设访问一次内存的时间为 $T$，那么 EAT 就等于查找页表对应页表项耗费的时间 T 与将页表的物理块号与页内地址拼接成实际物理地址耗费的时间 $T$ 的和，即： EAT=T+T而在引入了快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页对应的物理块，减少了一次内存访问，缩短了内存访问有效时间 但由于快表容量有限，因此在快表中查找表项存在命中率，即使用快表并在其中成功找到所需页面表项的比率 设 $\\lambda , a, T$ 分别为查找快表所需时间、命中率、访问一次内存所需时间，那么 EAT 的计算公式为： EAT = a \\lambda + (1-a) ( T + \\lambda ) + T =2T - aT + \\lambda二级页表与多级页表概述由于目前大多数计算机都支持非常大的逻辑地址空间，在这样的环境下，页表就变得非常大，此外，由于页表要求连续，又要占用相当大的内存空间，系统并无法提供大的连续的内存空间来存放页表 为解决上述问题，可再用下述两个方法解决： 对页表所需的内存空间，采用离散分配方式 只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入 对于 $32$ 位的系统，采用两级页表即可，但对于 $64$ 位的系统，两级仍无法解决页表过大的问题，此时，按照二级页表的原理，继续分页下去，可形成多级页表 地址结构针对难以找到大的连续的内存空间来存放页表的问题，可以将页表进行分页，使每个页面的大小与内存物理块的大小相同，并将他们进行编号，即依次为：0#页，1#页，2#页，…，n#页，然后离散地将各个页面分别存放于不同的物理块中 同样，将离散分配的页表再建立一张页表，称为外层页表，在每个表项下记录了页表页面的物理块号 二级页表的地址结构包含三部分内容：前一部分为外页号 P1，中间一部分为外页内地址(页在外页内的偏移) P2，后一部分为位偏移量(页内地址) W 以下图为例，地址长度为 $32$ 位，$0$ 到 $11$ 位为页内地址，即每页大小为 $2^{12}=4K$，$12$ 到 $21$ 位为外页内地址，即每页最多有 $2^{10}$ 个页表项，$22$ 到 $31$ 位为外页号，即最多允许有 $2^{10}$ 个页表分页 地址变换机构在地址变换机构中，增设了一个外页表寄存器，用于存放外页表的起始地址，并利用逻辑地址中的外层页号作为外层页表的索引，从中找到指定页表分页的起始地址，再利用 P2 作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号 $P$ 和页内地址 $W$ 即可访问内存的物理地址。 请求调页上述对页表实行离散分配的方法，虽然解决了对于大页表无需大片连续存储空间的问题，但并未解决用较少的内存空间去放大页表的问题 换言之，只用离散分配空间的方法并未减少页表所占用的内存空间 能够用较少的内存空间存放页表的唯一方法是：仅将当前需要的一批页表项调入内存，以后再根据需要陆续调入 反置页表在分页系统中，每个进程配置了一张页表，进程逻辑地址空间中的每一页，在页表中都要有一个页表项，这就占用了大量的内存空间 为减少页表占用的内存空间，由此引入了反置页表 反置页表为每一物理块设置了一个页表项，并将他们按物理块的编号排序，其中的内容则是已调入内存的进程标识符与页号 在利用反置页表进行地址变换时，根据进程标识符与页号，去进行检索 若检索到匹配的页表项，说明该页表项中的序号 i 便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送入内存地址寄存器；若未检索到匹配的页表项，说明此页未调入内存 当内存容量很大时，反置页表的页表项还是会很大，利用进程标识符和页号去检索一张大的线性表很费时，此时可利用哈希算法来提高检索速度 【分段存储管理】段分段存储管理方式的目的，主要是为了满足用户在编程和使用上多方面的要求，一方面，通常的程序都可以分成若干段，如：主程序段、子程序段、数据段、栈段等，每个段大多是一个相对独立的逻辑单位；另一方面，实现和满足信息共享、信息保护、动态链接、信息动态增长等需要，都是以段为基本单位的 在分段存储管理中，作业的地址空间被划分为若干段，每个段定义了一组逻辑信息，其具有如下特点： 每个段都有自己的名字，为实现简单，通常用一个段号来代替段名 每个段都从 $0$ 开始编址，并采用一段连续的地址空间 段的长度由相应的逻辑信息组的长度决定，因此各段的长度并不相等 整个作业的地址空间由于被分成多个段，因此呈现出二维特性，即每个段既包含了一部分地址空间，又标识了逻辑关系 编译程序自动地根据源程序的情况进行分段 分段地址的地址由段号 $S$ 和段内地址 $W$ 两部分构成，以下图为例：一个作业最多有 $2^{16}=64K$ 个段，每个段的最大长度为 $2^{16}=64KB$ 段表在分段存储管理系统中，为每个分段分配一个连续的分区，进程中的各个段，可以离散地装入内存中不同的分区 为保证程序正常运行，就必须能从物理内存中找出每个逻辑段所对应的位置 为此，类似于分页系统，在分段系统中，需为每个进程建立一张段映射表（段表），用于实现从逻辑段到物理内存区的映射，每个段在表中占有一个表项，其中记录了该段在内存中的起始位置与段的长度 地址变换机构为实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表起始地址和段表长度 在进程地址变换时，系统将逻辑地址中的段号 $S$ 与段表长度 $TL$ 进行比较： 若 $S&gt;TL$，说明访问越界，产生越界中断；若 $S&lt;=TL$，说明未产生越界情况，进行以下操作： 根据段表起始地址和该段段号，计算该段对应段表项位置，从中读出该段在内存中起始地址 检查段内地址 $W$ 是否超过该段的段长 $SL$： 若 $W&gt;SL$：访问越界，产生越界中断信号 若 $W&lt;=SL$： 未产生越界情况，将该段的基址 $W$ 与段内地址相加，得到要访问的物理地址 与分页系统相似，当段表放入内存时，每要访问一个数据，都要访问内存两次，这成倍的降低了计算机的速率 而解决的方法也与分页系统相似，即增设一个联想存储器，用于保存最近常用的段表项 分页与分段的区别不难看出，分页与分段有许多相似之处，但在概念上，两者完全不同，主要表现在以下方面： 需求：分页是出于系统管理的需要，是信息的物理划分单位；分段是出于用户应用的需要，是逻辑单位，常包含一组意义相对完整的信息 大小：页的大小由系统固定，段的大小则不固定 碎片：分页存在内碎片，分段存在外碎片 逻辑地址：分页是一维的，各模块在链接时必须组织成同一个地址空间；分段是二维的，各个模块在链接时可以每个段组织成一个地址空间 其他：通常段比页大，因此段表比页表短，可以缩短查找时间，提高访问速度；分段可针对不同类型采取不同的保护，还可以按段为单位来进行共享 信息共享分段系统的突出优点主要有两点，一是易于实现段的共享，而是易于实现信息保护 段的共享，是指若干进程共享一个或多个分段，由于在分段系统中，是以段为基本单位的，因此，实现共享只需在每个进程的段表中为共享程序设置一个段表项 信息保护，主要是代码的保护，这与其逻辑意义有关，因此成段的进行保护要远胜于分页的机械式划分 【段页式存储管理】基本原理分页系统是以页面为内存分配的基本单位，能有效地提高内存利用率；分段系统以段为内存分配的基本单位，能更好地满足用户多方面的需要 如果对两种存储管理方式各取所长，那么就形成了一种新的存储器管理方式——段页式存储管理，其既有分段系统的便于实现、易于保护、分段可共享、可动态链接的优点外，还能像分页系统那样很好地解决内存的外碎片问题 段页式系统的基本原理是分页与分段的结合，其先将用户程序分为若干段，再将每段分为若干页，地址结构由段号 $S$、段内页号 $P$、页内地址 $W$ 三部分构成 在段页式系统中，为实现逻辑地址到物理地址的变换，系统中需要同时配置段表和页表 段表的内容与分段系统中的段表略有不同，其不再是内存的起始地址与段长，而是页表的起始地址和页表长度 地址变换过程在段页式系统中，为实现地址变换，须配置一个段表寄存器，其中存放段表起始地址与段长 在进行地址变换时，首先将段号 $S$ 与段长 $TL$ 进行比较：若 $S&gt;TL$：说明访问越界，产生越界中断；若 $S&lt;=TL$：说明未越界，进行下述操作： 利用段表起始地址、段号，求出该段所对应的段表项在段表中的位置，得到该段的页表起始地址 利用逻辑地址中的段内页号 $P$ 获得对应页的页表项位置，从中读出该页所在的物理块号 $b$ 利用物理块号 $b$ 与页内地址构成物理地址 在段页式系统中，为获取一条指令或数据，需要访问内存三次： 访问内存中的段表，获取页表起始地址 访问内存中的页表，获取该页所在的物理块号，并将块号与页内地址一起组成物理地址 访问从第二次访问中所得的地址，取出指令或数据 显然这拖慢了执行速度，为此，在地址变化机构中增设了一个高速缓存寄存器","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"连续分配存储方式的对换技术","slug":"operating-system/28.连续分配存储方式的对换技术","date":"2019-12-03T14:13:00.000Z","updated":"2021-10-24T13:59:41.036Z","comments":true,"path":"notes/operating-system/9bce8aff.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/9bce8aff.html","excerpt":"【概述】对换技术也称交换技术，由于早期计算机的内存十分小，为使系统能分时运行多个用户程序而引入了对换技术 系统将所有用户作业放入磁盘，每次只调用一个作业进入内存，当该作业的一个时间片用完时，将他调至外存的后备队列上等待，再从后备队列上将另一个作业调入内存","text":"【概述】对换技术也称交换技术，由于早期计算机的内存十分小，为使系统能分时运行多个用户程序而引入了对换技术 系统将所有用户作业放入磁盘，每次只调用一个作业进入内存，当该作业的一个时间片用完时，将他调至外存的后备队列上等待，再从后备队列上将另一个作业调入内存 对换技术是早期分时系统上的技术，现在已很少使用 【多道程序环境下的对换技术】对换是改善内存利用率的有效措施，其可以直接提高处理机的利用率和系统的吞吐量 对换是将内存中暂时不能运行、或暂时不用的程序和数据调到外存上，以腾出足够的内存，把已具备运行条件的进程和进程所需要的程序和数据调入内存 根据每次对换时所对换的数量，可将对换分为两类： 整体对换（进程对换）：处理机的中级调度功能实质上就是存储器的对换功能，其以整个进程为单位 页面对换（分段对换）：以页或段为单位进行对换，是请求分页和请求分段式存储管理的基础 【对换空间的管理】在具有对换功能的 OS 中，通常将磁盘空间分为文件区和对换区两部分，对比如下： 外存 存储内存 驻留时间 主要目标 分配方式 文件区 文件 较长久不频繁 提供文件存储空间利用率 离散 对换区 从内存换出的进程 短暂频繁 提高进程换入和换出的速度 连续 此外，还需在对换区设置相应的数据结构，用于记录外存对换区中的空闲盘块的使用情况 其数据结构形式与内存在动态分区分配方式中的数据结构类似，即可利用空闲分区表或空闲分区链表，每个表目包含两项：对换区的首地址、对换区的大小，分别用盘块号和盘块数来表示 由于对换分区的分配采用的是连续分配方式，因而对换空间的分配与回收和动态分区方式时的内存分配与回收相同","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"连续分配存储方式","slug":"operating-system/27.连续分配存储方式","date":"2019-12-02T03:12:54.000Z","updated":"2021-10-24T13:53:51.312Z","comments":true,"path":"notes/operating-system/a9903dd1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/a9903dd1.html","excerpt":"【概述】连续分配方式是最早出现的一种存储器分配方式，曾被广泛应用于上世纪 60~80 年代的 OS 中，该分配方式为一个用户分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻 连续分配方式根据发展，可分为四类：","text":"【概述】连续分配方式是最早出现的一种存储器分配方式，曾被广泛应用于上世纪 60~80 年代的 OS 中，该分配方式为一个用户分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻 连续分配方式根据发展，可分为四类： 单一连续分配：将内存分为用户区和系统区，同一时刻下只允许一个程序在用户区运行 固定分区分配：将整个用户空间划分为若干固定大小的区域，在每个区域中只装入一道作业 动态分区分配：根据进程的实际需要，动态地为之分配内存空间 动态可重定位分区分配：在动态分区分配的基础上，加了紧凑功能，且设置重定位寄存器，在程序执行期间，随着对每条指令或数据的访问自动执行重定位 【单一连续分配】在单道环境下，存储器的管理方式是将内存分为系统区和用户区两部分： 系统区：放在内存的低址部分，仅提供给 OS 使用 用户区：除系统区外的全部内存空间，提供给用户使用 值得注意的是，在单一联系分配方式中，用户区一般仅装有一道用户程序，即同一时刻，只有一个程序占用内存用户区的全部空间 单一连续分配方式是最简单的一种存储管理方式，只能用于单用户、单任务的 OS 中，其优点是便于管理，缺点是对要求内存很少的程序造成了极大的内存浪费 【固定分区分配】基本原理为能在内存中装入多道程序，且这些程序之间又不会发生干扰，于是将整个用户空间划分为若干固定大小的区域，在每个区域中只装入一道作业，这就形成了最早的、可运行多道程序的分区式存储管理方式 固定分区分配方式的分区总数是固定的，这就限制了并发执行的程序数目，此外，由于内存分配是固定的，可能会出现内碎片而造成浪费，即一个分区内分配程序后存在剩余空间 分区在固定分区分配中，将内存的用户空间划分为若干固定大小的分区有以下两种方式： 分区大小相等：适用于多个相同程序的并发执行，缺乏灵活性 分区大小不等：划分为多个小分区、适量的中等分区、少量的大分区，根据程序的大小，分配当前空闲的、大小适当的分区 进行分区划分时，需要建立一个记录相关信息的分区表，表项值随着内存的分配和释放而动态进行改变，表项有： 起始位置：分区地址的开始位置 分区大小：分区的大小 分区状态：是否已分配 分配过程为简化分配过程，常将分区表根据分区状态分为两张表：空闲分区表、占用分区表 在进行分配时，检索空闲分区表，寻找一个满足要求且尚未分配的分区，并分配给请求程序，若未找到大小足够的分区，则拒绝为该用户程序分配内存 空闲分区表可能按照不同的分配算法而采用不同方式对表象进行排序 【动态分区分配】基本原理动态分区分配又称可变分区分配，其是根据进程的实际需要，动态地为之分配内存空间 该方式的并发进程数没有固定的限制，因此不会产生内碎片，但由于动态分区分配算法的设计，存在外碎片，即分区之间无法利用的空间 数据结构在实现动态分区分配时，要配置相应的数据结构，来描述空闲分区和已分配分区的情况，为分配提供依据，常用的数据结构有以下两种： 空闲分区表：记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区号、分区大小、分区起始位置 空闲分区链表：为实现对空闲分区的分配、链接，在每个分区的起始位置设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针、后向指针，通过前、后向链接指针，将所有的空闲分区链成一双向链表 动态分区分配算法首次适应算法首次适应（First Fit，FF）算法是一种顺序搜索算法，其要求空闲分区链以地址递增的次序链接 在分配内存时，首先从链首开始顺序查找直至找到一个大小能满足要求的空闲分区，然后从该分区中划出一块作业要求大小的内存空间分配给请求者，余下的空闲分区大小改变仍留在空闲链中 若从链表到链尾都检索不到满足要求的分区，则分配失败 该算法优先利用内存低址部分，而保留了高地址部分的大空闲区，但随着低址部分不断划分，会产生外碎片，而且每次查找从低址部分开始，会逐渐增加查找开销 循环首次适应算法循环首次适应（Next Fit，NF）算法是一种顺序搜索算法，其要求空闲分区链以地址递增的次序链接 在分配内存时，不再是每次从链首开始寻找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直到找到一个能满足要求的空闲分区 为实现该算法，应设置一起始查找指针，用于指示下一次起始查找的空闲分区，同时采用循环查找方式 该算法能使内存中的空闲分区分布更加均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区 最佳适应算法最佳适应（Best Fit，BF）算法是一种顺序搜索算法，其要求空闲分区按容量从小到大排成空闲分区表 在分配内存时，从分区表的头部开始检索，找到的第一个满足大小的空闲分区就进行分配 宏观上来看最佳适应算法是最佳的，但每次找到最合适大小的分区割下的空闲区也总是最小的，这就会产生外碎片 最坏适应算法最坏适应（Worst Fit，WF）算法是一种顺序搜索算法，其要求空闲分区按容量从大到小排成空闲分区表 在分配内存时，从分区表的头部开始检索，总是选择一个最大的空闲区，从中割一部分存储空间给作业使用 该算法与最佳适应算法正好相反，其能使得剩下的空闲区不至于太小，产生外碎片的可能性也就变小，对中、小型作业较为有利，但会出现缺乏较大的空闲分区的情况 快速适应算法快速适应算法（Quick Fit，QF）算法是一种基于索引搜索算法，其是将空闲分区根据容量大小进行分类，对于每一类具有相同容量的空闲分区，单独设立一个空闲分区链表 同时，在内存中设立一张管理索引表，其中的每一个索引表项都对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针 在分配内存时，首先根据进程长度从索引表中去寻找容纳它的最小空闲分区链表，然后从链表中取下第一块进行分配 该算法在进行空闲分区分配时，不会对任何分区产生分割，因此能保留大分区，也不会产生内存碎片，但分区归还时算法较为复杂，系统开销较大 伙伴系统伙伴系统规定，无论是已分配分区还是空闲分区，其大小均为 $2$ 的 $k$ 次幂，且 $1 \\leq k \\leq m$，通常 $2^m$ 为可分配内存的大小，即最大分区大小 在系统运行过程中，内存被不断划分，形成若干不连续的空闲分区，对每一类具有相同大小的空闲分区设置一双向链表，会有 $k$ 个链表，链表中的分区大小都是 $2^m$ 当进程申请 $n$ 个大小的空间时，计算一个 $i$ 值，使得 $2^{i-1} &lt; n \\leq 2^i$，然后在空闲分区大小为 $2^i$ 的空闲分区链表中查找 若找到，则将空闲分区分配给进程，否则表明长度为 $2^i$ 的空闲分区已耗尽，则在分区大小 $2^{i+1}$ 的空闲分区链表中查找 若存在 $2^{i+1}$ 的一个空闲分区，则将该空闲分区化为两个大小相等的 $2^i$ 的空闲分区，这两个分区称为一对伙伴，其中一个用于分配，另一个加入分区大小为 $2^i$ 的空闲分区链表中 若 $2^{i+1}$ 大小的空闲分区不存在，则去寻找 $2^{i+2}$ 大小的空闲分区，若找到则将其进行两次分割，若找不到继续寻找 $2^{i+3}$ 大小的空闲分区，以此类推 哈希算法哈希算法，是利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一表项记录了一个对应的空闲分区链表表头指针 当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略 分区分配操作分配内存分配内存是指利用某种分配算法，从空闲分区表中找到所需大小的分区 设请求分区大小为 u.size，表中每个分区大小为 m.size，则流程如下： 回收内存当进程运行完毕释放内存时，系统根据回收区的首地址，从空闲分区表中找到相应的插入点，此时可能会出现以下四种情况： 回收分区上邻接一个空闲分区：合并后首地址为空闲分区首地址，大小为二者之和 回收分区下邻接一个空闲分区：合并后首地址为回收分区首地址，大小为二者之和 回收分区上下邻接空闲分区：合并后首地址为上空闲分区首地址，大小为三者之和，删除下邻 回收分区不邻接空闲分区：在空闲分区表新建一表项，并填写分区大小等信息 【动态可重定位分区分配】紧凑当使用连续分配方式一段时间后，内存空间会被分割成多个小分区，从而缺乏大的空闲空间，此时这些分散的小分区的容量总和要大于要装入的程序，但由于这些分区不邻接，因此无法装入 若想将大作业装入，常用的一种方法是紧凑：将内存中所有作业进行移动，让他们全部邻接，使得原来分散的多个空闲小分区拼接成一个大分区，从而可以将作业装入 虽然紧凑可以获得大的空闲空间，但经过紧凑后的用户程序在内存中的地址发生了变换，此时需要对程序和数据的地址进行修改 为了提高内存的利用率，系统在运行过程中需要经常紧凑，而每紧凑一次，就要对移动了的程序和数据的地址进行重定位，这极大的影响了系统效率 动态重定位在动态分区分配的方式中，作业装入内存后的所有地址仍是逻辑地址，而将逻辑地址转为物理地址的工作被推迟到程序指令要真正执行时进行 为使地址的转换不影响指令的执行速度，动态可重定位分区分配在动态分区分配的基础上，加了紧凑功能 同时，在系统中设置一个重定位寄存器，作为硬件地址变换机构，即用来存放程序或数据在内存中的起始地址，在程序执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而成的 地址变换过程是程序执行期间，随着对每条指令或数据的访问自动执行的，因此称为动态重定位 动态重定位分区分配算法与动态分区分配算法基本相同，差别在于增加了紧凑的功能 动态重定位能较好的解决紧凑的问题，当系统对内存进行了紧凑，使得若干程序从内存的某处移动到另一处时，不需对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"内存管理的基本概念","slug":"operating-system/26.内存管理的基本概念","date":"2019-11-28T07:38:17.000Z","updated":"2021-10-24T13:37:05.052Z","comments":true,"path":"notes/operating-system/f7efe948.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/f7efe948.html","excerpt":"【存储器管理功能】内存管理即对存储器进行管理，主要完成以下任务： 内存分配：为每道程序分配内存空间，以提高存储器的利用率，根据分配方式分为：静态分配、动态分配 内存保护：确保每道用户程序只在自己的内存空间中运行，通过界限寄存器来存放正在执行进程的内存上下界，在程序运行时，对每条指令的访问地址进行越界检查 地址映射：实现进程的逻辑地址到内存物理地址的映射，在程序编译时形成的目标程序地址是逻辑地址，都是从 0 开始，而真正调入内存某个空间存放的地址是物理地址 内存扩充：用虚拟存储技术来从逻辑上扩充内存容量，以解决内存容量不足的问题，利用内存扩充机制，来实现请求调入功能与页面置换功能","text":"【存储器管理功能】内存管理即对存储器进行管理，主要完成以下任务： 内存分配：为每道程序分配内存空间，以提高存储器的利用率，根据分配方式分为：静态分配、动态分配 内存保护：确保每道用户程序只在自己的内存空间中运行，通过界限寄存器来存放正在执行进程的内存上下界，在程序运行时，对每条指令的访问地址进行越界检查 地址映射：实现进程的逻辑地址到内存物理地址的映射，在程序编译时形成的目标程序地址是逻辑地址，都是从 0 开始，而真正调入内存某个空间存放的地址是物理地址 内存扩充：用虚拟存储技术来从逻辑上扩充内存容量，以解决内存容量不足的问题，利用内存扩充机制，来实现请求调入功能与页面置换功能 【存储器的层次结构】层次结构对于通用计算机，存储层次至少应具有三层：CPU 寄存器、主存、辅存 根据具体的功能，可细分为：寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质 在存储层次中，层次越高，存储介质的访问速度就越快，价格也就越昂贵，相对所配置的存储容量也就越小 主存储器主存储器又称内存、主存、可执行存储器，是计算机系统中的主要部件，用于保存进程运行时的程序和数据 通常，处理机都是从主存储器中取得指令和数据，并将所取得的指令放入指令寄存器中，将数据放入数据寄存器中，反之，也可将寄存器中的内容放入主存 由于主存访问速度远低于 CPU 执行指令的速度，为缓和这一矛盾，在及计算机系统中引入了寄存器与高速缓存 寄存器寄存器与处理机具有相同的速度，因此对寄存器的访问速度是最快的，完全能与 CPU 协调工作，但价格十分昂贵，因此容量并不是很大 在当前的计算机中，寄存器的数目有数十至上百个，字长一般是 32 位或 64 位 高速缓存高速缓存是介于寄存器与存储器之间的存储器，主要用于备份主存中常用的数据，以减少处理机对主存的访问次数，从而大幅度提高程序执行速度 高速缓存的容量远大于寄存器，只比主存小二到三个数量级左右，访问速度快于主存 由于高速缓存的速度越高价格越贵，因此在计算机中设置了二级或多级告诉缓存，紧靠内存的一级高速缓存速度最高，容量最小，最低级的高速缓存容量速度最慢，容量最大 磁盘缓存由于目前磁盘的 I/O 速度远低于对主存的访问速度，为缓和两者在速度上的不匹配，因此设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据与信息，以减少访问磁盘的次数 但磁盘缓存与高速缓存不同，其本身并不是一种实际存在的存储器，而是利用主存中的部分空间暂时存放从磁盘中读写的信息 【存储方式】连续分配存储方式连续分配存储方式是最早出现的一种存储器分配方式，曾被广泛应用于上世纪 60~80 年代的 OS 中，该分配方式为一个用户分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻 连续分配方式根据发展，可分为四类： 单一连续分配：将内存分为用户区和系统区，同一时刻下只允许一个程序在用户区运行 固定分区分配：将整个用户空间划分为若干固定大小的区域，在每个区域中只装入一道作业 动态分区分配：根据进程的实际需要，动态地为之分配内存空间 动态可重定位分区分配：在动态分区分配的基础上，加了紧凑功能，且设置重定位寄存器，在程序执行期间，随着对每条指令或数据的访问自动执行重定位 离散分配存储方式连续分配存储方式会形成许多碎片，虽然可通过紧凑的方法将许多碎片拼接成可用的大块空间，但须付出很大的开销 如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存空间，无须再进行紧凑操作 基于上述思想，产生了离散分配存储方式，根据离散分配存储方式在分配地址空间的基本单位的不太，可分为三类： 分页存储管理：将用户程序的地址分为若干固定大小的区域（页），再将内存空间划分为同样大小的若干区域，从而将用户程序的任一页放入任一块中 分段存储管理：将用户程序的地址空间划分为若干大小不同的段，每段定义成一组相对完整的信息。在分配时，以段为单位，这些段在内存中可以不相邻 段页式存储管理：分页与分段两种存储方式相结合的产物","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"程序的链接与装入","slug":"operating-system/25.程序的链接与装入","date":"2019-11-27T09:34:00.000Z","updated":"2021-10-21T14:43:45.851Z","comments":true,"path":"notes/operating-system/26af09e7.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/26af09e7.html","excerpt":"【程序链接与装入】用户程序要在系统中运行，必须先将其装入内存，然后再将其转变为一个可执行的程序，通常要执行以下步骤： 编译：由编译程序对用户源程序进行编译，形成若干个目标模块 链接：由链接程序将编译后形成的一组目标模块及他们所需要的库函数链接在一起，形成一个完整的装入模块 装入：由装入程序将装入模块装入内存","text":"【程序链接与装入】用户程序要在系统中运行，必须先将其装入内存，然后再将其转变为一个可执行的程序，通常要执行以下步骤： 编译：由编译程序对用户源程序进行编译，形成若干个目标模块 链接：由链接程序将编译后形成的一组目标模块及他们所需要的库函数链接在一起，形成一个完整的装入模块 装入：由装入程序将装入模块装入内存 其中，在程序链接、装入的过程中，围绕着地址进行处理 【地址】逻辑地址逻辑地址又称相对地址、虚地址，当用户的程序经过汇编或编译后形成的代码，目标代码中的指令地址即为相对地址 一般来说，逻辑地址首地址为 $0$，其余指令中的地址都相对于首地址来编址，需要注意的是，不能利用逻辑地址在内存中读取信息 物理地址物理地址又称绝对地址、实地址，内存中存储单元的地址即为实地址，其可以直接寻址被执行 地址映射将用户程序中的逻辑地址转换为运行时机器直接寻址的内存物理地址的过程，称为地址映射 简单来说，地址映射，就将用户程序的第 $x$ 字节处的指令，转换为内存的第 $y$ 个地址上 【链接】概述源程序经过编译后，可得到一组目标模块 链接程序的功能是将这组目标模块及其所需要的库函数装配成一个完整的装入模块 在对目标模块进行链接时，根据进行链接的时间不同，可分为静态链接、装入时动态链接、运行时动态链接三种 静态链接静态链接，是指在程序运行前，将各目标模块及其所需的库函数链接成一个完整的装配模块，以后不再拆开，其需要解决两个问题： 对相对地址进行修改 变换外部调用符号 装入时动态链接装入时动态链接，是指讲用户源程序编译后所得的一组目标模块，在装入内存时，采用边装入边链接的方式 简单来说，在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去寻找相应的外部目标模块，并将他装入内存，同时，还要修改目标模块中的相对地址 装入时动态链接具有以下优点： 便于修改、更新：相对于静态链接方式，如果要修改某个模块，需要重新打开装入模块进行修改，而采用装入时动态链接，由于各目标模块是分开存放的，因此要修改或更新十分方便 便于实现对目标模块的共享：采用静态链接方式时，每个应用模块都必须含有其目标模块的拷贝，即 n 个程序就需要 n 次拷贝，但采用装入时动态链接的方式，OS 会十分容易将一个目标模块链接到几个应用模块上，从而实现多应用程序的共享 运行时动态链接在许多情况下，应用程序在运行时，每次要运行的模块可能是不相同的，但由于实现无法知道本次要运行哪些模块，因此只能将可能要运行到的所有模块链接后装入内存，这无疑是低效的 比较典型的例子就是错误处理时的目标模块，如果程序在运行过程中不出现错误，那么这么模块将不会用到 运行时动态链接是对上述链接方式的一种改进，其将某些模块的链接推迟到程序执行时才进行 简单来说，在程序执行过程中，当发现一个被调用模块尚未装入内存时，立即由 OS 去找到该模块，将其链接到调用者模块上，并装入内存 【装入】绝对装入方式当计算机系统很小，且仅能运行单道程序时，完全有可能知道程序将驻留在内存的什么位置，此时可采用绝对装入方式 用户程序经编译后，将产生物理地址的目标代码，绝对装入程序便可按照装入模块中的地址，将程序与数据装入内存，装入模块被装入内存后，由于程序中的逻辑地址与物理地址完全相同，因此不需要对程序和数据的地址进行修改 绝对装入方式具有装入过程简单，不需任何地址变换，程序中的逻辑地址与实际内存物理地址完全相同等优点，但其过于依赖硬件结构,，只适用早期针对硬件直接编程、单道环境 静态可重定位装入方式重定位是指将目标程序中的指令和数据的逻辑地址变成内存中的物理地址的地址变换过程。 静态可重定位装入方式是将逻辑地址经过重定位后，转为物理地址，再进行装入。 地址映射在程序执行之前进行，重定位后物理地址不再改变，可由专门设计的重定位装配程序完成，在装入时根据所定位的内存地址去修改每个逻辑地址，添加相应偏移量，重定位为物理地址 静态可重定位装入方式不需硬件支持，可以装入有限的多道程序，但要求软件装入一次完成，这就造成一个程序通常需要占用连续的内存空间，程序装入内存后不能移动，也不易实现共享 动态运行时装入方式在实际运行中，往往会需要程序在内存中的各位置移动，即经常需要将逻辑地址重定位到不同的物理地址上 这种运行时移动程序要求地址变换要快速，实现时一般依靠重定位寄存器来变换地址 动态运行时装入，可多次重定位到不同位置，即可以不将装入模块中的逻辑地址立刻转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"死锁检测与死锁解除","slug":"operating-system/24.死锁检测与死锁解除","date":"2019-11-26T04:49:13.000Z","updated":"2021-10-19T14:35:25.679Z","comments":true,"path":"notes/operating-system/f1df5f02.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/f1df5f02.html","excerpt":"【死锁检测】死锁检测通过检测系统状态，以确定系统中是否发生死锁 为了能对系统中是否发生死锁进行检测，在系统中，必须满足：","text":"【死锁检测】死锁检测通过检测系统状态，以确定系统中是否发生死锁 为了能对系统中是否发生死锁进行检测，在系统中，必须满足： 保存有关资源的请求与分配信息 提供一种利用信息检测系统是否进入死锁的算法 资源分配图资源分配图，是由点集 $V$ 与边集 $E$ 组成的一个图 $G(V,E)$，其定义为： 将 $V$ 分为两个互斥的子集，一组是用圆圈表示的进程结点 $P$，一组是方框表示的资源结点 $R$ 凡属于 $E$ 中的一个边 $e$，都连接着 $P$ 中的一个结点与 $R$ 中的一个结点，$e= &lt; P_i,R_i &gt; $ 是资源请求边，$e= &lt; R_i, P_i &gt;$ 是资源分配边 死锁定理利用资源分配图的简化来检测死锁，流程如下： 在资源分配图中找出一个既不阻塞又非独立的进程结点 $P_i$，在顺利的情况下运行完毕，释放其占有的全部资源 由于释放了资源，这样能使其它被阻塞的进程获得资源继续运行，从而消去了 $P_i$ 的边 经过一系列简化后，若能消去图中所有边，使结点都孤立，称该图是可完全简化的 因此，死锁定理内容为：当且仅当 $S$ 状态的资源分配图是不可完全简化的，$S$ 状态即为死锁状态 【死锁解除】若利用死锁检测算法检测出系统中已发生死锁，那么应立即采取相应的措施，以解除死锁 常采用的解除死锁方法有三种： 资源剥夺法：挂起某些死锁进程，并抢占其资源分配给其他死锁进程，需要防止被挂起的进程饥饿 撤销进程法：强制终止部分甚至全部死锁进程，并剥夺资源，实现简单，但会使前一段工作失效 进程回退法：让一或多个进程退回到可避免死锁的地步，要求系统记录进程历史信息，设置还原点","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"死锁预防与死锁避免","slug":"operating-system/23.死锁预防与死锁避免","date":"2019-11-25T11:23:25.000Z","updated":"2021-10-21T13:56:11.708Z","comments":true,"path":"notes/operating-system/e5094546.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/e5094546.html","excerpt":"【死锁预防】预防死锁的方法是通过破坏死锁的四个必要条件中的一个或几个，以避免发生死锁 由于互斥条件是非共享设备所必须的，不仅不能改变，还要加以保证，因此主要是破坏产生死锁的后三个条件","text":"【死锁预防】预防死锁的方法是通过破坏死锁的四个必要条件中的一个或几个，以避免发生死锁 由于互斥条件是非共享设备所必须的，不仅不能改变，还要加以保证，因此主要是破坏产生死锁的后三个条件 破坏请求与保持条件：系统必须做到当一个进程在请求资源时，其不能持有不可抢占资源，因此一般利用 AND 信号量机制，在进程开始前，一次性地为进程申请所需的全部资源 破坏不可抢占条件：允许进程先运行，但当提出的新要求不被满足时，必须释放其已保持的所有资源，待以后需要时再重新申请 破坏环路等待条件：将所有资源按类型进行线性排队，赋予不同序号，所有进程对资源的请求必须严格按照资源序号递增的次序提出，从而保证在形成的资源分配图中不会出现环路 可以看出，破坏请求与保持条件，算法简单，易于实现且十分安全，但资源浪费严重，且进程可能会延迟运行；破坏不可抢占条件实现复杂，可能会造成反复申请与释放的情况；破坏环路等待条件较前两者有了极大改善，资源利用率与系统吞吐量有了明显提高，但存在资源编号限制新设备的增加、应用中的使用设备顺序与规定顺序不协调等情况 【死锁避免】预防死锁的限制条件都太强，造成一定程度上的应用不变，因此在实际应用中，常采用避免死锁的方法，避免死锁只施加较弱的限制条件，但获得了令人满意的系统性能 安全状态与安全序列在避免死锁方法中，将系统的状态分为安全状态与不安全状态，当系统处于安全状态时，可避免发生死锁，当系统处于不安全状态时，可能进入死锁： 安全状态：系统能按某种进程顺序为每个进程分配所需资源，直至满足每个进程对资源的最大需求，并能顺利完成 不安全状态：系统无法找到一种使多个进程能够顺利分配资源执行完的安全序列 而安全序列，就是指系统按此进程序列进行分配资源，就能使每个进程都顺利完成 假定系统中有三个进程 $P_1,P_2,P_3$，共有 $12$ 个资源，三个进程分别要求 $10$ 个、$4$ 个、$9$ 个资源，假设在 $T_0$ 时刻，进程 $P_1,P_2,P_3$ 已获得 $5$ 个、$2$ 个、$2$ 个资源，尚有 $3$ 个资源未分配，那么有： 进程 最大需求 已分配 可用 $P_1$ $10$ $5$ $3$ $P_2$ $4$ $2$ $P_3$ $9$ $2$ 经过分析可知，由于存在一个安全序列 $P_2,P_1,P_3$，那么系统处于安全状态 即将剩余的 $3$ 个资源取出 $2$ 个分配给进程 $P_2$，使其继续运行，待执行完毕后即可释放出 $4$ 个资源，此时有： 进程 最大需求 已分配 可用 $P_1$ $10$ $5$ $5$ $P_2$ $0$ $0$ $P_3$ $9$ $2$ 此时可用资源达到了 $5$ 个，那么再将这 $5$ 个资源分配给进程 $P_1$，使其继续运行，待运行完毕后，即可释放出 $10$ 个资源，此时有： 进程 最大需求 已分配 可用 $P_1$ $0$ $0$ $10$ $P_2$ $0$ $0$ $P_3$ $9$ $2$ 这时进程 $P_3$ 就有足够的资源，从而使得每个进程都能顺利完成 每次资源分配时，都应按照上述实例来分析资源分配图，看该次操作后是否有安全序列，若不存在安全序列，说明该操作会使系统进入不安全状态 需要注意的是，只要使系统始终处于安全状态，便可避免发生死锁，但不是所有的不安全状态都是死锁状态。 银行家算法与安全性算法基本思路银行家算法是最有代表性的避免死锁的算法，其有 Dijkstra 提出，该算法因能用于银行系统现金贷款的发放而得名 该算法随时对系统中的所有资源信息进行统计，包括每种资源的数量、已分配给各进程的数量等，每当进程提出某种资源请求时，会判断该请求分配后是否安全，如果安全才分配 也就是说，对每个资源请求的处理都要保证系统始终从一个安全状态到另一个安全状态 数据结构1.进程请求资源的数量 进程请求某类型资源的数量 Request[i][j]：代表进程 $P_i$ 请求 $j$ 类型资源的数量 例如：$Request[i][j]=k$ 表示进程 $P_i$ 需要 $k$ 个 $j$ 类型的资源 2.各类可利用资源的数量 各类可利用资源的数量 Available[m]：包含 $m$ 个元素，每个元素代表一类可利用的资源数目，初始值是系统配置的该类资源的全部数目，值随着资源的分配与回收而动态改变 例如：$Available[j]=k$ 表示系统中 $j$ 类资源现有可用资源 $k$ 个 3.每个进程对每类资源的最大需求 每个进程对每类资源的最大需求 Max[n][m]：系统 $n$ 个进程中每个进程分别对 $m$ 类资源的最大需求，初始值是进程的需要资源数 例如：$Max[i][j]=k$ 表示进程 $i$ 需要 $j$ 类资源的最大数目为 $k$ 4.每个进程对每类资源的已分配矩阵 每个进程对每类资源的已分配矩阵 Allocation[n][m]​：系统 $n$ 个进程中每个进程分别对 $m$ 类资源已获得的资源数量 例如：$Allocation[i][j]=k$ 表示进程 $i$ 当前已获得 $j$ 类资源的数量为 $k$ 5.每个进程对每类资源的需求矩阵 每个进程对每类资源的需求矩阵 Need[n][m]​：系统 $n$ 个进程中每个进程分别对 $m$ 类资源还需要的资源数量 例如：$Need[i][j]=k$ 表示进程 $i$ 还需要 $j$ 类资源 $k$ 个 需要注意的是，上述的三个矩阵存在如下关系： Max[i][j]=Allocation[i][j]+Need[i][j]安全性算法安全性算法用于检查系统是否处于安全状态，其工作流程如下： 1.设置工作向量与标记向量 工作向量 Work[m]：表示系统可提供给进程继续运行所需的各类资源数目，其初始值与 Available[m] 向量相同 例如：$Work[j]=k$ 表示系统中 $j$ 类资源可提供给进程 $k$ 个 标记向量 Finish[n]：表示系统是否有足够的资源分配给进程，初始值为 false，当有足够资源分配给进程 $P_i$ 时，有 Finish[i]=true 2.在进程集合中寻找进程 在进程集合中找到一个满足下述条件的进程 $P_i$： \\begin{cases} Finish[i]=false\\\\ Need[i][j] \\leq Work[j] \\end{cases}若能找到，执行步骤 3，否则，执行步骤 4 3.分配资源 当进程 $P_i$ 获得资源后，可顺利执行，直至完成，并释放出分配给他的资源，因此执行： \\begin{cases} Work[j]=Work[j]+Allocation[i][j]\\\\ Finish[i]=true \\end{cases}然后转到步骤 2，寻找下一个满足条件的进程 4.判断安全状态 若所有进程的 $Finish[i]=true$ 均满足，则表示系统处于安全状态，否则，系统处于不安全状态 银行家算法银行家算法是一种资源分配策略，在经过安全性算法确定系统安全状态后，若处于安全状态，则执行该算法分配资源 当进程 $P_i$ 发出资源请求后，系统按下述步骤进行检查： 若 $Request_i[j] \\leq Need[i][j]$，转向步骤 2，否则认为出错，即所需资源数已超过宣布的最大值 若 $Request_i[j] \\leq Available[j]$，转向步骤 3，否则表示尚无所需资源，进程 $P_i$ 需等待 系统试探着将资源分配给进行 $P_i$，并修改下面数据结构中的值： \\begin{cases} Available[j] = Available[j]-Request_i[j]\\\\ Allocation[i][j]=Allocation[i][j]+Request_i[j]\\\\ Need[i][j]=Need[i][j]-Request_i[j] \\end{cases} 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全，则将资源正式分配给进程 $P_i$，以完成本次分配，否则，本次的试探分配作废，恢复原来的分配状态，让进程 $P_i$ 等待 实例安全性算法设系统有 $5$ 个进程 $\\{P_0,P_1,P_2,P_3,P_4\\}$，$3$ 类资源 $\\{R_1,R_2,R_3\\}$，数量分别为 $10,5,7$，在 $T_0$ 时刻，可分配资源 Available 为 $(3,3,2)$，同时资源分配表如下： 进程 Max Allocation $P_1$ $(7,5,3)$ $(0,1,0)$ $P_2$ $(3,2,2)$ $(2,0,0)$ $P_3$ $(9,0,2)$ $(3,0,2)$ $P_4$ $(2,2,2)$ $(2,1,1)$ $P_5$ $(4,3,3)$ $(0,0,2)$ 首先，求 Need​ 矩阵，有： \\begin{align} Need &= Max-Allocation \\notag \\\\ &= \\begin{bmatrix} 7 & 5 & 3\\\\ 3 & 2 & 2\\\\ 9 & 0 & 2\\\\ 2 & 2 & 2\\\\ 4 & 3 & 3\\\\ \\end{bmatrix} - \\begin{bmatrix} 0 & 1 & 0\\\\ 2 & 0 & 0\\\\ 3 & 0 & 2\\\\ 2 & 1 & 1\\\\ 0 & 0 & 2\\\\ \\end{bmatrix} \\notag \\\\ &= \\begin{bmatrix} 7 & 4 & 3\\\\ 1 & 2 & 2\\\\ 6 & 0 & 0\\\\ 0 & 1 & 1\\\\ 4 & 3 & 1\\\\ \\end{bmatrix} \\notag \\end{align}之后，将 Work 向量和 Need 矩阵各行比较，找出比 Work 小的行，初始时，有： \\begin{align} P_1:(3,3,2)>(1,2,2)\\rightarrow Need_1=(3,2,2),Allocation_1=(2,0,0) \\notag \\\\ P_3:(3,3,2)>(0,1,1)\\rightarrow Need_1=(2,2,2),Allocation_1=(2,1,1) \\notag \\\\ \\end{align}将 $P_1,P_3$ 依次加入安全序列，然后释放资源 Work=(3,3,2)+(2,0,0)+(2,1,1)=(7,4,3)此时，Need 矩阵更新为： Need=\\begin{bmatrix} 7 & 4 & 3\\\\ 6 & 0 & 0\\\\ 4 & 3 & 1\\\\ \\end{bmatrix}最后，重复上述步骤，即可得到一个安全序列： \\{P_1,P_3,P_4,P_2,P_0\\}银行家算法设系统有 $5$ 个进程 $\\{P_0,P_1,P_2,P_3,P_4\\}$，$3$ 类资源 $\\{R_1,R_2,R_3\\}$，数量分别为 $10,5,7$，在 $T_0$ 时刻，可分配资源 Available 为 $(3,3,2)$，同时资源分配表如下： 进程 Max​ Allocation​ $P_1$ $(7,5,3)$ $(0,1,0)$ $P_2$ $(3,2,2)$ $(2,0,0)$ $P_3$ $(9,0,2)$ $(3,0,2)$ $P_4$ $(2,2,2)$ $(2,1,1)$ $P_5$ $(4,3,3)$ $(0,0,2)$ 下面给出银行家算法中可能出现的三种情况的实例： 1.分配成功 初始时，$P_2$ 请求资源 $Request_2=(1,0,2)$，此时，有： \\begin{align} Request_2=(1,0,2)\\leq Need_1=(1,2,2) \\notag \\\\ Request_2=(1,0,2)\\leq Available=(3,3,2) \\notag \\end{align}假定可为 $P_2$ 分配资源，则： \\begin{cases} Available=(2,3,0) \\notag \\\\ Allocation_2=(3,0,2) \\notag \\\\ Need_2=(0,2,0) \\notag \\end{cases}令向量 $Work=Available=(2,3,0)$，然后执行安全性算法检查，可得安全序列： \\{P_1,P_3,P_4,P_2,P_0\\}此时，可为 $P_2$ 分配资源 2.需要等待 初始时，$P_5$ 申请资源 $Request_5=(3,3,0)$，此时，有： \\begin{align} Request_5=(3,3,0)\\leq Need_5=(4,3,1) \\notag \\\\ Request_5=(3,3,0)\\geq Available=(2,3,0) \\notag \\end{align}可分配的资源不足，$P_4$ 需要等待 3.拒绝分配 初始时，$P_1$ 申请资源 $Request_1=(0,2,0)$，此时，有： \\begin{align} Request_1=(0,2,0)\\leq Need_2=(7,4,3) \\notag \\\\ Request_1=(0,2,0)\\geq Available=(2,3,0) \\notag \\end{align}假定为 $P_1$ 分配资源，则： \\begin{cases} Available=(2,1,0) \\notag \\\\ Allocation_1=(0,3,0) \\notag \\\\ Need_1=(7,2,3) \\notag \\end{cases}令向量 $Work=Available=(2,1,0)$，然后执行安全性算法检查，此时无法满足任何进程的需要，进入不安全状态，因此拒绝为 $P_1$ 分配资源","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"死锁的基本概念","slug":"operating-system/22.死锁的基本概念","date":"2019-11-24T07:37:56.000Z","updated":"2021-10-19T14:27:44.738Z","comments":true,"path":"notes/operating-system/c4f16f83.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/c4f16f83.html","excerpt":"【资源】在系统中，有许多不同类型的资源，其中可能会引起死锁的主要是采用互斥访问机制、不可被抢占的资源，即临界资源，例如：打印机、数据文件、信号量等 可将系统中的资源分为两大类：可剥夺与非可剥夺性资源、永久性资源与临时性资源","text":"【资源】在系统中，有许多不同类型的资源，其中可能会引起死锁的主要是采用互斥访问机制、不可被抢占的资源，即临界资源，例如：打印机、数据文件、信号量等 可将系统中的资源分为两大类：可剥夺与非可剥夺性资源、永久性资源与临时性资源 其中，可剥夺与非可剥夺性资源有： 可剥夺性资源：分配给进程后可以被高优先级的进程剥夺，例如 CPU 、主存 不可剥夺性资源：分配给进程后只能在进程用完后释放，例如磁带机、打印机 永久性资源与临时性资源有： 永久性资源：可供用户重复使用多次的资源，例如打印机 临时性资源：在进程运行期间，由进程动态地创建与消耗，例如数据资源 【死锁】概述多道程序系统借助并发执行改善资源利用率，提高系统吞吐量，但可能会发生死锁问题，当进程处于死锁状态时，若无外力作用，它们都将无法再向前推进。 一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发事件，那么该组进程是死锁的。 简单来说，死锁，是指多个进程在运行过程中，因争夺资源而造成的一种僵局， 死锁状态不同于饥饿状态，死锁指进程之间因为争夺资源而无休止地互相等待，饥饿则是指一个进程无休止地等待 产生死锁的原因死锁产生的原因，主要是进程间竞争资源与进程推进顺序不当两大方面，由于竞争的资源的类别，因此，产生死锁的情况有以下三种： 竞争不可抢占资源：通常系统中所拥有的不可抢占资源数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入死锁 竞争可消耗资源：在进程运行过程中，由于可消耗资源是由进程动态创建与消耗的，因此如果进程运行顺序不当，就会使得进程间为可消耗资源而竞争，从而陷入死锁 进程推进顺序不当：由于进程在运行中具有异步性的特征，因此对资源的请求和释放的操作顺序会导致多进程向前推进具有推进顺序合法、推进顺序非法两种状态，当处于推进顺序非法状态时，会导致死锁产生 产生死锁的条件形成死锁的条件有四个，这四个条件缺一不可，只有当全部满足时，才会出现死锁： 互斥条件：进程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个进程占用 请求和保持条件：进程已经保持了至少一个资源，又提出新的资源请求，而新请求资源被其他进程占有只能造成自身进程阻塞，但对自己已获得的其他资源保持不放，必然影响其他进程 不剥夺条件：进程已获得的资源未使用完之前不能被剥夺，只能在使用完时由自己释放 环路等待条件：在发生死锁时，必然存在一个进程-资源循环链，即对于进程集 $\\{P_0,P_1,…,P_n\\}$，$P_0$ 正在等待 $P_1$ 的资源，而 $P_1$ 正在等待 $P_2$ 的资源，…，$P_n$ 正在等待 $P_0$ 的资源 处理死锁的方法目前处理死锁的方法可归结为 4 种： 预防死锁：设置限制条件，破坏产生死锁四个必要条件中的一个或几个来进行预防 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免产生死锁 检测死锁：运行进程在运行过程中出现死锁，但要通过检测机制及时检测出死锁的产生，然后采用适当的措施将进程从死锁中解脱出来 解除死锁： 当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来 上述四种方法对死锁的防范程度逐渐减弱，但相应的，资源利用率有所提高，且进程因资源因素而阻塞的频度下降（并发程度的提高）","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"实时调度算法","slug":"operating-system/21.实时调度算法","date":"2019-11-23T04:35:00.000Z","updated":"2021-10-19T14:10:45.977Z","comments":true,"path":"notes/operating-system/25441f45.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/25441f45.html","excerpt":"【实现实时调度的基本条件】提供必要的信息为实现实时调度，系统应向调度程序提供有关任务的下述信息：","text":"【实现实时调度的基本条件】提供必要的信息为实现实时调度，系统应向调度程序提供有关任务的下述信息： 就绪时间：任务成为就绪状态的起始时间 开始截止时间与完成截止时间：对于典型的实时任务，只需知道开始截止时间，或完成截止时间 处理时间：一个任务从开始执行到完成的时间 资源要求：任务执行时所需的一组资源 优先级：若某任务的开始截止时间错过，会引起故障，则应为该任务赋予绝对优先级；若任务的开始截止时间错过，对任务进行无重大影响，则可为其赋予相对优先级 系统处理能力强处理能力不足可能会出现某些实时任务不能得到及时处理，导致难以预料的后果。 假定系统中有 m 个周期周期性的硬实时任务，处理时间为 $C_i$，周期时间为 $P_i$，则在单机系统中有： \\sum_{i=1}^m \\frac{C_i}{P_i}提高系统处理能力的途径有两种： 采用单处理机系统：增强处理能力，显著地减少对每一个任务的处理时间 采用多处理机系统：采用多机系统时，假定有 $N$ 个处理器，则有限制条件 $\\sum_\\limits{i=1}^m \\frac{C_i}{P_i} \\leq N$ 调度机制实时任务分为两种： 硬实时任务：必须满足任务对截止时间的要求 软实时任务：联系着一个截止时间，但不严格，可偶尔错过，不会对系统造成太大影响 对于硬实时任务来说，应采用抢占机制，这样即可满足其对截止时间的要求 对于小的实时任务来说，如能预知任务的开始截止时间，为简化调度程序和对任务调度时所花费的系统开销，可采用非抢占调度机制 具快速切换机制为保证硬实时任务能及时运行，在系统中应具有快速切换机制，使之能进行任务的快速切换，该机制具有以下两方面的能力： 对外部中断的快速响应能力：利用快速硬件中断机构，可在紧迫的外部事件请求中及时响应 快速的任务分派能力：使系统中的运行功能单位适当的小，提高切换速度 【实时调度算法的分类】非抢占式调度算法非抢占式调度算法比较简单，常用于一些小型实时系统或要求不严格的实时系统中，根据采用的算法不同，分为以下两种： 非抢占式轮转调度算法：常用于工业生产的群控系统中，要求不太严格 非抢占式优先调度算法：常用于有一定要求的实时控制系统中，要求相对严格 抢占式调度算法在较严格的实时系统中，常选择抢占式优先权调度算法，根据抢占发生时间的不同，分为以下两种： 基于时钟：高优先级任务到达后并不立即抢占，而等下一个时钟中断时抢占 立即抢占：一旦出现外部中断，只要当前任务未处于临界区，就立即抢占处理机 【常用调度算法】最早截止时间优先算法最早截止时间优先（Earliest Deadline First，EDF）算法，根据任务截止时间来确定任务的优先级，任务的截止时间越早，其优先级越高 系统会保持一个实时任务就绪队列，队列按照各任务截止时间的早晚进行排序，调度程序总会选择就绪队列中的第一个任务，分配处理机使其投入运行 新任务产生时，根据系统是否允许等待当前程序执行完而采用抢占式、非抢占式调度方法 该算法可能会导致作业错过，因此常用于软实时系统 最低松弛度优先算法最低松弛度优先（Least Laxity First，LLF）算法，根据任务的紧急(或松弛)程度来确定优先级，任务的紧急程度越高(或松弛度越小)，优先级就越高 松弛度，是当前时刻到开始截止时间间的差距，随着时间的推进，这个差值会逐渐变小，任务也就越来越紧迫，优先级也就越高 松弛度=截止完成时间-还需执行时间-当前时间对于最低松弛度优先算法来说，其进程发生切换的时机有：进程执行完、进程 I/O 阻塞、新进程出现时可能的抢占、某进程松弛度为 0 时发生抢占，需要注意的是，有的时刻，其他并发的实时任务下一周期未到来，会出现只有一个任务的情况","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"进程调度算法","slug":"operating-system/20.进程调度算法","date":"2019-11-22T04:29:15.000Z","updated":"2021-10-19T14:07:26.503Z","comments":true,"path":"notes/operating-system/38adf97d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/38adf97d.html","excerpt":"【进程调度任务】进程调度是操作系统中必不可少的一种调度，因此在三种类型的 OS 中，无一例外的使用了进程调度，其是对系统性能影响最大的一种处理机调度 进程调度的任务有三：","text":"【进程调度任务】进程调度是操作系统中必不可少的一种调度，因此在三种类型的 OS 中，无一例外的使用了进程调度，其是对系统性能影响最大的一种处理机调度 进程调度的任务有三： 保存处理机现场信息：在调度时需要保存当前进程的处理机现场信息 按某种算法选取进程：调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备将处理机分配给他 将处理机分配给进程：由分派程序将处理机分配给该进程，此时需要将选中的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，将处理器的控制权交予该进程，让其从上次断点处恢复运行 【进程调度方式】非抢占方式非抢占方式实现简单，系统开销小，适用于大多数的批处理系统，但不适用于分时系统与实时系统 非抢占方式一旦将处理机分配给某进程后，就会让该进程一直运行下去，直至进程完成或因发生某事件堵塞，绝不会因为时钟中断或其他原因去抢占当前正在运行进程的处理机 在采用非抢占方式时，可能引起进程调度的因素有： 正在执行的进程运行完毕 因发生某事件使得进程无法继续运行 正在执行中的进程因提出 I/O 请求而暂停 进程通信或进程同步中，执行了某种原语操作 抢占方式抢占方式运行调度程序依据某种原则，去暂停某个正在执行的进程，将已分配给进程的处理机重新分配给另一进程 抢占不算一种任意性行为，而是遵循一定原则： 优先权原则：允许优先级高的新到进程抢占当前进程的处理机 短进程优先原则：运行新到的短进程抢占当前长进程的处理机 时间片原则：各进程按时间片轮转时，正在执行的进程的一个时间片完后，便停止该进程的执行而重新进行调度 【时间片轮转调度算法】在分时系统中，最简单也最常用的是基于时间片轮转（Round Robin，RR）调度算法，其让就绪队列上的每个进程仅运行一个时间片，对于 n 个进程，每个进程每次大约都可获得 $\\frac{1}{n}$ 的处理机时间 轮转法根据 FCFS 策略，将所有的就绪进程排成就绪队列，设置每一定时间间隔产生一次中断，激活进程调度程序，完成调度，将 CPU 分配给队首进程，当进程的时间片耗尽或运行完毕后，系统再次将 CPU 分给新的队首进程 在轮转法中，进行进程的切换分为两种情况： 时间片未用完，正在运行的进程已完成：将完成的进程从就绪队列中删除，再调度就绪队列队首进程，启动一个新时间片 时间片已用完，正在运行的进程未完成：中断程序被激活，调度程序将进程送往就绪队列尾部 时间片大小的确定对性能有很大的影响，如果选择较小的时间片，那么会有利于短作业，但会频繁的执行进程调度与进程上下文切换，增加了系统开销；如果时间片选择的过长，且每个进程都能在一个时间片内完成，那么 RR 算法就退化成了 FCFS 算法，无法满足短作业与交互用户的需求 因此，一个较为可取的时间片大小是略大于一次典型的交互所需的时间，从而使得大多数交互式进程能在一个时间片内完成 【优先级调度算法】非抢占与抢占式优先级调度算法优先级调度算法，是将处理机分配给就绪队列中优先级最高的进程，依据进程调度方式，其可进一步的分为以下两种： 非抢占式优先级调度算法：一旦将处理机分配给就绪队列中优先级最高的进程后，该进程会一直执行直至完成，除非因该进程发生某事件而放弃处理机时，系统才可将处理机分配给另一优先级最高的进程 抢占式优先级调度算法：将处理机分配给优先级最高的进程后，在执行期间，只要出现另一个优先级更高的进程，调度程序就会将处理机分配给这个优先级更高的进程 优先级类型优先级调度算法的关键在于两点：一是确定进程的优先级，二是优先级类型的选择 静态优先级是创建进程时确定的，其用某一范围内的一个整数 (优先数) 来表示，在进程的整个运行期间不变；动态优先级是创建进程之初先赋予了一个优先级，然后其值随着进程的推进或时间的增加而改变 对于静态优先级来说，其简单易行，系统开销小，但不够精确，可能会出现优先级低的进程长期没有被调度的情况；对于动态优先级来说，其较为精确，但系统开销大 【多队列调度算法】多队列调度算法将系统中的进程就绪队列从一个拆分为多个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列可以采用不同的调度算法，每个就绪队列中的进程也可以设置不同的优先级 在多处理机系统中，由于该算法安排了多个就绪队列，因此在多处理机系统中，可以很方便地为每个处理机设置一个单独的就绪队列 【多级反馈队列调度算法】多级反馈队列调度算法不像上述算法一样，要知道各进程所需的执行时间，其调度机制描述如下： 设置多个就绪队列：在系统中设置多个就绪队列，并为每个队列设置不同的优先级，第一个队列优先级最高，第二个次之，其他队列优先级逐个降低，优先级越高的时间片越小，一般设置为后一个优先级的时间片长度为前一个优先级的时间片的一倍 每个队列采用 FCFS 算法：当新进程进入内存后，首先将其放入第一队列末尾，按 FCFS 原则进行调度，当轮到该进程时，如果其能在时间片内完成，便可撤离系统；如果其不能在时间片内完成，那么就将其转入第二队列的末尾等待调度，以此类推。当进程被降到第 $n$ 队列后，在第 $n$ 队列中采取 RR 方式运行 按队列优先级调度：调度程序仅当第 $1$ 到第 $i-1$ 的所有队列都为空时，才会调度第 $i$ 队列中的进程。如果处理机在第 $i$ 队列中为某进程服务时又有新进程进入 $i$ 之前的队列，那么须将正在运行的进程放回第 $i$ 进程的末尾，并将处理机分配给高优先级的进程 【基于公平原则的调度算法】保证调度算法保证调度算法是另一种类型的调度算法，其向用户做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。 如果在系统中有 n 个相同类型的进程在运行，为公平起见，那么须保证每个进程都获得相同的处理机时间 $\\frac{1}{n}$ 公平分享调度算法保证调度算法分配给每个进程相同的处理机时间，对于诸进程来说，是体现了一定程度的公平，但如果各个用户拥有的进程数不同，就会发生对用户的不公平问题 在该调度算法中，调度的公平性是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"作业调度算法","slug":"operating-system/19.作业调度算法","date":"2019-11-20T04:40:00.000Z","updated":"2021-10-19T14:05:11.971Z","comments":true,"path":"notes/operating-system/13cfc18f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/13cfc18f.html","excerpt":"【作业与作业调度算法】作业在批处理系统中，是以作业为基本单位从外存调入内存的，作业不仅包含了通常的程序和数据，而且还配有一份作业说明书，系统会根据说明书来对程序运行进行控制","text":"【作业与作业调度算法】作业在批处理系统中，是以作业为基本单位从外存调入内存的，作业不仅包含了通常的程序和数据，而且还配有一份作业说明书，系统会根据说明书来对程序运行进行控制 同时，每个作业设置了一个作业控制块（Job Control Block，JCB），作为作业在系统中存在的标志 每当一个作业进入系统时，会为作业建立一个 JCB，再根据作业类型，放入到相应的后备队列中等待调度，调度程序会根据一定的调度算法进行调度 在作业运行期间，系统会按照 JCB 中的信息与作业说明书对作业进行控制 当一个作业执行结束进入完成态时，系统会回收已分配的资源并撤销该 JCB 作业步在作业运行期间，每个作业都必须经过若干相对队列又相互关联的顺序加工步骤才能得到结果 每一个加工步骤称为一个作业步，各作业步间存在着相互联系，往往将上一个作业步的输出作为下一个作业步的输入 作业调度算法作业调度主要是根据 JCB 中的信息，检查系统中的资源能否满足作业对资源的需求 然后按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为他们创建进程、分配必要的资源 最后再将新创建的进程排到就绪队列上等待调度 【先来先服务算法】先来先服务（First-Come First-Served，FCFS）调度算法，既可用于作业调度，也可用于进程调度 当在作业调度中采用 FCFS 时，系统按照作业到达的先后次序进行调度，不考虑作业所执行的时间长度，即优先考虑在系统中等待时间最长的作业 当在进程调度中采用 FCFS 时，每次调度从就绪的进程队列中选择一个最先进入队列的进程分配处理机，使其投入运行 【短作业优先算法】短作业优先（Short Job First，SJF）调度算法，既可以用于作业调度，也可以用于进程调度 当在作业调度中采用 SJF 时，系统按照作业长短进行调度，即作业越短优先级越高，每次会将从外存的作业后备队列中选择运行时间最短的作业，优先调入内存运行 当在进程调度中采用 SJF 时，每次调度从就绪的进程队列中选择一个运行时间最短的进程分配处理机，使其投入运行 【优先级调度算法】在优先级调度算法（Priority-Scheduling Algorithm，PSA）中，是根据作业紧迫程度，由外部赋予作业相应的优先级，然后根据优先级进行调度，从而保证紧迫性作业优先运行 对于 FCFS 算法，作业等待时间就是作业的优先级，等待时间越长优先级越高，对于 SJF 算法，作业运行时间就算作业的优先级，作业运行时间越短优先级越高 【高响应比优先调度算法】在批处理系统中，FCFS 算法只考虑作业等待时间，忽视了作业运行时间，而 SJF 算法只考虑了作业运行时间，忽视了作业等待时间 高响应比优先算法（Highest Response Ratio Next，HRRN） 既考虑了作业等待时间，又考虑了作业运行时间，因此既照顾了短作业，又不致使长作业等待时间过长 HRRN 为每个作业引入了一个动态优先级，优先级是可以改变的，令它随等待时间延长而增加，其可描述为： 优先权=\\frac{等待时间+要求服务时间}{要求服务时间}由于等待时间与服务时间之和就算系统对作业的响应时间，因此该优先级相当于响应比 $R_p$，因此优先权又可表示为： R_p=\\frac{等待时间+要求服务时间}{要求服务时间}=\\frac{响应时间}{要求服务时间}由此可以看出，HRRN 具有以下特点： 如果作业的等待时间相同，则要求服务的时间越短，其优先级越高，因而该算法类似于 SJF，利于短作业 当要求服务时间相同时，作业优先权又决定于其等待时间，因而该算法又利于 FCFS 算法 对于长作业的优先级，随着等待时间的增加而提高，当其等待时间足够长时，也可获得处理机 从上可以看出，该算法实现了 SJF 与 FCFS 较好的折中，但需要注意的是，利用该算法每次进行调度前，都需要做响应比的计算，这会不可避免的增加系统开销","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"处理机调度算法评价指标","slug":"operating-system/18.处理机调度算法评价指标","date":"2019-11-19T09:26:37.000Z","updated":"2021-10-19T13:58:17.803Z","comments":true,"path":"notes/operating-system/96f39a3e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/96f39a3e.html","excerpt":"【常见调度算法的比较】处理机调度算法是根据处理机分配策略所规定的处理机分配算法，不同的情况和对象需求不同，适用的方式和算法也不同 以下是几种常见调度算法的比较：","text":"【常见调度算法的比较】处理机调度算法是根据处理机分配策略所规定的处理机分配算法，不同的情况和对象需求不同，适用的方式和算法也不同 以下是几种常见调度算法的比较： 【批处理系统的目标】CPU 利用率CPU 利用率是指 CPU 忙碌时间占总时间的比例，即： 利用率=\\frac{忙碌时间}{总时间}为提供系统的资源利用率，应使得系统中的处理机和其他所有资源都尽可能的保持忙碌状态，即 CPU 的利用率越高越好 同时，对于多道程序并发执行的情况，一般会采用甘特图来辅助计算 系统吞吐量系统吞吐量是指单位时间内系统所完成的作业数，即： 系统吞吐量=\\frac{总共完成作业数量}{总花费时间}对于长作业来说，其耗费时间长，会降低系统吞吐量；而对于短作业，其耗费时间短，会提高系统吞吐量，因此系统吞吐量与批处理作业的平均长度有关 同时，如果单纯为获得高的系统吞吐量，应尽可能地选择短作业运行 周转时间周转时间，是指作业从提交给系统到作业完成的时间间隔，分为四个部分：作业等待、就绪队列排队、处理机运行（运行态）、I/O 操作时间总和（阻塞态） 其中，作业等待属于高级调度部分，仅调度一次，就绪队列排队属于低级调度部分，会发生多次 对于每个独立用户来说，其更加关心自己所提交的单个作业调度周转时间，故有： 作业周转时间=作业完成时间-作业提交时间对于每个用户来说，都希望自己作业的周转时间尽可能的短，但作为操作系统来说，则希望使平均周转时间最短，以尽可能的令大多数用户满意，故有： 平均周转时间=\\frac{各作业周转时间和}{作业数}为进一步反映单个作业在调度时的性能，又引入了带权周转时间，其被定义为作业周转时间与系统为它提供服务的时间的比，即： 带权周转时间=\\frac{作业周转时间}{作业实际运行时间}可以发现，对于两周转时间相同的作业来说，实际运行长的作业被服务的更多，带权周转时间也就更小；对于两实际运行时间相同的作业来说，周转时间越短的作业带权时间反而更小 那么，平均带权周转时间为： 平均带权周转时间=\\frac{各作业带权周转时间和}{作业数}等待时间等待时间，是指进程处于等待处理机状态的时间和 一个作业或进程被 CPU、I/O 服务多久一般是确定不变的，调度算法只会等待时间 对于进程来说，其是进程建立后等待被服务的时间和，即： 等待时间=周转时间-运行时间对于作业来说，其是进程建立后等待被服务的时间和与作业在外存后备队列的等待时间的和，即： 等待时间=周转时间-运行时间-I/O\\:操作时间【实时系统的目标】响应时间，是指用户从键盘提交一个请求开始，到屏幕显示出处理结果为止的一段时间间隔，其包含三部分时间： 请求信息从输入到送到处理机的时间 处理机对请求信息处理的时间 形成的响应时间回送到终点显示器的时间 用户对响应时间的要求不完全相同，这就要求系统响应时间的快慢程度与用户请求服务的复杂性相适应","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"处理机调度的基本概念","slug":"operating-system/17.处理机调度的基本概念","date":"2019-11-19T03:36:00.000Z","updated":"2021-10-19T12:47:30.419Z","comments":true,"path":"notes/operating-system/ff08ae5a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/ff08ae5a.html","excerpt":"【处理机调度】在多道程序系统中，处理机的分配与运行均以进程为基本单位，对处理机的管理，就是对进程的管理，除了完成进程控制、进程同步、进程通信外，处理机还需要进行调度 处理机调度的实质是一种资源分配，即按照某种算法，将处理机资源分配给就绪队列中的一个","text":"【处理机调度】在多道程序系统中，处理机的分配与运行均以进程为基本单位，对处理机的管理，就是对进程的管理，除了完成进程控制、进程同步、进程通信外，处理机还需要进行调度 处理机调度的实质是一种资源分配，即按照某种算法，将处理机资源分配给就绪队列中的一个 作业进入系统驻留在外存的后备队列上，再到调入内存运行完毕，可能经历下述三级调度： 1.高级调度 高级调度又称长程调度或作业调度，其调度的对象是作业，即一个具体的任务，用户每提交一个任务，本质是让操作系统启动一个程序来处理这个提交的任务 在批处理系统中，作业进入系统后先驻留外存，故需要有作业调度；在分时系统中，为及时响应，作业由终端直接送入内存，故也不需作业调度；在实时系统中，通常不需要作业调度 每个作业只进行一次调度，在进行作业调度时，主要完成以下任务： 从外存的后备队列中选择哪些作业调入内存 创建进程并分配必要的资源 将创建的进程排在就绪队列上，准备执行 因此，每个作业在调入时会建立 PCB，在调出时会撤销 PCB，同时对任何一个作业，在调入时都需要作出两个决定： 接纳多少作业：取决于多道程序度，应根据系统规模与运行速度等情况综合考虑 接纳哪些作业：取决于采用的调度算法，例如先来先服务、短作业优先等 一个作业运行完毕退出系统时即触发重新调度一个新作业入内存，周期较长，大约几分钟一次，因而也允许作业调度算法花费较多的时间 2.中级调度 中级调度又称内存调度，引入中级调度的目的是为了提高内存利用率与系统吞吐量，其是按照一定的策略将处于挂起状态的进程调入内存，其运行频率介于进程调度与作业调度之间 在内存不够时，操作系统会应将那些暂时无法运行的进程调至外存等待，此时进程的状态称为就绪驻外存状态（挂起状态），当具备运行条件且内存有空闲时，会通过中级调度来决定将位于外存上的哪些就绪进程调度内存，并修改状态为就绪态 3.低级调度 低级调度又称短程调度或进程调度，是最基本的一种调度，在多道批处理、分时、实时三种类型的 OS 中，都必须配置这级调度，其调度的对象是进程 简单来说，进程调度是按照某种方法，从就绪队列中选择进程，并由分派程序将处理机分配给它 进程调度的运行频率最高，这使得其算法不能太过复杂，以免占用太多的 CPU 时间，在分时系统中，通常每 10~100ms 便进行一次进程调度 【调度队列模型】不论高级、中级或者低级调度，都涉及到进程队列，由此形成了三类调度队列模型： 仅有进程调度的调度队列模型：常用于分时系统，用户键入的命令与模型均直接送入内存，其调度对象是处于就绪状态的进程 具有高级和低级调度的调度队列模型：常用于批处理系统，在批处理系统中，必须要具有作业调度 同时具有三级调度的调度队列模型：引入中级调度后，进程的状态发生了变化，就绪态扩为内存就绪、外存就绪，阻塞态扩为内存阻塞、外存阻塞，使得数据在内外存间互换","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"线程的实现与多线程模型","slug":"operating-system/16.线程的实现与多线程模型","date":"2019-11-18T09:54:29.000Z","updated":"2021-10-14T04:13:50.204Z","comments":true,"path":"notes/operating-system/546cc817.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/546cc817.html","excerpt":"【线程的实现方式】线程的实现可以分为两类：用户级线程（User-Level Thread，ULT）、内核级线程（Kernel-Level Thread，KLT） 在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在","text":"【线程的实现方式】线程的实现可以分为两类：用户级线程（User-Level Thread，ULT）、内核级线程（Kernel-Level Thread，KLT） 在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在 通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程 在内核级线程中，有关线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口 内核进程为进程及其内部的每个线程都会维护上下文信息，调度也是在内核基于线程架构的基础上完成 【多线程模型】在某些系统中，同时支持用户线程和内核线程，由此可使用组合方式来实现多线程模型，线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行 一个应用程序的多个用户级线程被映射到一些小于等于用户级线程数目的内核级线程中 具体来说，用户级线程与内核级线程的连接方式分为三种： 1.多对一模型 多个用户级线程映射到一个内核级线程上，线程管理在用户空间中完成，用户级线程对操作系统透明 该方案的线程管理是在用户空间中进行的，效率较高，但当一个线程在使用内核服务被阻塞时，整个进程都会被阻塞，此外，多个线程也不能并行地在处理机上运行 2.一对一模型 每个用户级线程映射到一个内核级线程上 当一个线程被阻塞时，允许另外一个线程继续执行，并发能力较强，但每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销较大，影响应用程序性能 3.多对多模型 $n$ 个用户级线程映射到 $m$ 个内核级线程上，要求 $m\\leq n$ 该方案是对多对一模型和一对一模型的折中，不仅克服了多对一模型的并发性不高的缺点，还克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"线程的基本概念","slug":"operating-system/15.线程的基本概念","date":"2019-11-18T05:22:13.000Z","updated":"2021-10-14T04:15:35.194Z","comments":true,"path":"notes/operating-system/f2b5873a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/f2b5873a.html","excerpt":"【线程】进程是一个资源的拥有者，因而在创建、撤销、切换过程中，系统要付出较大的时空开销，这就限制了系统中所设置进程的数目，且进程切换也不能太过频繁，这就限制了程序的并发程度 为解决上述问题，在进程的基础上引入了线程，由于进程的不仅拥有资源，其还是调度与分派的基本单位，因此将进程的两个属性分开，使得不把作为调度与分派的基本单位也同时作为拥有资源的单位","text":"【线程】进程是一个资源的拥有者，因而在创建、撤销、切换过程中，系统要付出较大的时空开销，这就限制了系统中所设置进程的数目，且进程切换也不能太过频繁，这就限制了程序的并发程度 为解决上述问题，在进程的基础上引入了线程，由于进程的不仅拥有资源，其还是调度与分派的基本单位，因此将进程的两个属性分开，使得不把作为调度与分派的基本单位也同时作为拥有资源的单位 由此，线程就成为了调度与分派的基本单位 线程具有许多传统进程的特征，因此称为轻量级进程，其是一个基本的 CPU 执行单元，也是程序执行流的最小单元，相应的，传统进程被称为重量级进程 【线程控制块】系统为每个线程配置了一个线程控制块（Thread Control Block，TCB），所有用于控制、管理线程的信息均记录其中，其包括以下几项内容： 线程标识符：每个线程具有一个唯一的线程标识符 寄存器：包括程序计数器 PC、状态寄存器、通用寄存器等 线程运行状态：描述线程处于何种运行状态 优先级：线程执行的优先程度 线程专有存储区：用于线程切换时暂存线程保护信息 信号屏蔽：对某些信号加以屏蔽 堆栈指针：保存局部变量与返回地址 【线程状态】基础状态与传统进程一样，各线程间也存在着共享资源与相互合作的制约关系，使得线程在运行时具有间断性，相应地，线程在运行时也具有下述的三种基本状态，其状态转换与进程间的状态转换相同： 执行态：线程已获得处理机而正在运行 就绪态：线程已具备各种执行条件，只需获得 CPU 资源即可执行 阻塞态：线程在执行过程中因某事件受阻而处于暂停状态 线程的创建应用程序启动时，通常只有一个线程（初始化线程） 在执行，其主要功能是创建新线程 在创建新线程时，利用一个线程创建函数（或系统调用） ，并提供相应参数，在创建完成后，将返回一个线程标识符供以后使用 线程的终止当一个线程被终止后，不会立即释放资源，只有当进程中的其它线程执行分离函数后，资源才分离出来能被其它线程利用 被终止而未释放资源的线程仍可被需要它的线程调用，使其重新恢复运行 【进程与线程的对比】在多线程的操作系统中，进程包含多个线程，并为它们提供资源，操作系统支持在一个进程中的多个线程能并发执行，但此时的进程不再作为一个执行的实体 多线程下的进程具有以下属性： 进程是一个拥有资源的基本单位，其仍为系统资源分配的基本单位 多个线程可并发执行，但至少有一个线程为其他线程提供资源与运行环境 进程已不再是可执行的实体，线程作为独立运行的基本单位 因此，进程与线程可进行以下对比： 调度：线程作为CPU调度的基本单位，而进程只作为其它资源分配单位 并发性：进程之间可以并发，实质上是不同进程中的两个线程并发，而一个进程的多个线程之间也可并发 拥有资源：进程间资源相互独立，同一进程的各线程间共享，但某进程内的线程在其它进程不可见 系统开销：由于同进程内线程间共享内存地址和打开的文件资源，因此线程上下文切换在同进程环境下上下文切换要快得多","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"进程通信","slug":"operating-system/14.进程通信","date":"2019-11-16T11:15:29.000Z","updated":"2021-10-13T14:37:10.145Z","comments":true,"path":"notes/operating-system/53ad465c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/53ad465c.html","excerpt":"【概述】进程通信是指进程间的信息交换，由于进程是系统分配资源的单位，因此各进程内存地址空间是独立的，一个进程不能直接访问另一个进程的地址空间 而进程的互斥与同步往往需要在进程间交换信息，信号量机制虽是有效的同步工具，但作为通信工具来说效率低、通信对用户不透明，因此常常归类为低级进程通信","text":"【概述】进程通信是指进程间的信息交换，由于进程是系统分配资源的单位，因此各进程内存地址空间是独立的，一个进程不能直接访问另一个进程的地址空间 而进程的互斥与同步往往需要在进程间交换信息，信号量机制虽是有效的同步工具，但作为通信工具来说效率低、通信对用户不透明，因此常常归类为低级进程通信 为了使通信时用户使用方便、能高效地传递大量数据，OS 隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信命令（原语），利用这些原语，可以高效地传送大量数据，也即高级进程通信 高级进程通信方法主要有共享存储器系统、消息传递系统、管道通信系统、远程过程调用等 【共享存储器系统】共享存储器系统是指，在通信的进程间存在一块可以被直接访问的共享空间，通过对这片共享空间的读写操作，来实现进程间的信息交换 需要注意的是，在对共享空间进行读写操作时，需要使用 $P$、$V$ 操作，来对共享空间进行互斥访问 对于共享存储器系统来说，其又分为以下两种类型： 基于共享数据结构的通信（低级通信）：OS 仅提供共享存储器，程序员负责对公用数据结构设置与对进程间同步进行处理，通信效率低下，适合于传递少量数据 基于共享存储区的通信（高级通信）：在存储器中划出了一块共享存储区，诸进程可通过共享存储区中数据的读写来实现通信，适合于传输大量数据 【消息传递系统】概述消息传递系统是进程通信方法中应用最广泛的一种，其以格式化的消息为单位，屏蔽底层复杂的操作 根据实现方式的不同，可分为以下两类： 直接通信方式：发送进程利用 OS 发送消息原语，直接将消息发送给目标进程，接收进程通过接收消息原语来接收信息，发送进程和接收进程都以显式方式，提供对方的标识符 间接通信方式：发送、接收进程均通过共享中间实体（信箱）进行消息的发送与接收，因此该种方法又被称为信箱通信 直接通信方式直接通信原语系统通信命令分为两类，一类是对称寻址方式，一类是非对称寻址方式。 对于对称寻址方式来说，有以下两种通信命令： Send(receiver, message)：将一个消息给接收进程 receiver Receive(sender, message)：接收 sender 发送的消息 对于非对称寻址方法来说，有以下两种通信命令： send(P, message)：发送一个消息给进程 $P$ receive(id, message)：接收任何来自进程的消息，id 为进行通信的发送方 id 同步方式在进程间进行通信时，同样要有进程同步机制，从而使各进程间能协调通信 无论是发送进程还是接收进程，在完成消息发送、接收后，都存在两种可能：进程继续发送/接收、进程阻塞 由此，可得到三种情况： 发送进程阻塞，接收进程阻塞：该情况主要用于进程间紧密同步，即两进程间无缓冲时 发送进程不阻塞，接收进程阻塞：该情况是应用最广的进程同步方式，常用于服务器程序，接收进程平时处于阻塞状态，只有当消息发送过来才被唤醒 发送进程不阻塞，接收进程不阻塞：该情况利用缓冲队列的数据结构，仅当某事件发生无法运行时，才阻塞起来进行等待 通信链路为在发送进程与接收进程间通信，必须在两者间建立一条通信链路，根据通信方式的不同，通信链路分为单向通信链路、双向通信链路 在计算机网络中，发送进程在通信前用显式的及建立连接原语请求系统为其建立一条通信链路，在通信完成后拆除链路 在单机系统中，发送进程无须明确提出建立链路的请求，只须利用系统提供的发送原语，系统会自动为其建立一条链路 间接通信方式信箱间接通信方式需要通过某种中间实体来完成，该实体被称为信箱，其建立在随机存储器的公用缓冲区上，用来暂存发送进程给目标的消息，接收进程可以从该实体中取出发送进程给自己的消息 每个信箱都有一个唯一的标识符，消息在信箱中可以安全的保存，只允许目标用户随时读取，因此，信箱通信方式即可以实时通信，又可以非实时通信 信箱由 OS 创建，也可由用户进程创建，创建者是信箱的拥有者，据此可将信箱分为：私用信箱、公用信箱、共享信箱 信箱结构信箱定义为一种数据结构，在逻辑上，其可以分为以下两部分： 信箱头：存放有关信息的描述信息，如信箱标识符、信箱拥有者、信箱口令等 信箱体：由若干可存放消息的信箱格组成，信箱格的数目及每格大小在创建信箱时确定 信箱通信原语系统为信箱通信提供了若干条原语： 信箱创建：进程利用信箱创建原语来建立一个新信箱 信箱撤销：进程利用信箱撤销原语来撤销一个不再需要的信箱 消息发送：send(mailbox, message)，将一个消息发送到指定信箱 消息接收：receive(mailbox, message)，从指定信箱中接收一个消息 【管道通信系统】管道通信系统，是借助管道来完成的，所谓管道，即 pipe 文件，其是一种用于连接读、写进程以实现通信的一个共享文件 向管道提供输入的发送进程（写进程） 以字符流形式将数据送入管道，接收管道输出的接收进程（读进程） 同样以字符流的形式接收数据 管道通信系统，就是利用管道来进行通信的，为协调双方通信，管道机制必须具备互斥、同步、确认对方是否存在的能力 【远程过程调用】远程过程调用（Remote Procedure Call，RPC），是基于客户/服务器模型进行相互通信模型的一种同步通信形式，其借助网络套接字来进行进程通信，常用于通过网络的连接的系统间的进程通信 该协议允许运行于一台主机系统（本机） 上的进程调用另一台主机系统（远程） 上的进程，为客户提供了远程服务的过程抽象，同时，底层消息传递操作对客户是透明的 负责远程过程调用的进程有两个，一个是本地客户进程，一个是远程服务器进程，这两个进程通常被称为网络守护进程，主要负责在网络间的消息传递，一般情况下，这两个进程均处于阻塞状态，等待消息","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"管程","slug":"operating-system/13.管程","date":"2019-11-16T07:23:13.000Z","updated":"2021-10-13T14:07:09.696Z","comments":true,"path":"notes/operating-system/305a7f62.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/305a7f62.html","excerpt":"【管程】系统中的各种硬件资源和软件资源，都可用数据结构来抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，并忽视其内部结构和实现细节 由于每个要访问的临界资源的进程都要自备 wait(S) 操作与 signal(S) 操作，这就使大量的 $P$、$V$ 操作分散在各个进程中，不仅管理困难，还容易因同步操作顺序不当而产生死锁","text":"【管程】系统中的各种硬件资源和软件资源，都可用数据结构来抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，并忽视其内部结构和实现细节 由于每个要访问的临界资源的进程都要自备 wait(S) 操作与 signal(S) 操作，这就使大量的 $P$、$V$ 操作分散在各个进程中，不仅管理困难，还容易因同步操作顺序不当而产生死锁 为解决这种问题，引入了管程，其是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能够初始化并改变管程中的数据和同步进程 【管程的组成】管程由以下结构组成： 管程名称 共享结构数据说明（共享变量、条件变量等） 对该数据结构进行操作的一组过程（可调用的方法） 对共享数据初始化的语句 其实质上就是一个抽象类，这个抽象类有许多成员变量，系统中任何设备都可以通过这几个成员变量进行区分和描述，同时，这个抽象类中还存在对这些成员变量进行操作的一组成员函数 【管程的同步控制】管程的变量有两种，一种是普通变量，一种是条件变量 其中，条件变量用于控制进程阻塞与唤醒，其类似于信号量变量，但其没有具体值，相当于每个阻塞队列的队列指针 管程中的每个条件变量都必须予以说明，其形式为：condition x,y，而对条件变量的操作，需要结合对普通变量的条件判断，由此来控制进程状态 对条件变量的操作只有 wait 与 signal，因此条件变量是一种抽象的数据类型，每个条件变量只保留了一个链表，用于记录因该条件变量而阻塞的所有进程，因此，两个操作可表示为： x.wait：将执行进程挂到 x 对应的等待队列上 x.signal：唤醒 x 相应的等待队列上的一个进程","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"信号量机制的应用","slug":"operating-system/12.信号量机制的应用","date":"2019-11-15T11:23:42.000Z","updated":"2022-03-27T07:44:35.421Z","comments":true,"path":"notes/operating-system/176134fb.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/176134fb.html","excerpt":"【进程同步与进程互斥的实现】进程同步假设有两个并发执行的进程 $P_1$ 与 $P_2$，$P_1$ 中有语句 $S_1$，$P_2$ 中有语句 $S_2$，现们希望 $S_1$ 执行后再执行 $S_2$","text":"【进程同步与进程互斥的实现】进程同步假设有两个并发执行的进程 $P_1$ 与 $P_2$，$P_1$ 中有语句 $S_1$，$P_2$ 中有语句 $S_2$，现们希望 $S_1$ 执行后再执行 $S_2$ 为实现这样的同步关系，可令进程 $P_1$、$P_2$ 共享一个初值为 $0$ 的公用信号量 $S$，将 signal(S) 放在 $S_1$ 语句后面，将 wait(S) 放在 $S_2$ 语句前面 这样一来，若 $P_2$ 先执行 wait(S) 时，会将进程阻塞，并放入阻塞队列中，当进程 $P_1$ 中的 $S_1$ 执行完后，执行 signal(S) 操作，将 $P_2$ 从阻塞队列中放回就绪队列，当 $P_2$ 得到处理机时，即可继续执行，从而使得当语句 $S_1$ 执行完后，语句 $S_2$ 才可以执行 123456789Semaphore S = 0; //初始化信号量void process1() &#123; S1; signal(S);&#125;void process2() &#123; wait(S); S2;&#125; 进程互斥当多个进程需要互斥地访问某临界资源时，仅需为该资源设置一初值为 $1$ 的互斥信号量 mutex，然后将各进程访问该资源的临界区置于 wait(mutex) 与 signal(mutex) 之间即可 12345678910111213Semaphore mutex = 1; //初始化信号量void P1() &#123; wait(mutex); //进入区，加锁 critical section; //临界区 signal(mutex); //退出区，解锁 remainder section; //剩余区&#125;void P2() &#123; wait(mutex); //进入区，加锁 critical section; //临界区 signal(mutex); //退出区，解锁 remainder section; //剩余区&#125; 当没有进程在临界区时，任意一个进程在进入临界区前会执行 $P$ 原语，将资源量 $S$ 减为 $0$，然后进入临界区；当有进程存在于临界区时，$S=0$，再有进程要进入临界区时，执行 $P$ 操作将会阻塞，直到在临界区中的进程退出 【前驱关系问题】当多个进程之间或语句之间存在前驱关系时，会根据前驱图分析每一对前驱关系，为每一对前驱关系设置一个同步信号量，以保证进程或语句的顺序执行 关于前驱图，详见：前驱图与进程图 假设存在 $P_1$、$P_2$、$P_3$、$P_4$、$P_5$、$P_6$ 这 $6$ 个进程，每个进程中只有 $S_i$ 这一条语句，这 $6$ 个进程的前驱图如下所示 可以发现，前驱图中存在 $P_1\\rightarrow P_2$、$P_1\\rightarrow P_3$、$P_2\\rightarrow P_4$、$P_2\\rightarrow P_5$、$P_3\\rightarrow P_6$、$P_4\\rightarrow P_6$、$P_5\\rightarrow P_6$ 这 $7$ 个前驱关系，为使得各程序段间能正常执行，设置 $7$ 个同步信号量，分别代表上述的 $7$ 个前驱关系，之后对每个前驱关系与同步信号量，采用进程同步的方法即可 12345678910111213141516171819202122232425262728293031323334353637383940semaphore p12 = 0; //P1-&gt;P2semaphore p13 = 0; //P1-&gt;P3semaphore p24 = 0; //P2-&gt;P4semaphore p25 = 0; //P2-&gt;P5semaphore p36 = 0; //P3-&gt;P6semaphore p46 = 0; //P4-&gt;P6semaphore p56 = 0; //P5-&gt;P6void P1() &#123; S1; signal(p12); signal(p13); //此时P1执行完毕&#125;void P2() &#123; wait(p12); //检查P1是否执行完毕 S2; signal(p24); signal(p25); //此时P2执行完毕&#125;void P3() &#123; wait(p13); //检查P1是否执行完毕 S3; signal(p36); //此时P3执行完毕&#125;void P4() &#123; wait(p24); //检查P2是否执行完毕 S4; signal(p46); //此时P4执行完毕&#125;void P5() &#123; wait(p25); //检查P2是否执行完毕 S5; signal(p56); //此时P5执行完毕&#125;void P6() &#123; wait(p36); //检查P3是否执行完毕 wait(p46); //检查P4是否执行完毕 wait(p56); //检查P5是否执行完毕 S3;&#125; 【生产者-消费者问题】1.问题描述 一组生产者进程和一组消费者进程共享一个初值为空，大小为 $n$ 的缓冲区，只有缓冲区未满时，生产者才能将产品放入缓冲区中，否则必须等待；只有缓冲区不空时，消费者才能从缓冲区中提取出产品，否则必须等待，同时，缓冲区是临界资源，任一时刻只允许一个生产者放入产品或一个消费者提取产品 2.问题分析 可以发现，生产者和消费者对缓冲区的访问是互斥关系，同时生产者和消费者又存在同步关系，只有生产者生产后，消费者才能消费 为此，设置一个初值为 $1$ 的互斥信号量 mutex，用来互斥访问缓冲区，再设置一个初值为 $0$ 的记录当前缓冲区中存放产品格子的数量的信号量 full，还需设置一个初值为 $n$ 的记录当前缓冲区中未存放产品格子的数量的信号量 empty，用来标志缓冲区已空 3.实现 1234567891011121314151617181920212223semaphore mutex = 1; //临界区互斥信号量semaphore empty = n; //空缓冲区semaphore full = 0; //满缓冲区void producer() &#123; //生产者进程 while (true) &#123; 生产产品; P(empty); //申请存入缓冲区，空缓冲区-1 P(mutex); //进入区 放入缓冲区; //临界区 V(mutex); //退出区 V(full); //增加一个产品，满缓冲区+1 &#125;&#125;void consumer() &#123; //消费者进程 while (true) &#123; P(full); //申请取出一个产品，满缓冲区-1 P(mutex); //进入区 放入缓冲区; //临界区 V(mutex); //退出区 V(empty); //减少一个产品，空缓冲区+1 使用产品; &#125;&#125; 【多生产者消费者问题】1.问题描述 桌上有一个盘子，每次只能放一个水果，父亲只能向盘子里放苹果，母亲只能向盘子里放橘子，女儿专门吃苹果，儿子专门吃橘子，只有盘子中有水果时，女儿或儿子才能吃水果，同时，盘子是临界资源，任一时刻只允许父亲或母亲放入水果，儿子或女儿吃水果 2.问题分析 可以发现，该问题是生产者与消费者问题的改进，即存在两个生产者、两个消费者，缓冲区大小为 $1$ 对盘子的访问是互斥关系，同时父亲和女儿、母亲和儿子间存在两对同步关系，即父亲放完苹果后女儿要立刻吃，母亲放完橘子后儿子要立刻吃 为此，设置一个初值为 $1$ 的互斥信号量 mutex，用来互斥访问盘子，再设置一个初值为 $0$ 的表示父女间前驱关系的同步信号量 apple，一个初值为 $0$ 的表示母子间前驱关系的同步信号量 orange 3.实现 123456789101112131415161718192021222324252627282930313233343536semaphore mutex = 1; //互斥信号量semaphore apple = 0; //父女间同步信号量semaphore orange = 0; //母子间同步信号量void father() &#123; //父亲进程 while (true) &#123; 准备苹果; P(mutex); //进入区 向盘子中放苹果; //临界区 V(apple); //苹果数量+1 &#125;&#125;void daughter() &#123; //女儿进程 while (true) &#123; P(apple); //苹果数量-1 从盘子中拿苹果; //临界区 V(mutex); //退出区 吃苹果; &#125;&#125;void mother() &#123; //母亲进程 while (true) &#123; 准备橘子; P(mutex); //进入区 向盘子中放橘子; //临界区 V(orange); //橘子数量+1 &#125;&#125;void son() &#123; //儿子进程 while (true) &#123; P(orange); //橘子数量-1 从盘子中拿橘子; //临界区 V(mutex); //退出区 吃苹果; &#125;&#125; 【吸烟者问题】1.问题描述 有三个抽烟者，一个供应者，抽烟者不停的卷烟并抽烟，其需要三种材料：烟草、纸、胶水，三个人中，第一个有胶水，第二个有纸，第三个有烟草；供应者无限提供这三种材料，每次随机将两种不同的材料放到桌上，拥有剩下那种材料的抽烟者就会拿起桌上的材料卷烟并抽掉，同时告诉供应者已完成，供应者又会随机再提供两种材料，如此往复 2.问题分析 可以发现，总共存在 $4$ 个进程，一个进程负责提供材料，剩下三个负责卷烟抽烟 供应者和每个抽烟者之间都存在一对同步关系，只有供应者提供材料后，抽烟者才可以卷烟抽烟，同时，供应者无法同时满足两个及以上的抽烟者，彼此之间存在互斥关系，此外，在一个抽烟者完成后，会通知供应者，这里也存在一个同步关系 为此，设置三个初值为 $0$ 的同步量 offer1、offer2、offer3，分别表示供应者提供的烟草与纸、烟草与胶水、纸与胶水，设置一个初值为 $0$ 的同步量 finish，来代表抽烟者通知供应者提供材料 由于每次供应者提供材料是随机提供两种的，为此要设置一个随机数再模 $3$，根据结果令供应者每次随机提供两种材料 3.实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int random; //随机数semaphore offer1 = 0; //烟草与纸semaphore offer2 = 0; //烟草与胶水semaphore offer3 = 0; //纸与胶水semaphore finish = 0; //卷烟吸烟是否完成void supply() &#123; //供应者 while (true) &#123; seed = time(0); //随机数种子 srand(seed); //根据种子产生随机数流 random = rand(); //生成一个随机数 random %= 3; if (random == 0) V(offer1); //提供烟草与纸 else if (random == 1) V(offer2); //提供烟草与胶水 else V(offer3); //提供纸与胶水 将材料放到桌子上; P(finish); //供应者完成提供材料的任务 &#125;&#125;void smoke1() &#123; //抽烟者1 while (true) &#123; P(offer1); //从桌上取烟草与纸 拿材料、卷烟、抽烟; V(finish); //通知供应者提供材料 &#125;&#125;void smoke2() &#123; //抽烟者2 while (true) &#123; P(offer2); //从桌上取烟草与胶水 拿材料、卷烟、抽烟; V(finish); //通知供应者提供材料 &#125;&#125;void smoke3() &#123; //抽烟者3 while (true) &#123; P(offer3); //从桌上取纸与胶水 拿材料、卷烟、抽烟; V(finish); //通知供应者提供材料 &#125;&#125; 【读写者问题】1.问题描述 存在读、写两组并发进程，共享一个文件，允许当两个及以上读进程时，但当某个写进程与其他进程同时访问时，会出现错误，为此要求： 允许多个读进程同时读 任一时刻只允许一个写进程写 任一写进程写完前不允许其他进程工作 写进程写前应让已有进程退出 2.问题分析 可以发现，读进程与写进程间存在互斥关系，写进程与其他任意进程存在互斥关系，此外，还应记录有几个读者在读 为此，设置一个初值为 $0$ 的计数器 count 来记录读者数量，还要设置一个互斥信号量 mutex 来防止更新 count 时出现错误，一个互斥信号量 rw 来用于读写进程互斥访问文件 3.实现 由于未说明读、写进程间是否存在优先级，为此分别给出读进程优先、写进程优先的实现 读进程优先：可能会导致写进程饿死 12345678910111213141516171819202122232425262728int count = 0;semaphore mutex = 1;semaphore rw = 1;void writer() &#123; //写进程 while (true) &#123; P(rw); //进入区，上锁 向文件中写入; //临界区 V(rw); //退出区，开锁 &#125;&#125;void read() &#123; //读进程 while (true) &#123; P(mutex); if (count == 0) //当读进程读时，只要count&gt;0就不再上锁 P(rw); //防止写进程写，上锁 count++; V(mutex); 从文件中读取; P(mutex); count--; if (count == 0) //当读进程读完时 V(rw); //允许写进程写，开锁 V(mutex); &#125;&#125; 写进程优先：读写公平，优先级相同 1234567891011121314151617181920212223242526272829303132int count = 0;semaphore mutex = 1;semaphore rw = 1;semaphore w = 1; //用于实现写优先void writer() &#123; //写进程 while (true) &#123; P(w); //无写进程时进入 P(rw); //进入区，上锁 向文件中写入; //临界区 V(rw); //退出区，开锁 V(w); //恢复对文件的访问 &#125;&#125;void read() &#123; //读进程 while (true) &#123; P(w); //无写进程时进入 P(mutex); if (count == 0) //当读进程读时，只要count&gt;0就不再上锁 P(rw); //防止写进程写，上锁 count++; V(mutex); V(w); //恢复对文件的访问 从文件中读取; P(mutex); count--; if (count == 0) //当读进程读完时 V(rw); //允许写进程写，开锁 V(mutex); &#125;&#125; 【哲学家进餐问题】1.问题描述 一个圆桌上有 $n$ 个哲学家，每两人之间摆一根筷子，中间一碗米饭，哲学家只进餐、思考，思考时不影响他人，进餐时试图拿起左右两根筷子，若筷子已经在他人手上，则进行等待，当进餐完毕后，放下筷子，进行思考 2.问题分析 对于 $n$ 个哲学家来说，其与左右相邻的人对其中间的筷子进行互斥访问 为此，对于 $n$ 根筷子来说，每根筷子设置一个互斥信号量，从而构成一个互斥信号量组 chopsticks[n]，再令哲学家编号从 $0$ 到 $n-1$，规定 $i$ 号左边筷子为 $i$，右边筷子为 $(i+1)\\%n$ 而对于 $n$ 个哲学家进程来说，最简单的方法是同时拿起左右两根筷子，但这可能造成死锁，为避免死锁，有以下三种做法： if 条件控制：制定拿筷子的规则，筷子奇偶限制 同步量限制：对进程加以限制，最多允许 $n-1$ 个人同时用餐 互斥量限制：规定仅当左右两只筷子同时可用时才进餐 3.实现 同时拿起筷子：当同时都拿起左筷子或同时都拿起右筷子，可能会造成死锁 123456789101112131415semaphore chopsticks[n];void init() &#123; //互斥信号量集初始化 for (int i = 0; i &lt; n; i++) chopsticks[i] = 1;&#125;void philosopher_i(int i) &#123; //第i个哲学家进程 while (true) &#123; P(chopsticks[i]); //拿左边 P(chopsticks[(i + 1) % n]); //拿右边 吃饭; V(chopsticks[i]); //放左边 V(chopsticks[(i + 1) % n]); //放右边 思考; &#125;&#125; if 条件控制：奇数号哲学家先拿左边筷子，偶数号哲学家先拿右边筷子 1234567891011121314151617181920212223semaphore chopsticks[n];void init() &#123; //互斥信号量集初始化 for (int i = 0; i &lt; n; i++) chopsticks[i] = 1;&#125;void philosopher_i(int i) &#123; //第i个哲学家进程 while (true) &#123; if (i % 2) &#123; //奇数，先左后右 P(chopsticks[i]); //拿左边 P(chopsticks[(i + 1) % n]); //拿右边 吃饭; V(chopsticks[i]); //放左边 V(chopsticks[(i + 1) % n]); //放右边 思考; &#125; else &#123; //偶数，先右后左 P(chopsticks[(i + 1) % n]); //拿右边 P(chopsticks[i]); //拿左边 吃饭; V(chopsticks[(i + 1) % n]); //放右边 V(chopsticks[i]); //放左边 &#125; &#125;&#125; 同步量限制：即限制进餐人数，最多允许 $n-1$ 个人同时用餐 123456789101112131415161718semaphore chopsticks[n];semaphore num = 4; //进餐人数同步信号量void init() &#123; //互斥信号量集初始化 for (int i = 0; i &lt; n; i++) chopsticks[i] = 1;&#125;void philosopher_i(int i) &#123; //第i个哲学家进程 while (true) &#123; P(num); P(chopsticks[i]); //拿左边 P(chopsticks[(i + 1) % n]); //拿右边 吃饭; V(chopsticks[i]); //放左边 V(chopsticks[(i + 1) % n]); //放右边 V(num); 思考; &#125;&#125; 互斥量限制：规定仅当左右两只筷子同时可用时才进餐 123456789101112131415161718semaphore chopsticks[n];semaphore mutex = 1; //筷子互斥信号量void init() &#123; //互斥信号量集初始化 for (int i = 0; i &lt; n; i++) chopsticks[i] = 1;&#125;void philosopher_i(int i) &#123; //第i个哲学家进程 while (true) &#123; P(mutex); P(chopsticks[i]); //拿左边 P(chopsticks[(i + 1) % n]); //拿右边 V(mutex); 吃饭; V(chopsticks[i]); //放左边 V(chopsticks[(i + 1) % n]); //放右边 思考; &#125;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"信号量机制","slug":"operating-system/11.信号量机制","date":"2019-11-15T05:40:52.000Z","updated":"2021-10-13T13:58:48.941Z","comments":true,"path":"notes/operating-system/d0c0f553.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/d0c0f553.html","excerpt":"【信号量机制】利用硬件指令可以有效地实现进程互斥，但当进程资源忙碌时，其他访问进程必须不断地进行测试，处于一种忙等状态，不符合让权等待原则，造成了处理机的浪费 1965 年，Dijkstra 提出了信号量机制，在长期广泛的应用中，证明了其是一种卓有成效的进程同步机制，现广泛地利用于各种系统中","text":"【信号量机制】利用硬件指令可以有效地实现进程互斥，但当进程资源忙碌时，其他访问进程必须不断地进行测试，处于一种忙等状态，不符合让权等待原则，造成了处理机的浪费 1965 年，Dijkstra 提出了信号量机制，在长期广泛的应用中，证明了其是一种卓有成效的进程同步机制，现广泛地利用于各种系统中 信号量是用于表示系统资源数量的变量，一般用 $S$ 来表示，规定其只能通过信号量机制中的两个标准的原语 $P$ 原语和 $V$ 原语来访问 其中，$P$ 原语常写为 wait(S)，用于申请资源，$V$ 原语常写为 signal(S)，用于释放资源，两者成对使用 【整型信号量】整型信号量定义为一个用于表示资源数目的整型量 S，其与一般除初始化外，仅能通过 $P$ 原语和 $V$ 原语来访问 $P$ 原语和 $V$ 原语在执行时不可中断，他们的描述如下： 1234567void wait(S) &#123; //P原语 while(S &lt;= 0); //忙等 S--;&#125;void signal(S) &#123; //V原语 S++;&#125; 在 $P$ 原语中，只要信号量 $S\\leq 0$，就会不断的测试，陷入忙等状态，因此，该机制并未遵循让权等待原则 【记录型信号量】为解决整型信号量中的忙等问题，有了记录型信号量，其除了一个用于表示资源数目的整型变量 value 外，还增加了一个进程链表指针 link，用于链接多个等待进程 记录型信号量的结构如下： 1234struct Semaphore &#123; int value; //记录资源数目 struct process_control_block *link; //PCB链表指针&#125;; 在记录型信号量中，${S-&gt;value}$ 的初值表示系统中某类资源的数目，对他的每次 wait 操作，意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源数减少一个；对他的每次 signal 操作，意味着进程释放一个单位的该类资源，使系统中可供分配的该类资源数增加一个 相应的， $P$ 原语和 $V$ 原语的描述如下： 12345678910void wait (Semaphore *S) &#123; //P原语 S-&gt;value--; if (S-&gt;value &lt; 0) //该类资源已分配完毕 block(S-&gt;link); //自我阻塞，放弃处理机&#125;void signal (Semaphore *S) &#123; //V原语 S-&gt;value++; if (S-&gt;value &lt;= 0) //仍有等待资源的进程被堵塞 wakeup(S-&gt;link); //唤醒链表中的第一个等待进程&#125; 每执行一次 $P$ 原语，表示进程请求一个资源，当资源量 $value&lt;0$ 时，表示该类资源已经分配完毕，因此要调用 block 原语，进行自我阻塞，放弃处理机，并插入到该类资源的 PCB 队列中 每执行一次 $V$ 原语，表示进程释放一个资源，使系统中可供分配的该类资源数 $+1$，故若 $+1$ 后，资源量 $value\\leq0$，则表示在 PCB 链表中仍有等待该资源的进程被阻塞，因此还应调用 wakeup 原语，将 PCB 链表中的第一个等待进程唤醒 【AND 型信号量】在某些应用场合，一个进程往往需要两个及以上的共享资源才能执行其任务 假定有两个进程 $A$、$B$，要求访问临界资源 $C$、$D$，那么，如果 $A$ 占有了 $C$ 等待 $D$，$B$ 占有了 $D$ 等待 $C$，那么就会陷入死锁状态，两者都在等待对方释放自己所需的资源 显然，当进程同时要求的共享资源越多时，发生进程死锁的可能性就越大 为预防进程死锁的问题，出现了 AND 型信号量，其基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放，简单来说，要么全部分配完成，要么一个也不分配 在实现中，对若干临界资源的分配采取了原子操作方式，为此在 wait 与 signal 的操作的基础上，加了一个 AND 条件，称为同时 wait 操作、同时 signal 操作，其描述如下： 1234567891011121314151617181920void Swait(int S1, int S2, ..., int Sn) &#123; while (true) &#123; if(S1 &gt; 0 &amp;&amp; S2 &gt; 0 &amp;&amp; ... &amp;&amp; Sn &gt; 0) &#123; for (int i = 1; i &lt;= n; i++) Si--; break; &#125; else&#123; 将进程堵塞在第一个不能满足资源信号量的队列中 &#125; &#125;&#125;void Ssignal(int S1, int S2, ..., int Sn) &#123; while (true) &#123; for (int i = 1; i &lt;= n; i++) &#123; Si+; 唤醒所有与Si相关的阻塞进程 &#125; &#125;&#125; 【信号量集】对于记录型信号量，$P$ 原语或 $V$ 原语只能对某临界资源进行一个单位的申请或释放，当一次需要 $n$ 个单位时，意味着需要 $n$ 次 $P$、$V$ 操作，这不仅低效，还会增加死锁的概率 在某些情况下，为保证系统的安全性，当所申请的资源数量低于一定值时，必须要加以管制不予分配，因此当进程申请某类临界资源时，每次分配前都要测试资源数量，判断是否大于可分配的下限值，决定是否予以分配 基于以上两点，对 AND 型信号量进行扩充，在一次 P、V 原语中，对进程所申请的所有资源以及每类资源不同资源的需求量完成申请或释放 进程对信号量 ${S_i}$ 的测试值不再是 $1$，而是该类资源的分配下限值 ${t_i}$，即要求 ${S_i\\geq t_i}$，否则不予分配，一旦允许分配，进程对该类资源的需求为 ${d_i}$，那么就进行 ${S_i=S_i-d_i}$操作，由此形成一般化的信号量集机制，对应的 $P$ 原语或 $V$ 原语次格式如下： 123456789void Swait (int S[], int t[], int d[], int n) &#123; //P原语 if (S[1] &gt;= t[1] &amp;&amp; ... &amp;&amp; S[n] &gt;= t[n]) for (int i = 1; i &lt;= n; i++) S[i] -= d[i];&#125;void Ssignal (int S[], int d[], int n) &#123; //V原语 for (int i = 1; i &lt;= n; i++) S[i] += d[i];&#125; 一般的信号量集还具有以下三种情况： Swait(S,d,d)：此时信号量集中仅有一个信号量，但允许他每次申请 $d$ 个资源，若现有资源数少于 $d$，不予分配 Swait(S,1,1)：相当于一般的记录型信号量（$S&gt;1$）或互斥信号量（$S=1$） Swait(S,1,0)：相当于一个可控开关，当 ${S \\geq 1}$ 时，允许多个进程进入某特定区，当 ${S=0}$ 时，阻止任何进程进入特定区","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"实现临界区互斥的基本方法","slug":"operating-system/10.实现临界区互斥的基本方法","date":"2019-11-14T11:48:57.000Z","updated":"2021-10-11T13:46:26.195Z","comments":true,"path":"notes/operating-system/238d6eca.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/238d6eca.html","excerpt":"【软件实现方法】软件实现方法，是在进入区设置和检查一些标志，来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后，在退出区修改标志 单标志法","text":"【软件实现方法】软件实现方法，是在进入区设置和检查一些标志，来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后，在退出区修改标志 单标志法单标志法其通过设置一个公用整型变量 turn，来指示被允许进入临界区的进程编号，从而确保每次只允许一个进程进入临界区，例如，当 turn=0 时，允许进程 $P_0$ 进入临界区 12345678910111213141516int turn;void init() &#123; turn = 0;&#125;void P0() &#123; //P0进程 while (turn != 0); //进入区 critical section; //临界区 turn = 1; //退出区 remainder section; //剩余区&#125;void P1() &#123; //P1进程 while (turn != 1); //进入区 critical section; //临界区 turn = 0; //退出区 remainder section; //剩余区&#125; 但该算法违反了空闲让进原则，其要求两个进程交替进入临界区，如果某个进程不再进入临界区，那么另一个进程也无法进入临界区 例如，$P_0$ 进入临界区并从临界区离开，那么此时临界区是空闲的，但 $P_1$ 并没有进入临界区的打算，trun=1 会一直成立，$P_0$ 会被 while 死循环困住，无法进入临界区 双标志先检查法双标志先检查法的基本思想是在每一个进程访问临界区资源前，先检查临界资源是否正在被访问，若正被访问，该进程需要等待，若未被访问，该进程才可进入临界区 该方法设置了一个 flag[i] 标志，标识第 $i$ 个进程 $P_i$ 是否已经进入临界区，若 flag[i]=ture，表示 $P_i$ 已经进入临界区，若 flag[i]=false，表示 $P_i$ 未进入临界区 12345678910111213141516171819bool flag[2];void init() &#123; flag[0] = false; flag[1] = false;&#125;void P0() &#123; //P0进程 while (flag[1]); //1 进入区 flag[0] = true; //2 critical section; //3 临界区 flag[0] = false; //4 退出区 remainder section; //剩余区&#125;void P1() &#123; //P1进程 while (flag[0]); //5 进入区 flag[1] = true; //6 critical section; //7 临界区 flag[1] = false; //8 退出区 remainder section; //剩余区&#125; 按 $1$、$5$、$2$、$6$、$3$、$7\\dots$ 的顺序，可能会导致 $P_0$、$P_1$ 同时访问临界区，违反了忙则等待原则 这是因为先检测对方进程状态标志后，再设置自己的标志，由于检测和放置中可插入另一个进程到达时的检测操作，从而可能造成两个进程分别检测后同时进入临界区 双标志后检查法双标志后检查法先设置自己的标志为 true 后，再检测对方的标志，若对方标志为 true，则进程等待，否则进入临界区 12345678910111213141516171819bool flag[2];void init() &#123; flag[0] = false; flag[1] = false;&#125;void P0() &#123; //P0进程 flag[0] = true; //1 进入区 while (flag[1]); //2 critical section; //3 临界区 flag[0] = false; //4 退出区 remainder section; //剩余区&#125;void P1() &#123; //P1进程 flag[1] = true; //5 进入区 while (flag[0]); //6 critical section; //7 临界区 flag[1] = false; //8 退出区 remainder section; //剩余区&#125; 按 $1$、$5$、$2$、$6\\dots$ 的顺序，可能会导致 $P_0$、$P_1$ 都无法进入临界区，导致出现饥饿现象，违反了空闲让进和有限等待原则 Peterson 算法Peterson 算法结合了单标志法、双标志后检查法，若双方都想进入临界区，会尝试让进程彼此谦让 每个进程先设置自己的 flag[i] 标志，表示 $P_i$ 是否进入临界区，用于解决互斥；又设置了 turn 标志，表示优先让哪个进程进入，用于解决饥饿 1234567891011121314151617181920212223bool flag[2];int turn;void init() &#123; turn = 0; flag[0] = false; flag[1] = false;&#125;void P0() &#123; //P0进程 flag[0] = true; //进入区 turn = 1; while (flag[1] &amp;&amp; turn == 1); critical section; //临界区 flag[0] = false; //退出区 remainder section; //剩余区&#125;void P1() &#123; //P1进程 flag[1] = true; //进入区 turn = 0; while (flag[0] &amp;&amp; turn == 0); critical section; //临界区 flag[1] = false; //退出区 remainder section; //剩余区&#125; 可以发现，Peterson 算法在进入区中，是先主动争取，然后主动谦让，最后再检查对方是否想进入临界区，己方是否谦让 其遵循了空闲让进、忙则等待、有限等待原则，但违反了让权等待原则，可能会造成忙等 【硬件实现方法】许多计算机中提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换，利用这些特殊的硬件指令，可以解决临界区问题。 进入临界区往往与其标志有关，我们可以将标志看做一个初始时开启的锁：锁开启时，允许进入，且进入后关闭锁；锁关闭时，必须等待 中断屏蔽法中断屏蔽法是实现互斥的最简单的方法，其利用了开关中断指令实现互斥 在进入锁测试前关闭中断，直到完成锁测试并上锁后才能打开中断，这样进程在临界区执行期间，系统不响应中断，从而也就不会引发调度 但关中断的方法具有许多缺点，例如：滥用关中断权力、关中断时间过长影响系统效率、不适用于多 CPU 系统等 123456while (true) &#123; 关中断; //进入区 critical section; //临界区 开中断; //退出区 remainder section //剩余区&#125; TSL 指令TSL 指令是一条硬件指令：Test-and-Set-Lock 指令，其是用硬件实现的原子操作，在读出指定标志后，会将标志设为真，整个检查、上锁过程一气呵成 该指令一般性描述如下： 12345bool TSL (bool *lock) &#123; //lock表示临界区是否被上锁 bool old = *lock; //存放lock原来的值 *lock = true; //无论之前是否加锁，都上锁 return old; //返回lock原来的值&#125; TSL 指令可以看做一个函数过程，其执行过程是不可分割的，即其是一条原语，其中 lock 具有两种状态： *lock=false 时：表示该资源空闲 *lock=true 时：表示该资源正被使用 用 TSL 指令管理临界区时，现为每个临界资源设置一个布尔变量 lock，由于变量 lock 代表了该资源的状态，故可以将其看作一把锁 利用 TSL 指令实现互斥的循环进程结构描述如下： 123456while (true) &#123; while(TS(&amp;lock)); //进入区 critical section; //临界区 lock = false; //退出区 remainder section //剩余区&#125; 该方法实现简单，适合多处理机，但不满足让权等待原则，无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令 swap 指令swap 指令即对换指令，其同样是由硬件实现的原子操作，用于交换两个字的内容，其处理过程描述如下： 123456void swap (bool *a, bool *b) &#123; bool temp; temp = *a; *a = *b; *b = temp;&#125; 使用对换指令可以简单有效地实现互斥，其方法是为每个临界资源设置一个初值为 false 的全局布尔变量 lock，在每个进程中再利用一个局部布尔变量 key，利用 swap 进行交换来实现互斥 利用 swap 指令实现互斥的循环进程结构描述如下： 12345678while (true) &#123; bool key = true; //进入区 while(key) swap(&amp;lock, &amp;key); critical section; //临界区 lock = false;//退出区 remainder section //剩余区&#125; 该方法与 TSL 指令方法一样，实现简单，适合多处理机，且不满足让权等待原则","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"进程同步与进程互斥的基本概念","slug":"operating-system/09.进程同步与进程互斥的基本概念","date":"2019-11-14T03:32:22.000Z","updated":"2021-10-10T14:24:34.351Z","comments":true,"path":"notes/operating-system/d2f7777c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/d2f7777c.html","excerpt":"【临界资源与临界区】虽然多个进程可以共享系统中的各种资源，但有许多进程一次只能被一个进程使用，这种一次仅允许一个进程使用的资源被称为临界资源，例如打印机、磁带机等 对临界资源的访问，应采取互斥的方式进行访问，在每个进程中访问临界资源的代码被称作临界区","text":"【临界资源与临界区】虽然多个进程可以共享系统中的各种资源，但有许多进程一次只能被一个进程使用，这种一次仅允许一个进程使用的资源被称为临界资源，例如打印机、磁带机等 对临界资源的访问，应采取互斥的方式进行访问，在每个进程中访问临界资源的代码被称作临界区 显然，若能保证诸进程互斥地进入自己的临界区，便可实现进程对临界资源的互斥访问，为此，在每个进程进入临界区前，应先对欲访问的临界资源进行检查，看他是否正在被访问 由此，可以在临界区前增加一段用于检查的代码：如果某时刻临界资源正被访问，那么进程就可以访问该临界资源，并设置该临界资源正被访问的标志；如果某时刻临界资源正被访问，那么该进程就不能进入临界区 于是，可以将对临界资源的访问过程分为四个部分： 进入区：用于检查能否进入临界区 临界区：访问临界资源的代码 退出区：将正在访问临界区的标志清除 剩余区：进程中除进入区、临界区、退出区的其他部分 因此，一个访问临界资源的循环进程可以被描述为： 123456while (true) &#123; entry section; //进入区 critical section; //临界区 exit section; //退出区 remainder section //剩余区&#125; 【进程间的制约关系】多个程序在并发执行时，对于同处一个系统中的多个进程，由于他们共享系统中的资源，或为完成某一任务而相互合作，使得他们存在制约关系，制约关系分为以下两种 同步同步，又称直接制约关系，其是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系 可以发现，进程间的直接制约关系就是源于它们间的相互合作 互斥互斥，又称间接制约关系，当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问该临界资源 为禁止两个进程同时进入临界区，同步机制应遵循以下四条规则： 空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，此时允许请求进入临界区的进程进入 忙则等待：当有进程处于临界区时，表明临界资源处于忙碌状态，此时请求进入临界区的进程必须等待，以保证对临界资源的互斥访问 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入 死等 让权等待：进程无法进入自己的临界区时，应立刻师范处理机，以免陷入 忙等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"HTTP 协议","slug":"computer-networks/56.HTTP协议","date":"2019-11-12T14:44:00.000Z","updated":"2021-08-29T17:34:05.451Z","comments":true,"path":"notes/computer-networks/1e0873bb.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/1e0873bb.html","excerpt":"【概述】通过超文本传输协议（Hypertext Transfer Protocol，HTTP），定义了万维网客户进程（浏览器）如何向万维网服务器请求万维网文档，以及服务器如何将文档传送给浏览器 从层次的角度来看，HTTP 是面向事务的应用层协议，其基于 TCP 协议，保障数据的可靠传输，但其本身是无连接的，即 HTTP 虽然使用了 TCP 连接，但通信双方在交换 HTTP 报文时，不需要建立 HTTP 连接","text":"【概述】通过超文本传输协议（Hypertext Transfer Protocol，HTTP），定义了万维网客户进程（浏览器）如何向万维网服务器请求万维网文档，以及服务器如何将文档传送给浏览器 从层次的角度来看，HTTP 是面向事务的应用层协议，其基于 TCP 协议，保障数据的可靠传输，但其本身是无连接的，即 HTTP 虽然使用了 TCP 连接，但通信双方在交换 HTTP 报文时，不需要建立 HTTP 连接 在同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时相同，因为服务器不记得曾经访问过的这个客户，也不记得为该客户曾服务过多少次，因此，HTTP 协议是无状态的，这简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求 在实际应用中，通常使用 Cookie 加数据库的方式来追踪用户活动，Cookie 是存储在用户主机的文本文件，其中包含一串识别码，用于令 Web 服务器来识别服务，Web 服务器根据 Cookie 就能从其数据库中查询到该用户的活动记录，进而执行一些个性化的工作 【HTTP 操作过程】从 HTTP 协议的执行过程来说，当浏览器要访问 WWW 服务时，大致工作流如下： 通过 DNS 来完成对 WWW 服务器的域名解析，一旦获取服务器的 IP 地址，浏览器会通过 TCP 来向服务器发送建立连接请求 每个万维网站点都有一个服务器进程，其不断地监听 TCP 的 $80$ 端口，当监听到连接请求后，就与浏览器建立连接 TCP 连接建立后，浏览器就向服务器发送请求来获取某一 Web 页面的 HTTP 请求 在服务器收到 HTTP 请求后，将构建所请求的 Web 页面的信息，并通过 HTTP 响应返回给浏览器 浏览器将返回的信息进行解释，之后将 Web 页面显示给用户 通信完成，TCP 连接释放 以用户单击 HTML 页面的 www.baidu.com/images/index.html 的超链接为例，在单击后，发生的事件顺序如下： 浏览器分析链接指向页面的 URL：www.baidu.com/images/index.html 浏览器向 DNS 请求解析 www.baidu.com DNS 解析出 www.baidu.com 的 IP 地址 浏览器与该 IP 地址对应服务器建立 TCP 连接（默认端口号 $80$） 浏览器发出 HTTP 请求：GET /images/index.html 服务器通过 HTTP 响应将文件 index.html 发送给浏览器 TCP 连接释放 浏览器将文件 index.html 进行解释，并展现给用户 【连接方式】由于 HTTP 是无连接的，也就是说，在收发 HTTP 报文时，是基于 TCP 连接的 根据 TCP 连接是否在发送完响应后断开，HTTP 可分为持久连接与非持久连接 1.持久连接 持久连接，就是万维网服务器在发送响应后，仍然保持这条 TCP 连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求和响应报文 持久连接又分为流水线和非流水线两种方式： 非流水线方式：客户在收到前一个响应后，才能发出下一个请求 流水线方式：客户采用流水线的方式，接收响应与发送请求 2.非持久连接 非持久连接，就是在每一个 HTTP 请求发送后，都建立一条 TCP 连接，在服务器响应后，断开该 TCP 连接 也就是说，请求一个万维网文档所需的时间，是该文档的传输时间加上两倍的 RTT，其中，一个 RTT 用于 TCP 连接，另一个 RTT 用于请求和接收文档 【HTTP 报文结构】类型HTTP 是面向文本的，因此，在报文中的每个字段都是一些 ASCII 码，且每个字段的长度都是不确定的 在浏览器与服务器间请求和响应的交互，必须按照规定的格式和一定的规则，这些格式和规则就是 HTTP，因此，HTTP 有两类报文： HTTP 请求报文：从 Web 客户端向 Web 服务器发送服务请求 HTTP 响应报文：从 Web 服务器向 Web 客户端发送服务响应 请求报文HTTP 请求报文由开始行、首部行、实体主体组成，具体格式如下图 其中，开始行也称请求行，其各字段含义如下： 方法：请求报文采用的各种方法，如 GET、POST、PUT URL：即所请求的资源的 URL 版本：HTTP 的版本 常见的方法及作用如下表： 响应报文HTTP 响应报文由开始行、首部行、实体主体组成，具体格式如下图 其中，开始行也称状态行，其各字段含义如下： 版本：HTTP 的版本 状态码：反映请求状态的代码 短语：解释状态码的简单短语 状态码都是三位数字，其基本含义如下： 1xx：表示通知信息，如请求收到了或正在进行处理 2xx：表示成功，如接受或知道了 3xx：表示重定向，表示要完成请求还必须采取进一步的行动 4xx：表示客户的差错，如请求中有错误的语法或不能完成 5xx：表示服务器的差错，如服务器失效无法完成请求","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"万维网 WWW","slug":"computer-networks/55.万维网WWW","date":"2019-11-12T13:59:00.000Z","updated":"2021-08-29T16:58:43.459Z","comments":true,"path":"notes/computer-networks/6ccd1df6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/6ccd1df6.html","excerpt":"【概述】万维网（World Wide Web，WWW）是无数个网络站点和网络的集合，它们一起构成了因特网的最主要部分，其内核部分由以下三个标准构成： 统一资源定位符 URL：标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符 超文本传输协议 HTTP：基于 TCP 协议的应用层协议，是万维网客户程序与服务器程序间交互所必须严格遵守的协议 超文本标记语言 HTML：文档结构的标记语言，使用一些约定的标记对页面上的各种信息、格式进行描述","text":"【概述】万维网（World Wide Web，WWW）是无数个网络站点和网络的集合，它们一起构成了因特网的最主要部分，其内核部分由以下三个标准构成： 统一资源定位符 URL：标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符 超文本传输协议 HTTP：基于 TCP 协议的应用层协议，是万维网客户程序与服务器程序间交互所必须严格遵守的协议 超文本标记语言 HTML：文档结构的标记语言，使用一些约定的标记对页面上的各种信息、格式进行描述 【工作方式】万维网以 C/S 方式工作，浏览器是在用户计算机上的万维网客户程序，万维网文档所驻留的计算机被称为万维网服务器，运行服务器程序 客户程序向服务器程序发送请求，服务器程序会向客户程序返回客户所需要的文档，大致工作流程如下： Web 用户使用浏览器，通过制定 URL 来与 Web 服务器建立连接，并发送浏览请求 Web 服务器将 URL 转为文件路径，并返回信息给 Web 服务器 通信完成，释放连接 【URL】万维网是一个资料空间，其中的每个事务被称为资源，每个资源通过一个全域的统一资源定位符（Uniform Resource Locator，URL）来标识 URL 相当于一个文件名在网络范围的扩展，不区分大小写，其一般形式为：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 其中，常用的协议有 HTTP、FTP 等，&lt;主机&gt;是存放资源的主机在因特网中的域名或 IP 地址，&lt;端口&gt;、&lt;路径&gt; 有时可以省略 【HTTP 与 HTML】一个万维网文档通常通过使用超文本标记语言（HyperText Markup Language，HTML）来展现，用户可以利用 HTML 页面上的超链接，来获取万维网上的资源，每个超链接都链接到一个 URL 上 当使用者点击超链接后，超链接所对应的 URL 会通过超文本传输协议（Hypertext Transfer Protocol，HTTP）来传送给使用者 HTTP 协议定义了万维网客户进程如何向万维网服务器请求万维网文档，以及服务器如何将文档传送给浏览器 从层次的角度来看，HTTP 是面向事务的应用层协议，其规定了浏览器与服务器间请求和响应的格式、规则，是万维网上能够可靠交换文件的重要基础","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"电子邮件","slug":"computer-networks/54.电子邮件","date":"2019-11-12T07:12:00.000Z","updated":"2021-08-29T14:00:46.640Z","comments":true,"path":"notes/computer-networks/34e9705e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/34e9705e.html","excerpt":"【概述】电子邮件是一种异步通信方式，通信时不需要双方同时在场 电子邮件将邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取","text":"【概述】电子邮件是一种异步通信方式，通信时不需要双方同时在场 电子邮件将邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取 【电子邮件系统组成】一个电子邮件系统具有三个组成构件：用户代理、邮件服务器、邮件发送协议和读取协议 用户代理，是用户与电子邮件系统的接口，其能够使用户通过一个接口来收发邮件，同时，其具有撰写、显示、邮件处理的功能，在通常情况下，用户代理就是一个运行在 PC 端的程序，常见的有：Outlook、Foxmail 等 邮件服务器，是电子邮件系统的核心，其主要功能是发送、接收邮件，同时还要向发信人报告邮件传送的情况，包括已交付、被拒绝、丢失等 邮件服务器采用 C/S 方式，其能够同时充当客户和服务器，举例来说，当邮件服务器 A 向邮件服务器 B 发送邮件时，A 就作为客户，B 是服务器，反之，B 向 A 发送邮件时，B 作为客户，A 是服务器 邮件发送协议用于用户代理向邮件服务器发送邮件，或在邮件服务器间发送邮件，通常使用 SMTP 协议 邮件读取协议用于用户代理从邮件服务器读取邮件，通常使用 POP3 协议 【电子邮件收发过程】 电子邮件的发送接收过程可简化为上图所示形式： 发信人通过用户代理来撰写要发送的邮件 用户代理通过 SMTP 协议将邮件传给发送方邮件服务器 发送方邮件服务器放入邮件缓存队列中，等待发送 运行在发送方邮件服务器的 SMTP 客户进程，发现邮件缓存中存在待发送邮件，就向运行在接收方邮件服务器的 SMTP 客户进程建立 TCP 连接 TCP 连接建立后，SMTP 客户进程开始向远程 SMTP 进程发送邮件 当所有待发送邮件发送完毕，发送方 SMTP 进程关闭所建立的 TCP 连接 运行在接收方的 SMTP 进程收到邮件后，将邮件放入收信人的用户邮箱中，等待收信人接收 收信人在打算收信时，使用用户代理，通过 POP3 协议，将自己的邮件从接收方邮件服务器的用户邮箱中取回 【SMTP 协议】简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）是一种提供可靠且有效的电子邮件传输协议，控制两个相互通信的 SMTP 进程交换信息，SMTP 基于 C/S 模型，在传输层上采用 TCP 协议，端口号为 $25$ SMTP 通信主要有以下三个阶段： 1.连接建立 发件人的邮件发送到发送方邮件服务器的缓存后，SMTP 客户每隔一定时间，就对邮件缓存扫描一次 若发现有邮件，就利用 SMTP 的 $25$ 号端口与接收方的 SMTP 建立 TCP 连接 TCP 连接建立后，接收方 SMTP 要发送 220 Service ready 服务就绪消息，然后 SMPT 发送方会发送 HELO 命令，并附上发送方的主机名 2.邮件传送 在 TCP 连接建立后，就可以进行邮件的传送 1）邮件的传送从 MAIL 命令开始，其后跟有发件人的地址，例如：MAIL FROM: &lt;123@qq.com&gt;，若 SMTP 接收方准备好接收邮件，就回答 250 OK 信息 2）接着 SMTP 客户端发送一个或多个 RCPT 命令，来确定接收方是否已经做好接收邮件的准备，RCPT 命令的格式为： RCPT\\:\\:\\: TO: 每发送一个 RCPT 命令，都应有相应的信息从 SMTP 服务器返回，一般为 250 OK 信息或 550 无此用户信息 3）在获取 250 OK 信息后，发送方会使用 DATA 命令，开始传送邮件内容 一般情况下，接收方会回复： 354\\:\\:Start\\:\\:mail\\:\\:input;end\\:\\:with.这说明 SMTP 发送方可以开始传送邮件内容，并用 &lt;CRLF&gt;.&lt;CRLF&gt; （两个回车中间一个点）表示邮件内容的结束 3.连接释放 邮件发送完毕后，SMTP 发送方会发送 QUIT 命令，若 SMTP 接收方同意释放连接，会返回 221 服务关闭信息 随着万维网的流行，目前出现了许多基于万维网的电子邮件，例如 Gmail、Hotmail 等 这种电子邮件的特点是用户浏览器与邮件服务器间，发送、接收邮件使用 HTTP 协议，仅在不同邮件服务器间传送邮件才使用 SMTP 协议 【POP3 协议】邮局协议（Post Office Protocol，POP），是一个简单但功能有限的邮件读取协议，目前使用的是其第 $3$ 个版本，即 POP3 协议，其基于 C/S 模型，在传输层使用 TCP 协议，端口号为 $110$ POP3 采取的是拉（Pull）的通信方式，当用户读取邮件时，用户代理会向邮件服务器发出请求，拉取用户邮箱中的邮件 POP 有两种工作方式： 下载并保留：用户从邮件服务器中读取邮件后，邮件依然保留在服务器上，可下次再次从服务器上读取该邮件 下载并删除：用户从邮件服务器中读取邮件后，邮件就从服务器上删除了 值得注意是，除了 POP3 外，还有一个邮件读取协议是网际报文存取协议 IMAP，其比 POP3 要复杂的多，目前只是因特网的建议标准 【电子邮件格式】一个电子邮件分为信封和内容两部分，邮件内容又分为首部和主体两部分 其中，邮件的首部格式在 RFC 822 中有具体的规定，而邮件内容的主体部分让用户自行撰写 在用户写好首部和主体后，邮件系统会自动将信封所需的信息提取出来，并填写在信封上，无需用户亲自填写 邮件内容的首部包含一些首部行，每个首部行的格式为 关键字:值，有些首部行是必需的，有些则是可选的，最重要的关键字是 To、Subject To，是必需的关键字，其后跟一个或多个收信人的电子邮件地址；Subject ，是可选的关键字，其是邮件的主题 此外，还有一个必需的关键字 From，但其是由邮件系统自动填入的，其是发信人的电子邮件地址 一个典型的邮件内容如下图所示 【MIME】由于 SMTP 只能传送一定长度 ASCII 码，这导致许多非英语国家的文字无法利用 SMTP 来传送，也无法传送可执行文件与二进制对象，为此，提出了多用途网络邮件扩充（Multipurpose Internet Mail Extensions，MIME） MIME 并没有改动 SMTP 或取代它，其继续仍旧使用当前的格式，只是增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则 MIME 与 SMTP 关系如下图所示 MIME 主要包括了以下三部分内容： 定义了五个新的邮件首部：MIME 版本、内容描述、内容标识、内容传送编码、内容类型 定义了许多邮件内容的格式，同时对多媒体邮件的表示方法进行了标准化 在 ASCII 码的基础上定义了内容传送编码（Content-Transfer-Encoding） 关于内容传送编码 MIME 在 SMTP 的基础上定义了该编码，对原 ASCII 编码进行了扩充，具体规则如下： 1）若传送数据为 ASCII 码的话，仍采用 ASCII 码的编码方案 2）若传送数据只有少量 ASCII 码的话，采用 quoted-printable 编码方案 对于可打印 ASCII 码，除 = 外的所有编码，均不变 对于不可打印 ASCII 码、=、非 ASCII 码，每个字节的二进制代码用两个十六进制表示，然后在前面加上一个 = 3）对于二进制文件，采用 base64 编码方案 即先将二进制码划分为一个个 $24$ 位长的单元，再将每一个 $24$ 位单元划分为 $4$ 个 $6$ 位组，最后将每个 $6$ 位组转成一个 ASCII 码，具体规则是： A~Z 表示 0~25 a~z 表示 26~51 0~9 表示 52~61 + 表示 62 / 表示 63","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"域名系统 DNS","slug":"computer-networks/53.域名系统DNS","date":"2019-11-12T05:12:00.000Z","updated":"2021-08-29T13:57:12.240Z","comments":true,"path":"notes/computer-networks/fc548857.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/fc548857.html","excerpt":"【概述】域名系统（Domain Name System，DNS）是因特网使用的命名系统，用来将便于记忆的含有特定含义的主机名转换为便于机器处理的 IP 地址 因特网的域名系统被设计为一个联机分布式数据库系统，并采用 C/S 模型，运行在 UDP 协议之上，使用 53 号端口","text":"【概述】域名系统（Domain Name System，DNS）是因特网使用的命名系统，用来将便于记忆的含有特定含义的主机名转换为便于机器处理的 IP 地址 因特网的域名系统被设计为一个联机分布式数据库系统，并采用 C/S 模型，运行在 UDP 协议之上，使用 53 号端口 从概念上讲，DNS 分为三个部分：层次域名空间、域名服务器、域名解析 需要注意的是，域名与 IP 地址、MAC 地址、主机等均不存在一一对应的关系 如果一个主机利用两块网卡采用服务器双线接入的方式连接到不同的两个网络，那么会具有两个 IP 地址，每个网卡对应一个 MAC 地址，那么这两个 IP 地址就可以映射到同一个域名上 而多个主机之间可采用负载均衡的方式，映射到同一个域名上；一个主机也可以采用虚拟主机的方式，映射到多个域名上 【层次域名空间】域与域名因特网采用层次树形结构的命名方法，使得任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构名字，即域名（Domain Name） 域，是命名空间中一个可被管理的划分，其可进一步划分为子域，还可继续划分为子域的子域，这样就形成了顶级域、二级域、三级域等 每一个域名都是由标号序列组成，各标号之间用 . 来隔开，对于标号序列来说，其要求如下： 标号中的英文不分大小写 标号中除连字符 - 外不能使用其他标点符号 每一个标号不超过 $63$ 个字符，多标号组成的完整域名不超过 $255$ 个字符 级别最低的域名写在最左边，级别最高的域名写在最右边 举例来说，对于域名 www.baidu.com，其中 www 为三级域名，级别最低；baidu 为二级域名；com 为顶级域名，级别最高 顶级域名顶级域名（Top Level Domain，TLD）是最高级别的域名，其有以下三大类： 1）国家顶级域名 nTLD 国家顶级域名，是国家和某些地区的域名，例如：.cn 表示中国，.us 表示美国，.uk 表示英国 2）通用顶级域名 gTLD 最早的通用顶级域名有： 域名 用途 .com 公司和企业 .org 非赢利性组织 .net 网络服务机构 .int 国际组织 .edu 美国专用的教育机构 .gov 美国专用的政府部门 .mil 美国专用的军事部门 除以上通用顶级域名外，后续又增加了若干通用顶级域名，如 .museum 表示博物馆、.name 表示个人、.pro 表示有证书的专业人员等 3）基础结构域名 基础结构域名只有一个，即 arpa，用于反向域名解析，因此又称反向域名 域名空间结构在域名系统中，每个域分别由不同的组织管理，每个组织都可以将它的域再分成一定数目的子域，再将这些子域委托给其他机构管理 对于国家顶级域名来说，会交由各国相关机构管理，在国家域名下注册的二级域名，均由该国家自行确定 下图展示了域名空间的结构 【域名服务器】区域名到 IP 地址的解析是由运行在域名服务器上的程序完成的，一个服务器所负责管辖的范围被称为区，各单位根据具体情况来划分自己管辖的区，但要求在一个区中的所有结点必须是能够连通的 同时，每个区会设置相应的权限域名服务器，用来保存该区中所有的主机域名到 IP 地址的映射 下图给出了区的不同划分方法的例子 此外，每一个域名服务器不仅能够进行域名到 IP 地址的解析，还必须要具有连向其他域名服务器的信息，当自己不能进行域名解析时，要知道能去什么地方找到别的域名服务器来解析 域名服务器层次DNS 采用层次分布式设置了大量的域名服务器，因特网上所有域名到 IP 地址的映射，分布地存储在 DNS 系统中的域名服务器中，没有一台域名服务器具有因特网上所有主机的映射 根据域名服务器的层次，可分为四种类型的域名服务器： 1.根域名服务器 根域名服务器是最高层次的域名服务器，其用来管辖顶级域，每个根域名服务器都知道所有的顶级域名服务器的 IP 地址 因特网上总共设置了 $13$ 个不同 IP 地址的根域名服务器，全世界共有几百台服务器来组成这 $13$ 套根域名服务器，从而方便用户，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器 无论是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就会首先求助根域名服务器，根域名服务器会告诉本地域名服务器下一步应该去寻找哪个顶级域名服务器查询 2.顶级域名服务器 顶级域名服务器负责管理该顶级域名服务器注册的所有二级域名，当 DNS 查询请求时，就给出相应的回答，可能是最终的结果，也可能是下一步应当查找的域名服务器的 IP 地址 3.权限域名服务器 权限域名服务器又称授权域名服务器，每一个主机都会在权限域名服务器上登记 通常来说，为保障可靠性，一台主机最少会在两个授权域名服务器上登记，其一定可以将其管辖的主机名转换成该主机的 IP 地址 通常来说，许多域名服务器在同时充当权限域名服务器与本地域名服务器 4.本地域名服务器 每一个因特网服务提供商 ISP，或者每一个单位，甚至一个单位中的一个部门，都可以拥有一个本地域名服务器 当一个主机发出 DNS 查询请求时，这个查询请求报文会最先发送给本地域名服务器进行查询 实际上，在 Windows 系统中配置本地连接时，填写的 DNS 服务器地址，就是该本地域名服务器的地址 【域名解析】域名解析过程域名解析是指将域名映射层 IP 地址，或将 IP 地址映射成域名的过程，前者称为正向解析，后者称为反向解析，当客户端需要域名解析时，通过本机的 DNS 客户端构造一个 DNS 请求报文，以 UDP 数据报方式发往本地域名服务器 当本地主机所询问的本地域名服务器不知道被查询域名的 IP 地址时，会向根域名服务器发送查询请求报文，之后根域名服务器要么采用递归查询的方法，代替本地域名服务器以 DNS 客户的身份进行查询，给出查询到的 IP 地址，要么采用迭代查询的方法，告诉本地域名服务器下一步应该向哪一个域名服务器进行查询 下图给出了使用递归查询的示例，当本地域名服务器以 DNS 客户的身份向根域名服务器发送查询请求报文后，根域名服务器会代替该主机进行查询，递归地在其他几个域名服务器之间进行查询 下图则给出了使用迭代查询的示例，当本地域名服务器以 DNS 客户的身份向根域名服务器发送查询请求报文后，要么给出要查询的 IP 地址，要么告诉本地域名服务器下一步应该向哪一个顶级域名服务器进行查询，之后，本地服务器会向这个顶级域名服务器进行后续查询，同样，顶级域名服务器收到查询报文后，要么给出查询的 IP 地址，要么告诉本地域名服务器下一步应向哪个权限域名服务器查询 域名服务器高速缓存为提高 DNS 的查询效率，同时减少因特网上 DNS 查询报文的数量，域名服务器中广泛使用了高速缓存 当一个 DNS 服务器收到 DNS 查询结果时，其能将该 DNS 信息缓存在高速缓存中 这样，当另一个相同的域名查询到达该 DNS 服务器时，该服务器能够直接提供要求的 IP 地址，不需再向其他 DNS 服务器询问 由于主机名与 IP 地址之间的映射不是永久的，因此 DNS 服务器会在一段时候后丢弃高速缓存中的信息","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"进程控制","slug":"operating-system/08.进程控制","date":"2019-11-08T13:22:03.000Z","updated":"2021-10-10T13:47:13.045Z","comments":true,"path":"notes/operating-system/d9c2550.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/d9c2550.html","excerpt":"【进程控制】进程控制的主要功能，是对系统中的所有进程实施有效的管理，其具有创建新进程、撤销已有进程、实现进程状态转换等功能 在操作系统中，通常将进程控制用的程序段称为原语，其在执行期间不允许中断，是一个不可分割的基本单位","text":"【进程控制】进程控制的主要功能，是对系统中的所有进程实施有效的管理，其具有创建新进程、撤销已有进程、实现进程状态转换等功能 在操作系统中，通常将进程控制用的程序段称为原语，其在执行期间不允许中断，是一个不可分割的基本单位 进程控制主要有以下原语： 创建原语：为操作系统创建一个新进程 终止原语：终止操作系统中的一个进程 阻塞原语：将处于运行态的进程转为阻塞态 唤醒原语：将等待某事件的处于等待态的进程唤醒，转为就绪态 挂起原语：当出现引起进程挂起的事件时，将指定进程挂起 激活原语：当出现引起进程激活的事件时，将指定进程激活 【进程的创建】引起进程创建的事件为使程序间能并发运行，应先为它们分别创建进程，导致一个进程去创建另一个进程的典型事件有四类： 用户登录：分时系统中，用户在终端登录成功后，系统为该用户创建一个进程，并插入就绪队列中 作业调度：当作业调度程序按一定算法调度到某些作业时，会将它们装入内存，并创建进程，然后插入就绪队列中 提供服务：当运行中的用户程序提出功能请求时，系统会创建相应的服务进程 应用请求：用户进程自己创建新进程，以便新进程以同创建者进程并发运行的方式完成特定任务 进程的创建过程在系统中，每当出现了创建新进程的请求后，OS 便调用进程创建原语（Creat），按下述步骤创建一个新进程： 申请空白 PCB：申请唯一的数字标识符，并从 PCB 集合中获取一个空白 PCB 为新进程分配所需资源：从 OS 或新进程的父进程获得各种物理、逻辑资源 初始化 PCB：初始化标识信息、处理机状态信息、处理机控制信息 将新进程插入就绪队列：若就绪队列能接纳新进程，则将新进程插入就绪队列 【进程的终止】引起进程终止的事件引起进程终止的事件可分为有以下三类： 正常结束：进程的任务已经完成，准备退出运行 异常结束：进程在运行时发生了某种异常事件，使得程序无法继续运行，常见的有：越界错误、保护错误、非法指令、运行超时、I/O 故障等 外界干预：进程应外界请求而终止运行，常见的干预有：父进程终止、父进程请求、OS 干预、操作员干预等 进程的终止过程若系统中发生了要求终止进程的某事件，OS 将调用进程终止原语（Destroy） ，按下述步骤终止指定的进程： 读取终止进程的状态：根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从而读出该进程的状态 执行态：若被终止进程处于执行态，立即终止该进程，并置调度标志为真，用于指示该进程被终止后应重新进行调度 有子孙进程：若被终止进程有子孙进程，应将其所有子孙进程全部终止，防止成为不可控进程 归还全部资源：将被终止进程所拥有的全部资源归还给父进程或 OS 移出 PCB：将终止进程 PCB 从所在队列中移出，等待其他程序搜集信息 【进程的阻塞与唤醒】引起进程阻塞与唤醒的事件引起进程阻塞或唤醒的事件有以下四种： 向系统请求共享资源失败：进程在向系统请求共享资源时，由于系统已无足够的资源分配，此时进程将转为阻塞状态，当其他进程释放出足够的资源后，请求进程才被唤醒 等待某种操作的完成：当进程启动某种操作后，若该进程必须在该操作完成后才能继续执行，则应先将该进程阻塞，等待操作完成后再将其唤醒 新数据尚未到达：对于相互合作的进程，若一进程需要另一进程提供的数据后才能对该数据进行处理，则当数据未到达时，该进程只能处于阻塞状态，直到数据到达，才会将其唤醒 等待新任务的到达：在某些系统中，往往会设置一些特定的系统进程，每当这种进程完成任务后就将自己阻塞起来，等待新任务的到来后，才被唤醒 进程的阻塞过程正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语（block） 将自己阻塞，可见阻塞是进程自身的一种主动行为，其步骤如下： 停止执行：若该进程还处于执行状态，则应立即停止执行 改变 PCB 状态：将 PCB 中的现行状态由执行改为阻塞 插入阻塞队列：将改变现行状态后的 PCB 插入阻塞队列 转进程调度：将处理机分配给另一就绪进程 进行进程切换：保留被阻塞进程的处理机状态，按新进程的 PCB 中的处理机状态设置 CPU 环境 进程的唤醒过程当被阻塞进程所期待的事件发生时，则有关进程调用唤醒原语（wakeup），将等待该事件的进程唤醒，其执行过程如下： 移出阻塞队列：将被阻塞的进程从等待该事件的阻塞队列中移出 改变 PCB 状态：将 PCB 中的现行状态由阻塞改为就绪 插入就绪队列：将该 PCB 插入就绪队列中 值得注意的是，block 原语与 wakeup 原语是一对作用相反的原语，在使用它们时，必须成对使用 即如果某进程中调用了阻塞原语，则必须在与之相合作、相关的进程中安排一条相应的唤醒原语，以便能唤醒被阻塞进程，否则，阻塞进程将会因不能被唤醒而永久处于阻塞状态 【进程的挂起与激活】进程的挂起过程当系统中出现引起进程挂起的事件时，OS 将利用挂起原语（suspend） 指定进程挂起，其步骤如下： 检查被挂起进程状态：若被挂起的进程处于活动就绪态，就改为静止就绪；若处于活动阻塞态，就改为静止阻塞 复制 PCB 到指定区域：为方便用户或父进程检查进程运行情况，将该进程的 PCB 复制到某指定的内存区域 重新调度：若被挂起的进程正在执行，则转向调度程序重新调度需要注意的是，进程只能挂起自己或其子孙进程 进程的激活过程当系统中出现引起进程激活的事件时，OS 将利用激活原语（active） 指定进程激活，其步骤如下： 调入内存：若挂起进程处于外存上，首先将其调入内存 检查被激活进程状态：若被激活的进程处于静止就绪态，就改为活动就绪；若处于静止阻塞态，就改为活动阻塞","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"FTP 协议","slug":"computer-networks/52.FTP协议","date":"2019-11-08T11:12:00.000Z","updated":"2021-08-29T13:56:19.081Z","comments":true,"path":"notes/computer-networks/439e8653.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/439e8653.html","excerpt":"【概述】文本传输协议（File Transfer Protocol，FTP）是因特网上使用的最广泛的文件传送协议，其提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限 同时，FTP 屏蔽了计算机系统的细节，适合在异构网络中任意计算机间传送文件","text":"【概述】文本传输协议（File Transfer Protocol，FTP）是因特网上使用的最广泛的文件传送协议，其提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限 同时，FTP 屏蔽了计算机系统的细节，适合在异构网络中任意计算机间传送文件 FTP 主要提供以下功能： 提供不同种类主机系统间的文件传输 以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力 以匿名 FTP 的方式提供公用文件共享的能力 【工作方式】FTP 基于 C/S 模型，使用 TCP 可靠传输服务，一个 FTP 服务器进程可同时为多个客户进程提供服务 FTP 的服务器进程由两部分组成： 主进程：一个，负责接收新的请求 从属进程：多个，负责处理单个请求 FTP 服务器的工作步骤如下： 打开熟知端口 $21$，使客户进程能够连接上服务器 等待客户进程发送连接请求 启动从属进程来处理客户进程发来的请求，此时主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止 回归等待状态，继续接受其他客户进程的请求 FTP 服务器必须在整个会话期间保留用户的状态信息，尤其是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置 同时，在使用 FTP 时，若要修改服务器上的文件，需要先将该文件传送到本地主机，再将修改后的文件副本传送到原服务器 【控制连接与数据连接】FTP 在工作时使用两个并行 TCP 连接，一个是端口号为 $21$ 的控制连接，一个是端口号为 $20$ 的数据连接 需要注意的是，是否使用 $20$ 端口建立数据连接，是与传输模式有关的，主动方式使用 $20$ 端口，被动方式由服务器与客户端自行协商决定 控制连接用来传输 FTP 客户端发送的连接请求、传送请求等控制信息（ $7$ 位 ASCII 码格式），FTP 服务器会一直监听 $21$ 号端口，等待客户连接，对于 FTP 客户发送的传送请求，会通过控制连接发送给 FTP 服务器的控制进程，同时，在整个会话期间，控制连接会一直保持打开状态 FTP 服务器的控制进程在接收到 FTP 客户发来的文件传输请求后，就创建数据传送进程和数据连接，数据连接用来连接客户端和服务器的数据传送进程，数据传送进程用来实际完成文件的传送，在传送完毕后，会关闭数据传送连接并结束数据传送进程 由于 FTP 使用分离控制连接和数据连接的方式，因此也称 FTP 的控制信息是带外传送的","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"DHCP 协议","slug":"computer-networks/51.DHCP协议","date":"2019-11-08T05:22:00.000Z","updated":"2021-08-29T13:54:24.255Z","comments":true,"path":"notes/computer-networks/e121afa2.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/e121afa2.html","excerpt":"【概述】动态主机配置协议（Dynamic Host Configuration Protocol，DHCP），用于给主机动态分配 IP 地址，其采用即插即用的机制，允许一台计算机加入新的网络获取 IP 地址不用人工干预 【工作原理】","text":"【概述】动态主机配置协议（Dynamic Host Configuration Protocol，DHCP），用于给主机动态分配 IP 地址，其采用即插即用的机制，允许一台计算机加入新的网络获取 IP 地址不用人工干预 【工作原理】DHCP 使用客户/服务器方式，需要 IP 地址的主机在启动后，立刻向 DHCP 服务器广播发送 DHCP 发现报文，此时该主机就成为 DHCP 客户 本地网络上所有主机都能收到该广播发送的发现报文，但只有 DHCP 服务器才回答该发现报文，回答的报文被称为 DHCP 提供报文 DHCP 服务器会先在其数据库中查找该计算机的配置信息，若找到，就将找到的信息封装为提供报文；若找不到，就从服务器的 IP 地址池中取一个地址分配给该计算机，并封装为提供报文 DHCP 服务器与 DHCP 客户机的报文交换流程具体如下： 1）DHCP 客户机广播 DHCP 发现报文，试图找到网络中的 DHCP 服务器，以从服务器获得一个 IP 地址 2）DHCP 服务器收到 DHCP 发现报文后，向网络中广播 DHCP 提供报文，其中包含提供 DHCP 客户机的 IP 地址与相关配置信息 3）DHCP 客户机收到 DHCP 提供报文后，若接受 DHCP 服务器提供的相关参数，就广播 DHCP 请求报文，向 DHCP 服务器请求提供 IP 地址 4）DHCP 服务器广播 DHCP 确认报文，将 IP 地址分配给 DHCP 客户机 【广播方式与租用期】广播方式DHCP 客户端与 DHCP 服务器通过广播方式交互，这是因为在 DHCP 执行期间，客户端与服务器都没有标识自己身份的 IP 地址，因此不可能通过单播的形式进行交互 此外，DHCP 工作在应用层，基于无连接的 UDP 协议 不采用 TCP 协议是因为 TCP 需要建立连接，但 DHCP 在工作过程中没有标识身份的 IP 地址，无法通过双方套接字建立连接 租用期DHCP 服务器分配给 DHCP 客户机的 IP 地址是临时的，故而 DHCP 客户机只能在一段有限的时间内使用分配的 IP 地址，这段时间被称为租用期 租用期的数值由 DHCP 服务器自身决定，此外，DHCP 客户机也可在发送的报文中提出自己对租用期的要求","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"应用层功能","slug":"computer-networks/50.应用层功能","date":"2019-11-08T04:01:00.000Z","updated":"2021-08-29T09:15:55.131Z","comments":true,"path":"notes/computer-networks/6e00d21.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/6e00d21.html","excerpt":"【概述】应用层，是计算机网络体系结构的最高层，其中的每一个协议都是为了解决某一类的应用问题，应用层的具体内容就是规定应用进程在通信时所遵循的协议 应用层的协议要么基于C/S 模型，要么基于 P2P 模型，这两者被统称为网络应用模型","text":"【概述】应用层，是计算机网络体系结构的最高层，其中的每一个协议都是为了解决某一类的应用问题，应用层的具体内容就是规定应用进程在通信时所遵循的协议 应用层的协议要么基于C/S 模型，要么基于 P2P 模型，这两者被统称为网络应用模型 【C/S 模型】在客户/服务器（Client/Server，C/S）模型中，总有一个被称为服务器（Server）的一直打开的主机，其服务于多个来自其他被称为客户机（Client）的主机请求，其工作流程如下： 服务器处于接收请求的状态 客户机发出服务请求，并等待接收结果 服务器收到请求，分析请求并进行必要处理，将结果发给客户机 对于服务器来说，其一直运行，永久提供服务，这就需要具有一个永久性的访问地址；对于客户机来说，其只需要间歇性接入网络发出服务请求即可，能够使用动态 IP，同时可以不与其他客户机通信 常见的使用 C/S 模型的应用有：文件传输 FTP、远程登录、电子邮件等 【P2P 模型】在 C/S 模型中，服务器性能的好坏决定了整个系统的性能，当大量用户请求服务时，服务器就成为了系统的瓶颈 在对等式（Peer-to-Peer，P2P）模型中，没有固定的客户和服务器的划分，任意一对计算机被称为对等方（peer），可以直接相互通信 从本质上来看，P2P 模型仍然是一个 C/S 模型，只是每个结点既能作为客户访问其他结点的资源，也能作为服务器提供资源给其他结点 与 C/S 模型相比，P2P 减轻了服务器器的压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，但每个结点在获取服务的同时，还要给其他结点提供服务，这不可避免的会占据较多的内存，影响整机速度 常见的使用 P2P 模型的应用有：PPLive、Bittorrent、电驴等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"前驱图与进程图","slug":"operating-system/07.前驱图与进程图","date":"2019-11-08T03:49:15.000Z","updated":"2021-10-10T13:39:19.968Z","comments":true,"path":"notes/operating-system/79a44d45.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/79a44d45.html","excerpt":"【前驱图】前驱图是一个 DAG，其用于描述进程间执行的先后次序，图中的每个结点用于表示一个进程或一个程序段，结点间的有向边表示两个结点间存在的偏序关系(前趋关系) 进程间的前趋关系用 $\\rightarrow$ 来表示，若进程 $P_i$ 和 $P_j$ 间存在前趋关系，可表示为 $(P_i,P_j) \\in \\rightarrow$，即：$P_i \\rightarrow P_j$，表示 $P_j$ 在执行前 $P_i$ 必须完成","text":"【前驱图】前驱图是一个 DAG，其用于描述进程间执行的先后次序，图中的每个结点用于表示一个进程或一个程序段，结点间的有向边表示两个结点间存在的偏序关系(前趋关系) 进程间的前趋关系用 $\\rightarrow$ 来表示，若进程 $P_i$ 和 $P_j$ 间存在前趋关系，可表示为 $(P_i,P_j) \\in \\rightarrow$，即：$P_i \\rightarrow P_j$，表示 $P_j$ 在执行前 $P_i$ 必须完成 在前驱图中，将没有前驱的结点称为初始结点，将没有后继的结点称为终止结点，此外，每个结点还具有一个价值，用于表示该结点所含有的进程的执行时间 【进程图】层次结构在 OS 中，允许一个进程创建另一个进程，通常将创建进程的进程称为父进程，将被创建的进程称为子进程，子进程可以继续创建更多孙进程，以此类推，由此便形成了一个进程的层次结构 在 UNIX 中，进程与其子孙进程共同组成了一个进程组 而在 Windows 中，所有的进程都具有相同的地位，如果一个进程创建另外的进程时创建进程获得了一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程，但这个句柄是可传递的，也就是说，获得了句柄的进程拥有控制其他进程的权力，因此，进程之间的关系不是层次关系，而是获得句柄与否、控制与被控制的简单关系 进程图为了形象地描述一个进程的家族关系，从而引入了进程图 简单来说，进程图就是用于描述进程间关系的一棵有向树，如下图，图中结点代表进程，有向边代表创建关系","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"进程状态与转换","slug":"operating-system/06.进程状态与转换","date":"2019-11-07T13:19:04.000Z","updated":"2021-10-10T12:43:55.227Z","comments":true,"path":"notes/operating-system/8b084059.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/8b084059.html","excerpt":"【进程的三种基本状态】进程在其生命周期内，由于系统中各进程间的相互制约关系及系统的运行环境的变化，使得进程的状态也不断发生变化 对于任意一个进程来说，其有以下三个进程的基本状态：","text":"【进程的三种基本状态】进程在其生命周期内，由于系统中各进程间的相互制约关系及系统的运行环境的变化，使得进程的状态也不断发生变化 对于任意一个进程来说，其有以下三个进程的基本状态： 就绪态（Ready）：进程已处于准备好运行的状态，即进程已分配到除 CPU 外的所有必要资源，只要获得 CPU 资源，便可立刻执行 运行态（Running）：进程已获得 CPU 资源，其程序正在执行，对于单核 CPU 来说，每一时刻最多只有一个进程处于运行状态；对于 $n$ 核 CPU 来说，每一时刻最多有 $n$ 个进程处于运行状态 阻塞态（Blocked）：正在执行的进程由于发生某事件而暂停运行 对于就绪状态而言，若系统中有多个处于就绪状态的进程，通常会将他们按一定的策略排成一个队列，称为就绪队列；对于阻塞状态而言，发生阻塞时 OS 会把处理机分配给另一个就绪进程，让受阻进程处于暂停状态，通常会将处于阻塞状态的进程也排成一个队列，称为阻塞队列 在就绪队列中位于队首的进程，在调度程序为之分配处理机后即可执行，相应的，就绪态转为执行态，该进程从就绪队列出队；正在执行的进程如果因分配给他的时间片已完，那么会被剥夺处理机，执行态转为就绪态，并加入就绪队列；如果处于执行态的进程因发生某事件，例如进程需要访问某临界资源，而临界资源正被其他进程访问时，那么会导致当前进程无法继续执行，执行态转为阻塞态，并加入阻塞队列；当阻塞队列位于队首的进程的事件完成，那么其不在堵塞，阻塞态转为就绪态，该进程从阻塞队列出队 【创建态与终止态】进程是由创建而产生，但创建工作尚未完成，进程不能被调度运行，此时的状态称为创建状态，进程的创建过程如下： 进程申请一个空白 PCB，并向 PCB 中填写用于控制和管理进程的信息 为该进程分配运行时所必须的资源 将该进程转入就绪态，并插入就绪队列中 当一个进程达到了自然结束点，或出现了无法克服的错误，或被 OS 所终结，亦或被其他有终止权的进程所终结，其将进入终止状态，进程的终止过程如下： 等待 OS 进行善后处理 将其 PCB 清零，并将该空白 PCB 返还系统 进入终止状态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中包含状态码与一些计时统计数据，以供其他进程收集，一旦其他进程完成对其信息提取后，OS 将删除该进程，即将其 PCB 清零，并将该空白 PCB 返还系统 【挂起操作】为系统与用户的需要，引入了一个十分重要的操作——挂起操作，与挂起操作相对应的是激活操作 挂起操作产生的原因大体分为以下四种： 终端用户的需要：当终端用户在自己的程序运行期间发现有可疑问题时，会希望暂停程序运行，使其暂停以进行修改 父进程请求：当父进程需要考察、修改、协调子进程时，会挂起相应的子进程 负荷调节需要：当实时系统中的工作负荷较重时，系统会将一些不重要的进程挂起，以保证系统正常运行 操作系统的需要：当 OS 需要检查运行中等等资源使用情况时，会将相应的某些进程挂起 当该挂起操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态，如果进程正在执行，其将暂停执行，若原本处于就绪态，则该进程此时暂不接受调度 在三种基本状态的转换中，当引入挂起操作与激活操作后，阻塞状态与执行状态的衍生出四种状态： 活动就绪态（Readya）：进程处于未被挂起的就绪状态 静止就绪态（Readys）：进程处于已被挂起的就绪状态 活动阻塞态（Blockeda）：进程处于未被挂起的阻塞状态 静止阻塞态（Blockeds），进程处于已被挂起的阻塞状态 那么相应的，就会有以下状态的转换： 再考虑进程的创建与终止状态，对于进程创建来说，若当前系统的性能和内存容量均允许的情况下，完成创建的必要操作后，会将进程的状态转为活动就绪态，否则会转为进制就绪态","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"进程与进程控制块","slug":"operating-system/05.进程与进程控制块","date":"2019-11-06T13:16:08.000Z","updated":"2021-10-10T13:38:57.130Z","comments":true,"path":"notes/operating-system/a964df1a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/a964df1a.html","excerpt":"【程序的顺序执行与并发执行】一个应用程序由若干程序段组成，每一程序段完成特定的功能，他们在执行时，都要按照某种先后次序执行，仅当前一程序段执行完后，再运行后一程序段，这种执行过程被称为程序的顺序执行 程序顺序执行时，具有以下三个特征：","text":"【程序的顺序执行与并发执行】一个应用程序由若干程序段组成，每一程序段完成特定的功能，他们在执行时，都要按照某种先后次序执行，仅当前一程序段执行完后，再运行后一程序段，这种执行过程被称为程序的顺序执行 程序顺序执行时，具有以下三个特征： 顺序性：处理机的操作严格按程序规定顺序执行 封闭性：程序一旦开始执行，其计算结果不受外界因素影响 可再现性：程序执行只要初始条件一样，不论如何停顿，重复执行多少次结果都一样 程序顺序执行时，虽然减少了开发周期，但系统资源的利用率却很低，为此，在系统中引入了多道程序技术，使得程序或程序段间能并发执行 事实上，并非所有的程序都能并非执行，只有不存在前趋关系的程序之间才可能并发执行 程序并发执行时，具有以下三个特征： 间断性：在执行过程中，由于要共享资源与相互合作，使得这些并发的程序间形成了相互制约的关系，从而导致了 “ 执行 — 暂停 — 执行 ” 这种间断性的活动规律 失去封闭性：由于共享资源，资源状态由多道程序改变，程序运行失去了封闭性，即程序运行受其他程序的影响 结果不可再现性：结果的不确定，使得程序执行将没有任何意义 【进程】进程的概念在多道程序环境下，程序的执行属于并发执行，此时它们失去其封闭性，并具有间断性，而且其运行结果具有不可再现性，由此，通常的程序是不能参与并发执行的 为了使参与并发执行的每个程序都能独立地运行，在操作系统中引入了进程（Process）的概念，以便更好地描述和控制程序的并发执行 为了使参与并发执行的程序与数据能够的独立运行，必须为之配置一专门的数据结构——进程控制块（Process Control Block，PCB） 系统利用 PCB 来描述进程的基本情况和活动过程，进而控制、管理进程，这样由程序段、相关数据、PCB 三部分就组成了进程实体 在一般情况下，会将进程实体称为进程，但实际上，进程是进程实体的运行过程，是系统进行资源分配和调度的独立单位 所谓创建进程，实质上是创建进程实体中的 PCB，撤销进程，实质上是撤销进程的 PCB 进程的特征进程和程序是两个不同的结构，简单来说，程序=程序段+数据，进程=程序段+数据+PCB，除了构成不同外，进程还具有以下特征： 动态性：进程实质是进程实体的执行过程，其有一定的生命期 并发性：多个进程实体同存于内存中，且能在一段时间内同时执行 独立性：进程实体是一个能独立运行、独立获得资源、独立接受调度的基本单位 异步性：进程是按异步方式运行的，会产生不可再现性（为保证结果可再现，引入了进程同步机制） 结构性：每个进程都配备一个 PCB 对其进行描述，从结构上来看，进程实体是由程序段、数据段、进程控制段三部分组成的 【进程控制块】在 OS 中，每个资源、进程都设置了一个数据结构，用于表征其实体，称为资源信息表，其中包含了资源或进程的标识、描述、状态等信息以及一批指针，通过指针，可以将同类资源或进程的信息表链接成不同的队列，以便系统进行查找 OS 管理的这些数据结构一般分为四类：内存表、设备表、文件表、进程表，其中，进程表即进程控制块（PCB） PCB 作为进程实体的一部分，记录了 OS 所需的、用于描述进程当前情况的、管理进程运行的全部信息，是进程存在的唯一标志 组成在 PCB 中，主要包含四类信息： 进程描述信息：由标识进程归属用户的用户标识符（UID）和唯一标识进程的进程标识符（PID）组成 处理机状态信息：处理机中各寄存器中的内容 资源分配信息：说明内存空间、虚址空间使用状况、I/O 设备信息等 进程控制与管理信息：进程控制所必须的信息，包含进程当前状态、优先级等 组织方式在系统运行过程中，有若干 PCB，他们常驻 PCB 区，为有效的进行管理，常采用适当的数据结构将他们组织起来 目前常用的组织方式有三种： 线性方式：组织在一张线性表中，实现简单、开销小，适用于进程数不多的系统 链式方式：将具相同状态进程的 PCB 分别通过 PCB 中的链接字链接成一个队列，以形成就绪队列、若干阻塞队列、空白队列等 索引方式：根据所有进程状态的不同，建立若干张索引表","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"TCP 拥塞控制","slug":"computer-networks/49.TCP拥塞控制","date":"2019-11-05T12:24:00.000Z","updated":"2021-08-29T13:53:48.275Z","comments":true,"path":"notes/computer-networks/ca8e642a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/ca8e642a.html","excerpt":"【概述】拥塞控制，就是防止过多的数据注入到网络中，从而使网络中的路由器或链路不至于出现过载 当出现拥塞时，端点并不能了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为时延的增加","text":"【概述】拥塞控制，就是防止过多的数据注入到网络中，从而使网络中的路由器或链路不至于出现过载 当出现拥塞时，端点并不能了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为时延的增加 比较来说，拥塞控制是让网络能够承受现有网络负荷，是一个全局性的过程，涉及到所有的主机、路由器、与降低网络传输性能有关的因素；流量控制，是端到端的通信量控制，通过抑制发送端发送速率，来使接收端来得及接收 在 TCP 中，流量控制由接收方根据其放在 TCP 报文段首部的窗口字段来通知发送方，从而保证将未确认的数据量控制在接收窗口 rwnd 的范围内；拥塞窗口，就是通过一定的算法，来维护拥塞窗口 cwnd 的大小 为了对 TCP 进行拥塞控制，定义了四个算法：慢开始、拥塞避免、快重传、快恢复 【慢开始与拥塞避免】慢开始当 TPC 连接建立完毕，刚开始发送 TCP 报文段时，先令拥塞窗口 cwnd=1，即一个最大报文段长度 MSS，之后，每收到一个对新的报文段的确认后，就令 cwnd 加 $1$ 例如，A 向 B 发送数据，发送时 A 的 cwnd=2，那么 A 一次可以发送 $2$ 个 TCP 报文段，当经过一个传输轮次 RTT 后，A 收到 B 对刚才 $2$ 个 TCP 报文段的确认，于是就令 cwnd=4，下一次发送就可发送 $4$ 个报文段 在使用慢开始算法后，没经过一个传输轮次，拥塞窗口 cwnd 就会加倍，其大小呈指数型增长 这样，慢开始一直将拥塞窗口 cwnd 增大到一个事先规定的慢开始门限 ssthresh，之后，采用拥塞避免算法 拥塞避免拥塞避免是指：当发送方的拥塞窗口 cwnd 每经历一个 RTT，就增加一个 MSS，即令 cwnd 加 $1$，这使得 cwnd 线性增长，即加法增大 综上，根据 cwnd 与 ssthresh 的大小，可以进行如下归纳： cwnd $&lt;$ ssthresh：执行慢开始算法 cwnd $&gt;$ ssthresh：执行拥塞避免算法 cwnd $=$ ssthresh：可以使用慢开始也可以使用拥塞避免，通常使用拥塞避免 网络拥塞的处理无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件发生，即没有收到确认，重传计时器超时，就可认为网络出现拥塞 此时，要将慢开始门限 ssthresh 设为出现拥塞时发送方 cwnd 的一半，即乘法减小，同时，令 cwnd=1，之后，执行慢开始算法 这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间将队列中积压的分组处理完毕 也就是说，拥塞避免并非完全避免拥塞，而是指在拥塞避免阶段，将拥塞窗口 cwnd 控制为线性增长，在出现拥塞时减少网络分组，使网络比较不容易出现拥塞 慢开始与拥塞避免的实现过程下面给出一个慢开始与拥塞避免实现过程的示例图 初始时，拥塞窗口 cwnd=1，慢开始门限 ssthresh=16 之后，发送方每收到一个确认 ACK，cwnd 的值就加 $1$，即 cwnd 呈指数增大 当拥塞窗口 cwnd=ssthresh，即 cwnd=16 时，改为采用拥塞避免算法，此时 cwnd 呈加法增大 假定 cwnd=24 时，出现拥塞，那么，设置 ssthresh=12，并令 cwnd=1，此时，cwnd 呈乘法减小 之后，重新开始执行慢开始算法，当 cwnd=12 时，改为执行拥塞避免算法 要注意的是，在慢开始阶段，若 $2cwnd&gt;ssthresh$，则下一个 RTT 的cwnd 应该等于 ssthresh，而不是 2cwnd，即 *cwnd 不能跃过 ssthresh 在上例中，第 $16$ 个轮次 cwnd=8，ssthresh=12，第 $17$ 个轮次 cwnd=12，而非 $16$ 【快重传与快恢复】快重传与快恢复是对慢开始和拥塞避免的改进，其在两者的基础上引入了 TCP 可靠传输机制中的冗余 ACK 机制 在拥塞控制中，慢开始、拥塞避免、快重传、快恢复，实际上是同时应用在拥塞控制机制中的，当发送方检测到超时就采用慢开始和拥塞避免，当发送方接收到三个冗余 ACK 就采用快重传和快恢复 快重传在 TCP 可靠传输机制中，快速重传技术使用了冗余 ACK 来检测丢包的发生，而在网络中，丢包，说明网络可能出现拥塞 快重传即当发送方连续收到三个重复的 ACK 报文时，直接重传尚未收到的报文段，不必等待该 TCP 报文段设置的重传计时器超时 快重传并非取消重传计时器，而且在可能丢包的情况下更早地重传丢失的报文段 快恢复快恢复是指：当发送方连续收到三个冗余 ACK 报文时，就认为网络中出现丢包，开始执行乘法减小，令慢开始门限 ssthresh 为发送方拥塞窗口 cwnd 的一半 与慢开始算法将 cwnd 设为 $1$ 不同，快恢复将 cwnd 的值设为 ssthresh 改变后的数值，之后开始执行拥塞避免算法，令拥塞窗口加法增大 如下图，可以发现，当网络出现拥塞时，cwnd 跳过了从 $1$ 开始的慢开始过程，所以被称为快恢复","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"TCP 流量控制","slug":"computer-networks/48.TCP流量控制","date":"2019-11-05T10:35:00.000Z","updated":"2021-08-29T13:53:28.398Z","comments":true,"path":"notes/computer-networks/eea0a825.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/eea0a825.html","excerpt":"【概述】TCP 提供了流量控制服务，以消除发送方使接收方缓冲区溢出的可能性，其本质上是一个速度匹配服务，使发送方的发送速率与接收方的接收速率相匹配 TCP 提供了一种基于滑动窗口协议的流量控制机制，与链路层的流量控制机制十分相似","text":"【概述】TCP 提供了流量控制服务，以消除发送方使接收方缓冲区溢出的可能性，其本质上是一个速度匹配服务，使发送方的发送速率与接收方的接收速率相匹配 TCP 提供了一种基于滑动窗口协议的流量控制机制，与链路层的流量控制机制十分相似 两者的区别在于：传输层定义了端到端用户间的流量控制，链路层定义了两个中间相邻结点的流量控制 此外，链路层的滑动窗口协议的窗口大小不能动态变化，传输层的窗口可以动态变化 【TCP 窗口机制】发送方在确定发送报文段的速率时，既要从流量控制的角度考虑接收方的接收能力，也要从拥塞控制的角度考虑网络全局是否会发生拥塞 因此，TCP 协议要求发送方维护接收窗口 rwnd 和拥塞窗口 cwnd 这两个窗口，并根据这两个窗口的值来设置发送窗口的值 发送窗口的上限值，一般取 rwnd 和 cwnd 两者的最小值，即： min\\{rwnd,cwnd\\}而对于接收窗口 rwnd 和拥塞窗口 cwnd 来说，有： 1）接收窗口 rwnd 接收窗口 rwnd 即根据接收方的接收缓存大小，反映了接收方允许连续接收的最大能力 流量控制，就是由接收方根据其放在 TCP 报文段首部的窗口字段来通知发送方，从而保证将未确认的数据量控制在 rwnd 范围内 2）拥塞窗口 cwnd 拥塞窗口 cwnd 是根据发送方自己估算的网络拥塞程度来设置的窗口值，这个窗口值反映了当前网络的容量，其大小与网络的带宽和时延密切相关 拥塞控制，就是通过一定的算法，来维护拥塞窗口 cwnd 的大小 【接收窗口与流量控制】假设有效数据只从 A 发往 B，B 仅向 A 发送确认报文 这时，B 就可以通过设置 TCP 确认报文段首部的窗口字段，来将 rwnd 通知给 A 发送方 A 会根据最新收到的 rwnd 来限制自己的发送窗口大小，保证 A 不会使 B 的接收缓存溢出 下图中的例子说明了利用滑动窗口进行流量控制的过程 一般来说，接收方总是有足够大的缓存空间，发送窗口的大小由网络拥塞程度决定，因而实际上并不需要考虑对 TCP 进行流量控制 也就是说，可以将发送窗口等同于拥塞窗口","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"TCP 可靠传输","slug":"computer-networks/47.TCP可靠传输","date":"2019-11-05T05:16:00.000Z","updated":"2021-08-29T13:53:15.799Z","comments":true,"path":"notes/computer-networks/17df9a8d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/17df9a8d.html","excerpt":"【概述】TCP 是在 IP 的不可靠服务的基础上建立的一种可靠数据传输服务 其提供的可靠传输服务，就是要保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一致的","text":"【概述】TCP 是在 IP 的不可靠服务的基础上建立的一种可靠数据传输服务 其提供的可靠传输服务，就是要保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一致的 与链路层的可靠性传输机制相似，TCP 中的可靠传输使用了校验、序号、确认、重传等机制来完成这个目的 由于 TCP 的校验与 UDP 的校验几乎一致，只是将伪首部的协议字段由 $6$ 改为了 $17$，这里不再赘述 【序号】TCP 协议是面向字节数据流的，其将数据看作一个无结构但有序的字节流，通过 TCP 数据报的序号字段来保证数据能有序提交给应用层 TCP 连接中，传送的数据流的每一个字节都会编上一个序号，序号字段的值是本 TCP 报文段发送的数据的第一个字节的序号 如下图所示，一 TCP 报文段的序号字段值为 $301$，携带的数据共有 $100B$，这就表明本报文段的数据的最后一字节的序号为 $400$，下一报文段的数据序号应从 开始 $401$ 开始 【确认】TCP 首部的确认号是期望收到对方的下一报文段的数据的第一个字节的序号 TCP 默认使用累计确认方式，即若确认号为 $N$，则表明到序号 $N-1$ 为止的所有数据都已被正确接收 例如，B 正确收到了 A 发送的一个报文段，其序号字段为 $501$，数据长度为 $200B$，这表明 B 正确收到了 A 发送的到序号 $700$ 为止的数据，因此，B 期望收到 A 的下一数据序号为 $701$，于是 B 发送给 A 的确认号会置为 $701$ 【重传】在传输层中，有两种事件会导致对 TCP 报文段的重传：超时、冗余 ACK 超时超时机制与链路层类似，TCP 每发送一个报文段，就会对这个报文段设置一个计时器，只要计时器设置的重传时间到期，但还没有收到这一确认，就重传这一报文段 由于 TCP 的下层是一个互联网环境，因此 IP 数据报所选择的路由变化很大，这导致了传输层的往返时延的方差也很大 为计算超时计时器的重传时间，TCP 采用了一种自适应的算法 加权平均往返时间一个报文段发出的时间、收到相应确认的时间的差被称为报文段的往返时间（Round-Trip Time，RTT） TCP 保留了 RTT 的一个加权平均往返时间 $RTT_s$，当第一次测量 RTT 样本时，$RTT_s$ 值为测量到的 RTT 样本值，以后每次测量到一个新的 RTT 样本 $RTT_n$，就按照下式来重新计算一次 $RTT_s$ RTT_s=(1-\\alpha)RTT_s+\\alpha RTT_n其中，$0\\leq \\alpha \\leq1$，若 $\\alpha$ 接近于 $0$，说明 RTT 值更新较慢，新的 $RTT_s$ 与旧的 $RTT_s$ 变化不大，受新测量的 $RTT_n$ 影响较小；若 $\\alpha$ 接近于 $1$，说明 RTT 值更新很快，新的 $RTT_s$ 与旧的 $RTT_S$ 变化较大，受新测量的 $RTT_n$ 影响较大 RTF 2988 中，推荐 $\\alpha=0.125$ 超时重传时间超时计时器设置的超时重传时间（Retransmission Time-out，RTO）应该略大于上面得出的加权平均往返时间 $RTT_S$，其采用下式进行计算： RTO=RTT_S+RTT_D其中，$RTT_D$ 是 RTT 的偏差的加权平均值，其与 $RTT_s$ 和 $RTT_n$ 的差有关 在第一次测量时，$RTT_D$ 为测量到的新 RTT 样本值 $RTT_n$ 的一半，之后的每次测量中，采用下式计算： RTT_D=(1-\\beta)RTT_D+\\beta|RTT_s-RTT_n|其中，$0\\leq \\beta \\leq 1$，推荐 $\\beta=0.25$ 冗余 ACK超时触发重传存在的一个问题，就是超时周期太长，但发送方通常可在超时时间发生前，通过冗余 ACK 来检测丢包情况 在 TCP 中，规定每当期望序号大的失序报文段到达时，发送冗余 ACK，指明下一个期待字节的序号 同时，当发送方收到同一个报文段的 $3$ 个冗余 ACK 时，可以认定这个确认报文段后的报文段已经丢失，此时，可以立刻对这个丢失的报文段进行重传，这被称为快速重传 举例来说，发送方 A 发送了序号为 $1,2,3,4,5$ 的报文段，其中 $2$ 号报文段在链路中丢失，将无法到达接收方 B 由于 $3,4,5$ 号报文段对 B 来说就成了失序报文段，B 会发送 $3$ 个对 $1$ 号报文段的冗余 ACK，表示自己希望接收 $2$ 号报文段 而 A 收到了 $3$ 个对 $1$ 号报文段的 ACK，就认为 $2$ 号报文段已经丢失，可以立即对 $2$ 号报文段进行重传","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"TCP 连接管理","slug":"computer-networks/46.TCP连接管理","date":"2019-11-05T04:15:00.000Z","updated":"2021-08-29T13:52:59.821Z","comments":true,"path":"notes/computer-networks/10109414.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/10109414.html","excerpt":"【概述】TCP 是面向连接的协议，因此，每一个 TCP 连接都有三个阶段：连接建立、数据传送、连接释放 TCP 连接管理，就是使 TCP 连接的建立与释放能够顺利进行","text":"【概述】TCP 是面向连接的协议，因此，每一个 TCP 连接都有三个阶段：连接建立、数据传送、连接释放 TCP 连接管理，就是使 TCP 连接的建立与释放能够顺利进行 TCP 将连接作为最基本的抽象，每一条 TCP 连接都有两个端点，端点使用套接字（Socket）作为接口，也就是说，每一条 TCP 连接被通信两端的两个套接字唯一确定 TCP 连接的建立方式采用客户/服务器式，主动发起连接的应用进程被称为客户机，被动等待连接建立的应用进程被称为服务器 【TCP 连接建立】TCP 连接建立又称三次握手，经历以下三个步骤： 1.客户机发送 TCP 连接请求 当客户机想要建立 TCP 连接时，会向服务器发送一个 TCP 连接请求报文段 这个 TCP 连接请求报文段不含应用层数据，即该 TCP 报文段只有 TCP 首部，不携带任何数据 虽然该报文段不携带数据，但要消耗掉一个序号，即客户机会随机选择一个起始序号 seq=x 此外，TCP 连接请求报文段中的同步位 SYN=1 2.服务器收到 TCP 连接请求，若同意建立，就发回确认 在服务器收到 TCP 连接请求报文段后，若同意建立连接，会向客户机发送一个 TCP 确认报文段，该报文段同样不携带任何数据，但也要消耗掉一个序号，即客户机会随机选择一个起始序号 seq=y 同时，在 TCP 确认报文段中，确认位 ACK=1，同步位 SYN=1，确认号 ack=x+1 此外，在服务器发送完 TCP 确认报文段后，该服务器会为该连接分配 TCP 缓存与变量 3.客户机收到 TCP 确认，发回该确认的确认 在客户机收到 TCP 确认报文段后，会向服务器发送一个 TCP 确认报文段，即确认的确认 在该 TCP 确认报文段中，确认位 ACK=1，同步位 SYN=1，确认号 ack=y+1，序号 seq=x+1 此外，在客户机发送完 TCP 确认报文段后，该客户机会为该连接分配 TCP 缓存与变量 在经历以上三步后，TCP 连接就建立了，接下来就可以传送应用层数据，同时，由于 TCP 提供的全双工通信，因此，通信双方的应用进程在任何时间都可以发送数据 要注意的是，服务器的资源是完成第二次握手时分配的，客户端的资源是完成第三次握手时分配的，这使得服务器易受 SYN 洪泛攻击 【TCP 连接释放】TCP 连接的释放又称四次挥手，需要经历四个步骤，参与 TCP 连接的两个进程中的任何一个都能终止该连接，下面以客户机提出主动关闭连接为例，说明 TCP 连接释放过程 1.客户端发送 TCP 释放请求 当客户端打算关闭连接后，会向服务器发送一个 TCP 连接释放报文段，并停止发送数据，主动关闭 TCP 连接 TCP 连接释放报文段，不携带任何数据，但也要消耗掉一个序号，序号为前面已经传输的数据的最后一个字节的序号 $+1$，这里假设为 seq=u 同时，终止位 FIN=1，表明客户端的数据已发送完毕，并要求释放 TCP 连接 需要注意的是，由于 TCP 是全双工的，当客户端发送 TCP 连接释放报文段后，其只是单方面关闭了客户端到服务器方向的连接，服务器方仍可发送数据 2.服务器收到 TCP 释放请求，发回确认 服务器收到来自客户端的 TCP 连接释放报文段后，会立即对该报文段发回确认 对于发回的TCP 确认报文段来说，不携带任何数据，但也要消耗掉一个序号，序号为前面已经传输的数据的最后一个字节的序号 $+1$，这里假设为 seq=v 同时，其确认位 ACK=1，确认号 ack=u+1 此时，从客户机到服务器方向的连接彻底释放，TCP 连接处于半关闭状态，服务器方仍可发送数据 3.服务器发送 TCP 释放请求 若服务器已经没有要向客户机发送的数据，会向客户机发送 TCP 连接释放报文段，并停止发送数据，主动关闭连接 对于该 TCP 连接释放报文段来说，同样不携带任何数据，但也要消耗掉一个序号，序号为前面已经传输的数据的最后一个字节的序号 $+1$，这里假设为 seq=w 同时，其终止位 FIN=1，确认位 ACK=1，确认号 ack=u+1 4.客户机收到 TCP 释放请求，发回确认 客户机收到来自服务器的 TCP 连接释放报文段后，会立即对该报文段发回确认 对于发回的 TCP 确认报文段来说，其确认位 ACK=1，确认号 ack=w+1，序号 seq=u+1 此时，TCP 连接并没有完全释放掉，只有当服务器收到该确认后，服务器端才进入连接关闭状态，而对于客户端来说，必须等待超时计时器设置的 2MSL 后，才进入连接关闭状态 之所以客户端要等待 2MSL，有以下两个原因： 保证客户端发送的最后一个 TCP 确认报文能够到达服务器端 防止已失效的连接请求报文段出现在本连接中，使下一新的连接中不会出现这种旧的连接请求报文段","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"操作系统的体系结构","slug":"operating-system/04.操作系统的体系结构","date":"2019-11-05T03:40:00.000Z","updated":"2021-10-10T12:14:57.001Z","comments":true,"path":"notes/operating-system/4c2f5846.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/4c2f5846.html","excerpt":"【无结构操作系统】在早期，操作系统的开发者只是将注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想 此时 OS 是为数众多的一组过程的集合，每个过程可以任意地调用其他过程，使得操作系统内部结构混乱又复杂","text":"【无结构操作系统】在早期，操作系统的开发者只是将注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想 此时 OS 是为数众多的一组过程的集合，每个过程可以任意地调用其他过程，使得操作系统内部结构混乱又复杂 因此，这种 OS 是无结构的，也有人将其称为整体系统结构 【模块化操作系统】20 世纪 60 年代，随着模块化程序设计技术的出现，操作系统的编写也开始利用该技术 该技术是基于分解与模块化的原则来控制大型软件的复杂度 为使 OS 具有较清晰的结构，OS 的设计按照模块-接口法来进行，即按其功能精心地划分为若干具有一定独立性的模块，每个模块具有某方面的管理功能，各模块间能通过接口实现交互 同时，进一步将各个模块分为若干具有一定功能的子模块，同样也规定好他们之间的接口 该方法不仅提高设计的正确性、可理解性、可维护性，还增强了 OS 的可适应性，通过对相应功能模块增减和修补，可以满足新需求，同时还加速了开发过程 但该方法同样存在不少问题，在设计初期，模块划分和接口规定是十分不精确的，并且很难保证其完全正确，这会使得接口规定与实际完成的模块需求不匹配，而出现装配困难 此外，各模块的设计齐头并进，没有决策顺序，是一种 “无序” 模块，模块间仍会有复杂依赖关系，这反而可能会使 OS 结构不清晰 【分层式操作系统】为将模块-接口法中决定顺序的无序性变为有序性，引入了有序分层法，即在目标系统 $A_n$ 和逻辑系统 $A_0$ 间，铺设若干层次的软件 $A_1,A_2,…,A_{n-1}$，使得 $A_n$ 通过 $A_{n-1},…,A_2,A_1$ 层后，最终能在 $A_0$ 上运行 在分层式操作系统中，采用自底向上的有序分层法，每一步设计都建立在可靠基础上，每一次仅能使用其底层所提供的功能与服务，由此使得系统的调试与验证变得十分容易 由于各层之间只存在单向的依赖关系，即高层仅依赖紧邻的低层，这保证了系统正确性，使得系统容易维护与扩充 但由于分层单向依赖，当执行一个功能时，总要自下而上地穿越多层，这增加系统通信开销，降低了效率 【微内核操作系统】微内核操作系统，即实现了一个可在其上构建通用 OS 的基础内核，该内核程序运行在核心态，开机常驻内存 当前微内核操作系统结构仍没有一致公认的定义，但可从以下 4 方面进行描述： 足够小的内核：微内核并非一个完整的 OS，其与硬件紧密相关，实现较基本功能，复杂客户和服务器通信 应用机制与策略分离原理：机制用于实现某一功能的具体执行机构，位于基层；策略借助某些参数和算法实现功能优化或达到不同功能目标，位于高层 采用面向对象技术 基于 C/S 模式 微内核包含的基本功能有：进程管理、低级存储管理、中断和陷入处理等，调度算法、虚拟内存的页面置换算法等都放入外部服务器中实现 对于微内核操作系统来说，只有内核能访问硬件，服务器在用户态出错时绝不会导致系统瘫痪，同时其可移植性强，尤适用于分布式系统","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"操作系统的运行环境","slug":"operating-system/03.操作系统的运行环境","date":"2019-11-04T13:13:33.000Z","updated":"2021-10-08T13:17:17.129Z","comments":true,"path":"notes/operating-system/4a7057b4.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/4a7057b4.html","excerpt":"【内核】在软件工程思想和结构程序设计方法影响下而诞生的操作系统，几乎都是层次式的结构，操作系统的各项功能被设置在不同的层次上 一些与硬件关联紧密的模块，如时钟管理、中断处理、设备驱动等，会放置在操作系统的最底层，同时，运行频率较高的程序，如进程管理、存储器管理、设备管理等，也同样会放在最底层，这些程序被统称为内核程序","text":"【内核】在软件工程思想和结构程序设计方法影响下而诞生的操作系统，几乎都是层次式的结构，操作系统的各项功能被设置在不同的层次上 一些与硬件关联紧密的模块，如时钟管理、中断处理、设备驱动等，会放置在操作系统的最底层，同时，运行频率较高的程序，如进程管理、存储器管理、设备管理等，也同样会放在最底层，这些程序被统称为内核程序 由内核程序组成的数据结构，被称为内核（Kernel），其就是处于最底层、最核心的内核程序的集合 不同的操作系统对内核的定义不同，大多数操作系统内核包括时钟处理、中断机制、原语、系统控制的数据结构及处理这四个方面 1.时钟处理 在计算机的各类部件中，时钟，是最关键的设备，其第一功能是计时，操作系统通过时钟管理，来向用户提供标准的系统时间 此外，通过时钟中断的管理，可以实现进程的切换 2.中断处理 引入中断技术的初衷，是提高多道程序运行环境中 CPU 的利用率，随着操作系统的发展，中断形成了多种类型，称为了操作系统各项操作的基础 在中断机制中，只有一小部分功能属于内核，如负责保护和恢复中断现场的信息，转移控制权到相关的处理程序 这样能够有效的减少中断处理时间，提高系统的并行处理能力 3.原语 按层次设计的操作系统，其底层必然是可被调用的公用小程序，其各自完成一个规定的操作，这些程序被称为原语（Atomic Operation），具有以下特点： 处于操作系统的最底层，是最接近硬件的部分 这些程序的运行具有原子性，其操作只能一气呵成 这些程序的运行时间很段，且调用频繁 系统中的设备驱动、CPU 切换、进程通信等功能中的部分操作都可以被定义为原语，在原语执行过程中，为保证原子性，会关闭中断，让它的所有动作不可分割地完成后再打开中断 4.系统控制的数据结构及处理 系统中用来登记信息的数据结构有很多，如：作业控制块、进程控制块、设备控制块、消息队列、缓冲区、空闲区分配表、内存分配表等等 为实现有效的管理，系统就需要一些基本的操作，常见的操作有： 进程管理：进程状态管理、进程调度与分配、创建与撤销进程控制块等 存储器管理：存储器空间分配与回收、内存信息保护程序、代码对换程序等 设备管理：缓冲区管理、设备分配与回收等 【核心态与用户态】在计算机系统中，通常 CPU 要执行两种性质不同的程序： 应用程序：用户自编的应用程序、系统外层的应用程序 内核程序：操作系统内核程序 这两种程序的作用不太，内核程序是应用程序的管理者，而作为管理者，就需要执行一些特殊的命令，这些特殊的命令被称为特权指令，由此，有了特权指令与非特权指令的划分 特权指令：计算机中不允许用户直接使用的指令，如 I/O 指令、置中断指令 非特权指令：计算机中允许用户直接使用的指令 在操作系统的具体实现上，通过状态寄存器 PSW 来标识两类程序的转换，由此划分出两种状态： 用户态：运行应用程序，PSW 置 $0$ 核心态：运行内核程序，PSW 置 $1$ 【中断与异常的概念】操作系统内核工作在核心态，应用程序工作在用户态，系统不允许应用程序实现核心态的功能，但又必须使用这些功能，因此就要考虑这两种状态如何转换 在实际的操作系统中，当内核态转为用户态时，往往通过特权指令，将 PSW 标志位设为用户态；当用户态转为内核态时，通过 CPU 检测中断信号，由硬件自动变为内核态，即中断屏蔽 简单来说，在某些情况下内核会将 CPU 主动权让给应用程序，中断，是让内核夺回 CPU 使用权的唯一途径，若无中断机制，一旦应用程序运行，其将会一直运行下去 中断（Interruption），也称外中断，是指来自 CPU 执行命令以外的事件的发生，如时钟中断、I/O 请求等，这一类中断通常是与当前程序运行无关的事件，即与当前处理机所运行的程序无关 异常（Exception），也称内中断、陷入（Trap），是指来自 CPU 执行指令内部的事件，如非法操作码、算术溢出、地址越界等，这一类问题的处理一般要依赖于当前程序的运行现场，且异常不能被屏蔽，一旦出现要立即处理 【系统调用】系统调用，是用户在程序中调用操作系统所提供的一些子功能，其可以被看作特殊的公共子程序 系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作，都必须通过系统调用的凡是提出服务请求，并由操作系统代为完成 通常，一个操作系统所提供的系统调用命令有几十甚至上百条之多，这些系统调用按功能可大致分为以下几类： 设备管理：完成设备的请求或释放、设备启动等 文件管理：完成文件读、写、创建、删除操作等 进程控制：完成经常的创建、撤销、阻塞、唤醒等 进程通信：完成进程间的消息传递、信号传递等 内存管理：完成内存的分配、回收、作业占用内存区大小等功能 系统调用运行在系统的核心态，其可以保证使用系统功能时系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"操作系统的发展与分类","slug":"operating-system/02.操作系统的发展与分类","date":"2019-11-03T11:23:45.000Z","updated":"2021-10-10T12:14:40.502Z","comments":true,"path":"notes/operating-system/5bcf1559.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/5bcf1559.html","excerpt":"【未配备操作系统的计算机系统】人工操作方式早期的操作方式是利用事先穿孔的纸带，装入纸带输入机将纸带上的程序与数据输入计算机，再启动计算机，只有当程序运行完毕并取走运算结果后，才允许下一个用户上机","text":"【未配备操作系统的计算机系统】人工操作方式早期的操作方式是利用事先穿孔的纸带，装入纸带输入机将纸带上的程序与数据输入计算机，再启动计算机，只有当程序运行完毕并取走运算结果后，才允许下一个用户上机 人工操作的方式严重降低了计算机资源的利用率，出现了所谓的人机矛盾，即用户独占全机、CPU 等待人工操作 脱机输入/输出方式为解决人机矛盾，后出现了脱机 I/O 技术，即事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的处理下，将纸带上的数据、程序输入到磁带上，当 CPU 需要时，再调入内存 脱机 I/O 技术在一定程度上，减少了 CPU 的空闲时间并提高了 I/O 速度 【单道批处理系统】为实现作业的连续处理，需要将一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在监督程序的控制下，使得作业能一个接一个地连续处理 虽然系统对作业的处理是成批进行的，但内存中始终保持一道作业，仍然存在 I/O 设备与 CPU 速度不匹配的情况 【多道批处理系统】对于单道批处理操作系统来说，其可以连续的运行多个程序，减少了程序切换时的 CPU 等待时间，但其问题在于：当执行 I/O 操作时，CPU 是空闲的，这极大的增加了 CPU 的等待时间 为解决资源利用率与系统吞吐量低下的问题，出现了多道批处理系统 多道批处理系统是将多个程序同时加载到内存中，当其中正在运行的程序执行 I/O 操作时，CPU 可以继续执行其他的程序，而当 I/O 操作结束后，之前的程序继续执行 多道批处理系统虽然内存中存在多个程序，但同样一个时间内只有一个程序被执行，其他没有被执行的程序存入后备队列中，等待调度程序调用 多道批处理系统具有多道性、无序性、调度性等特点，其资源利用率高、系统吞吐量大、平均运行时间长，但由于后备队列需要内存管理，调度程序需要设备管理等问题，增加了系统的负载 【分时系统】对于多道批处理系统来说，其人机交互性极差，为满足用户对交互性的需求，由此形成了一种新型 OS —— 分时系统 所谓分时系统是指，在一台主机上连接了多个配有显示器与键盘终端，并由此组成的系统，该系统允许多个用户同时通过自己的终端，以交互式使用计算机，共享主机资源 分时系统实现了多用户连接主机、请求轮转进内存、快速响应处理等功能，其最大特点是采用时间片轮转方式来处理服务请求 所谓时间片，是指分配给进程运行的一段时间，根据时间片的定义，由此有了用户响应时间(RT)，即： 用户响应时间 \\approx 时间片 \\times 用户数量【实时系统】随着计算机的发展，计算机需要一种能及时计算的系统，即系统的正确性不仅由计算的逻辑结果来确定，还取决于产生结果的时间 简单来说，就是将时间作为关键参数，其必须对接收到的某些信号做出实时的反应 由此我们可得到实时系统的定义：系统能及时响应外部事件的请求，在规定时间内完成对事件的处理，并控制所有实时任务协调一致地运行 常见是实时系统有：工业控制系统、信息查询系统、武器控制系统、嵌入式系统等 【其他操作系统】除上述的操作系统外，目前主流的操作系统还有网络操作系统、分布式操作系统、个人操作系统等 网络操作系统，是指将网络中的各主机结合起来，统一有效地使用各计算机，实现计算机间的数据传输，其充分利用了网络资源共享的特点，令数据在多台主机间有效通信 分布式操作系统，在整个体系中每台主机地位同等，各主机间资源共享，没有主机和从机的概念，同时，任意两台主机间可交换信息，任意台主机可以构成一个子系统，在处理任务时，各主机协同、并行完成，具有分布性、并行性的特点 个人操作系统，是目前最流行的操作系统，如常见的 Windows、MacOS、Linux 的各发型版等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"操作系统的基本概念","slug":"operating-system/01.操作系统的基本概念","date":"2019-11-03T03:59:51.000Z","updated":"2021-10-10T12:14:18.988Z","comments":true,"path":"notes/operating-system/4be8d730.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/operating-system/4be8d730.html","excerpt":"【操作系统的概念】操作系统（Operating System，OS）是配置在计算机硬件之上的第一层软件，其是对硬件系统的首次扩充，在计算机开机后，其会被首先加载到内存中 具体来说，操作系统是控制、管理计算机系统的软、硬件资源，能够合理的组织计算机工作、资源分配，是为用户、软件提供方便接口与环境的程序集合","text":"【操作系统的概念】操作系统（Operating System，OS）是配置在计算机硬件之上的第一层软件，其是对硬件系统的首次扩充，在计算机开机后，其会被首先加载到内存中 具体来说，操作系统是控制、管理计算机系统的软、硬件资源，能够合理的组织计算机工作、资源分配，是为用户、软件提供方便接口与环境的程序集合 操作系统设计的主要目标有四点： 方便性：便于用户使用 有效性：提高系统资源利用率 可扩充性：使用模块化以便于修改和扩充 开放性：系统遵循国际标准以便实现互连 【操作系统的功能】用户与计算机硬件间的接口用户通过 OS 来使用计算机，从下图可以看出，用户可以通过系统调用、命令方式、图形窗口三种方式来实现与 OS 的通信，并取得其服务 对于系统调用来说，其常见于程序接口中，这是一种由用户间接使用 OS 服务的方式，是在程序中使用系统调用的方法来请求 OS 提供服务，如 C 语言中的库函数 对于命令方式来说，其是通过命令接口来由用户直接调用的，具体分为以下两种： 联机命令接口：交互式，由键盘操作命令组成，如 cmd 命令行窗口 脱机命令接口：批处理，由作业控制命令组成，如 .bat 文件 对于图形窗口来说，其通过调用程序接口来实现，不属于 OS，但其调用的系统调用命令，属于 OS 计算机系统资源的管理者在计算机系统中，包含多种软硬件资源，OS 的主要功能正是对资源进行管理，归结来说，总共分为四类： 处理机管理：处理机的分配与控制 存储器管理：内存的分配与回收 I/O 设备管理：I/O 设备的分配、回收与操纵 文件管理：对数据和程序文件的存取、共享、保护 对硬件机器扩展将 OS 附加在裸机（完全无软件的计算机系统）上，实现了对裸机的首次扩充，之后，系统软件及更上层的用户软件在操作系统虚拟机上进行运行，使得计算机成为功能更强大的多层虚拟机 【操作系统的特征】并发并行是指两个或多个事件在同一时刻发生，并发是指两个或多个事件在同一时段发生 在单处理机系统中，多个程序宏观来看是并行，实际上是多个程序交替占用 CPU；而在多处理机系统中，多个程序被分配到多个处理机上，每个处理机处理一个可并发执行的程序 在未引入进程的系统中，同属一应用程序的计算程序与 I/O 程序间只能顺序执行，这样极大地影响了系统资源利用率 若对内存中的多个程序都分别建立一个进程，他们就可以并发执行，从而提高系统资源利用率，所谓进程是指系统中能独立运行并作为资源分配的基本单位，是由一组机器指令、数据、堆栈等组成的能独立运行的实体 目前市面上流行的 CPU，单核 CPU 是指同一时刻只允许一个程序运行，各程序并发执行；多核 CPU 是同一时刻允许多个程序运行，各程序可并行执行 共享在 OS 下的资源共享是指系统中的资源可供内存中多个并发执行的进程共同使用，由于内存资源有限，系统必须对资源共享进行妥善管理，以避免进程对共享资源的争夺 根据资源属性的不同，进程对资源复用的方式也不同，目前主要有以下两种方式： 互斥共享方式：在一段时间内只允许一个进程访问资源（临界资源） 同时访问方式：在一段时间内允许多个进程同时访问（在单处理机上，本质上是串行的） 需要注意的是，并发与共享之间是互为存在的关系，共享以并发为条件，没有并非就无法共享，并发以共享为基础，没有共享就无法实现并发 虚拟虚拟最早出现在通信系统中，为提高信道利用率从而引入了虚拟技术，所谓虚拟，是指通过某种技术将一个物理实体变为若干逻辑上的对应物。 在 OS 中，借鉴了通信系统的虚拟设备技术，有以下两种实现方式： 时分复用：利用处理机的空闲时间运行其他进程，提高处理机利用率 空分复用：利用存储器的空闲空间，分区域存放运行多道程序，提高内存利用率 异步由于资源等因素的限制，多个进程并发执行时间和执行顺序是不可预知的，所谓异步即是指进程的执行顺序与执行时间的不确定性 尽管如此，但只要在 OS 中配置有完善的进程同步机制，且运行环境相同，作业即使经过多次运行，得到的结果是完全相同的","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"操作系统","slug":"notes/operating-system","permalink":"https://alex-mcavoy.github.io/categories/notes/operating-system/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"操作系统","slug":"operating-system","permalink":"https://alex-mcavoy.github.io/tags/operating-system/"}],"author":"Alex_McAvoy"},{"title":"TCP 协议概述","slug":"computer-networks/45.TCP协议概述","date":"2019-11-01T11:24:00.000Z","updated":"2021-08-29T13:52:42.481Z","comments":true,"path":"notes/computer-networks/322f7d33.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/322f7d33.html","excerpt":"【概述】TCP 协议，是 TCP/IP 协议体系中一个十分重要且复杂的协议，是在不可靠的 IP 层之上实现的可靠的数据传输协议，其主要解决传输的可靠、有序、无丢失、不重复的问题 TPC 协议主要具有如下特点：","text":"【概述】TCP 协议，是 TCP/IP 协议体系中一个十分重要且复杂的协议，是在不可靠的 IP 层之上实现的可靠的数据传输协议，其主要解决传输的可靠、有序、无丢失、不重复的问题 TPC 协议主要具有如下特点： 1）面向连接的传输层协议 TCP 协议是面向连接的协议，每一条 TCP 连接只能有两个端点，且每一条 TPC 连接只能是点对点的 同时，TCP 连接是一条虚连接，而非一条真正的物理连接 2.提供可靠的交付服务 与 UDP 的不可靠的交付服务不同，TCP 提供可靠的交付服务，以保证双方传送的数据无差错、不丢失、不重复、有序 3.面向字节流 虽然应用程序与 TCP 的交互是一次一个大小不等的数据块，但 TCP 将应用程序交付下来的数据看作一连串的无结构数据流 正是因为面向字节流的特性，TCP 在与在应用程序交互时，可以将太长的数据块划分短一些后再传送，也可等待积累有足够多的字节后再构成报文段发送出去 具体来说，TCP 发送方会根据接收方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的） 4）提供全双工通信 TCP 两端都设有发送缓存、接收缓存，用来临时存放双向通信的数据，同时，而 TCP 对应用进程一次将多长的报文发送到 TCP 的缓存中是不关心的 对于 TCP 两端的发送缓存、接收缓存来说，他们存放如下数据： 发送缓存 接收缓存 准备发送的数据 按序到达但尚未接收的数据 已发送但尚未收到确认的数据 不按序到达的数据 【TCP 报文】TCP 传送的数据单元被称为 TCP 报文段，整个 TCP 报文段会作为 IP 数据报的数据部分封装在 IP 数据报中 一个 TCP 报文段分为 TCP 首部和 TCP 数据两个部分，其中 TCP 首部前 $20B$ 是固定的，后面有长度为 $4B$ 整数倍的可变部分 同时，TCP 首部的最大长度为 $60B$ TCP 报文格式如下图所示 其中，各字段含义如下： 1）源端口与目的端口 各占 $2B$，端口是传输层与应用层的服务接口，传输层复用与分用功能通过端口实现 2）序号 占 $4B$，TCP 是面向字节流的，因此 TCP 连接中传送的数据流的每一字节都会有一个序号，序号的值是本报文段所发送的数据的第一个字节的序号 例如，一 TCP 报文段的序号字段值为 $301$，携带的数据共有 $100B$，这就表明本报文段的数据的最后一字节的序号为 $400$，下一报文段的数据序号应从 $401$ 开始 3）确认号 占 $4B$，是期望收到对方的下一报文段的数据的第一个字节的序号 若确认号为 $N$，则表明到序号 $N-1$ 为止的所有数据都已被正确接收 例如，B 正确收到了 A 发送的一个报文段，其序号字段为 $501$，数据长度为 $200B$，这表明 B 正确收到了 A 发送的到序号 $700$ 为止的数据，因此，B 期望收到 A 的下一数据序号为 $701$，于是 B 发送给 A 的确认号会置为 $701$ 4）数据偏移 数据偏移即首部长度，占 $4B$，其指出了 TCP 报文段的数据起始处距离 TCP 报文段的起始有多远 该字段的单位是 $32bit=4B$，因此当该字段的值为 $15$ 时，表明达到了 TCP 首部的最大长度 $60B$ 5）保留 占 $6B$，保留为以后使用，目前全部置为 $0$，该字段可忽略不计 6）紧急位 URG 该位与紧急指针配套使用，当 URG=1 时，表明紧急指针字段有效，其告诉系统，此 TCP 报文中有紧急数据，需要尽快传送；当 URG=0 时，紧急指针字段无效 紧急数据，是指从第一个字节到紧急指针所指的字节 7）确认位 ACK 该位与确认号配套使用，当 ACK=1 时，确认号有效；当 ACK=0 时，确认号无效 TCP 规定，在连接建立后，所有传送的报文段都要将确认位 ACK 置为 $1$ 8）推送位 PSH 当接收方收到了 PSH=1 的 TCP 报文时，就要尽快交付给上层，不再等到缓存填满后再向上交付 9）复位位 RST 当接收方收到了 RST=1 的 TCP 报文时，说明 TCP 连接出现严重差错，例如主机崩溃等，此时必须释放连接，然后再重新建立 TCP 连接 10）同步位 SYN 该位 TCP 连接有关，与确认位 ACK 组合使用 当 SYN=1 时，说明是一个连接请求或连接接收请求，此时根据确认位 ACK 的值，有： SYN=1, ACK=0：是一个连接请求报文，对方若同意建立连接，就在响应报文中使用 SYN=1, ACK=1 SYN=1, ACK=1：是一个连接接收请求报文，当同意建立连接时，在响应报文中使用该配置 11）终止位 FIN 该位用来释放 TCP 连接，FIN=1 表明该 TCP 报文段的发送方的数据已发送完毕，并要求释放 TCP 连接 12）窗口 占 $2B$，用来作为接收方让发送方设置其发送窗口的依据，指出现在允许对方发送的数据量，单位为 $1B$，用于 TCP 流量控制中 例如，某 TCP 报文段的确认号是 $701$，窗口字段是 $1000$，这表明，从 $701$ 号开始算起，发送此报文段的一方还有接收 $1000B$ 数据的接收缓存空间，即可以接收 $701$ 号到 $1700$ 号的数据 13）检验和 占 $2B$，检验和检验的范围包括 TCP 首部与 TCP 数据两部分 在计算检验和时，与 UDP 一样，要在 TCP 首部前加上 $12B$ 的伪首部，只需要将 UDP 伪首部中的协议字段的 $17$ 改为 $6$ 即可 TCP 伪首部格式如下 14）紧急指针 占 $2B$，仅当紧急位 URG=1 时有效，指出了本报文段中紧急数据共有多少字节 紧急数据会放置在本报文段的数据部分的最前面，当 URG=1 时，会将第一个字节到紧急指针所指的字节的紧急数据尽快交付 15）选项 长度可变，规定了最大报文段长度、移位数、时间戳、时间戳回显应答等选项 16）填充 为了使整个首部长度为 $4B$ 的整数倍而设立，当上述的所有字段的长度和不为 $4B$ 的整数倍时，将填充 $0$ 【TCP 连接管理】TCP 是面向连接的协议，因此，每一个 TCP 连接都有三个阶段：连接建立、数据传送、连接释放 TCP 连接管理，就是使 TCP 连接的建立与释放能够顺利进行 TCP 将连接作为最基本的抽象，每一条 TCP 连接都有两个端点，端点使用套接字（Socket）作为接口，也就是说，每一条 TCP 连接被通信两端的两个套接字唯一确定 TCP 连接的建立方式采用客户/服务器式，主动发起连接的应用进程被称为客户机，被动等待连接建立的应用进程被称为服务器 【TCP 可靠传输】TCP 是在 IP 的不可靠服务的基础上建立的一种可靠数据传输服务 其提供的可靠传输服务，就是要保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一致的 与链路层的可靠性传输机制相似，TCP 中的可靠传输使用了校验、序号、确认、重传等机制来完成这个目的 由于 TCP 的校验与 UDP 的校验几乎一致，只是将伪首部的协议字段由 $6$ 改为了 $17$，这里不再赘述 【TCP 流量控制】TCP 提供了流量控制服务，以消除发送方使接收方缓冲区溢出的可能性，其本质上是一个速度匹配服务，使发送方的发送速率与接收方的接收速率相匹配 TCP 提供了一种基于滑动窗口协议的流量控制机制，与链路层的流量控制机制十分相似 两者的区别在于：传输层定义了端到端用户间的流量控制，链路层定义了两个中间相邻结点的流量控制 此外，链路层的滑动窗口协议的窗口大小不能动态变化，传输层的窗口可以动态变化 【TCP 拥塞控制】拥塞控制，就是防止过多的数据注入到网络中，从而使网络中的路由器或链路不至于出现过载 当出现拥塞时，端点并不能了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为时延的增加 比较来说，拥塞控制是让网络能够承受现有网络负荷，是一个全局性的过程，涉及到所有的主机、路由器、与降低网络传输性能有关的因素；流量控制，是端到端的通信量控制，通过抑制发送端发送速率，来使接收端来得及接收 为对传输层进行拥塞控制，TCP 定义了四个算法：慢开始、拥塞避免、快重传、快恢复","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"UDP 协议","slug":"computer-networks/44.UDP协议","date":"2019-11-01T09:24:00.000Z","updated":"2021-08-29T13:51:18.226Z","comments":true,"path":"notes/computer-networks/b98c7bc4.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/b98c7bc4.html","excerpt":"【概述】RFC 768 定义的 UDP 只是做了传输协议能做的最少工作，只在 IP 数据报服务之上提供了两个最基本的服务：复用与分用、差错检测 因此，如果应用程序开发者选择了 UDP，那么应用程序几乎是直接与 IP 数据报服务打交道，之所以很多应用选择使用 UDP，主要是因为 UDP 具有以下优点：","text":"【概述】RFC 768 定义的 UDP 只是做了传输协议能做的最少工作，只在 IP 数据报服务之上提供了两个最基本的服务：复用与分用、差错检测 因此，如果应用程序开发者选择了 UDP，那么应用程序几乎是直接与 IP 数据报服务打交道，之所以很多应用选择使用 UDP，主要是因为 UDP 具有以下优点： UDP 无需建立连接，不会引入建立连接的时延 UDP 不维护连接状态，一般能够支持更多的活动客户机 UDP 分组首部开销小，仅有 $8B$ 的开销 UDP 没有拥塞控制，应用层能够更好地控制要发送的数据与发送时间 【UDP 的特点】1）UDP 的开销小 由于开销小，因此 UDP 常用于一次性传输较少数据量的应用，如 DNS、SNMP 等 对于这些应用，若采用 TCP，则会因为建立连接、维护连接、拆除连接带来不小的开销 2）UDP 的实时性较好 其也常用于实时性较高的多媒体应用，如视频会议、IP 电话等 3）UDP 提供尽最大努力的交付 UDP 尽最大努力交付，即不保证可靠传输，但这并不意味着应用对数据的要求是不可靠的 因此，所有维护传输可靠性的工作由用户在应用层来完成，应用实体根据应用的需求来灵活设计自己的可靠性机制 4）UDP 服务是面向报文的 报文不可分割，是 UDP 数据报处理的最小单位 发送方 UDP 对应用层交付下来的报文，在添加首部后就向下交付给 IP 层，即不合并也不拆分，之前保留这些报文的边界；接收方 UDP 对 IP 层上交的 UDP 数据报，在去除首部后就原封不动的交付给上层应用，一次性交付一个完整的报文 【UDP 数据报】UDP 数据报包含两个部分：UDP 首部、用户数据，其中 UDP 首部长度只有 $8B$，整个 UDP 数据报作为 IP 数据报的数据部分封装在 IP 数据报中 在计算 UDP 数据报的检验和时，会添加一个长度为 $12B$ 的伪首部，这个伪首部仅用于计算检验和，并不实际参加数据传输 下图给出了 UDP 数据报的格式 其中，各字段含义如下： 源端口：源端口号，在需要对方回信时使用，不需要时一般设为全 $0$ 目的端口：目的端口号，在终点交付报文时必须使用 长度：包含 UDP 首部和用户数据的整个 UDP 数据报的长度，其最小值为 $8$，此时整个 UDP 数据报仅有 UDP 首部 检验和：检测 UDP 数据报在传输过程中是否出错，该字段是可选的，当源主机不想计算检验和时，直接令该字段值为全 $0$ 【UDP 复用与分用】在 UDP 协议中，复用，发送方不同的应用进程，都可使用同一个传输层协议传输数据；分用，接收方的传输层，在剥去报文首部后，能将数据交付给目的进程 在实现分用时，依据的是 UDP 首部的目的端口号；在实现复用时，依据的是 UDP 首部的源端口号 下图给出了 UDP 基于端口的复用、分用示意图 当接收方传输层从 IP 层收到 UDP 数据报后，会根据 UDP 首部中的目的端口，将 UDP 数据报通过相应的端口上交给应用进程 如果接收方发现收到的 UDP 报文中的目的端口号不正确，即发现不存在对应端口号的应用进程，就丢弃该报文，并通过 ICMP 协议发送端口不可达差错报文给发送方 【UDP 差错检验】在发送方计算检验和时，会添加如上图中的长度为 $12B$ 的伪首部 之后，会将整个 UDP 数据报以 $16bit$ 分为一组，对所有的组通过二进制反码运算求和 最后将计算结果求反码，装填到 UDP 首部的检验和字段中 若整个 UDP 数据报不是 $2B$ 的整数倍，则将会在 UDP 数据报的数据尾部填充 $0$，以用于计算检验和 下图给出了一个计算 UDP 检验和的例子 在接收方接收到 UDP 数据报后，会同样添加 $12B$ 的伪首部，并按照上述过程进行校验，若得出的检验和为全 $1$，则说明无差错 若发现 UDP 数据报出错，可以直接丢弃，也可以交付给上层，但在交付给上层时，需要附上错误报告，即告知上层这是错误的 UDP 数据报 UDP 校验的差错检验方法的检错能力并不强，但这种方法简单、处理速度快","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"传输层功能","slug":"computer-networks/43.传输层功能","date":"2019-11-01T04:23:00.000Z","updated":"2021-08-29T13:51:04.236Z","comments":true,"path":"notes/computer-networks/6ad2b2b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/6ad2b2b.html","excerpt":"【概述】传输层，是在网络层所提供的服务基础上向应用层提供服务，属于面向通信部分的最高层，同时也是用户功能中的最低层 网络层为主机之间提供通信，而传输层为主机间的应用进程提供了逻辑通信，显然，即使网络层协议会使分组丢失、混乱、重复，传输层仍能为应用层提供可靠的服务","text":"【概述】传输层，是在网络层所提供的服务基础上向应用层提供服务，属于面向通信部分的最高层，同时也是用户功能中的最低层 网络层为主机之间提供通信，而传输层为主机间的应用进程提供了逻辑通信，显然，即使网络层协议会使分组丢失、混乱、重复，传输层仍能为应用层提供可靠的服务 从下图可以看出，网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端通信时，只有主机的协议栈才有传输层和应用层，路由器在转发分组时都只用了下上层的功能 简单来说，与网络层相比，传输层主要具有以下功能： 网络层 传输层 提供主机到主机的通信 为应用进程间的提供端到端的逻辑通信 对 IP 数据报首部进行差错检测 对报文的首部、数据部分进行差错检测 要么提供面向连接的虚电路，要么提供无连接的数据报，不可能同时存在两种方式 可提供两种不同的传输协议，无连接的 UDP、面向连接的 TCP 复用：发送方不同协议的数据，都可封装成 IP 数据报发送出去 复用：发送方不同的应用进程，都可使用同一个传输层协议传输数据 分用：接收方的网络层，在剥去报文首部后，能将数据交付给相应协议 分用：接收方的传输层，在剥去报文首部后，能将数据交付给目的进程 传输层向高层用户屏蔽了网络拓扑、路由协议等底层网络核心细节，使应用进程看见的就是好像两个传输层实体间有一条端到端的逻辑信道，这条逻辑信道对三层的表现却因传输层协议不同而有很大的差别 当传输层采用 TCP 时，尽管下面的网络是不可靠的，但这种逻辑信道就相当于一条全双工的可靠信道；当传输层采用 UDP 时，这种逻辑信道仍是一条不可靠信道 【寻址与端口】端口的作用端口（Port），能让应用层的各种应用进程将其数据通过端口交付给传输层，同时让传输层知道，当其将报文段中的数据向上通过端口交付给应用层时，交付给的是哪个进程 端口，就是传输层的服务访问点 SAP，其在传输层的作用类似于 IP 地址在网络层的作用，或 MAC 地址在链路层的作用，只是 IP 地址与 MAC 地址标识的是主机，端口标识的是主机中的进程 在协议栈层之间，抽象的协议端口是软件端口，是各种协议进程与传输实体进行层间交互的一种地址；而路由器和交换机上的接口是硬件端口，是不同硬件设备进行交互的接口 端口号端口号（Port Number）只具有本地意义，其用于标识本计算机应用层中的进程 主机中的端口号长度为 $16bit$，最多可标识 $2^{16}=65536$ 个不同的进程 根据端口号的范围，可将端口分为两类： 1.服务端使用端口号 服务端使用端口号又分为范围为 0~1023 的熟知端口号，和范围为 1024~49151 的登记端口号 其中，熟知端口号由互联网地址指派机构 IANA 分配给了 TCP/IP 的一些重要应用程序，让所有的用户都知道，常用的熟知端口号如下表 应用程序 FTP TELNET SMTP DNS TFTP HTTP SNMP 熟知端口号 21 23 25 53 69 80 161 登记端口号，是为没有熟知端口号的应用程序使用的，若想使用这些端口号，需要在 IANA 进行登记，以防止重复 2.客户端使用端口号 客户端使用端口号的范围为 49152~65535，这类端口号仅在客户进程运行时才动态选择 其又称临时端口号、短暂端口号，提供给客户短暂使用，当通信结束后，这个端口号会被注销，之后，就又可以提供给其他客户进程使用 套接字网络中，通过 IP 地址来标识不同的主机，通过端口号来标识一台主机中不同的进程 在网络中，采用发送方和接收方的套接字（Socket），来识别端点，其唯一标识了网络中的一个主机和其上的一个进程，本质上是一个通信端点，即： Socket::=\\{,\\}在网络通信中，主机 $A$ 给主机 $B$ 发送的报文段包含目的端口号和源端口号，源端口号作为返回地址的一部分，即当 $B$ 需要发回给一个报文段给 $A$ 时，$B$ 到 $A$ 的报文段中目的端口号就是 $A$ 到 $B$ 报文段中源端口号 【无连接服务与面向连接服务】网络层知道如何将分组投递给一台主机，但不知道如何将它们投递给主机上具体的应用进程，而 TCP/IP 协议族在 IP 层之上使用两个传输协议来将数据交付给进程： 无连接的 UDP 协议：传输层向上提供一条不可靠的逻辑信道 面向连接的 TCP 协议：传输层向上提供一条全双工的可靠的逻辑信道 UDP 是一个无连接的不可靠的传输层协议，其在 IP 之上仅提供两个附加服务：多路复用与对数据的差错检测，同时，其尽最大努力交付，其在传送数据前不建立连接，远程主机的传输层收到 UDP 报文后，也不给出任何确认 由于 UDP 比较简单，其执行速度较快、实时性好，因此 UDP 主要用于对速度要求高的场合，例如：小文件传输协议 TFTP、实时协议 RTP、域名解析 DNS、简单网络管理协议 SNMP 等 TCP 是一个面向连接的可靠的传输层协议，在传输数据前先建立连接，数据传输结束后释放连接，同时，其不提供广播、组播服务 但由于 TCP 提供可靠的传输服务，这不可避免的增加了许多开销，不仅使 TCP 的数据单元头部增大许多，还占用许多处理机资源，因此 TCP 主要用于可靠性更重要的场合，例如：文件传输协议 FTP、超文本传输协议 HTTP、远程登录 TELNET 等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"网络层设备","slug":"computer-networks/42.网络层设备","date":"2019-10-29T10:52:00.000Z","updated":"2021-08-29T13:50:52.019Z","comments":true,"path":"notes/computer-networks/26b856f5.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/26b856f5.html","excerpt":"【概述】路由器是网络层的核心设备，其是一种具有多个输入输出端口的计算机，用来连接异构网络并完成路由转发，尤其是在具有不同广播域的多个逻辑网络互联时，必须使用路由器 此外，路由器也可以作为最基础的包过滤防火墙应用","text":"【概述】路由器是网络层的核心设备，其是一种具有多个输入输出端口的计算机，用来连接异构网络并完成路由转发，尤其是在具有不同广播域的多个逻辑网络互联时，必须使用路由器 此外，路由器也可以作为最基础的包过滤防火墙应用 在源主机与目的主机通信时，IP 数据报的交付分为直接交付、间接交付两种 直接交付：源主机、目的主机在同一网络，无须通过路由器可直接交付 间接交付：源主机、目的主机不在同一网络，需要利用路由器，查找转发表来转发到下一路由器 在进行间接交付时，路由器主要完成两个功能，一个是路由选择，通过与其他路由器进行基于路由协议的交互，完成路由表的计算；另一个是分组转发，通过处理路由器的数据流，来进行转发表的查询、转发、相关的队列管理、任务调度等 需要注意的是，路由表是根据路由选择算法得出的，转发表是从路由表得出的 【路由器结构】从结构上看，路由器由进行路由选择和分组转发的两部分组成，下图展示了路由器的基本结构 路由选择处理机部分用来进行路由选择，其根据路由选择协议来构建路由表，同时定期与相邻路由交换路由信息，来维护路由表 交换结构与输入输出端口部分用来进行分组转发 其中，交换结构中的转发表是核心部分，对于输入端口的数据流，通过查询转发表，选择合适的端口进行转发 对于交换结构本身来说，其就是一个网络，有三种常见的交换方法：通过存储器交换、通过总线交换、通过互联网络交换 对于输入端口来说，通过物理层、链路层、网络层的逐层处理，以及网络层的排队、查表、转发，会产生一定的等待时延 对于输出端口来说，其会将交换结构传过来的分组进行缓存，然后通过网络层、链路层、物理层逐层处理，这同样会产生一定的等待时延 当路由器处理分组的速率赶不上分组进入队列的速率时，会造成路由器的输入或输出队列产生溢出，从而造成分组丢失 【路由表与转发表】路由表路由表是根据路由选择算法得出的，主要用途是路由选择 一般的路由表通常具有四个项目：&lt;目的网络地址&gt;, &lt;子网掩码&gt;, &lt;下一跳路由地址&gt;, &lt;接口&gt; 在上图所给出的网络拓扑结构图中，R1 的路由表见下表 目的网络地址 子网掩码 下一条路由地址 接口 202.114.1.0 255.255.255.0 直连 E1 202.114.2.0 255.255.255.0 直连 L0 202.114.3.0 255.255.255.0 202.114.2.2 L0 0.0.0.0 0.0.0.0 202.114.2.2 L0 转发表转发表是从路由表中得出的，其表项与路由表表项有直接对应关系，但转发表的格式与路由表不同，其结构应使查找过程最优化，而路由表需要对网络拓扑变化计算最优化 一般的路由表通常具有两个项目：&lt;目的网络地址&gt;, &lt;下一跳&gt; 此外，为减少转发表的重复项目，通常使用一个默认路由来代替所有相同的下一跳，同时设置该默认路由优先级比其他项目优先级低 如下图所示，给出了使用默认路由和未使用默认路由的转发表的对比","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"移动 IP","slug":"computer-networks/41.移动IP","date":"2019-10-29T07:52:00.000Z","updated":"2021-08-29T13:50:33.735Z","comments":true,"path":"notes/computer-networks/7d39fdf3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/7d39fdf3.html","excerpt":"【概述】移动 IP，是支持移动性的因特网体系结构与协议的统称，其满足了移动结点在移动中保持连接的特性 具体来说，移动 IP 技术是移动结点以固定的网络 IP 地址，实现跨域不同网段的漫游功能，同时保证了基于网络 IP 的网络权限在漫游过程中不发生任何改变","text":"【概述】移动 IP，是支持移动性的因特网体系结构与协议的统称，其满足了移动结点在移动中保持连接的特性 具体来说，移动 IP 技术是移动结点以固定的网络 IP 地址，实现跨域不同网段的漫游功能，同时保证了基于网络 IP 的网络权限在漫游过程中不发生任何改变 【基本定义】IPv4 中，针对移动 IP，作出了以下基本定义： 移动结点：具有永久 IP 地址的移动设备 归属网络：又称本地网络，是移动结点未移动前所属的网络 归属代理：又称本地代理，是归属网络中代表移动结点执行移动管理的实体，根据移动用户的转交地址，使用隧道技术转交移动结点的数据包 归属地址：又称本地地址、主地址，是移动结点在归属网络中的原始地址，该地址是固定不变的 外部代理：在外部网络中，帮助移动结点完成移动管理功能的实体 转交地址：又称辅地址，外部代理的地址或动态配置的地址，该地址是动态的 【通信过程】 移动 IP 的基本工作过程可分为：代理发现、注册、分组路由、注销四个阶段，具体通信情况可分为三种情况：移动结点刚进入外部网络、移动结点移动到下一网络、移动结点回到归属网络 1.移动结点刚进入外部网络 当移动结点刚进入外部网络时，会进行以下工作： 1）获得外部代理的转交地址 2）通过外部代理发送含有永久地址、转交地址的注册请求报文给归属代理 3）归属代理接收请求，并将移动结点的永久地址、转交地址绑定，返回注册响应报文，此后，到达该归属代理且要被发往该移动结点的数据报将会被封装，并以隧道方式发送给转交地址 4）外部代理接收响应，并转发给移动结点 之后，即可正常进行通信 2.移动结点移动到下一网络 当移动结点移动到下一网络时，会进行以下工作： 1）在新的外部网络中，通过外部代理登记、注册转交地址 2）新外部代理给本地代理发送新的转交地址，将之前的转交地址覆盖 之后，即可正常进行通信 3.移动结点回到归属网络 当移动结点回到归属网络时，会进行以下工作： 1）向本地代理注销转交地址 2）回归原始方式，正常通信","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"BGP 协议","slug":"computer-networks/40.BGP协议","date":"2019-10-25T06:02:00.000Z","updated":"2021-08-29T13:50:23.756Z","comments":true,"path":"notes/computer-networks/4573dd90.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/4573dd90.html","excerpt":"【概述】边界网关协议（Border Gateway Protocol，BGP），是不同自治系统的路由器间交换路由信息的协议，是外部网关协议 EGP 由于因特网的规模太大，这使得自治系统之间路由选择非常困难，因此 BGP 只是是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由","text":"【概述】边界网关协议（Border Gateway Protocol，BGP），是不同自治系统的路由器间交换路由信息的协议，是外部网关协议 EGP 由于因特网的规模太大，这使得自治系统之间路由选择非常困难，因此 BGP 只是是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由 其具有以下特点： 交换路由信息的结点数量级是自治系统的数量级 支持 CIDR，因此 BGP 的路由表中的每一项为：&lt;目的网络前缀&gt;,&lt;下一跳路由地址&gt;,&lt;到达该目的网络要经过的各自治系统序列&gt; 应用层协议，在传输层上采用的是 TCP 协议 【工作原理】每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 BGP 发言人，通常来说，为了避免自治系统间的路由选择不过分复杂，BGP 发言人的数目是很少的，通常选择边界路由器来作为 BGP 发言人 每一个 BGP 发言人除了运行 BGP 协议外，还要运行该自治系统内所使用的内部网关协议 一个 BGP 发言人与其他自治系统的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在该 TCP 连接的基础上，将 BGP 报文封装进 TCP 报文的数据部分，进而建立 BGP 会话，再利用 BGP 会话来交换路由信息 在 BGP 刚运行时，BGP 的邻站交换的是整个 BGP 路由表，但之后仅需要交换发生变化时新变化的部分，当所有的 BGP 发言人都互相交换网络可达性信息后，各 BGP 发言人就可以找出到达各自治系统的比较好的路由 BGP 采用路径向量路由选择算法，所交换的网络可达性信息，就是要到某个网络所要经过的一系列自治系统 如下图，给出了主干网与自治系统间的路径向量交换 【BGP 报文】BGP 的运行是通过消息驱动的，总共有 $4$ 种类型，这些消息具有相同的报文首部，其格式如下图 其中，各字段含义如下： 标记：检查 BGP 对等体的同步信息是否完整，同时用于 BGP 验证的计算 长度：BGP 消息的总长度 类型：BGP 消息的类型，总共有 $4$ 个类型 BGP 消息总共有 $4$ 种类型，通过报文首部的类型字段制约，具体类型如下： 打开报文（Open）：与相邻的另一个 BGP 发言人建立关系 更新报文（Update ）：发送某一路由的信息，以及列出要撤销的多条路由 保活报文（Keepalive）：确认打开报文、周期性证实邻站关系 通知报文（Notification）：发送检测到的差错","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"OSPF 协议","slug":"computer-networks/39.OSPF协议","date":"2019-10-25T04:01:00.000Z","updated":"2021-08-29T13:48:48.552Z","comments":true,"path":"notes/computer-networks/32d714e1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/32d714e1.html","excerpt":"【概述】开放最短路径优先（Open Shortest Path First，OSPF）协议，是使用分布式链路状态路由算法的典型代表，其也是内部网关协议 IGP 的一种 其具有以下特点：","text":"【概述】开放最短路径优先（Open Shortest Path First，OSPF）协议，是使用分布式链路状态路由算法的典型代表，其也是内部网关协议 IGP 的一种 其具有以下特点： 对不同的链路可根据 IP 分组的不同服务类型而设置不同的代价，因此，对于不同类型的业务可计算出不同的路由 若到同一目的网络有多条代价相同的路由，那么可将通信量同时分配给这几条路径，这被称为多路径间的负载均衡 所有在 OSPF 路由器间交换的 IP 数据报都具有鉴别的功能，从而保证仅在可信赖的路由器间交换链路状态信息 每一个发送的链路状态上都会附加一个 $32$ 位的序号，序号越大表示链路状态越新 支持可变长的子网划分与无分类编址 CIDR 【与 RIP 的比较】与 RIP 相比，OSPF 与其主要有以下区别： OSPF 采用洪泛法向本自治系统内所有路由器发送路由信息；RIP 仅向直接相邻的路由器发送路由信息 OSPF 发送的路由信息是与本路由器直接相邻的路由器的链路状态，即本路由器与哪些相邻，以及该链路的度量代价；RIP 发送的路由信息是本路由器所知道的全部信息，即整个路由表 OSPF 只有当链路状态发生变化时，才向所有路由发送信息；RIP 中无论网络拓扑是否改变，路由器间都会定期交换路由信息 OSPF 每个路由器的链路状态仅涉及与相邻路由器的连通状态，与整个网络规模无关，因此更新过程收敛快，适用于大型网络；RIP 更新过程可能存在慢收敛问题，适用于小型网络 OSPF 是网络层协议，直接使用 IP 数据报传送路由信息，其 IP 数据报首部协议字段为 $89$；RIP 是应用层协议，在传输层使用 UDP 协议 【工作原理】对于 OSPF 来说，由于各路由间频繁的交换链路状态信息，因此所有的路由器最终都可以建立出一个链路状态数据库，这个数据库实际上就是全网拓扑结构图，其在全网范围内都是一致的，这被称为链路状态数据库的同步 在建立出这个链路状态数据库后，每个路由器就可以根据这个全网拓扑结构图使用 Dijkstra 算法，来计算从自己到各目的网络的最优路径，从而构造自己的路由表 在此之后，每当链路状态发生变化时，每个路由器就根据更新后的全网拓扑结构图来重新计算自己到各目的网络的最优路径，构造新的路由表 需要注意的是，虽然使用 Dijkstra 能够计算出完整的路径，但为了减小路由表的容量，路由表中并不会存储完整路径，只会存储下一跳，只有到达下一跳路由器，才能知道再下一跳怎么走 因此，在采用 OSPF 的路由器中，每一个路由表项都有两条项目：&lt;目的网络 N&gt;,&lt;下一跳路由器的地址 X&gt; 【OSPF 分组】OSPF 分组会作为 IP 数据报的数据部分封装到 IP 数据报中，每个 OSPF 分组由固定的 $24B$ 的分组首部与数据部分组成，具体格式如下图 其中，类型字段规定了 OSPF 分组的类型，总共有以下五种类型的分组： 问候分组：用来发现、维持邻站的可达性 数据库描述分组：向邻站给出自己的链路状态数据库中的所有链路状态的摘要信息 链路状态请求分组：请求发送某些链路状态项目的详细信息 链路状态更新分组：使用洪泛法向全网更新链路状态 链路状态确认分组：对链路更新分组的确认 【链路数据库的建立与维护】通常每隔 $10$ 秒，每两个相邻路由器都要交换一次问候分组，以便知道哪些站可达 在路由器开始工作时，OSPF 让每一个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息 之后，路由器使用链路状态请求分组，向对方请求发送自己缺少的某些链路状态项目的详细信息 经过一系列的分组交换，全网同步的链路数据库就建立完成了 在网络运行过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态，在其他路由器更新后，发送链路状态确认分组对更新分组进行确认 此外，为确保链路状态数据库的同步，OSPF 规定每隔一段时间就刷新一次数据库中的链路状态，这个时间通常规定为 $30$ 分钟 如下图，给出了两个路由器分组交换的流程 【区域】划分区域为了使 OSPF 能够用于大规模网络，其将一个自治系统划分为若干更小的范围，每个范围称为区域（Area），每一区域通过用一个 $32$ 位的区域标识符来标识 在一个区域内，路由器一般不超过 $200$ 个，同时，区域内的每一路由器只知道本区域的完整网络拓扑，不知道其他区域的网络拓扑情况 划分区域的好处就是使用洪泛法交换链路状态信息的范围局限于每一个区域，从而大大减少了整个网络上的通信量 层次结构区域之间也有层次之分，处于上层的区域称为主干区域（Backbone Area），其区域标识符规定为 0.0.0.0，用于连通其他在下层的区域 在主干区域内部的路由器被称为主干路由器，主干区域连接其他下层区域的路由器称为区域边界路由器，主干区域连接其他自治系统的路由器称为自治系统边界路由器 如下图，在一个自治系统内部划分区域后，R3、R4、R5、R6、R7 为主干路由器，R3、R4、R7 为区域边界路由器，R4 为自治系统边界路由器","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"RIP 协议","slug":"computer-networks/38.RIP协议","date":"2019-10-22T11:59:00.000Z","updated":"2021-08-29T13:48:27.884Z","comments":true,"path":"notes/computer-networks/aa1f87ea.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/aa1f87ea.html","excerpt":"【概述】路由信息协议（Routing Informatica Protocol，RIP），是内部网关协议 IGP 中最先得到广泛应用的协议，其是一种分布式的基于距离向量算法的路由选择协议，最大的优点就是简单 需要注意的是，RIP 是基于 UDP 协议的应用层协议","text":"【概述】路由信息协议（Routing Informatica Protocol，RIP），是内部网关协议 IGP 中最先得到广泛应用的协议，其是一种分布式的基于距离向量算法的路由选择协议，最大的优点就是简单 需要注意的是，RIP 是基于 UDP 协议的应用层协议 RIP 协议具有以下特点： 仅与相邻路由器交换信息 路由器交换的信息是当前路由器知道的全部信息，即自己的路由表 按固定的时间间隔交换路由信息，一般为 $30$ 秒 【基本规定】RIP 协议有以下基本规定： 网络中的每个路由器都要维护从它自身到其他每一个目的网络的距离记录，这一组距离被称为距离向量 距离被规定为跳数（Hop Count），同时，从一个路由器到直接连接的网络距离规定为 $1$，每经过一个路由器，距离加 $1$ 允许一条路径最多包含 $15$ 个路由器，即最多允许 $15$ 跳，当距离等于 $16$ 跳时，表示网络不可达 认为好的路由就是通过的路由器的数目少，即优先选择跳数少的路径 默认在任意两个使用 RIP 协议的路由器间每 $30$ 秒广播一次 RIP 路由更新信息，以便自动建立并动态维护路由表 默认超时时间为 $180$ 秒 不支持子网掩码的 RIP 广播，因此 RIP 中每个网络的子网掩码必须相同（RIP2 中，支持变长子网掩码与 CIDR） 【RIP 报文格式】RIP 报文作为数据分装到 UDP 数据报中，RIP 报文的格式如下图 【收敛】RIP 协议通过距离向量算法来完成路由表的更新 最开始时，每个路由器只知道与自己直接相连的网络，通过每 $30$ 秒的 RIP 广播，相邻两个路由器将自己的路由表发送给对方 于是，经过第一次 RIP 广播，每个路由器就知道与自己相邻路由器的路由表，即知道了与自己距离跳数为 $1$ 的网络的路由信息；经过第二次 RIP 广播，每个路由器就知道了与自己距离跳数为 $2$ 的网络的路由信息… 因此，在经过若干次 RIP 广播后，所有路由器都最终知道了整个网络的路由表，因此 RIP 最终是收敛（Convergence）的 通过 RIP 协议收敛后，每个路由器到每个目标网络的路由都是距离最短，即跳数最少的，但此时可能存在另一条低时延但路由器较多的路由 【慢收敛现象】RIP 限制了网络规模，路由链路长度最长为 $15$ 跳，同时，由于路由器间交换的是当前路由器的完整路由表，这就导致了网络规模越大开销也越大，因此其只适合小型网络 而当网络出现故障时，需要较长时间紧才能将此信息传送到所有路由器，这被称为慢收敛现象，即坏消息传得慢 慢收敛现象会导致更新过程的收敛时间过长，从而使得路由器可能接收无效路由信息，这就可能造成路由回路问题 【距离向量算法】在采用 RIP 的路由器中，每一个路由表项都有三个项目：&lt;目的网络 N，距离 d，下一跳路由器的地址 X&gt; 在每次路由器对相邻路由器发送路由更新信息时，对发送过来的 RIP 报文，执行以下步骤： 1）对地址为 $X$ 的相邻路由器发来的 RIP 报文，修改此报文中的项目：将下一跳中的地址改为 $X$，所有距离值加 $1$ 2）对修改后的 RIP 报文中的每一项目，进行以下步骤： ① 当原来的路由表中没有目的网络 $N$ 时，将该项目添加到路由表中 ② 当原来的路由表中有目的网络 $N$，且下一跳路由器地址是 $X$ 时，用收到的项目替换路由表中原有的项目 ③ 当原来的路由表中有目的网络 $N$，且下一跳路由器地址不是 $X$ 时，若收到的项目中的距离小于路由表中的距离，用收到的项目替换路由表中原有的项目 3）若在默认超时时间 $180$ 秒内，没有收到相邻路由器的更新路由表信息，就将该相邻路由器视为不可达的路由器，即将距离设为 $16$","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"路由算法与路由选择协议","slug":"computer-networks/37.路由算法与路由选择协议","date":"2019-10-22T07:58:00.000Z","updated":"2021-08-29T13:48:08.269Z","comments":true,"path":"notes/computer-networks/74ee5df7.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/74ee5df7.html","excerpt":"【路由算法】概述路由器转发分组是通过路由表转发的，而路由表是通过各类算法得到的，根据能否随网络通信量或拓扑自适应进行调整，路由算法可分为静态路由算法、动态路由算法两类","text":"【路由算法】概述路由器转发分组是通过路由表转发的，而路由表是通过各类算法得到的，根据能否随网络通信量或拓扑自适应进行调整，路由算法可分为静态路由算法、动态路由算法两类 静态路由算法，又称非自适应路由算法，是指由网络管理员手工配置路由信息，一旦当网络拓扑结构或链路状态发生变化，网络管理员需要手工去修改路由表中相关的静态路由信息，适用于小型网络 动态路由算法，又称自适应路由算法，是指路由表上的路由表项通过相互连接的路由器不断交换信息，然后通过一定算法优化出来的，常见的动态路由算法分为距离向量路由算法、链路状态路由算法两类 距离-向量路由算法在距离-向量路由算法中，所有的结点都在每次更新中都将他们的全部路由表传送给所有与其直接相邻的结点，这种路由表每行只有两个项目： 另一结点 IP 地址：每条路径的目的地 到另一结点的距离：路径的代价 在这种算法中，所有结点都必须参与距离向量交换，以保证路由的有效性和一致性，也就是说，所有的结点都监听从其他结点传送过来的路由选择更新信息，并在下列情况下更新他们的路由选择表： 被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入该条新路由信息 发送来的路由信息中有一条到达某结点的路由，且该路由比当前使用的路由有较小的代价，此时用较小代价的路由代替当前使用的路由 该算法的实质是迭代计算一条路由中的站点数或延迟时间，从而得到到达一个目标的最小代价通路 在 RIP 协议中，进行路由更新的 RIP 算法就是距离-向量算法，其采用跳数作为距离的度量 链路状态路由算法链路状态路由算法，要求每个参与该算法的结点都掌握完整网络拓扑信息，同时，每个结点会执行以下两个任务： 主动测试所有邻接结点的状态，即测试两个共享一条链接的结点 定期将链路状态传播给所有其他结点 也就是说，在链路状态路由算法中，每个结点都会检查所有直连链路的状态，并将所得的状态信息发送给网络上其他的结点，同时，每个结点都会从其他结点接收包含直接链路状态的路由选择信息 每当链路状态报文到达时，路由结点便利用这些状态信息去更新自己的网络拓扑和状态，一旦链路状态发生变化，结点对更新了的网络图利用 Dijkstra 算法来重新计算路径，从单一的源点出发，计算到达所有目的结点的最短路径 简单来说，链路状态路由算法，就是只有当链路状态发生变化时，路由器才会向本自治系统内的其他所有路由器采用泛洪法发送信息，发送的信息就是与路由器相邻的所有路由器的链路状态，即说明路由器都与哪些路由器相邻，以及该链路的度量 在 OSPF 协议中，进行路由更新的 OSPF 算法就是链路状态路由算法 所谓泛洪法，就是路由器通过所有端口向所有相邻的路由器发送信息，每一个相邻路由器又将该信息发往除了刚刚发来信息的那个路由器外的，其他的所有相邻的路由器 【路由选择协议】自治系统而当网络规模扩大时，路由器的路由表成比例增大，这不仅消耗大量的路由器缓冲区，还耗费大量的 CPU 时间进行扫描，为解决这种问题，提出了自治系统（Autonomous System，AS） Internet 将整个互联网划分为许多较小的自治系统，每个自治系统内可能包含许多局域网，同时，每个自治系统有权自主决定本系统内采用何种路由选择协议 这样一来，路由选择会按照层次方式进行，在自治系统内部的路由选择称为域内路由选择，在两个自治系统之间的路由选择称为域间路由选择 内部网关协议与外部网关协议对于域内路由选择来说，其采用的路由选择协议被称为内部网关协议（Interior Gateway Protocol，IGP） IGP 与互联网中其他自治系统中选用什么路由选择协议无关，目前这类路由选择协议应用的最多，常见的有 RIP 协议、OSPF 协议 对于域间路由选择来说，其采用的路由选择协议被称为外部网关协议（External Gateway Protocol，EGP） 其将路由选择信息从一个自治系统的边界传递到另一个自治系统中，目前使用最多的外部网关协议是 BGP-4 协议 自治系统的互联如下图，是两个自治系统互联在一起的示意图，每个自治系统自己决定在系统内部运行何种路由协议，但每个自治系统都有一个或多个路由器，除了运行本系统内部的路由选择协议外，还要运行自治系统间的路由选择协议","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"IP 组播","slug":"computer-networks/36.IP组播","date":"2019-10-22T03:51:00.000Z","updated":"2021-08-29T13:47:55.468Z","comments":true,"path":"notes/computer-networks/46b1c324.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/46b1c324.html","excerpt":"【概述】对于 IP 数据报来说，有三种通信方式： 单播：点对点通信，发送数据报到单个目的地，每次发送都使用单播 IP 作为目的地址 广播：点对多点通信，发送数据报到同一广播域，子网中所有设备都会收到数据 组播（多播）：某些用户需要数据时，发送方仅发送一次数据，借助组播路由协议为数据报建立组播分发树，被传送的数据到达距离用户端尽可能近的结点后复制、分发","text":"【概述】对于 IP 数据报来说，有三种通信方式： 单播：点对点通信，发送数据报到单个目的地，每次发送都使用单播 IP 作为目的地址 广播：点对多点通信，发送数据报到同一广播域，子网中所有设备都会收到数据 组播（多播）：某些用户需要数据时，发送方仅发送一次数据，借助组播路由协议为数据报建立组播分发树，被传送的数据到达距离用户端尽可能近的结点后复制、分发 对于视频点播、视频会议这样的多媒体应用，要将一个分组发送给多个目的主机，如果每个目的主机都要发送一个 IP 数据报，这无疑会引起大量的处理开销与太多的网络通信量 因此，可以令这些目的主机的 IP 地址用一组地址来标识，发送方仅发送时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发，这样对于发送者而言，数据只需要发送一次就可以发送给所有的接受者，极大的减轻了网络负载与发送方的负担 单播与组播的比较示意图如下 【IP 组播的特点】IP 组播具有如下特点： 组播地址仅可作为目的地址，不能采用源地址（源地址采用单播地址） 对组播数据报不产生 ICMP 差错报文，因此若在 PING 命令后键入组播地址，将永远不会收到响应 组播是基于 UDP 的，其尽最大努力交付，不提供可靠交付 组播分为在本局域网上的硬件组播、在因特网上的组播 组播地址永久不变，由因特网号码指派管理局 IANA 负责指派 组播的组成员是动态的，一个主机可以选择加入或离开一个组，也可以同时属于多个组 组播数据报使用的 D 类 IP 地址仅作为目的地址（源地址为单播地址），且首部中的协议字段值为 $2$，表明使用 IGMP 协议 【IP 组播地址】IP 组播分为在本局域网上进行的硬件组播和在因特网范围内的因特网组播，但在因特网组播的最后阶段，还是要将组播数据报在局域网上将硬件组播交付给组播组内的所有成员 在 IPv4 中，组播地址在 D 类地址空间中分配，在 IPv6 中，保留了一部分地址空间用于组播地址，这里仅介绍 IPv4 下的组播 因特网组播采用的是 D 类地址，其前四位是 1110，故而其地址范围从 224.0.0.0 到 239.255.255.255，每一个 D 类 IP 地址，都标识了一个组播组 对于硬件组播来说，因特网号码指派管理局 IANA 所拥有的以太网组播地址范围从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF，可以发现，给出的每一个地址，只有 $23$ 位可用于组播 由于因特网组播最终要利用硬件组播将组播数据报交付给组播组内的所有成员，因此，对于 IANA 给出的硬件组播地址，与因特网组播中利用的 D 类 IP 地址存在一定的映射关系 由于硬件组播给出的地址只有 $23$ 位用于组播，而 D 类 IP 地址除去前 $4$ 位外，还剩余 $28$ 位，可见这 $28$ 位中的前 $5$ 位不能用来构成以太网的硬件地址 下图显示出两地址的对应关系 举例来说，对于 IP 组播地址 224.128.64.32，转换成十六进制表示为 E0-80-40-20，对于另一 IP 组播地址 224.0.64.32，转换成十六进制表示为 E0-00-40-20 根据硬件组播与因特网组播的对应关系，可以得出这两者的硬件组播地址都是 01-00-5E-00-40-20 由于组播 IP 地址与以太网硬件地址的映射关系不是唯一的，收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃 【IGMP 协议】概述因特网组管理协议（Internet Group Management Protocol，IGMP），是目前最常用组播协议，主机通过运行该协议加入组播组，路由器通过该协议来扩展路由选择与分组转发，从而于因特网上其他组播路由器协同工作，以最小代价将组播数据报传送给所有的组成员 IGMP 并非在因特网范围内对所有多播组成员进行管理的协议，其并不知道 IP 组播组包含的成员数，也不知道这些成员都分布在哪些网络上，只是让连接在本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组 组播转发必须动态地适应组播组成员的变化，组播路由器在转发组播数据报时，不能仅仅根据组播数据报中的目的地址，而是还要考虑这个组播数据报从什么地方来和要到什么地方去 组播数据报可以由没有加入组播组的主机发出，也可以通过没有组成员接入的网络 基本原理IGMP 可视为 TCP/IP 的一部分，其工作过程可分为两个阶段： 1.阶段一 当某个主机加入新的组播组时，该主机应向组播组的组播地址发送IGMP 报文，声明自己要成为该组的成员，本地的组播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他组播路由器 2.阶段二 由于组成员关系是动态的，因此本地多播路由器要周期性探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员，默认每 $125$ 秒探询一次 只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的 但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器 【组播的路由选择与分组转发】路由选择组播路由选择协议尚未标准化，由于一个组播组中的成员是动态变化的，随时会有主机加入或离开这个多播组 因此，组播路由选择实际上就是要找出以源主机为根结点的组播转发树，其中每一分组在每条链路上只传输一次，即组播转发树上的路由器不会收到重复的组播数据报，可见，组播转发树很好的避免了路由环路问题 对于不同的组播组，对应于不同的组播转发树；对于同一个组播组，对不同的源点也会有不同的组播转发树 分组转发组播数据报的分组转发有三种方法：洪泛与剪除、隧道技术、基于核心的发现技术 1.洪泛与剪除 洪泛与剪除适用于较小的组播组，同时要求所有的组成员接入的局域网是邻接的 最开始，路由器转发组播数据报使用洪泛法进行广播 之后，为了避免兜圈子，采用了叫做反向路径广播（Reverse Path Broadcasting，RPB）的策略 简单来说，路由器收到组播数据报时，先检查是否从源点经最短路径传送来的，若是，就向所有其他方向转发刚才收到的组播数据报；若不是，就丢弃而不转发 若存在几条同样长度的最短路径，就只选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小 2.隧道技术 组播数据报采用隧道技术进行分组转发，是将组播数据报封装到单播数据报中，然后通过不支持组播的网络 3.基于核心的发现技术 基于核心的发现技术适合组播组的大小在较大范围内变化时的情况 该方法是对每一个多播组 G 指定一个核心路由器，给出它的 IP 单播地址 之后，核心路由器创建出 G 的组播转发树，再进行分组转发","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"IPv6","slug":"computer-networks/35.IPv6","date":"2019-10-18T14:55:00.000Z","updated":"2021-08-29T13:47:34.327Z","comments":true,"path":"notes/computer-networks/1d3badf2.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/1d3badf2.html","excerpt":"【概述】为解决 IP 地址耗尽的问题，从分类 IP 的基础上发展出了网络地址转换 NAT、无类别编址 CIDR 的方法，但这两种方法只是延长了 IP 地址分配的结束时间，随着时间的增长 IP 地址总有耗尽的一天 为此，开发了 具有更大地址空间的 IPv6","text":"【概述】为解决 IP 地址耗尽的问题，从分类 IP 的基础上发展出了网络地址转换 NAT、无类别编址 CIDR 的方法，但这两种方法只是延长了 IP 地址分配的结束时间，随着时间的增长 IP 地址总有耗尽的一天 为此，开发了 具有更大地址空间的 IPv6 【与 IPv4 的对比】与 IPv4 相比，IPv6 具有以下特点： 地址长度从 $32bit$ 扩展到了 $128bit$ 减少不必要的功能，首部字段数减少到仅有 $8$ 个 路由一般不对扩展首部检查，同时提供 QoS 服务 支持即插即用，自动配置，IPv4 若想自动配置需要采用 DHCP 只允许源站进行分片，对于发送时经过的主机和路由器来说，若数据报过大则丢弃，同时向主机发送 ICMP 分组过大报文 使用 ICMPv6 版本，其在 ICMP 的基础上又加了一系列的报文（例如：ICMP 分组过大报文） 【IPv6 数据报格式】下图展示了 IPv6 数据报的一般形式，直观来看，相较于 IPv4 数据报，其将固定字段变为基本首部，将可选字段变为扩展首部，同时，引入了有效载荷的概念 对于 IPv6 的基本首部，具体格式如下： 其中，各字段含义如下： 版本：占 $4bit$，指明协议的版本，对于 IPv6 来说，该字段总是 $6$ 通信量类：占 $8bit$，用来区分不同 IPv6 数据报的类别或优先级，目前正在进行不同的通信量类性能的实验 流标号：占 $20bit$，流是网络上从特定源点到特定终点的一系列数据报，流所经过的路径上的路由器都保证指明的服务质量，所有属于同一个流的数据报都具有同样的流标号 有效载荷长度：占 $16bit$，有效载荷是指扩展首部与数据部分的长度，指明了 IPv6 数据除基本首部外的字节数，最大值为 $64KB$ 下一首部：占 $8bit$，相当于 IPv4 的协议字段或可选字段，表示上层协议或第一个扩展首部的类型 跳数限制：占 $8bit$，源站在数据报发出时即设定跳数限制，路由器在转发数据报时将跳数限制字段中的值减 $1$，当跳数限制的值为 $0$ 时，就要将此数据报丢弃 源地址：占 $128bit$，是数据报的发送站的 IP 地址 目的地址：占 $128bit$，是数据报的接收站的 IP 地址 对于目的地址来说，IPv6 可以是以下三种基本类型地址之一： 单播：即传统点对点通信 多播：也称组播，一点对多点的通信，分组被交付到一组计算机的每台计算机 任播：目的站是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机 【地址形式】IPv6 采用冒号十六进制来表示 IP 地址，即每 $4$ 位二进制数用一个十六进制表示，$128bit$ 的 IP 地址写成 $32$ 个十六进制数，同时，每 $4$ 个十六进制数用冒号隔开 进一步，在上述的记法采用压缩形式，每组中，若有连续的四个 $0$，可用一个 $0$ 来表示四个 $0$，若前面存在连续的 $0$，后面存在一个非零，可将连续的 $0$ 省略 例如，对于 4BF5:0000:000A:... ，可以压缩为 4BF5:0:A:... 此外，在压缩形式的基础上，可采用双冒号记法，即一串连续的 $0$ 可采用 $::$ 来取代，但这种记法在一个 IP 地址中只能出现一次，以便从总位数中推算省略 $0$ 的个数 例如，对于 FF05:0:0:0:0:0:0:B3，可记为 FF05::B3 【特殊地址】在 IPv6 中，同样有一些具有特殊用途的地址 地址类型 二进制前缀 IPv6 表示 作用 未指定 全 $0$ ::/128 系统启动之初，尚未分配 IP 地址，对外请求 IP 地址时，作为源地址使用 环回地址 除最后一位为 $1$ 外，其余全 $0$ ::1/128 用于环回测试 多播地址 前八位为 $1$，其余全 $0$ FF00::/8 用于多播通信 本地链路单播地址 前十位为 1111 1110 10，其余全 $0$ FE80::/10 用于本地链路单播通信 全球单播地址 剩余所有 用于全球链路单播通信 【从 IPv4 到 IPv6 的过渡】从 IPv4 到 IPv6 的过渡只能采取逐步演进的方法，同时必须令新安装的 IPv6 系统能够向后兼容，即 IPv6 系统能够接受和转发 IPv4 分组，且能为 IPv4 分组选择路由 目前，采取的过渡方法主要有两种策略：双协议栈技术、隧道技术 双协议栈技术，是指在一台设备上同时安装 IPv4 和 IPv6 协议栈 当设备是主机时，会同时拥有 IPv4 和 IPv6 地址，且具备同时处理两个协议地址的功能；当设备是路由器时，路由器的不同接口上分别配置 IPv4 和 IPv6 地址，且可能分别连接 IPv4 和 IPv6 网络 隧道技术，是将整个 IPv6 分组封装到 IPv4 数据报的数据部分，使 IPv6 数据报可以在 IPv4 网络的隧道中传输","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"ICMP 协议","slug":"computer-networks/34.ICMP协议","date":"2019-10-18T14:23:00.000Z","updated":"2021-08-29T13:46:22.579Z","comments":true,"path":"notes/computer-networks/1a97c2c0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/1a97c2c0.html","excerpt":"【概述】为提高 IP 数据报交付成功的机会，网络层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）来允许主机或路由器报告差错和异常情况 ICMP 报文会作为 IP 数据报的数据，然后加上 IP 数据报的首部，之后再发送出去","text":"【概述】为提高 IP 数据报交付成功的机会，网络层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）来允许主机或路由器报告差错和异常情况 ICMP 报文会作为 IP 数据报的数据，然后加上 IP 数据报的首部，之后再发送出去 根据实际需要，ICMP 报文分为报告差错和异常情况的 ICMP 差错报文，以及网络探询追踪的 ICMP 询问报文 【ICMP 报文结构】ICMP 报文结构如下图所示 其中，各字段含义如下： 类型：占 $8bit$，取值 1~127 为差错报文，取值 128 以上为询问报文 代码：占 $8bit$，在类型的基础上进一步指明 ICMP 报文类型 检验和：包括数据部分的检验和 【ICMP 差错报文】类型ICMP 差错报文主要用于目的主机或到目的主机路径上的路由器向源主机报告差错和异常情况，总共有以下五种类型： 1.终点不可达 当主机、路由器无法交付 IP 数据报时，目的主机将会向源主机发送该类型的 ICMP 差错报文 2.源点抑制 当目的主机、路由器由于拥塞丢弃 IP 数据报时，目的主机会向源主机发送该类型的 ICMP 差错报文，以使得源主机将 IP 数据报的发送速率减慢 3.时间超过 时间超过类型的 ICMP 差错报文注意分为以下两种情况： 1）当路由器收到生存时间 TTL 为 $0$ 的 IP 数据报时，除丢弃该 IP 数据报外，还要向源主机发送该类型的 ICMP 差错报文 2）当目的主机在预定时间内没有收到 IP 数据报的全部 IP 数据报片时，会将已收到的 IP 数据报片全部丢弃，再向源主机发送该类型的 ICMP 差错报文 对于工作在网络层的用来追踪分组经过的路由 Tracert(Windows)、Traceroute(UNIX) 来说，就直接使用了时间超过报文 4.参数问题 当目的主机、路由器收到的 IP 数据报的首部中，存在某些字段值不正确时，会丢弃该 IP 数据报，并向源主机发送该类型的 ICMP 差错报文 5.改变路由 当路由需要更改时，路由器会将该类型的 ICMP 差错报文发送给源主机，告知主机下次应将 IP 数据报发送给另外的路由器 不可发送情况对于 ICMP 差错报文来说，有以下四种情况是不可发送的： 对 ICMP 差错报文不可发送 对第一个分片的 IP 数据报片后所有后续 IP 数据报片不可发送 对具有组播地址的 IP 数据报不可发送 对具有特殊地址（例如：127.0.0.0、0.0.0.0）的 IP 数据报不可发送 【ICMP 询问报文】ICMP 询问报文主要有：回送请求与回答报文、时间戳请求与回答报文、掩码地址请求与回答报文、路由器询问与通告报文 对于工作在应用层的用于测试两个主机间连通性的分组网间探测 PING，其直接使用了 ICMP 协议，没有使用传输层的 TCP、UDP 协议 具体来说，PING 使用了 ICMP 协议的回送请求与回答报文","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"ARP 协议","slug":"computer-networks/33.ARP协议","date":"2019-10-18T09:07:00.000Z","updated":"2021-08-23T12:49:51.884Z","comments":true,"path":"notes/computer-networks/481361ad.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/481361ad.html","excerpt":"【IP 地址与硬件地址】IP 地址与硬件地址IP 地址是网络层使用的地址，其是分层次等级的；硬件地址，是链路层使用的地址，一般使用的均是 MAC 地址，其是平面式的","text":"【IP 地址与硬件地址】IP 地址与硬件地址IP 地址是网络层使用的地址，其是分层次等级的；硬件地址，是链路层使用的地址，一般使用的均是 MAC 地址，其是平面式的 在网络层以及网络层之上，所使用的是 IP 地址，其放置于在 IP 数据报的首部；而在链路层，使用的是 MAC 地址，其放置于在 MAC 帧首部 在经过数据封装，将 IP 数据报封装成 MAC 帧后，数据链路层是看不到 IP 数据报中的 IP 地址 寻址过程由于路由器的隔离广播域，IP 网络中无法通过广播方式依靠 MAC 地址来完成跨网络的寻址，因此，在 IP 网络的网络层中，只能使用 IP 地址来完成寻址 在寻址时，每个路由器会依据路由表来选择到达目标网络需要转发到的下一跳，IP 数据报经过多次路由转发，到达目的网络后，会在该局域网 LAN 中通过链路层的 MAC 地址以广播方式寻找目的主机 在上述的寻址过程中，通过路由器转发 IP 数据报时，在每个网络中都会将 IP 数据报进行解封、封装，也就是说，在寻址过程中，MAC 帧的源地址是不断变化的 【ARP 协议】概述无论网络层使用的何种协议，在实际网络的链路上传输数据时，最终还是要以广播方式使用硬件地址来传送 地址解析协议（Address Resolution Protocol，ARP）工作在网络层，用于解决同一局域网上主机或路由器的 IP 地址到 MAC 地址的映射问题 具体来说，对于网络上的每个主机，都会设置一个 ARP 高速缓存，来存放本局域网中各主机和路由器的 IP 地址到 MAC 地址的映射表，即 ARP 表，同时，使用 ARP 协议来动态维护该表 需要说明的是，从 IP 地址到 MAC 地址的解析是自动进行的，主机用户对于这种地址解析过程是不知情的，也就是说，只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器通信，ARP 协议就会自动将该 IP 解析为链路层所需要的 MAC 地址 工作原理当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，会进行如下操作： 1）在 ARP 表中查看有无主机 B 的 IP 地址，若有，即可得出对应 MAC 地址，将该 MAC 地址写入 MAC 帧，通过局域网将该 MAC 帧广播发送；若没有，执行以下步骤 2）使用目的 MAC 地址为 FF-FF-FF-FF-FF-FF 来封装一个 MAC 帧，该帧被称为 ARP 请求分组，之后进行广播 3）同一局域网内的主机均会收到 ARP 请求分组，当主机 B 收到该 ARP 请求分组后，会向主机 A 单播发送 ARP 响应分组，分组中包含主机 B 的 IP 地址与 MAC 地址的映射关系 4）主机 A 收到 ARP 响应分组后，会将映射关系写入 ARP 表中，然后按照该映射关系发送 MAC 帧 典型情况根据发送方的情况，ARP 协议的使用情况可分为以下四种： 1.发送方是主机，要将 IP 数据报发送到本网络上的另一主机 直接使用 ARP 找到目的主机的 MAC 地址 2.发送方是主机，要将 IP 数据报发送到另一网络上的主机 使用 ARP 协议找到本网络上连接另一网络的路由器的 MAC 地址，之后的工作由该路由器完成 3.发送方是路由器，要将 IP 数据报发送到本网络上的主机 直接使用 ARP 找到目的主机的 MAC 地址 4.发送方是路由器，要将 IP 数据报发送到另一网络上的主机 使用 ARP 协议找到本网络上连接另一网络的路由器的 MAC 地址，之后的工作由该路由器完成","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"IPv4 地址与 CIDR","slug":"computer-networks/32.IPv4地址与CIDR","date":"2019-10-15T13:06:00.000Z","updated":"2021-08-23T12:50:03.082Z","comments":true,"path":"notes/computer-networks/d0b63051.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/d0b63051.html","excerpt":"【概述】连接在 Internet 中的每一台主机或路由器，都会被分配一个 $32bit$ 的全球唯一标识符，即 IPv4 地址，常被称为 IP 地址 IP 地址的发展阶段经历分类 IP、子网划分、无分类编址三个阶段","text":"【概述】连接在 Internet 中的每一台主机或路由器，都会被分配一个 $32bit$ 的全球唯一标识符，即 IPv4 地址，常被称为 IP 地址 IP 地址的发展阶段经历分类 IP、子网划分、无分类编址三个阶段 本文主要介绍无分类编址 【无分类域间路由选择 CIDR】概述无分类域间路由选择（CIDR）是在变长子网掩码的基础上，提出的一种消除传统 A、B、C 类网络划分的方法，并且其可在软件的支持下实现超网构造 举例来说，如果某个单位需要 2000 个地址，那么就分配给它一个 2048 地址的块，即 8 个连续的 C 类网络，而非一个完全的 B 类地址 这样可以极大幅度的提高 IP 地址空间的利用率，减小路由器的路由表大小，提高路由转发能力 基本思想CIDR 使用网络前缀的概念来代替子网络的概念，这样 IP 地址的无分类两级编址为： IP::=\\{,\\}同时，其在点分十进制记法的基础上，使用了斜线记法，即：IP 地址/网络前缀所占比特数，这样一来，网络前缀所占比特数的部分，对应于分类 IP 中的网络号，等效于子网掩码中连续 $1$ 的部分 例如，对于 128.14.32.5/20 这个地址，其掩码是 $20$ 个连续的 $1$ 和后续 $12$ 个连续的 $0$，通过直接截取前 $20$ 位或与子网掩码逐位与的方法，即可得到该地址的网络前缀 CIDR 虽然不适用子网，但仍然使用掩码这一概念，具体来说，是指 CIDR 并没有在 $32$ 位地址中指明若干位作为子网字段，但分配到一个 CIDR 地址块的单位，可在本单位内根据需要来划分一些子网 例如，某单位分配到地址块 /20，可以在其基础上划分 $8$ 个子网，即从主机号中借用 $3$ 位，此时，每个子网的网络前缀就变为 /23 CIDR 地址数CIDR 地址块中的地址数一定是 $2$ 的整数幂，实际可指派的地址数为 2^N-2其中，$N$ 代表主机号的位数，减去的 $2$ 分别代表主机号全 $0$ 的网络号和全 $1$ 的广播地址 网络前缀越短，其地址块包含的地址数就越多 【最长前缀匹配】最长前缀匹配，又称最佳匹配，是使用 CIDR 时查找路由表利用一种方法 在使用 CIDR 时，路由表中的每个条目由网络前缀、下一跳地址这两个信息构成 在查找路由表时，可能会得到不止一个匹配结果，而由于网络前缀越长，其地址块就越小，路由就越具体，因此，应该从匹配结果中选择具有最长网络前缀的路由 【超网构造】超网构造，又称路由聚合，是将网络前缀相同的连续的 IP 地址，组成一个 CIDR 地址块，从而使得一个 CIDR 地址块可以表示很多地址 超网构造可以使路由表中的一个项目表示为很多个原来的分类 IP 地址的路由，有利于减少路由选择信息的交换，从而提高网络性能 如下图所示，若不使用超网构造的方法，R1 的路由表中将需要有到网络 $1$ 和网络 $2$ 的路由表项 但可以发现，两个网络的前 $16$ 位都是相同的，第 $17$ 位分别是 $0$、$1$，且从 R1 到网络 1 和网络 2 的路由的下一跳皆 R2 因此，可以采用超网构造的方法，将网络 1 和网络 2 构成一个更大的地址块 206.1.0.0/16，到网络 1 和网络 2 的路由，聚合层一条到 206.1.0.0/16 的路由","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"IPv4 地址与子网划分","slug":"computer-networks/31.IPv4地址与子网划分","date":"2019-10-15T07:01:00.000Z","updated":"2021-08-23T12:50:06.955Z","comments":true,"path":"notes/computer-networks/45e27fbe.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/45e27fbe.html","excerpt":"【概述】连接在 Internet 中的每一台主机或路由器，都会被分配一个 $32bit$ 的全球唯一标识符，即 IPv4 地址，常被称为 IP 地址 IP 地址的发展阶段经历分类 IP、子网划分、无分类编址三个阶段","text":"【概述】连接在 Internet 中的每一台主机或路由器，都会被分配一个 $32bit$ 的全球唯一标识符，即 IPv4 地址，常被称为 IP 地址 IP 地址的发展阶段经历分类 IP、子网划分、无分类编址三个阶段 本文主要介绍子网划分 【子网划分】概述对于分类 IP 来说，其是由网络号与主机号构成的两级 IP，则导致 IP 地址空间的利用率有时会很低，同时给每一个物理网络分配一个网络号会导致路由表太大使得网络性能变差 因此，在分类 IP 的基础上又增加了一个子网号字段，使两级 IP 变为三级 IP，这种做法被称为子网划分，目前已成为正式标准协议 基本思想划分子网被规定为一个单位内部网络的过程，单位对外仍表现为没有划分子网的网络 其基本思想是从原有的分类 IP 的主机号 Host Id 中借用若干位比特，来作为子网号 SubNet Id，因此，三级 IP 地址结构如下 IP ::=\\{,,\\}具体来说，凡是从其他网络发送给本单位某个主机的 IP 数据报，仍是根据 IP 数据报的目的网络号，先找到连接在本单位网络上的路由器，然后该路由器在收到 IP 数据报后，再按目的网络号与子网号找到目的网络，最后根据主机号将 IP 数据报直接交付给目的主机 特殊用途 IP由于子网划分是在分类 IP 的基础上进行的改进，因此其在分类 IP 中的特殊用途 IP 的基础上也进行具体规定 具体来说，在对分类 IP 地址进行子网划分时，子网号 SubNet Id 不能全 $0$ 或全 $1$ 同时，子网中的主机号全 $0$ 的地址被视为子网本身的网络地址，主机号全 $1$ 的地址被视为子网的广播地址 【子网掩码】概述由于划分子网只是将 IP 地址的主机号这部分进行再划分，没有改变分类 IP 地址中原来的网络号，因此，对一个 IP 数据报来说，无法判断源主机或目的主机所连接的网络是否进行了子网划分 为告诉主机或路由器对一个 A、B、C 类网络进行了子网划分，引入了子网掩码（Subnet Mask）的概念，其用来表达对原 IP 地址中对主机号的借位 并规定在以下三种情况使用子网掩码： 一个主机在设置 IP 地址信息时，必须设置子网掩码 同属一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码 路由器的路由表中，所包含的信息主要内容有：目的网络地址、子网掩码、下一跳地址 格式子网掩码，是一个与 IP 地址等长的 $32bit$ 的二进制字符串，其由一串连续的 $1$ 和跟随的连续的 $0$ 构成，其中，$1$ 对应于 IP 地址中的网络号与子网号，$0$ 对应与 IP 地址中的主机号 这样一来，计算机或路由器仅需将 IP 地址与其对应的子网掩码，进行逐位与运算，即可得到相应子网的网络地址 举例来说，假设某主机的 IP 地址是 136.34.5.56，子网掩码为 255.255.255.0 在将其分别转换为二进制后，再进行逐位与运算，即可得到该主机所在子网的网络号为：136.34.5.0 默认子网掩码Internet 标准规定，所有的网络都必须使用子网掩码，如果一个网络没有进行划分子网，那么将采用默认子网掩码 A、B、C 类地址的默认子网掩码分别如下： A 类：255.0.0.0 B 类：255.255.0.0 C 类：255.255.255.0 分组转发算法在 IPv4 地址与分类 IP 中，介绍了采用分类 IP 时，路由器执行分组转发算法的算法流程，那么，当使用子网掩码后，路由器的分组转发算法如下： 1）从 IP 数据报的首部提取目的主机的 IP 地址 D 2）对路由器直接相连的网络逐个检查，用各网络的子网掩码与 D 逐位相与，若结果与相应的网络地址匹配，若匹配，则为直接交付，否则，为间接交付，执行步骤 3） 3）若当前路由器的路由表中，含有目的地址为 D 的特定主机路由，则将 IP 数据报传送给路由表中指明的下一跳路由器，否则，执行步骤 4） 4）对路由表中的每一行（目的网络地址、子网掩码、下一跳地址）中的子网掩码与 D 进行逐位相与，若结果与该行的目的网络地址匹配，则将 IP 数据报传送给该行指明的下一跳路由器，否则，执行步骤 5） 5）若当前路由器的路由表中，含有一个默认路由，则将 IP 数据报传送给路由表中所指明的默认路由器，否则，执行步骤 6） 6）报告转发分组出错","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"IPv4 地址与分类 IP","slug":"computer-networks/30.IPv4地址与分类IP","date":"2019-10-15T05:21:00.000Z","updated":"2021-08-23T12:48:54.882Z","comments":true,"path":"notes/computer-networks/4fadfae.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/4fadfae.html","excerpt":"【概述】连接在 Internet 中的每一台主机或路由器，都会被分配一个 $32bit$ 的全球唯一标识符，即 IPv4 地址，常被称为 IP 地址 IP 地址的发展阶段经历分类 IP、子网划分、无分类编址三个阶段","text":"【概述】连接在 Internet 中的每一台主机或路由器，都会被分配一个 $32bit$ 的全球唯一标识符，即 IPv4 地址，常被称为 IP 地址 IP 地址的发展阶段经历分类 IP、子网划分、无分类编址三个阶段 本文主要介绍分类 IP 【分类 IP 的构成】传统的 IP 地址是分类的地址，被分为 A、B、C、D、E 五大类，但无论是哪种 IP 地址，都由网络号、主机号两部分组成，即： IP\\: Address::=\\{,\\}其中，网络号 Network Id，用于标识主机或路由器所连接到的网络，一个网络号在整个 Internet 范围内是唯一的；主机号 Host Id ，用于标识该主机或路由器，一个主机号在它前面的网络号所指明的网络范围内必须是唯一的 【五类 IP 地址】五类 IP 地址结构下图说明了五类 IP 地址的结构 可以看出，对于常用的 A、B、C 类网络，有： A 类：网络号 $8bit$，用点分十进制表示时，范围从 0 到 127 B 类：网络号 $16bit$，用点分十进制表示时，范围从 128.0 到 191.255 C 类：网络号 $24bit$，用点分十进制表示时，范围从 192.0.0 到 223.255.255 特殊用途 IP 地址在各类 IP 地址中，有一些 IP 地址表示特殊用途，不能用作主机 IP 地址 网络号 主机号 作为源地址 作为目的地址 用途 全 $0$ 全 $0$ 可以 不可以 本网范围内表示当前主机，路由表中表示默认路由 全 $0$ 特定值 可以 不可以 本网范围内表示特定值表示的主机 全 $1$ 全 $1$ 不可以 可以 受限广播地址，常表示本网广播地址 特定值 全 $0$ 不可以 不可以 网络地址，表示当前网络 特定值 全 $1$ 不可以 可以 直接广播地址，对特定网络内所有主机进行广播 $127$ 非全 $0$、全 $1$ 可以 可以 环回地址，用于本地环回测试 使用范围对于 A、B、C 类地址来说，在排除掉特殊用途的 IP 地址后，各类别 IP 地址的使用范围如下表 类别 最大可用网络数 第一个可用的网络号 最后一个可用的网络号 每个网络中最大的主机数 A $2^7-2$ 1​ 126​ $2^{24}-2$ B $2^{14}-1$ 128.1 191.255 $2^{16}-2$ C $2^21-1$ 192.0.1​ 233.255.255​ $2^{8}-2$ 其中，对于最大可用网络数来说，有： A 类：减去的 $2$ 分别为代表本网络的全 $0$、代表环回地址的全 $1$ B 类：减去的 $1$ 为不可指派的 128.0 C 类：减去的 $1$ 为不可指派的 192.0.0 【网络地址转换 NAT】概述网络地址转换（Network Address Translation，NAT），是指通过专用网络地址转换为公用网络地址，从而对外隐藏内部管理的 IP 地址 NAT 使得整个专用网只需要一个 IP 地址即可与 Internet 连通，大大减少了 IP 地址的消耗，同时，隐藏了内部网络结构，降低了内部网络受攻击的风险 私有地址为了网络安全，分类 IP 划出了部分 IP 地址作为私有 IP 地址，这些私有 IP 仅用于局域网 LAN 中，不用于广域网 WAN 连接，同时，允许这些私有 IP 可被 LAN 重复使用 因此，私有 IP 不能直接用于 Internet，必须通过网关利用 NAT 将私有 IP 转换成 Internet 中合法的全球 IP 后才可使用，从而解决了 IP 地址不足的问题 私有 IP 的网段如下表所示 类别 网段个数 范围 A $1$ 个 A 类网段 10 10.0.0.0 到 10.255.255.255 B $16$ 个 B 类网段 16 到 31 172.16.0.0 到 172.31.255.255 C $256$ 个 C 类网段 0 到 255 192.168.0.0 到 192.168.255.255 NAT 路由与 NAT 转换表使用 NAT 时，需要在专用网连接到因特网的路由器上安装 NAT 软件，该路由被称为 NAT 路由器，其至少有一个有效的外部全球 IP 地址 当使用本地地址的主机与外界通信时，NAT 路由器将使用 NAT 软件中的 NAT 转换表将本地地址转换为全球地址，或将全球地址转换为本地址，从而进行专用网与外部网络通信 NAT 转换表中存放着 {本地 IP:端口} 到 {全球 IP:端口} 的映射，通过这样的映射方式，即可令多个私有 IP 映射到同一个全球 IP 上 一个典型的 NAT 转换表如下图所示 需要说明的是，普通路由器在转发 IP 数据报时，不改变数据报的源 IP 地址与目的 IP 地址，而 NAT 路由器在转发 IP 数据报时，会转换数据报的源 IP 地址与目的 IP 地址 同时，普通路由器仅工作在网络层，NAT 路由器的 NAT 转发表由于涉及到端口，因此需要查看和转换传输层的端口号 【分组转发算法】对于网络层来说，当采用分类 IP 时，路由器执行分组转发算法的算法流程如下： 1）从 IP 数据报的首部提取目的主机的 IP 地址 D，并从 D 中得出目的网络地址 N 2）若网络 N 与当前路由直接相连，则将 IP 数据报直接交付给目的主机 D，此时，被称为路由器的直接交付，否则，被称为路由器的间接交付，执行步骤 3） 3）若当前路由器的路由表中，含有目的地址为 D 的特定主机路由（对特定的目的主机指明一个特定的路由，通常为了控制或测试网络），则将 IP 数据报传送给路由表中指明的下一跳路由器，否则，执行步骤 4） 4）若当前路由器的路由表中，含有到达网络 N 的路由，则将 IP 数据报传送给路由表指明的下一跳路由器，否则，执行步骤 5） 5）若当前路由器的路由表中，含有一个默认路由，则将 IP 数据报传送给路由表中所指明的默认路由器，否则，执行步骤 6） 6）报告转发分组出错","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"IPv4 数据报","slug":"computer-networks/29.IPv4数据报","date":"2019-10-15T03:54:00.000Z","updated":"2021-08-23T12:49:01.860Z","comments":true,"path":"notes/computer-networks/cb1e3d37.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/cb1e3d37.html","excerpt":"【概述】IPv4 协议，是现在普遍使用的 IP 协议，其版本号为 $4$，常简称为 IP 协议 该协议定义数据传送的基本单元及其确切的数据格式，同时定义了一套指明分组如何处理、错误如何控制、非可靠传输、分组路由选择的规则","text":"【概述】IPv4 协议，是现在普遍使用的 IP 协议，其版本号为 $4$，常简称为 IP 协议 该协议定义数据传送的基本单元及其确切的数据格式，同时定义了一套指明分组如何处理、错误如何控制、非可靠传输、分组路由选择的规则 IP 协议的数据传送基本单元被称为 IPv4 数据报，也常被称为 IP 分组、IP 数据报 【IP 数据报格式】一个 IP 数据报由首部、数据两部分构成，其中，首部分为所有 IP 数据报必须具有的长度为 $20B$ 的固定部分，以及用来提供错误检测、安全机制等功能的长度可变的可变部分 如上图所示，其指明了一个 IP 数据报的具体字段，各字段的含义说明如下： 1.版本 IP 协议的版本，对于 IPv4 数据报来说，其版本号为 $4$ 2.首部长度 该字段长度为 $4bit$，用来表示 IP 数据报首部的长度，单位是 $32bit=4B$，故该字段的最大值，即首部最大长度为： (2^4-1)*4B=60B由于 IP 数据报的首部部分的固定部分长度为 $20B$，因此，该字段的最小值为 $5$ 进一步可知，可变部分的长度最大为 $40B$ 目前最常用的首部长度是 $20B$，也就是说不占用任何可选部分 3.区分服务 又被称为服务类型，指示期望获得哪种类型的服务（例如某些 IP 数据报需要进行优先转发） 目前 IPv4 一般不使用该字段 4.总长度 该字段长度为 $16bit$，用来表示 IP 数据报的总长度，单位是 $B$，故该字段的最大值，即 IP 分组最大长度为： (2^{16}-1)*1B=65535B由于以太网帧的最大传送单元 MTU 为 $1500B$，因此，当一个 IP 数据报封装成帧时，若 IP 数据报的总长度大于 MTU，则需要进行分片处理，以防止超过链路层的 MTU 值 5.标识 该字段长度为 $16bit$，是一个循环计数器，网络中每产生一个数据报就加 $1$ 其作用是用来标识分片处理后的 IP 数据报是否为同一数据报 具体来说，当 IP 数据报的总长度大于链路层 MTU 时，需要进行分片处理，同时，对于分片后的每个 IP 数据报，都将会赋予分片前的标识号，这样当 IP 数据报到达目的地址后，根据每个 IP 数据报的标识字段进行重装，标识字段相同的 IP 数据报说明在分片前属于同一 IP 数据报 6.标志 该字段长度为 $3bit$，用于表示分片情况 该字段的中间位用来表示当前数据报能否进行分片，被称为 DF 标志位，即 Don’t Frame DF=1：不允许分片 DF=0：可以分片 最低位用来表示当前数据报后是否还有分片的数据报，被称为 MF 标志位，即 More Frame MF=1：当前数据报后还有分片 MF=0：当前数据报位最后一个分片 需要说明的是，仅当 DF=0 时，MF 标志位才有意义，当 DF=1 时，MF 标志位无意义 7.片偏移 该字段长度为 $13bit$，其指出了较长的分组在分片后，某片在原分组的相对位置 该字段以 $64bit=8B$ 作为偏移单位，即除去最后一个分片外，每个分片的长度一定是 $8B$ 的整数倍 8.生存时间 生存时间（Time To Live，TTL），该字段长度为 $8bit$，用来表示当前数据报在网络中可以通过的路由器数量的最大值 路由器在转发分组前，会将 TTL 先减 $1$，再进行传输，若 TTL 被减为 $0$，则该分组会直接丢弃 TTL 标识了数据报在网络中的寿命，以确保数据报不会在网络中无限制传输 9.协议 该字段占 $8bit$，用于标识当前数据报携带的数据是何种协议，即数据报的数据部分应该交付给哪种传输层协议 例如：值为 $6$ 标识 TCP 协议，值为 $17$ 表示 UDP 协议 10.首部检验和 该字段占 $16bit$，用于 IP 数据报的首部校验 需要注意是，IP 数据报每经过一个路由就需要重新校验一次 11.源地址 该字段占 $32Bit=4B$，用于标识发送方的 IP 地址 12.目的地址 该字段占 $32Bit=4B$，用于标识接收方的 IP 地址 13.可选字段 该字段可占 $0-40B$，是 IPv4 中的一些可选功能，包括排错、测量、安全控制等措施 14.填充 在使用可选字段后，首部长度可能不足以满足 $4B$ 的整数倍，因此可利用该字段进行填充，以保证首部长度为 $4B$ 的整数倍 【IP 数据报分片】MTU 与分片处理一个数据链路层的数据报可承载的最大数据量被称为最大传送单元 MTU 由于 IP 数据报被封装在链路层数据报中，因此链路层数据报严格地限制着 IP 数据报的长度 同时，在 IP 数据报从源端到目的端的路径上的各段链路可能使用不同的链路层协议，这也就导致着不同的链路上有着不同的 MTU，例如以太网的 MTU 为 $1500B$，广域网的 MTU 一般不超过 $576B$ 因此，在传输过程中，若 IP 数据报的总长度大于链路的 MTU 时，就需要进行分片处理，即将 IP 数据报中的数据进行分割，分装到若干较小的 IP 数据报中，这些若干较小的 IP 数据报，每个被称为片 分片实例每当源主机创建一个新的 IP 数据报，都会为该数据报的标识字段赋予一个新的标识号，具体规则是在原来的标识号上加 $1$ 当一个路由器需要对一个数据报分片时，形成的每片都具有原始数据报的标识号 这样当目的主机收到数据报后，可以通过检查数据报的标识号来确定哪些数据报属于同一个原始数据报 同时，还使用标志字段来说明是否存在分片，利用片偏移来确定片放在原始 IP 数据报的哪个位置 举例来说，现在存在一个首部长 $20B$，数据长 $3980B$，总长 $4000B$ 的 IP 数据报到达一个路由器，该数据报的标识号为 $777$，其要转发到一条 MTU 为 $1500B$ 的链路上 这意味着原始数据报中 $3980B$ 的数据部分需要进行分片处理，总共被分为 $3$ 个片，那么分成的 $3$ 片如下图所示 可以看出，由于片偏移的单位是 $8B$，因此除最后一个片外，其他所有片中的有效数据均为 $8B$ 的倍数","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"网络层功能","slug":"computer-networks/28.网络层功能","date":"2019-10-11T14:13:00.000Z","updated":"2021-08-29T13:44:54.093Z","comments":true,"path":"notes/computer-networks/a2f8fc30.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/a2f8fc30.html","excerpt":"【概述】网络层，是在数据链路层所提供的服务基础上向传输层提供服务，负责将各种计算机网络相互联接起来，以构成更大的网络系统 其主要具有异构网络互联、路由选择与分组转发、拥塞控制等功能","text":"【概述】网络层，是在数据链路层所提供的服务基础上向传输层提供服务，负责将各种计算机网络相互联接起来，以构成更大的网络系统 其主要具有异构网络互联、路由选择与分组转发、拥塞控制等功能 【异构网络互联】中继设备与异构网络互联网络的互联，是指将两个以上的异构网络通过一定的方法，用一种或多种通信设备相互连接起来，以构成更大的网络系统 其中，用于连接的通信设备被称为中间设备，又被称为中继系统，根据中继系统所在层次，有以下四种： 物理层中继系统：中继器、集线器 链路层中继系统：网桥、交换机 网络层中继系统：路由器 网络层以上中继系统：网关 所谓异构网络，是指在物理层、链路层定义的传输介质、编码方式、链路控制协议等不同的网络，故而在使用物理层、链路层的中继系统时，仅仅是将一个网络扩大了，从网络层的角度来看，其仍然是一个网络 因此，狭义上的网络互联其实是利用路由器进行的网络互联与路由选择 TCP/IP 体系在网络层采用标准化的协议来进行网络互联，但互联的网络是异构的 IP 网络如下图所示，多个计算机网络通过路由器进行互联，由于参与互联的网络都使用同样的网际协议 IP，因此可以将互联后的计算机网络看作一个虚拟互联网络 虚拟互联网络，其实就是逻辑互联网络，也被称为 IP 网络，也就是说互联起来的各种物理网络的异构性是客观存在的，但在网络层使用 IP 协议可以使得这些性能各异的网络在网络层上看起来像是一个统一的网络 IP 网络最大的好处是，网络上的主机进行通信时，就好像在一个网络上通信一样，其屏蔽了互联的具体的网络异构细节 【路由选择与分组转发】基本概念在网络互联时，网络层的中继系统是路由器，其主要完成两个功能： 路由选择：确定数据分组传送的路径，可根据特定的路由选择协议来构造路由表，同时定期与相邻路由交换路由信息来更新、维护路由表 分组转发：在数据分组到达某结点时采取的动作，即处理通过路由器的数据量，完成转发表查询、队列管理、任务调度等功能 具体来说，路由选择是按照复杂的分布式算法，根据相邻路由器得到整个网络的拓扑变化情况，根据路由表来动态地改变所选择的路由；分组转发是路由器根据转发表，将用户的 IP 数据报从合适的端口转发出去 其中，路由表是根据路由选择算法得出的，需要对网络拓扑变化的计算最优化；转发表是从路由表上得出的，需要使得查找过程最优化 但在讨论路由选择的原理时，通常不去区分两者的区别，而是笼统的使用路由表这一名词 路由算法与路由选择协议路由器转发分组是通过路由表转发的，而路由表是通过各类算法得到的，根据能否随网络通信量或拓扑自适应进行调整，路由算法可分为静态路由算法、动态路由算法两类 静态路由算法，又称非自适应路由算法，是指由网络管理员手工配置路由信息，一旦当网络拓扑结构或链路状态发生变化，网络管理员需要手工去修改路由表中相关的静态路由信息，适用于小型网络 动态路由算法，又称自适应路由算法，是指路由表上的路由表项通过相互连接的路由器不断交换信息，然后通过一定算法优化出来的，常见的动态路由算法分为距离向量路由算法、链路状态路由算法两类 当网络规模扩大时，路由器的路由表成比例增大，不仅消耗大量的路由器缓冲区，还耗费大量的 CPU 时间进行扫描，为此路由选择按照层次方式进行，此时网络被划分为一个个的自治系统 根据在自治系统内部还是外部进行路由选择，路由选择协议可分为以下两类： 内部网关协议：RIP 协议、OSPF 协议等 外部网关协议：BGP 协议等 分组转发 分组转发，是通过硬件从路由器上的路由表生成转发表，在分组到达时根据转发表将分组进行转发 【拥塞控制】拥塞状态在通信子网中，由于出现过量分组而引起导致网络性能下降的现象被称为拥塞 如图所示，假设当分组进入路由器的速率为 $r_{in}$，当速率接近 $R$ 时，由于路由器端口的缓冲区是有限的，这导致大量分组被丢弃，整个网络的吞吐量骤减，源结点与目的结点间的平均时延近乎无穷大 而判断网络是否出现拥塞状态的方法是观察网络吞吐量与网络负载的关系，一旦网络中出现网络负载增加吞吐量反而降低的情况，即可认定出现拥塞，根据拥塞的轻重，可分为以下三类情况： 轻度拥塞：随网络负载的增加，网络吞吐量明显小于正常吞吐量 拥塞状态：随网络负载的增加，网络吞吐量急剧下降 死锁状态：随网络负载的增加，网络吞吐量下降到 $0$ 拥塞控制为避免拥塞状态的出现，要采用能防止拥塞的一系列方法对子网进行拥塞控制，主要解决的问题是如何获取网络中发生拥塞的信息，然后利用这些信息进行控制，从而避免由于拥塞出现带来的分组丢失与严重拥塞导致的网络死锁情况 拥塞控制是确保通信子网能够承载其所达到的流量，是一个全局性的过程，单一的增加资源无法解决拥塞，其涉及到网络中的各方面，包括主机、路由器、路由器内部转发处理过程等 拥塞控制的方法有以下两种： 开环控制：静态预防，设计网络时预先考虑好拥塞情况，一旦系统运行，将无法修改 闭环控制：动态预防，采用网络系统进行实时监控，一旦发生拥塞立即调整系统运行","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"数据链路层设备","slug":"computer-networks/27.数据链路层设备","date":"2019-10-11T09:08:00.000Z","updated":"2021-08-23T12:49:18.272Z","comments":true,"path":"notes/computer-networks/18c4cb61.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/18c4cb61.html","excerpt":"【网桥】基本原理网桥，处理的数据对象是帧，工作在数据链路层的 MAC 子层，可以将以太网各网段隔离开以形成不同的碰撞域，同时，各网段的相对独立，一个网段的故障不会影响到另一网段的运行","text":"【网桥】基本原理网桥，处理的数据对象是帧，工作在数据链路层的 MAC 子层，可以将以太网各网段隔离开以形成不同的碰撞域，同时，各网段的相对独立，一个网段的故障不会影响到另一网段的运行 当两个或多个以太网通过网桥连接后，就可以成为一个覆盖范围更大的以太网，原来的每个以太网就被称为一个网段 此外，使用网桥连接的以太网的吞吐量为每一个网段吞吐量的和，如下图所示，假设每一个网段的吞吐量都为 $10Mb/s$，那么整个网络的吞吐量为 $30Mb/s$ 当网络 $A$ 和网络 $B$ 通过网桥连接后，当网络 $A$ 中的某主机向网络 $B$ 中的某主机发送数据帧时，网桥会接收到网络 $A$ 发来的数据帧，并检查数据帧中的目的地址，若目的地址是网络 $B$ 中的地址，则会转发给网络 $B$；若是网络 $A$ 中的地址，则会直接丢弃，因此源站与目的站属于一个碰撞域，目的站可以直接接收这个帧不需要借助网桥转发 特点网桥具有以下特点： 通过网桥，使得每个网段可进行通信，整体来说，过滤了通信量，增大网络吞吐量 扩大了物理范围，扩展了以太网 单个碰撞域内出现故障不会影响其他碰撞域，可靠性提高 可互联不同物理层、不同 MAC 子层、不同速率的以太网 类型网桥具有路由选择的功能，当接收到帧后，要决定路径以将帧传送到相应的目的局域网站点，根据路径选择算法的不同，可分为选择非最佳路由的透明网桥、选择最近路由的源路由网桥 透明网桥透明网桥以混杂模式工作，其会接收与其连接的 LAN 传送的每一帧，之后，到达帧的路由选择过程取决于该帧的源 LAN 与目的 LAN： 源 LAN 与目的 LAN 相同：丢弃该帧 源 LAN 与目的 LAN 不同：转发该帧 目的 LAN 未知：扩散该帧 具体来说，当网桥刚连接到以太网时，转发表是空的，网桥根据自学习算法来处理收到的帧，该算法基本思想如下：网桥每收到一帧时，就会在转发表中记录该帧的源地址与进入网桥的端口号；在转发帧时，根据收到帧的目的地址进行转发，此时，会将转发表中的地址作为目的地址，进入网桥的端口号当作转发端口 此外，为了避免转发的帧在网络中不断地循环转发，透明网桥采用生成树算法，以确保每个源到每个目的地只有唯一的路径，该算法使得整个扩展局域网在逻辑上形成树形结构，保证逻辑上没有环路，但一般不是最佳路由 源路由网桥在源路由网桥中，路由选择由发送数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行转发与接收 为寻找最佳路由，源站在发送帧前会先以广播方式向目的站发送一个发现帧，在转发过程中，途中的每个网桥都会转发该帧，最终该发现帧可能会从多个途径到达目的站 在目的站每收到一个发现帧后，就会发送一个应答帧，每个应答帧会沿着原路径返回，途径的网桥会将自己的标志记录记录在应答帧中 在源站收到所有的应答帧后，会选择一个最佳路由（发送帧往返时间最短的路由），封装成路由信息，之后，凡是从该源站向该目的站发送的帧，都会在首部附加一个路由信息 但随着网络中网桥数量的增加，源站发送的发现帧会指数式增长，可能会造成严重的网络拥塞 此外，发现帧可帮助源站来确定整个网络的可通过帧的最大长度 【交换机】基本原理网桥，主要限制是在任一时刻只能执行一个帧的转发操作，在有大量帧要转发时，这无疑增大了排队时延，为此，有了局域网交换机 局域网交换机，又称以太网交换机，其本质上就是一个多端口的网桥，能够将网络分割为各小的冲突域，为每个工作站提供更高的带宽 此外，利用交换机还能实现虚拟局域网（Virtual LAN，VLAN），不仅能够隔绝冲突域，还能隔绝广播域 交换机的基本原理是：检测从以太端口发来的数据帧的源地址和目的地址，然后在系统内部的动态查找表进行比较，若数据帧的 MAC 地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口 特点以太网交换机具备以下特点： 每个端口连接的设备独占带宽（集线器是平均分配） 类似透明网桥，属于即插即用设备，内部帧的转发表通过自学习算法自动构建 每个端口都直接与单个主机相连，且一般工作在全双工方式（普通网桥端口连接到以太网的一个网段） 每个端口连接的主机可认为是一个独立的冲突域、 交换模式以太网交换机具备两种数据交换模式： 直通式：只检查 MAC 帧的目的地址，检查完后立即转发，速度快，但智能性、安全性低，且不支持不同速率的端口转换 存储转发式：将收到的 MAC 帧存于高速缓存中，之后进行检验，确认无误后通过查找表根据相应端口转发，若帧有错则直接丢弃，可靠性高。能支持不同速度端口间的转换，但延迟大","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"HDLC 协议","slug":"computer-networks/26.HDLC协议","date":"2019-10-08T07:09:00.000Z","updated":"2021-08-23T12:49:25.366Z","comments":true,"path":"notes/computer-networks/dc8a24f2.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/dc8a24f2.html","excerpt":"【概述】高级数据链路控制协议（High-level Data Link Control，HDLC）与 PPP 一样，是广域网的数据链路层的链路控制协议，直接应用在两个直接连接的结点的链路上，是面向比特的链路协议 HDLC 中，结点被称为站，根据功能不同，站被分为三类：","text":"【概述】高级数据链路控制协议（High-level Data Link Control，HDLC）与 PPP 一样，是广域网的数据链路层的链路控制协议，直接应用在两个直接连接的结点的链路上，是面向比特的链路协议 HDLC 中，结点被称为站，根据功能不同，站被分为三类： 主站：负责控制链路操作，发出的帧被称为命令帧 从站：受控于主站，按主站的命令进行操作，发出的帧被称为响应帧 复合站：既具有主站的功能又具有从站的功能，可发出命令帧，也可发出响应帧 由此，HDLC 适用于链路的两种基本配置： 非平衡配置：由一个主站控制整个链路工作 平衡配置：链路两端的站均为复合站，每个复合站可平等发起数据传输，不需要得到对方复合站的允许 【数据传输方式】当主站向从站传输数据时，根据从站响应传输的方式，可分为以下三类： 正常响应方式：非平衡配置下的操作方式，从站只有在收到主站许可后，才可进行响应 异步响应方式：非平衡配置下的操作方式，从站在没有接到主站的允许下，就可进行响应 异步平衡方式：平衡配置下的操作方式，每一个复合站都可以进行对另一端站点的数据传输 【HDLC 帧】HDLC 是面向比特的，其格式如下图所示 HDLC 采用比特填充法进行首尾定界，其首部的第一个标志字段 $F$ 为帧起始标志，固定为 0111 1110，尾部的最后一个标志字段 $F$ 为帧终止标志，同样固定为 0111 1110 首部的第二个字段 $A$ 为地址字段，在使用非平衡方式传输时，为从站地址；在使用平衡方式传输时，为应答站地址 首部的第三个字段为控制字段，根据该字段的第 $1$、$2$ 位的取值，将 HDLC 帧划分为三类： 信息帧 I：第 $1$ 位为 0，用于传输数据，或使用捎带技术对数据进行确认 监督帧 S：第 $1$、$2$ 位为 10，用于流量控制与差错控制，执行对信息帧的确认 无编号帧 U：第 $1$、$2$ 位为 11，用于提供对链路的建立、拆除等控制 信息部分的长度是可变的，没有规定其最大长度，同时由于采取了零比特填充法，为了透明传输，当其中出现连续的 $5$ 个 1 时，再其后要填充一个 0 尾部的第一个字段为帧检验序列 FCS，即 CRC 中的冗余码，检验部分包括地址字段 A、控制字段 C、信息字段 可以发现，HDLC 帧与 PPP 帧十分相似，但两者具有以下不同： PPP 面向字节，HDLC 面向比特 PPP 帧比 HDLC 帧多一个协议字段，当该字段取值为 0x0021 时，表明信息字段为 IP 数据报 PPP 不使用序号与确认机制，只保证无差错接收，端到端的差错检测由高层负责，是不可靠传输；HDLC 的信息帧使用序号与确认机制，能提供可靠传输","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"PPP 协议","slug":"computer-networks/25.PPP协议","date":"2019-10-08T05:23:00.000Z","updated":"2021-08-23T12:48:04.758Z","comments":true,"path":"notes/computer-networks/ae89a3fd.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/ae89a3fd.html","excerpt":"【概述】点对点协议（Point-to-Point Protocol，PPP），是广域网的数据链路层的链路控制协议，直接应用在两个直接连接的结点的链路上，既能在异步线路上传输，也能在同步线路上使用，是面向字节的串行链路协议 早期数据报的传送是采用串行线路网际协议（Serial Line Internet Protocol，SLIP），但由于 SLIP 主要用来完成数据报的传送，没有寻址、数据校验功能，只能传送 IP 分组，因此若上层没有采用 IP 协议则无法传输数据","text":"【概述】点对点协议（Point-to-Point Protocol，PPP），是广域网的数据链路层的链路控制协议，直接应用在两个直接连接的结点的链路上，既能在异步线路上传输，也能在同步线路上使用，是面向字节的串行链路协议 早期数据报的传送是采用串行线路网际协议（Serial Line Internet Protocol，SLIP），但由于 SLIP 主要用来完成数据报的传送，没有寻址、数据校验功能，只能传送 IP 分组，因此若上层没有采用 IP 协议则无法传输数据 为改进 SLIP 的缺点，于是制定了点对点协议 PPP 提供差错检测，但只是使用硬件来进行 CRC 检验，没有序号与确认机制，因此只能保证无差错接收，是不可靠的传输协议 此外，PPP 只支持全双工链路，其两端可以运行不同的网络层协议，但仍然可使用同一个 PPP 进行通信 【组成】PPP 有三个组成部分： 链路控制协议 LCP：扩展链路控制协议，用于建立、配置、测试、管理数据链路 网络控制协议 NCP：PPP 允许同时采用多种网络层协议，每个不同的网络层协议用一个相应 NCP 来配置，为网络层协议建立和配置逻辑连接 将 IP 数据报封装到串行链路的方法：IP 数据报在 PPP 帧中为其信息部分，该部分长度受最大传送单元 MTU 限制 【PPP 帧】PPP 是面向字符的，因此所有的 PPP 帧的长度均是整数个字节，其格式如下图所示 默认情况下，PPP 帧采用字符填充法进行首尾定界，因此，其首部的第一个标志字段 $F$ 为帧起始标志，固定为 0x7E，尾部的最后一个标志字段 $F$ 为帧终止标志，同样固定为 0x7E 首部的第二个字段 $A$ 为地址字段，规定为 0xFF，第三个字段 $C$ 为控制字段，规定为 0x03，这两个字段的内容始终是固定不变的 首部的第四个字段为协议字段，占两个字节，用于说明信息段中运载的是何种类型的分组，以比特 0 开始的是 IP、IPX、AppleTalk 等网络层协议，以比特 1 开始的被用来协商其他协议，包括 LCP 以及每个所支持的网络层协议的一个不同的 NCP 信息部分的长度是可变的，其最大长度不超过 $1500B$，同时由于采取了字符填充法，为了透明传输，当其中出现 0x7E 时，再其前要填充控制转移字符 0x7D 尾部的第一个字段为帧检验序列 FCS，即 CRC 中的冗余码，检验部分包括地址字段 A、控制字段 C、协议字段、信息字段 需要说明的是，PPP 默认使用在异步线路上，此时采用字符填充法进行首尾定界；若 PPP 用在同步线路上，则采用零比特填充法进行首尾定界 【PPP 链路状态】当线路处于静止状态时，不存在物理层连接 当线路检测到有载波信号时，建立物理连接，线路变为建立状态，此时 LCP 开始选项商定，商定成功后就进入身份验证状态 在双方身份验证通过后，进入网络状态，此时，使用 NCP 配置网络层，在配置完成后，进入打开状态，即可进行数据传输 在数据传输完成后，线路转为终止状态，等到载波停止，则会回归到静止状态 下图给出了 PPP 链路建立、使用、撤销所经历的状态图","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"广域网","slug":"computer-networks/24.广域网","date":"2019-10-08T05:08:00.000Z","updated":"2021-08-23T12:48:00.292Z","comments":true,"path":"notes/computer-networks/31e5ccf.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/31e5ccf.html","excerpt":"【广域网】广域网通常是指覆盖范围远超一个城市的长距离网络，其是因特网的核心部分，主要任务是通过长距离链路来运送主机所发的数据 连接广域网各结点交换机的链路均是高数链路，可以是几千公里的光缆线路，也可以是几万公里的点对点卫星链路","text":"【广域网】广域网通常是指覆盖范围远超一个城市的长距离网络，其是因特网的核心部分，主要任务是通过长距离链路来运送主机所发的数据 连接广域网各结点交换机的链路均是高数链路，可以是几千公里的光缆线路，也可以是几万公里的点对点卫星链路 在广域网内部，常通过交换机来扩展网络范围；在广域网边界，通过路由器来连接局域网和广域网，以构成一个覆盖范围极广的互联网 广域网与局域网二者平等，均为互联网的重要组成部分，连接到广域网或局域网的主机在网内通信时，只使用 MAC 地址，两者的区别如下： 广域网 局域网 覆盖范围 极广，通常跨区域 较小，通常在一个区域内 连接方式 结点间点对点连接，一个结点交换机常与多个结点交换机连接 多点接入技术 OSI 层次 物理层、链路层、网络层 物理层、链路层 着重点 强调资源共享 强调数据传输 【广域网链路层协议】从层次上来说，广域网与局域网区别很大，局域网协议主要工作在链路层，广域网协议主要工作在网络层进行路由选择与分组转发，但在网络层完成路由选择与分组转发后，在广域网的链路层中，需要对两个结点间的链路进行控制，针对广域网的这种需求，有两种链路控制协议：PPP 协议、HDLC 协议 点对点协议（Point-to-Point Protocol，PPP），是使用串行线路通信的面向字节的协议，应用在直接连接两个结点的链路上，主要用来通过拨号建立点对点连接发送数据，其是各种主机、网桥、路由器间简单连接的共同解决方案，该协议简单、成本低，目前常被采用 高级数据链路控制协议（High-level Data Link Control，HDLC）是 ISO 指定的面向比特的协议，该协议不依赖于任何一种字符编码集，使用由硬件实现的零比特插入法进行透明传输，采用全双工通信方式，对所有帧进行 CRC 检验并编号，可靠性高，该协议稳定可靠但成本高，实现复杂，目前基本不采用","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"无线局域网与 IEEE 802.11","slug":"computer-networks/23.无线局域网与IEEE802.11","date":"2019-10-04T07:25:00.000Z","updated":"2021-08-23T12:48:11.607Z","comments":true,"path":"notes/computer-networks/1d10d5b6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/1d10d5b6.html","excerpt":"【概述】IEEE 802.11 标准，是无线局域网（Wireless Local Area Network，WLAN）的一系列标准协议，这些协议规定了 MAC 层的标准，并运行在多个物理层标准之上 这些标准除了定义了基本的协调访问功能外，还规定了克服通道固有的不可靠性的差错控制、站点的可携带处理、寻址和关联规程、站点的可扩展的通信范围等一系列功能","text":"【概述】IEEE 802.11 标准，是无线局域网（Wireless Local Area Network，WLAN）的一系列标准协议，这些协议规定了 MAC 层的标准，并运行在多个物理层标准之上 这些标准除了定义了基本的协调访问功能外，还规定了克服通道固有的不可靠性的差错控制、站点的可携带处理、寻址和关联规程、站点的可扩展的通信范围等一系列功能 【MAC 帧】IEEE 802.11 标准规定在 MAC 层上采用 CSMA/CA 协议进行介质访问控制，并重新定义了 MAC 帧头 其中，各字段含义如下： 帧控制：帧的类型 生存周期：帧的生存周期 地址 1：RA 接收端，实际发送地址所注册到的基站地址 地址 2：TA 发送端，时间接收地址所注册到的基站地址 地址 3：DA 目的地址，实际接收地址 序列控制：同步信息、差错控制信息等 地址 4：SA 源地址，实际发送地址 如上图，移动端 $A$ 通过接入点 $AP1$ 向接入点 $AP2$ 下的移动端 $B$ 发送信息 那么，当 $A$ 发送一个 MAC 帧时，地址 1 为 $AP1$ 的 MAC 地址，地址 2 为 $AP2$ 的 MAC 地址，地址 3 为 $B$ 的 MAC 地址，地址 4 为 $A$ 的 MAC 地址 【类型】无线局域网分类两类，一类是有固定基础设施的无线局域网，另一类是无固定基础设施的无线局域网 有固定基础设施无线局域网IEEE 802.11 标准规定了无线局域网最小构件为基本服务集（Basic Service Set，BSS） 一个 BSS 包含一个基站和若干移动站，所有的站在其所属的 BSS 内可直接通信，但在和本 BSS 之外的站点通信时，要通过本 BSS 的基站进行通信，因此，BSS 的基站也被称为接入点（Access Point，AP） 一个 BSS 可以是孤立的，也可以通过其 AP 连接到一个主干分配系统（Distribution System，DS），再接入到另一个 BSS，以构成扩展服务集（Extended Service Set，ESS） 对于 ESS 来说，其可以通过门桥（Portal）为无线用户提供非 IEEE 802.11 无线局域网的接入，同时，当一个用户从一个 BSS 移动到该 ESS 内的另一个 BSS 内，仍可保持通信，这被称为漫游 无固定基础设施无线局域网无固定基础设施无线局域网又称为移动自组织网络（Ad-Hoc Network） Ad-Hoc 网络是由处于平等状态的移动站间相互通信组成的临时网络，各结点间低位平等，中间结点均为转发结点，具有路由器功能 Ad-Hoc 网络的构成过程如下：一些可移动设备发现他们附近还有其他可移动设备，并要求和其他移动设备通信，可以发现，Ad-Hoc 网络是将移动性扩展到无线领域的自治系统，具有自己特定的路由选择协议，且不可以和因特网相连","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"以太网与 IEEE 802.3","slug":"computer-networks/22.以太网与IEEE802.3","date":"2019-10-04T05:23:00.000Z","updated":"2021-08-28T14:04:53.289Z","comments":true,"path":"notes/computer-networks/db305c8.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/db305c8.html","excerpt":"【概述】IEEE 802.3 标准是基带总线型局域网标准，其定义了物理层与数据链路层的 MAC 子层的实现方法 以太网在逻辑上采用总线型拓扑结构，在以太网上，信息以广播方式发送，使用 CSMA/CD 方式进行介质访问控制，此外，其采用无连接的工作方式，尽最大努力交付数据，提供的是不可靠服务，对差错的纠正由高层完成","text":"【概述】IEEE 802.3 标准是基带总线型局域网标准，其定义了物理层与数据链路层的 MAC 子层的实现方法 以太网在逻辑上采用总线型拓扑结构，在以太网上，信息以广播方式发送，使用 CSMA/CD 方式进行介质访问控制，此外，其采用无连接的工作方式，尽最大努力交付数据，提供的是不可靠服务，对差错的纠正由高层完成 严格来说，以太网是符合 DIX Ethernet V2 标准的局域网，但该标准与 IEEE 802.3 标准区别很小，因此常将 802.3 局域网称为以太网 【传输介质】常见以太网的各种传输介质适用情况如下表： 参数 10 BASE5 10 BASE2 10BASE-T 10BASE-FL 传输媒体 基带同轴电缆（粗缆） 基带同轴电缆（细缆） 非屏蔽双绞线 850 nm 光纤对 编码 曼彻斯特编码 曼彻斯特编码 曼彻斯特编码 曼彻斯特编码 拓扑结构 总线型 总线型 星形 点对点 最大段长 500 m 185 m 100 m 2000 m 最多结点数 100 30 2 2 虽然 10BASE-T 非屏蔽双绞线以太网的网络拓扑结构是以集线器为中心的星形网络，但由于以太网不隔离冲突域，因此其在逻辑上为总线型 同时，以上所有以太网的最小帧长为 $64B$，最小帧间隔为 $9.6\\mu s$ 【网卡与 MAC 帧】网卡计算机与外界局域网的连接是通过主机上的网络接口卡（Network Interface Card，NIC）进行的 网卡是局域网连接计算机与传输介质的接口，是工作在数据链路层的网络组件，其上装有处理器与存储器，不仅能实现局域网与传输介质间的物理连接和电信号匹配，还能完成帧的发送与接收、帧的组装与拆分、介质访问控制、数据编码解码、数据缓存等功能 全世界的每块网卡，在出厂时都有一个唯一的代码，被称为介质访问控制地址（MAC 地址），也被称为物理地址，其长度为 $6$ 个字节，由连字符或冒号分隔的 $6$ 个十六进制数表示，其中，高 $24$ 位为网卡厂商代码，低 $24$ 位为厂商自行分配的网卡序列号 由于以太网是广播通信方式，因此对于一个数据链路层设备来说，当该设备的网卡从网络上每收到一个帧，就会检查其中的 MAC 地址，若是发往本站的帧，则将帧收下，否则丢弃 此外，网卡控制着主机对截止的访问，因此网卡也工作在物理层，但其只关注比特的传输，不关注任何地址信息与高层协议 计算机通过网卡与局域网进行通信，IP 地址与硬件地址的映射关系如下图 MAC 帧 以太网的 MAC 帧格式有两种标准：DIX Ethernet V2 标准、IEEE 802.3 标准，DIX Ethernet V2 标准的 MAC 帧格式如下： 对于以太网 MAC 帧来说，各字段的含义如下： 目的地址、源地址：均为 $6 B$，是目的站与源站的 MAC 地址 类型：$2 B$，指出数据域中携带的数据应交由哪个协议处理 数据：$46 - 1500B$，包含高层的协议信息，此外，由于 CSMA/CD 的限制，以太网帧的长度必须满足最小帧长 $64B$，因此当帧过短时，需要在数据字段的尾部进行填充，填充字段长度为 $0-46B$ 校验码 FCS：$4B$，采用 $32$ 位 CRC 码进行校验，校验上述的 $4$ 个字段 可以发现，在实际发送时，还要在 MAC 帧前插入一个长度为 $8$ 字节的前导码，使发送端与接收端时钟同步，其分为两个部分： 前同步码：$7B$，用于迅速实现 MAC 帧的比特同步 帧开始定界符：$1B$，帧起始标准，表明后面的信息为 MAC 帧 可以发现，MAC 帧并不需要帧结束符，这是因为在以太网传输帧时，要求各帧间必须有一定的间隙，因此，接收端仅需要找到帧开始定界符，其后面连续到达的比特流均属于同一个 MAC 帧 【高速以太网】速率达到或超过 $100Mb/s$ 的以太网被称为高速以太网，常见的高速以太网有以下三种： 1.100BASE-T 以太网 100BASE-T 以太网是在双绞线上传送 $100Mb/s$ 基带信号的星形拓扑结构的以太网 其既支持全双工方式又支持半双工方式，在全双工方式下，可无冲突（不使用 CSMA/CD 协议）；在半双工方式下， 仍然使用 CSMA/CD 协议 MAC 帧格式仍有 IEEE 802.3 标准定义，同时保持最短帧长不变，仍为 $64B$，但将网段的最大电缆长度减小到 $100m$，帧最小间隔从 $9.6\\mu s$ 变为 $0.96\\mu s$ 2.吉比特以太网 吉比特以太网又称千兆以太网，其是传送 $1Gb/s$ 基带信号的以太网，同样使用 IEEE 802.3 标准定义的 MAC 帧格式，与 10BASE-T 和 100BASE-T 以太网向后兼容 与 100BASE-T 以太网相同，其既支持全双工方式又支持半双工方式，在全双工方式下，可无冲突（不使用 CSMA/CD 协议）；在半双工方式下， 仍然使用 CSMA/CD 协议 3.10 吉比特以太网 10 吉比特以太网使用光纤作为传输媒体，只工作在全双工方式上，不存在冲突问题 其同样使用 IEEE 802.3 标准规定的 MAC 帧格式，与 10BASE-T、100BASE-T、吉比特以太网向后兼容","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"局域网","slug":"computer-networks/21.局域网","date":"2019-10-04T03:07:00.000Z","updated":"2021-08-23T12:48:23.327Z","comments":true,"path":"notes/computer-networks/8ed092c1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/8ed092c1.html","excerpt":"【概述】数据链路层存在两种通信方式，一种是采用广播方式的局域网，另一种是采用点对点方式的广域网 对于采用广播方式的链路来说，所有主机共享通信介质，在早期的以太网、如今的无线局域网中，常采用该方式","text":"【概述】数据链路层存在两种通信方式，一种是采用广播方式的局域网，另一种是采用点对点方式的广域网 对于采用广播方式的链路来说，所有主机共享通信介质，在早期的以太网、如今的无线局域网中，常采用该方式 局域网（Local Area Network，LAN），是在一个较小的地理范围内将各计算机、外设、数据库系统等通过双绞线、同轴电缆等介质相互连接起来，组成资源、信息共享的计算机互联网络 其具备以下特点： 为一个单位拥有，地理范围小，站点数目有限 所有站共享较高的总带宽，数据传输率高 通信时延短，误码率低，可靠性高 各站关系平等，共享传输信道 分布式控制，广播式通信，可进行广播、组播 一个局域网具有三个特性：拓扑结构、传输介质、介质访问控制 其中，常见的局域网拓扑结构有星形结构、环形结构、总线形结构、星形与总线形复合结构；可使用的传输介质有双绞线、同轴电缆、光纤等；可使用的介质访问控制方法有 CSMA/CD、CSMA/CA 等 【IEEE 802 标准】IEEE 802 标准定义了局域网参考模型，其只对应于 OSI 参考模型的链路层与物理层，并将链路层拆分为两个子层： 逻辑链路控制层 LLC：存放与接入到介质无关的内容，向上层提供服务，包括无确认无连接、面向连接、带确认无连接、高速传送 介质访问控制层 MAC：存放与接入到介质有关的内容，向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能有帧的组装与拆卸、透明传输、差错控制等 目前来说，IEEE 802 委员会制定的 LLC 子层作用已经不大，因此现在许多网卡仅装有 MAC 协议而无 LLC 协议 由于以太网在局域网取得垄断地位，其成为了局域网的代名词，但除以太网外，还有其他类型的局域网： 以太网（Ethernet）：IEEE 802.3 标准定义，其物理拓扑是星形拓扑结构，逻辑拓扑为总线形结构，介质访问控制协议采取 CSMA/CD 令牌环网（Token-Ring 网）：IEEE 802.5 标准定义，其物理拓扑是星形拓扑结构，逻辑拓扑为环形结构，介质访问控制协议采取令牌传递协议 光纤分布式数据接口（FDDI 网）：IEEE 802.8 标准定义，其物理拓扑是双环拓扑结构，逻辑拓扑为环形结构，介质访问控制协议采取令牌传递协议 无线局域网（WLAN）：IEEE 802.11 标准定义，介质访问控制协议采取 CSMA/CA","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"轮询访问介质访问控制","slug":"computer-networks/20.轮询访问介质访问控制","date":"2019-10-01T15:05:00.000Z","updated":"2021-08-23T12:46:29.141Z","comments":true,"path":"notes/computer-networks/8b70a292.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/8b70a292.html","excerpt":"【概述】轮询访问介质访问控制常用于总线形拓扑结构或星形拓扑结构的局域网，其同样是以争用信道为核心思想的介质访问控制方式，其结合了随机访问介质访问控制独占信道的优点，也结合了信道划分介质访问控制避免冲突的优点 但与随机访问介质访问控制不同的是，其是一种不存在冲突开销的介质访问控制方式","text":"【概述】轮询访问介质访问控制常用于总线形拓扑结构或星形拓扑结构的局域网，其同样是以争用信道为核心思想的介质访问控制方式，其结合了随机访问介质访问控制独占信道的优点，也结合了信道划分介质访问控制避免冲突的优点 但与随机访问介质访问控制不同的是，其是一种不存在冲突开销的介质访问控制方式 常见的协议有：轮询协议、令牌传递协议 【轮询协议】轮询协议，应用于总线形拓扑结构的局域网中，存在一个集中控制所有结点的监控站 监控站通过循环的方式访问每个结点，以短数据帧的方式询问每个结点是否要发送数据，在某个结点确定要使用信道时，其他结点均不能使用信道 可以发现，对于轮询协议来说，其不产生冲突，且在发送数据时独占全部带宽，但每一次询问都会产生询问开销，同时，对于靠后的主机，会有等待延迟 此外，轮询协议还存在单点故障问题，即一旦监控站出现故障，将引起整个网络的瘫痪 【令牌传递协议】令牌传递协议，应用于星形拓扑结构的局域网中，但其在逻辑上表现为一个环状 令牌，是一种特殊的帧，仅有收到令牌的主机才能发送信息，当令牌应用于在逻辑上为环状的局域网上时，该局域网被称为令牌环网 令牌在网络中的各结点按固定次序传递，当某个结点收到令牌时，该站点被允许发送数据帧，其余站点此时只能进行转发该数据帧 数据帧会沿着网络上的不同结点进行传输，当目的主机收到后，目的主机会留存该数据帧副本，之后，数据帧将会继续在环上转发，直到回到发送站点，发送站点将会撤销该数据帧，并令令牌继续向下交换 令牌传递协议同样存在等待延迟、单点故障等问题，此外，还会产生令牌开销，其常用于负载较重、通信量较大的网络中","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"随机访问介质访问控制","slug":"computer-networks/19.随机访问介质访问控制","date":"2019-10-01T10:01:00.000Z","updated":"2021-08-23T12:46:35.702Z","comments":true,"path":"notes/computer-networks/2875e8bd.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/2875e8bd.html","excerpt":"【概述】在随机访问介质访问控制中，不采用集中控制方式解决发送信息的次序问题，所有问题都可以根据自己的意愿随机地发送信息，占用信道全部速率 在总线型局域网中，当有两个或更多用户同时发送信息时，就会产生帧的冲突，从而导致所有冲突用户均发送失败","text":"【概述】在随机访问介质访问控制中，不采用集中控制方式解决发送信息的次序问题，所有问题都可以根据自己的意愿随机地发送信息，占用信道全部速率 在总线型局域网中，当有两个或更多用户同时发送信息时，就会产生帧的冲突，从而导致所有冲突用户均发送失败 为解决随机接入产生的碰撞，每个用户按照一定规则反复重传它的帧，直到该帧无碰撞地通过，常见的协议有：ALOHA 协议、CSMA 协议、CSMA/CD 协议、CSMA/CA 协议 这些协议的核心思想都是争用信道，争用成功者获得信道的使用权，独享信道所有资源 由于争用过程中可能出现失败，会使得所有结点进行重发，这就会造成冲突开销，降低信道利用率 【ALOHA 协议】纯 ALOHA 协议纯 ALOHA 的基本思想是：当网络中的任何一个站点需要发送数据时，不进行任何检测就发送数据，如果一段时间内没有收到确认，发送的站点就认为传输过程中发生冲突，之后依照概率 $p$，等待一随机时间后再次发送，直到发送成功 此外，在接收方收到数据后，会进行检错，若发现数据帧有错，则不予确认 综上，纯 ALOHA 协议的特点可概括为：不监听信道，随机发送 时隙 ALOHA 协议采用纯 ALOHA 协议的网络的吞吐量很低，为克服这个缺点，在纯 ALOHA 协议的基础上有了时隙 ALOHA 协议 对于站点发送数据的随意性，时隙 ALOHA 协议将网络上各个站点的时间进行同步，将时间划分为一段段等长的时隙，规定只能在每个时隙开始时才可发送帧 可以发现时隙 ALOHA 协议避免了发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率 综上，时隙 ALOHA 协议的特点可概括为：不监听信道，按时隙发送 【CSMA 协议】概述时隙 ALOHA 协议虽然比纯 ALOHA 协议效率有了提高，但每个站点都是不监听信道就发送数据，因此出现碰撞的概率很大 载波侦听多路访问（Carrier Sense Multiple Access，CSMA）协议对上述情况作出了改进，设置了一个载波侦听装置，其在每个站点都在发送前侦听信道，若信道空闲则发送，若信道忙碌则等待，这大大减小了冲突的概率，提高了信道利用率 所谓载波侦听（Carrier Sense，CS），是指每个站发送数据前检测总线上是否有其他站在发送数据，在多个站发送数据时，总线信号电压会因信号叠加而增大，当某站检测到电压摆动值超过一定幅度后，就认为至少两个站在同时发送数据，产生了冲突 而多路访问（Multiple Access，MA），是指多个计算机以多点接入的方式连接在一根总线上 CSMA 协议有三种不同类型，其特点如下： 归结来说，CSMA 的特点可以概括为：先听再发，空闲就发，忙则等待 1-坚持 CSMA1-坚持 CSMA（1-persistent CSMA）的基本思想是：当一个结点要发送数据时，先侦听信道，若信道空闲，就立即发送数据；若信道忙，则等待，并继续侦听直到信道空闲，若发生冲突，则随机等待一段时间后，再重新开始侦听信道 1-坚持的含义是：当侦听到信道忙后，继续侦听信道，当侦听到信道空闲后，立即发送数据，即发送帧的概率为 $1$ 传播时延对 1-坚持 CSMA 影响很大，举例来说，在某结点 $A$ 开始发送数据时，结点 $B$ 也要发送数据，但由于传播时延的问题，结点 $A$ 发出的信号距离结点 $B$ 有一定距离，此时结点 $B$ 侦听到信道空闲，于是立即发送数据，这必然导致信道冲突 此外，若不考虑传播时延，1-坚持 CSMA 也有较大可能产生冲突，举例来说，结点 $A$ 正在发送数据，此时结点 $B$、$C$ 正准备发送数据，他们均侦听到信道忙，于是继续侦听，当结点 $A$ 一发送完毕，$B$、$C$ 立即发送，这同样导致了信道冲突 非坚持 CSMA非坚持 CSMA（Non-presistent CSMA）的基本思想是：当一个结点要发送数据时，先侦听信道，若信道空闲，就立即发送数据；若信道忙，就放弃侦听，等待一随机时间后再开始侦听 非坚持 CSMA 在侦听到信道忙后就放弃侦听，这减少了多个结点同时等待信道空闲后发送数据导致冲突的概率，但这却使得数据在网络中的平均时延增加了，即信道利用率的提高是以数据在网络中的时延为代价的 p-坚持 CSMAp-坚持 CSMA（p-persistent CSMA）用于时分信道，其基本思想是：当一个结点要发送数据时，先侦听信道，若当前时隙内信道空闲，便以 $p$ 的概率发送数据，以 $1-p$ 的概率推迟到下一时隙；若信道忙，则等待下一时隙再侦听；之后重复上述过程，直到数据发送成功或因其他结点发送数据而检测到信道忙为止，若是后者，则会等待一个随机时间后再重新开始侦听 p-坚持的含义是：在检测到信道空闲后，以概率 $p$ 发送数据，以概率 $1-p$ 推迟到下一时隙 可以发现，p-坚持 CSMA 是 1-坚持 CSMA 与 非坚持 CSMA 的折中方案，其降低了 1-坚持 CSMA 中多个结点检测到信道空闲后同时发送数据的冲突概率，还克服了 非坚持 CSMA 中由于随机等待造成延迟较长的缺点，但其在发生冲突后仍要坚持发完数据，这无疑造成了资源浪费 【CSMA/CD 协议】概述载波侦听多路访问/碰撞检测（Carrier Sense Multiple Access with Collision Detection，CSMA/CD）协议，是 CSMA 的改进方案，常用于总线型局域网 CSMA/CD 是在 CSMA 的基础上加了碰撞检测（Collision Detection，CD），是指边发送边侦听，即载波侦听装置边发送边检测信道上信号电压的变化情况，以便判断自己在发送数据时是否有其他站点也在发送数据 CSMA/CD 的基本思想是：当一个结点要发送数据时，先侦听信道，若信道空闲，则发送数据；若信道忙，则等待，直到信道空闲再重新发送 同时，在数据发送过程中，收发双方会一直侦听，若直到发送完毕没有侦听到其他信号，则该数据帧传输完毕；若发送过程中侦听到其他信号，则发生冲突，发送方会立即停止发送，并发送一个48 bit 的拥塞信号，之后，采用二进制指数退避算法，等待一段时间后继续开始侦听 归结来说，CSMA/CD 的特点可以概括为：先听再发，边听边发，冲突停发，随机再发 传播时延与争用期设单程端到端传播时延为 $\\tau$，在 $t=0$ 时站点 $A$ 发送数据，此时由于传播时延的存在，在 $t=\\tau-\\delta$ 时，站点 $B$ 检测到信道是空闲的，其发送数据 经过 $\\frac{\\delta}{2}$ 后，即在 $t=\\tau-\\frac{\\delta}{2}$ 时，站点 $A$ 与站点 $B$ 发送的数据发送碰撞，但此时 $A$ 与 $B$ 均不知道 在 $t=\\tau$ 时，$B$ 收到来自 $A$ 的数据，此时 $B$ 检测到碰撞，于是停发数据，之后发送一个 48 bit 的拥塞信号；在 $t=2\\tau-\\delta$ 时，$A$ 检测到 碰撞，也停发数据，并发送一个 48 bit 的拥塞信号 可以发现，在站 $A$ 发送帧后最多经过 $2\\tau$ 的时间，即可知道所发送的帧是否经过碰撞，因此，常将以太网端到端的往返时间 $2\\tau$ 称为争用期 进一步，可以断定，只要在 $2\\tau$ 的时间内未检测到碰撞，则可认为肯定未发生碰撞 最小帧长为确保发送方在发送数据的同时能够检测可能存在的冲突，需要在发送完帧前就能收到自己发送出去的数据，即帧的传输时延至少要两倍于信号在总线中的传播时延 因此，CSMA/CD 中的所有数据帧都要大于一个最小帧长，任何站点收到帧长小于该最小帧长的帧，就将其当做无效帧 最小帧长被定义为： 最小帧长=总线传播时延\\times 数据传输率 \\times 2若要发送的数据帧小于最小帧长，会在数据字段后加入一个填充字段，以保证发送的数据帧不小于最小帧长 例如，以太网规定争用期为 $51.2 \\mu s$，那么，对于 $10Mb/s$ 的以太网，在争用期内可发送 $512\\: bit$ 即 $64B$ 的数据 如果前 $64B$ 没有发生冲突，那么就表明已经成功抢占信道，后续的数据不会发生冲突 因此，以太网规定最短帧长为 $64B$，凡是小于 $64B$ 的帧都是由于冲突而异常终止的无效帧 二进制指数退避算法在 CSMA/CD 中，除了上述的检测冲突外，CSMA/CD 还能从冲突中恢复，一旦发生冲突，参与冲突的两个站点立刻再次发送是无意义的，只会导致无休止的冲突 因此，CSMA/CD 中采用二进制指数退避算法来解决碰撞问题，算法流程如下： 确定基本退避时间，一般取争用期 $2\\tau$ 设置参数 $k$，其值为重传次数，但不超过 $10$，即 $k=min[重传次数,10]$ 在整数集合 $\\{0,1,…,2^k-1\\}$ 中随机取一个数 $r$，重传所需要退避时间为 $2r\\tau$ 当重传达到 $16$ 次仍不成功，说明网络拥挤，认为该帧永远无法正确发出，抛弃该帧并向高层报告出错 使用二进制指数退避算法，可以使重传需要推迟的平均时间随着重传次数的增大而增大，从而减小发生碰撞的概率，从而稳定整个系统 【CSMA/CA 协议】概述CSMA/CD 在有线局域网中得到有效应用，但在无线局域网中无法直接使用该协议，主要是由于以下两个原因： 接收信号强度小于发送信号强度，且在无线介质上信号强度动态变化范围很广，若要进行碰撞检测，硬件开销过大 在无线通信中，存在隐蔽站点问题，即并非所有站点都能听到对方（$A$、$C$ 互相检测不到，信道空闲同时向 $B$ 发送数据，导致冲突） 为此，在 IEEE 802.11 标准中，定义了载波侦听多路访问/碰撞避免（Carrier Sense Multiple Access with Collision Avoidance，CSMA/CA）协议，其用于无线局域网 碰撞避免（Collision Avoidance，CA），是指尽量降低碰撞发生的概率 CSMA/CA 的基本思想是：当一个结点要发送数据时，先侦听信道，若信道空闲，则发送数据；若信道忙，则等待，直到信道空闲再重新发送 同时，在发送数据时，若要发送的是第一个数据帧，则直接进行发送；若不是第一个数据帧，要采用二进制指数退避算法来计算随机退避时间，确定下一个帧要发送的时间 归结来说，CSMA/CA 的特点可以概括为：先听再发，忙则等待，预约信道，随机再发 碰撞避免CSMA/CA 采用预约信道、ACK 帧、RTS/CTS 帧三种机制来实现碰撞避免，其中，前两者是 CSMA/CA 必选的机制，后者是可选的机制 预约信道，是指发送方在发送数据时，向其他站点通知自己传输数据所需的时间，以便令其他站点在这段时间内不发送数据，从而避免碰撞 ACK 帧，是指在站点正确接收到发送给自己的数据帧后，都要向发送方发回一个 ACK 帧，若接收失败，则不采取任何行动；同时，发送方在发送完数据帧后，若在规定时间内没有收到 ACK 帧，则认为发送失败，进行该数据帧的重发，直到收到 ACK 帧或达到规定最大重发次数为止 RTS/CTS 帧，主要用于解决无线局域网中的隐蔽站点问题，其中，RTS 帧为请求发送帧，其包含发送地址、接收地址、下一数据发送时间等，用于通知接收站要发送信息；CTS 帧为响应发送帧，用于对 RTS 帧做出回应，通知发送站可以发送信息 当采用 RTS/CTS 帧机制时，CSMA/CA 的工作流程如下： 检测信道是否空闲，若信道空闲，发送 RTS 帧；若信道忙，则等待 接收方收到 RTS 帧后，响应 CTS 帧给发送方，此时两站点建立一定关系，其他站再向接收方发送 RTS 帧会被拒绝 发送方收到响应的 CTS 帧后，开始发送数据帧，同时预约信道，告知其他站点自己要使用信道的时间 接收方收到数据帧后，通过差错控制机制来检测数据帧，若正确，则响应 ACK 帧，否则直接丢弃 发送方收到响应的 ACK 帧后，进行下一数据帧发送；若未收到，则采用指数二进制退避算法确定随机退避时间，根据时间进行重传","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"信道划分介质访问控制","slug":"computer-networks/18.信道划分介质访问控制","date":"2019-10-01T03:05:00.000Z","updated":"2021-08-23T12:46:42.349Z","comments":true,"path":"notes/computer-networks/b21fca73.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/b21fca73.html","excerpt":"【概述】信道划分介质访问控制，是在数据链路层采用广播方式时，通过对信道进行静态划分的介质访问控制方式，从而避免两对结点在通信时造成的通信干扰 信道划分介质访问控制将使用介质的每个设备，与来自同一信道上的其他设备的通信隔离，将时域与频域资源合理分配给各设备","text":"【概述】信道划分介质访问控制，是在数据链路层采用广播方式时，通过对信道进行静态划分的介质访问控制方式，从而避免两对结点在通信时造成的通信干扰 信道划分介质访问控制将使用介质的每个设备，与来自同一信道上的其他设备的通信隔离，将时域与频域资源合理分配给各设备 当传输介质的带宽超过传输单个信号所需带宽时，就通过在一条介质上同时携带多个传输信号的方法来提高传输系统的利用率，即多路复用，其是实现信道划分介质访问控制的途径 多路复用技术将多个输入终端输入的信号整合在到一条物理链路上进行传输，之后在接收端将接收到的信号分离出来，传送到对应的输出终端 信道划分的实质，就是通过分时、分频、分码等方法，将一条广播信道，在逻辑上分为几条用于两结点间通信的互不干扰的子信道，也就是将广播信道转为点对点信道 【频分多路复用】频分多路复用（FDM），是一种将多路基带信号调制到不同频率载波上，再进行叠加形成一个复合信号的多路复用技术 在物理信道的可用带宽超过原始信号的所需带宽的情况下，可将该物理信道的总带宽分割成若干个与传输单个信号带宽相同或略宽的子信道，此时每个子信道传输一种信号 FDM 的优点，在于充分利用了传输介质的带宽，系统效率较高，实现较为容易，技术目前较为成熟 【时分多路复用】时分多路复用（TDM），是将一条物理信道按时间分成若干时间片，轮流分配给多个信号使用，每一时间片由复用的一个信号占用 这样利用每个信号在时间上的交叉，就可在一条物理信道上传输多个信号 就某一时刻来看，时分多路复用信道上传送的仅是某一对设备间的信号；就某一时间段来看，时分多路复用信道上传送的是按时间分割的多路复用信号 但由于计算机数据的突发性，TDM 的子信道利用率一般不高，为此在 TDM 上进行了改进，即统计时分多路复用（STDM），其采用 STDM 帧，不再是固定分配时隙，而是按需动态分配时隙，当终端有数据要传送时才会分配时间片，由此提高线路的利用率 【波分多路复用】波分多路复用（WDM），就是光的频分多路复用复用，在一根光纤中传输多种互不干扰的不同波长的光信号 在发送端，会将不同波长的信号用复用器整合成一个信号，之后在接收端利用分用器再将各路波长分解出来 【码分多路复用】码分多路复用（CDM），是依靠不同编码来区分各路原始信号的一种复用方式，常与多址技术结合使用，其既共享信道的频率，又共享时间，具有抗干扰能力强、保密性强、运行成本低等优点，常用于无线通信系统中 最常见的 CDM 技术是码分多址（CDMA），其将每个比特时间分成 $m$ 个时间片，每个时间片被称为码片 对于每个站来说，其会被指定一个唯一的 $m$ 比特的码片序列，并规定：若要发送 $1$，则实际发送被指定的 $m$ 比特的码片序列，若要发送 $0$，则发送被指定的 $m$ 比特的码片序列的反码 举例来说，假设 $S$ 站的码片序列为 0001 1011，那么在 $S$ 站要发送 $1$ 时，就发送 0001 1011，要发送 $0$ 时，就发送 1110 0100 通常来说，会将码片中的 $0$ 写作 $-1$，将 $1$ 写作 $+1$，当两个或多个站点同时发送时，各路数据在信道中被线性相加，为从信道中分离出各路信号，常规定各站点的码片序列相互正交 假设向量 $\\vec{S}$ 为 $A$ 站的码片序列，$\\vec{T}$ 为 $B$ 站的码片序列，两个不同站的码片序列正交，就是两向量的规格化内积为零，即： \\vec{S}\\cdot\\vec{T}=\\frac{1}{m}\\sum_{i=1}^mS_iT_i=0任何一个一个码片序列与其自身的规格化内积为 $1$，即： \\vec{S}\\cdot\\vec{S}=\\frac{1}{m}\\sum_{i=1}^mS_iS_i=1任何一个码片序列与其反码的规格化内积值为 $-1$，即： \\vec{S}\\cdot(-\\vec{S})=\\frac{1}{m}\\sum_{i=1}^mS_i(-S_i)=-1 举例来说， $A$ 站的码片序列为 0001 1011，$B$ 站的码片序列为 0010 1110 当 $A$ 站向 $C$ 站发送 $1$ 时，发送向量 $\\vec{A}=(-1,-1,-1,+1,+1,-1,+1,+1)$，当 $B$ 站向 $C$ 站发送 $0$ 时，发送向量 $\\vec{B}=(+1,+1,-1,+1,-1,-1,-1,+1)$ 此时，两个向量到达公共信道上，就进行叠加，有： \\vec{A}+\\vec{B}=(0,0,-2,+2,0,-2,0,+2)到达 $C$ 站后，会进行数据分离，如果要得到来自 $A$ 站的数据，就让 $\\vec{A}$ 与 $\\vec{A}+\\vec{B}$ 进行规格化内积，可得： \\vec{A}\\cdot(\\vec{A}+\\vec{B})=1因此，$A$ 站发出的数据是 $1$ 同理，若想得到来自 $B$ 站的数据，就让 $\\vec{B}$ 与 $\\vec{A}+\\vec{B}$ 进行规格化内积，可得： \\vec{A}\\cdot(\\vec{A}+\\vec{B})=-1因此，$A$ 站发出的数据是 $0$","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"介质访问控制","slug":"computer-networks/17.介质访问控制","date":"2019-10-01T01:48:00.000Z","updated":"2021-08-23T12:46:53.476Z","comments":true,"path":"notes/computer-networks/f8c2b35d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/f8c2b35d.html","excerpt":"【介质访问控制】数据链路层存在两种信道，一种是采用广播方式的广播信道，另一种是采用点对点方式的点对点信道 在早期的总线以太网、无线局域网等，常采用广播方式，在这个广播信道中，所有主机共享通信介质，为了避免两对结点通信时可能会出现通信干扰的情况，数据链路层划分出一个用来决定广播信道中信道分配协议的子层，称为介质访问控制（Medium Access Control，MAC）层","text":"【介质访问控制】数据链路层存在两种信道，一种是采用广播方式的广播信道，另一种是采用点对点方式的点对点信道 在早期的总线以太网、无线局域网等，常采用广播方式，在这个广播信道中，所有主机共享通信介质，为了避免两对结点通信时可能会出现通信干扰的情况，数据链路层划分出一个用来决定广播信道中信道分配协议的子层，称为介质访问控制（Medium Access Control，MAC）层 由此，在局域网的 IEEE 802.2 标准中，将数据链路层划分为两部分： 逻辑链路控制层（LLC）：链路层上层，负责识别网络层协议并进行封装 介质访问控制层（MAC）：链路层下层，定义了帧在介质上如何传输，并进行介质访问控制 介质访问控制，就是采取一定的措施，使广播信道中两对结点间的通信不会相互干扰 以下图的广播信道为例，结点 $A$、$B$、$C$、$D$、$E$ 共享广播信道，假设 $A$ 与 $C$ 要发生通信， $B$ 与 $D$ 要发生通信，那么这两对结点间的通信可能会因为相互干扰而失败，因此，为避免这种情况，采用介质访问控制来对信道进行分配 【类型】介质访问控制分为两大类 第一类是利用复用技术对信道进行静态划分，这种介质访问控制方式被称为信道划分介质访问控制，具体分为频分多路复用、时分多路复用、波分多路复用、码分多路复用四种 第二类是采取争用思想对争取信道的使用权，争用胜利者可在一定时间内独占整个信道的全部资源，这种介质访问控制方式又分为两类，一类是存在冲突开销的随机访问介质访问控制，常用的协议有 ALOHA 协议、CSMA 协议、CSMA/CD 协议、CSMA/CA 协议；另一类是不存在冲突开销的轮询访问介质访问控制，常用的协议是令牌传递协议","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"多帧滑动窗口与选择重传协议","slug":"computer-networks/16.多帧滑动窗口与选择重传协议","date":"2019-09-27T09:36:00.000Z","updated":"2021-08-23T12:47:01.479Z","comments":true,"path":"notes/computer-networks/72c3eb32.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/72c3eb32.html","excerpt":"【概述】对于数据链路层中流量控制与可靠性传输机制，其可分为停止等待 ARQ、后退 $N$ 帧 ARQ、选择性重传 ARQ三种 由于 GBN-ARQ 发送方累计确认的存在，一旦出错不仅要重传丢失的帧，还要重传丢失的帧后的所有帧，这无疑降低了传输效率","text":"【概述】对于数据链路层中流量控制与可靠性传输机制，其可分为停止等待 ARQ、后退 $N$ 帧 ARQ、选择性重传 ARQ三种 由于 GBN-ARQ 发送方累计确认的存在，一旦出错不仅要重传丢失的帧，还要重传丢失的帧后的所有帧，这无疑降低了传输效率 为此，选择重传 ARQ 对其进行了改善： 回归单个确认 扩充接收窗口，可以临时存储错误帧与乱序到达的帧 也就是说，对于 SR-ARQ 来说，其发送窗口大小 $&gt;1$，接收窗口大小 $&gt;1$ 【发送窗口与接收窗口】在 SR-ARQ 中，发送方及其发送窗口中的数据划分与 GBN-ARQ 中一样，不做任何更改 但接收方的接收窗口中的数据可划分为四个部分： 接收完毕并确认的数据帧 希望收到但没有收到的数据帧 收到并且确认但缓存在接收窗口中的数据帧 等待接收的数据帧 其中，第 2、3、4 部分，即接收窗口内的数据帧 设 $n$ 是帧编码序号的比特位数，那么，对于发送窗口的大小 $W_T$ 和接收窗口的大小 $W_R$ 有： W_T=W_R\\leq2^{n-1}因此，有： W_T+W_R\\leq2^n当 $W_R=W_T&gt;2^n-1$ 时，同样会出现无法分辨新帧与旧帧的问题 【工作原理】发送方对于 SR-ARQ 的发送方来说，会做以下三件事： 1.上层调用 在从上层收到数据后，发送方会检查下一个可用于该帧的序号 若序号在发送窗口内，则发送数据帧 若序号不在发送窗口内，则像 GBN-ARQ 一样，缓存到发送窗口的缓冲区内 2.单个确认 当收到某个数据帧的确认帧时，如果这个帧的序号在发送窗口内，那么发送窗口会将这个被确认的数据帧标记为已接收；否则，不进行任何操作 如果该帧序号是发送窗口的下界（最左边第一个窗口对应的序号），那么将发送窗口向前移动到具有最小序号的未确认帧处 若发送窗口移动，且在发送窗口内存在未发送帧，则将这些数据帧发送 3.超时重传 与停止等待 ARQ、GBN-ARQ 相似，SR-ARQ 的发送方为每个帧设置了一个超时计时器 若某个超时计时器出现超时，发送方会重传当前超时计时器对应数据帧 接收方对于 SR-ARQ 的接收方来说，会做以下三件事： 1.全部接收 当接收方收到数据帧时，若数据帧处于接收窗口内，则进行接收，并逐个发送确认帧 此时，失序的帧将会被缓存起来，直到所有帧均被正确接收后，才会将这一批帧按序交付给上层，从而前移接收窗口 2.返回确认 当接收方收到数据帧时，若数据帧小于接收窗口的下界，说明之前返回的确认帧超时，此时会将该数据帧丢弃，并重新发送确认帧 3.差错处理 当接收方通过差错控制技术发现数据帧有错时，将会丢弃该帧，并返回一个 NAK 否定应答帧，要求发送方重新发送数据局帧","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"多帧滑动窗口与后退 N 帧协议","slug":"computer-networks/15.多帧滑动窗口与后退N帧协议","date":"2019-09-27T07:16:00.000Z","updated":"2021-08-23T12:45:35.773Z","comments":true,"path":"notes/computer-networks/b6101f7f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/b6101f7f.html","excerpt":"【概述】对于数据链路层中流量控制与可靠性传输机制，其可分为停止等待 ARQ、后退 $N$ 帧 ARQ、选择性重传 ARQ三种 由于停止等待 ARQ 大多数时间都处于等待中，这无疑浪费了大量的时间与资源","text":"【概述】对于数据链路层中流量控制与可靠性传输机制，其可分为停止等待 ARQ、后退 $N$ 帧 ARQ、选择性重传 ARQ三种 由于停止等待 ARQ 大多数时间都处于等待中，这无疑浪费了大量的时间与资源 后退 $N$ 帧 ARQ 对停止等待 ARQ 做出了改善： 可连续发送多个帧 为了便于定位出错帧，对帧的编号进行了扩充 对缓冲区进行扩充，扩充后的缓冲区放入要连续发送的帧的拷贝，当发送出现问题需要再次发送时，可在缓冲区中找到对应的帧，以供再次发送 也是就说，对于 GBN-ARQ 来说，其发送窗口大小 $&gt;1$，接收窗口大小 $=1$ 【发送窗口】在 GBN-ARQ 中，发送方要发送的数据可以分为四个部分： 发送完且已被确认的数据帧 发送完正在等待确认的数据帧 未发送正在准备继续发送的数据帧 无法发送的数据帧 其中，第 2、3 部分即发送窗口内的数据帧 设 $n$ 为帧编码序号的比特位数，那么对于发送窗口的大小 $W_T$ 有： 1\\leq W_T\\leq 2^n-1当 $W_T&gt;2^n-1$ 时，会出现无法分辨新帧与旧帧的问题 【工作原理】发送方对于 GBN-ARQ 的发送方来说，会做以下三件事： 1.上层调用 在上层要发送数据时，发送方会检查发送窗口是否已满 若发送窗口已满，发送方会告知上层，上层将数据发给发送方缓冲区，等待发送窗口有空间后进行发送 若发送窗口未满，上层会将数据直接交付给发送窗口，准备进行发送 2.累计确认 当发送方收到 $n$ 号数据帧对应的确认帧时，这说明接收方不仅收到了 $n$ 号数据帧，还收到了 $n$ 号帧之前的所有数据帧 由此，在 GBN-ARQ 方式下，发送方不用对每一个数据帧都返回确认帧，可以每隔几个数据帧返回一个确认帧，从而节省时间与资源 3.超时回退 与停止等待 ARQ 一样，发送方同样设置了一个超时计时器，若出现超时，发送方会重传所有已发送但未被确认的帧 举例来说，发送方发送了 $n$ 号数据帧，但该帧在链路上丢失了，$n+1$、$n+2$ 这两个数据帧仍然顺利发出，由于接收方的接收窗口只能容纳 $1$ 个帧，此时的接收方还是期望收到 $n$ 号数据帧，因此面对发送过来的 $n+1$ 和 $n-1$ 号帧将会被丢弃，一直等待 $n$ 号帧因为超时而被再次发送过来，因此，$n+1$ 与 $n+2$ 号帧会随着 $n$ 号帧再次被发送过来 接收方对于 GBN-ARQ 的接收方来说，会做以下两件事： 1.交付数据 当接收方正确收到所期望的 $n$ 号数据帧，且 $n$ 号数据帧之前的帧也都按序到达，那么会发送一个 ACKn 确认帧传递给发送方 告知发送方其已经正确接收 $n$ 号数据帧以及之前的所有数据帧 2.乱序丢弃 若出现数据帧丢失的情况，此时，接收方等待的是 $n$ 号帧，但传过来的是 $n$ 号帧后的数据帧，此时接收方会将这些数据帧丢弃，并返回一个 ACKn-1 确认帧给发送方，告知仅收到了 $n-1$ 号帧及其之前的数据帧，希望发送方重传 $n-1$ 号帧后的数据帧","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"单帧滑动窗口与停止-等待协议","slug":"computer-networks/14.单帧滑动窗口与停止-等待协议","date":"2019-09-27T05:16:00.000Z","updated":"2021-08-23T12:45:44.703Z","comments":true,"path":"notes/computer-networks/94d23e30.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/94d23e30.html","excerpt":"【概述】对于数据链路层中流量控制与可靠性传输机制，其可分为停止等待 ARQ、后退 N 帧 ARQ、选择性重传 ARQ三种 在停止等待 ARQ 中，源站发送单个帧后，必须停止并等待确认帧","text":"【概述】对于数据链路层中流量控制与可靠性传输机制，其可分为停止等待 ARQ、后退 N 帧 ARQ、选择性重传 ARQ三种 在停止等待 ARQ 中，源站发送单个帧后，必须停止并等待确认帧 从滑动窗口机制的角度来看，停止-等待协议相当于发送窗口和接收窗口大小均为 $1$ 的滑动窗口协议，即单帧滑动窗口 【无差错情况】在无差错的情况下，发送方发送的数据帧交替的用 0、1 来标识，接收方发送的对应确认帧则用 ACK0 和 ACK1 来表示确认，由于每发送一帧就停止等待，因此仅需要用 1 bit 即可完成编号 【差错情况】在停止-等待协议中，可能会出现以下差错： 数据帧丢失或到达接收方的数据帧遭到破坏 数据帧正确但确认帧遭到破坏 数据帧正确但确认帧迟到 对于第一种差错，发送方设置了超时计时器，若在一个帧发送后，计时器满仍未收到确认帧，则会再次发送相同的数据帧，直到该数据帧无错误到达接收方并且发送方收到确认帧为止；对于接收方来说，若数据帧丢失，其没有收到数据帧，故不会进行任何操作，若利用差错控制技术检测出数据帧出错，则直接丢弃数据帧 对于超时计时器来说，每次发送一个数据帧就会启动一次，其设置的重传时间比帧传输的 平均 RTT 要更长一些 对于第二种差错，此时接收方已经收到正确数据帧，但发送方收不到确认帧，发送方会在计时器满后重传该数据帧，接收方收到同样的数据帧后会丢弃该重复帧，然后重传确认帧 对于第三种差错，此时接收方已经收到正确数据帧，但发送方在超时重传时间内收不到确认帧，因此发送方会重传该数据帧，接收方收到同样的数据帧后丢弃该重复帧，然后重传确认帧，在若干时间后，接收方收到了之前迟到的确认帧，其会比对确认帧的编号，发现 ACK 迟到后，收下就丢弃 【性能分析】对于停止等待协议来说，设 $T_D$ 为数据帧发送时延，$T_A$ 为确认帧发送时延，$RTT$ 为往返时延 那么，一个数据帧的发送周期为： T=T_D+RTT+T_A设在这一个发送周期 $T$ 内，发送了 $L$ 比特的数据，发送方数据传输率为 $C$，那么整个信道的有效发送时间为： T_D=\\frac{L}{C}信道利用率，即信道的效率，其是针对于发送方而言的，指发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比例，即： U=\\frac{T_D}{T}=\\frac{T_D}{T_D+RTT+T_A}进一步，可得信道吞吐率为： R=U*C","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"数据链路层流量控制与可靠传输机制","slug":"computer-networks/13.数据链路层流量控制与可靠传输机制","date":"2019-09-27T03:03:00.000Z","updated":"2021-08-23T12:45:53.816Z","comments":true,"path":"notes/computer-networks/d7e1debd.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/d7e1debd.html","excerpt":"【流量控制】概述流量控制涉及链路上的帧的发送速率的控制，使接收方有足够的缓冲空间来接收每一个帧，其基本方法是由接收方控制发送方发送数据的速率，常见方式有停止-等待协议（Stop and Wait）、滑动窗口协议，其中，滑动窗口协议可分为后退 $N$ 帧协议（Go-Back-N，GBN）、选择重传协议（Selective Repeat，SR）","text":"【流量控制】概述流量控制涉及链路上的帧的发送速率的控制，使接收方有足够的缓冲空间来接收每一个帧，其基本方法是由接收方控制发送方发送数据的速率，常见方式有停止-等待协议（Stop and Wait）、滑动窗口协议，其中，滑动窗口协议可分为后退 $N$ 帧协议（Go-Back-N，GBN）、选择重传协议（Selective Repeat，SR） 对于滑动窗口协议来说，在任意时刻，发送方都维持一组连续的允许发送的帧的序号，称为发送窗口；接收方维持一组连续的允许接收的帧的序号，称为接收窗口，在传输过程中，两个窗口大小是固定的 从滑动窗口的概念来看，停止-等待协议、后退 $N$ 帧协议、选择重传协议之间只在发送窗口与接收窗口的大小上有区别： 停止-等待协议：发送窗口大小 $=1$，接收窗口大小 $=1$ 后退 $N$ 帧协议：发送窗口大小 $&gt;1$，接收窗口大小 $=1$ 选择重传协议：发送窗口大小 $&gt;1$，接收窗口大小 $&gt;1$ 停止-等待协议发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧；接收方每接收一帧，都要反馈给发送方一个应答信号，表示可接收下一帧 由于发送方每次发送一帧后就陷入等待接收方确认信息的过程中，传输效率很低 此外，如果接收方不反馈应答信号，那么发送方会一直等待 滑动窗口协议发送窗口用来对发送方进行流量控制，其大小代表在还没有收到对方确认信息的情况下发送方最多还可发送多少个数据帧 在发送端，每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可发送的帧时，即窗口内全是已发送但未收到确认的帧，发送方就会停止发送，直到收到接收方发送的确认帧，才会使窗口移动，之后，若移动的窗口内有可以发送的帧，就可继续发送 接收窗口用来可控制可以接收哪些数据帧、不可以接收哪些数据帧，只有当收到的数据帧的序号落入接收窗口，才允许将该数据帧收下，若接收到的数据帧的序号不在接收窗口中，则会将该数据帧丢弃 在接收端，当收到一个数据帧后，窗口将后移一个位置，并发回该数据帧的确认帧，若收到的数据帧落在接收窗口之外则一律丢弃，可以发现，当接收窗口大小 $=1$ 时，可以保证帧的有序接收 【可靠传输机制】可靠传输保证了数据传输无误，通常采用确认、超时重传两种机制来实现 确认，是一种无数据的链路层控制帧，其可以使接收方能够让发送方知道哪些内容被正确接收，某些情况下，通常将确认捎带在一个回复帧中，称为捎带确认 超时重传，是指发送方在发送某个数据帧后就启动一个计时器，在一定时间内如果没有收到数据的确认帧，就重新发送该数据帧 自动重传请求（Auto Repeat ReQuest，ARQ）就是结合确认与超时重传两种机制的可靠传输方法，其通过接收方请求发送方重传出错的数据帧来恢复出错的帧 在数据链路层中，流量控制与可靠性传输两者是交织在一起的，可分为三种：停止等待 ARQ、后退 N 帧 ARQ、选择性重传 ARQ 前者是停止等待协议与可靠性传输机制的结合，后两者是滑动窗口协议与可靠性传输机制的结合，同时，当窗口尺寸开到足够大时，帧在链路上可以连续地流动，因此后两者又并称连续 ARQ 协议","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"数据链路层差错控制与常见校验码","slug":"computer-networks/12.数据链路层差错控制与常见校验码","date":"2019-09-24T12:48:00.000Z","updated":"2022-05-04T11:33:06.110Z","comments":true,"path":"notes/computer-networks/5f11d3dc.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/5f11d3dc.html","excerpt":"【概述】帧在传输过程中会出现帧错或位错，造成这两种差错的来源是噪声，其可分为两方面： 线路本身电气特性造成的随机噪声：信道固有、随机存在，可通过提高信噪比来减少 外界原因造成的短暂冲击噪声：由于外界冲击造成、偶然发生，可通过编码技术来检错和纠错","text":"【概述】帧在传输过程中会出现帧错或位错，造成这两种差错的来源是噪声，其可分为两方面： 线路本身电气特性造成的随机噪声：信道固有、随机存在，可通过提高信噪比来减少 外界原因造成的短暂冲击噪声：由于外界冲击造成、偶然发生，可通过编码技术来检错和纠错 对于帧错，通常在数据链路层引入定时器与编号机制，当定时器到达设定的时间而帧的确认帧未到达时，发送方将重发该帧，同时，为保证接收方不会收到重复帧，对每个发送的帧进行编号，从而保证每一帧都能有且仅有一次正确地交付目的结点 对于位错，通常采用检错编码或纠错编码的方法，关于这两种方法的具体介绍见下 【检错编码】概述检错编码是利用自动重传请求 ARQ 的方式进行差错控制，在接收端检测出错后，就通知发送端重发，直到接收到正确的编码位置 具体来说，检测编码采用了冗余编码技术，核心思想是在信息位发送前，先按一定关系附加一定的冗余校验位，构成一个符合某一规则的校验码后再发送，在接收方收到校验码后，根据有效位重新生成冗余校验位，与原冗余校验位进行比较，判断是否出现错误 在检测出错误后，有三种处理方案：请求重发、删除数据、通过余数的值由接收端自行纠正（CRC 码） 常见的检错编码有能检测奇数位错误的奇偶校验码，以及能确定一位具体出错位置并纠正的循环冗余校验码 奇偶校验码奇偶校验码是奇校验码和偶校验码的统称，是最基本的一种检错码，可以检测出奇数位错误，无法确定出错的位置 对于若干位信息位，再其前或其后增加一位的被称为奇偶校验位的冗余位，其取值将使得整个校验码（有效信息位和校验位）中 1 的个数为奇数或偶数 对于奇校验码来说，整个校验码中 1 的个数为奇数；对于偶校验码来说，整个校验码中 1 的个数为偶数 循环冗余校验码循环冗余校验码（Cyclic Redundancy Code，CRC），又称多项式码，其基于线性编码理论，可以检测出一位错误，在 $k$ 位信息位后再拼接 $r$ 位的校验位，整个编码长度为 $n=k+r$ 位 一个 $k$ 位的帧可以看成从 $x^{k-1}$ 到 $x^0$ 的 $k$ 次多项式的系数序列，这个多项式的阶数是 $k-1$，高位是 $x^{k-1}$ 项的系数，举例来说，对于 1110011，其表示成多项式为 $x^6+x^5+x^4+x+1$ 发送方和接收方会事先商定一个阶为 $r$ 的多项式 $G(x)$，在发送方，会将 $k$ 位的信息位左移 $r$ 位，低端补 0，生成长度为 $n=k+r$ 的带检验码的帧 之后，将带检验码的帧对阶为 $r$ 的多项式 $G(x)$ 作模 $2$ 除法，得到的 $r$ 位余数即长度为 $r$ 的冗余校验位，称为帧检验序列（FCS） 最后，将 $k$ 位信息位与 $r$ 位帧检验序列拼接，即可得到长度为 $n=k+r$ 位循环冗余校验码 接收方会用这个多项式 $G(x)$ 来除以收到的循环冗余校验码，如果余数为 $0$，则认为无差错，若余数不为 $0$，则说明该余数对应的十进制位出错（左端为高位，右端为低位） 举例来说，设生成多项式为 $G(x)=x^3+x^2+1$，要发送的信息为 101001 生成多项式的最高幂次为 $3$，即有 $r=3$；信息位长度为 $6$，即 $k=6$；同时，生成多项式对应的二进制码为 1101 首先对要发送的信息码向左移 $r$ 位，低位补 $0$，有：101001000 之后，对 101001000 用生成多项式对应的二进制码 1101 进行模 $2$ 除法，产生余数 001，即帧检验序列，具体过程如下图 此时，得到编码后的 CRC 码 101001001 对于接收方来说，假若收到的 CRC 码为 101001011，对其与生成多项式 $G(x)$ 对应的二进制码 1101 进行模 $2$ 除法，得到余数为 010，说明第 $2$ 位出错 【纠错编码】概述纠错编码是利用前向纠错 FEC 的方式进行差错控制，在接收端检测出错后，可以确定二进制编码的出错位置，并加以纠正 具体来说，检测编码采用了冗余编码技术，核心思想是在信息位发送前，先按一定关系附加一定的冗余校验位，构成一个符合某一规则的校验码后再发送，在接收方收到校验码后，根据一定规则推测发送方实际送出的应该是什么样的编码 最常见的纠错编码是海明码 纠错理论对于任意两个合法码字之间最少变化的二进制位数，称为码距，简单来说，就是两个长度相同的编码对应位不同的个数 例如：1100 与 1101 间的码距为 $1$，1001 与 0010 间的码距为 $3$ 对于码距不小于 $2$ 的数据校验码，开始具有检错能力，码距越大，检错、纠错的能力就越强，且检错能力总是大于等于纠错能力 设可检测错误的位数为 $D$，可纠正错误的位数为 $C$，编码的码距为 $L$，那么有： L-1=D+C,\\quad D\\geq C海明码海明码纠错 $d$ 位需要码距为 $2d+1$ 的编码方案，检错 $d$ 位需要码距为 $d+1$ 的编码方案 对于 $m$ 位信息位，将插入 $r$ 位校验位组成 $n=m+r$ 位码字，要求满足以下关系： 2^r\\geq m+r+1下面，以 $n=4$ 的数据编码 $D_4D_3D_2D_1=1010$ 为例，说明发送端计算海明码与接收端检验海明码的过程 对于发送端，会将码字的位编号，规定校验位 $P_i$ 位于数据位位号 $2^{i-1}$ 的位置上，对于 $4$ 位数据编码 $D_4D_3D_2D_1$，将会插入 $3$ 位校验码 $P_3P_2P_1$，从而实际传输 $7$ 位码字 $H_7H_6H_5H_4H_3H_2H_1$ 之后，将每个数据位用多个校验位进行校验，被校验数据位的海明位号等于校验该数据位的将由改写各校验位海明位号，进行分组 对于校验位 $P_i$，其值为该校验位校验的所有数据位求异或 由此，可得到 1010 所对应的海明码为 101\\underline{0}0\\underline{10}其中，带有下划线的为校验位，其余为原信息位 对于接收端，会将每个校验位 $P_i$ 与参与形成该校验位的信息位求异或 若求得的 $r$ 个校验位值均为 0，说明没有出现错误，否则说明出错，且这个 $r$ 位二进制数对应的十进制数就是错误位的位号，将其取反，即可进行纠错","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"数据链路层组帧","slug":"computer-networks/11.数据链路层组帧","date":"2019-09-24T08:35:00.000Z","updated":"2021-08-23T12:46:11.940Z","comments":true,"path":"notes/computer-networks/31d0416.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/31d0416.html","excerpt":"【字符计数法】字符计数法，就是在帧头部使用一个计数字段，来记录包含该计数字段及其之后的字节数 当目标结点的数据链路层收到字节计数值时，就知道其后面跟随的字节数，从而确定帧结束的位置","text":"【字符计数法】字符计数法，就是在帧头部使用一个计数字段，来记录包含该计数字段及其之后的字节数 当目标结点的数据链路层收到字节计数值时，就知道其后面跟随的字节数，从而确定帧结束的位置 举例来说，设字符 $A$ 的二进制编码为 0100 0111，字符 $B$ 的二进制编码为 1110 0011 当发送由 $A$、$B$、这两个字符组成的帧时，若采用字符计数法，加上用于记录字节的计数字段，总共有 $3$ 个字符，$3$ 的二进制编码为 0000 0011 将其放入二进制位序列的首部，其实际发送的二进制序列为：0000 0011 0100 0111 1110 0011 【字符填充的首尾定界符法】字符填充法使用一些特定的字符来定界一帧的开始与结束，通常采用 DLE STX 来代表帧开始，用 DLE ETX 来代表帧结束 为了使信息位中出现的特殊字符不被误判为帧的首尾定界符，常规在特殊字符前加一个转义字符 DLE，其是 ASCII 码中的控制字符，不是 D、L、E 三个字符的组合 在接收方收到转义字符后，就知道其后面紧跟的是数据信息，而非控制信息 如图所示，帧的数据段中出现 DLE，发送方会在数据段中每个 DLE 前插入一个 DLE 字符，接收方收到数据后会删除数据段中插入的 DLE 字符，从而得到原来的数据 【零比特填充的首尾标志法】零比特填充的首尾标志法，容易使用硬件实现，性能优于字符填充的首尾定界符法 其允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特，其使用一个特定的比特模式 0111 1110 来标志一帧的开始与结束 为了不让在信息位中出现的 0111 1110 比特流被误判为帧的首尾标志，发送方的数据链路层会在信息位中遇到连续的 $5$ 个 1 时，就自动插入一个 0；接收方的数据链路层会在信息位 中遇到连续的 $5$ 个 1 时，就将其后紧跟的 0 删除 【违规编码法】在物理层比特编码时，通常采用违规编码法，其不需要采用任何填充技术就能实现数据传输的透明性，但只适用于采用冗余编码的特殊编码环境 以局域网 IEEE 802 标准为例，其物理层采用曼彻斯特编码，将数据比特 1 编码为 高-低 电平对，将数据比特 0 编码为 低-高 电平对，此时 高-高 电平对和 低-低 电平对在数据比特中是违规的，因此可以借助这两个违规的编码来作为帧定界的起始、终止 由于字节计数法中计数字段的脆弱性与字符填充法实现上的复杂性与不兼容性，目前常采用的是比特填充法和违规编码法","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"数据链路层功能","slug":"computer-networks/10.数据链路层功能","date":"2019-09-24T07:33:00.000Z","updated":"2021-08-23T12:44:34.416Z","comments":true,"path":"notes/computer-networks/9c8461a4.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/9c8461a4.html","excerpt":"【概述】数据链路层，是在物理层所提供服务的基础上向网络层提供服务，负责通过一条链路，从一个结点向物理链路相连的另一结点传送数据 数据链路层将物理层提供的可能出错的物理连接，改造为逻辑上无差错的数据链路，使其对网络层表现为一条无差错的链路","text":"【概述】数据链路层，是在物理层所提供服务的基础上向网络层提供服务，负责通过一条链路，从一个结点向物理链路相连的另一结点传送数据 数据链路层将物理层提供的可能出错的物理连接，改造为逻辑上无差错的数据链路，使其对网络层表现为一条无差错的链路 其主要具有为网络层提供服务、链路管理、组帧、差错控制、流量控制与可靠性传输、介质访问控制的功能 【为网络层提供服务】对网络层来说，数据链路层的基本任务就是将源机器中来自网络层的数据，传输到目标机器的网络层 链路层通常可为网络层提供以下服务： 无确认无连接服务：源机器发送数据帧无需建立连接，目的机器收到帧后无需返回确认，对于丢失的帧链路层不负责重发而是交由上层处理，适用于实时通信、误码率低的信道，如以太网 有确认无连接服务：源机器发送数据帧无需建立连接，目的机器收到帧后必须返回确认，源机器在规定时间内未收到确认信号，就重传丢失的帧，适用于误码率高的信道，如无线通信 有确认面向连接服务：帧传输分为建立链路、传输帧、释放链路三个过程，目的机器对收到的每一个帧都要给出确认，源机器收到确认后再发送下一帧，适用于要求高可靠性、高实时性的信道 【链路管理】数据链路层连接的建立、维持、释放过程被称为链路管理，其主要用于面向连接的服务 当链路两端的结点进行通信前，需要确认对方已处于就绪状态，并交换必要的控制信息以对帧序号初始化，之后才能建立连接 在传输过程中，要能够保证为此连接不断开，在传输完毕后，则要释放该连接 在譬如局域网这样多个站点共享同一物理信道的情况下，对通信站点间分配、对信道的管理等，也属数据链路层链路管理的范畴 【组帧】在两个工作站之间传递信息时，将比特封装为帧，以帧的格式进行传送，之所以要这样做，是为了在出错时只重发出错的帧，不重发全部的数据，从而提高效率 对于一段数据来说，要想将其封装为帧，只需要在其前后分别包含控制信息的添加头部和尾部，他们的一个重要作用就是利用帧定界符来确定帧的界限，即帧定界 由于在网络中是以帧为最小单位传输的，接收端要正确的接收帧，就要清楚的知道该帧在一串二进制比特流中区分出帧的起始与终止，即帧同步 如果数据中恰好出现与帧定界符相同的比特组合，那么终端将会误认为传输结束而丢弃后面的数据，为解决这种问题，采用透明传输的方法，使得无论传输的数据是何种比特组合，都可在链路上传输 【差错控制】由于信道噪声等原因，帧在传输过程中可能会出现错误，这些错误可分为帧错和位错，令发送方确定接收方是否正确收到由其发送的数据的方法被称为差错控制 帧错，指帧的丢失、重复、失序等错误，通常在数据链路层引入定时器与编号机制，能保证每一帧都能有且仅有一次正确地交付目的结点 位错，指帧中某些位出现了差错，即 1 可能变成 0，0 可能变成 1，通常采用编码技术来进行控制，一种是自动重传请求 ARQ，在接收端检测出错后，就通知发送端重发，直到接收到正确的编码位置；另一种是前向纠错 FEC，在接收端检测出错后，可以确定二进制编码的出错位置，并加以纠正 【流量控制与可靠性传输】由于收发双方各自的工作速率和缓冲空间的差异，可能会出现发送方发送速率大于接收方接收速率的情况 若不对发送方的发送速率（链路上的信息流量）进行适当的限制，接收方来不及接收的帧将会被发送方后续不断发来的帧所淹没，造成帧的丢失从而出错 因此，流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收速率 在流量控制的过程中，需要某种反馈机制，使得发送方知道在何种情况下发送下一帧，什么情况下暂停发送，目前，常见的方式有两种：停止-等待协议、滑动窗口协议 需要注意的是，流量控制不是数据链路层独有的功能，传输层的协议中也提供该功能，只是控制的对象不同，对于数据链路层来说，其控制的是相邻两结点间链路上的流量，对于传输层来说，其控制的是源端到目的端之间的流量 可靠传输保证了数据传输无误，通常采用确认、超时重传两种机制来实现 确认，是一种无数据的链路层控制帧，其可以使接收方能够让发送方知道哪些内容被正确接收，某些情况下，通常将确认捎带在一个回复帧中，称为捎带确认 超时重传，是指发送方在发送某个数据帧后就启动一个计时器，在一定时间内如果没有收到数据的确认帧，就重新发送该数据帧 自动重传请求（Auto Repeat ReQuest，ARQ）就是结合确认与超时重传两种机制的可靠传输方法，其通过接收方请求发送方重传出错的数据帧来恢复出错的帧 在数据链路层中，流量控制与可靠性传输两者是交织在一起的","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"物理层设备与传输介质","slug":"computer-networks/09.物理层设备与传输介质","date":"2019-09-20T10:06:00.000Z","updated":"2021-08-23T12:44:44.557Z","comments":true,"path":"notes/computer-networks/8d3ab262.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/8d3ab262.html","excerpt":"【物理层设备】中继器中继器，又称转发器，其通过信号再生的原理，来将信号整形并放大再转发出去，以消除信号由于经过长段线缆因噪声而造成的失真和衰减，使信号波形与强度达到所需要求，从而扩大传输距离","text":"【物理层设备】中继器中继器，又称转发器，其通过信号再生的原理，来将信号整形并放大再转发出去，以消除信号由于经过长段线缆因噪声而造成的失真和衰减，使信号波形与强度达到所需要求，从而扩大传输距离 中继器仅作用于信号的电气部分，不考虑数据中是否存在错误数据或不适用于网段的数据 中继器是局域网环境下用来扩大网络规模的最简单、最廉价的互联设备，其有两个端口，两端的网络部分是网段，因此使用中继器连接起来的网段仍为一个局域网，但由于中继器工作在物理层，因此其不能连接两个具有不同速率的局域网，同时，中继器两端的网段必须为同一协议 从理论上来将，中继器的使用数目是无限的，网络也因此可以无限延长，但由于网络标准中对信号的延迟范围作出具体规定，因此中继器只能在该规定范围内工作，以避免引起网络故障 中继器使用数目遵循 5-4-3 规则，即使用中继器连接最多不超过 $5$ 个网段，最多有 $4$ 个物理层设备，只有 $3$ 个网段可以有设备 集线器集线器（Hub），本质上是一个多端口中继器，其在网络中只起到信号放大与转发的作用，不具备信号定向传送能力，即信号传输方向是固定的， 集线器是一个标准的共享设备，当一个端口收到数据后，将其从除输入端口外的所有端口转发出去，由其组成的网络是共享式网络，由集线器连接的网络在拓扑结构上属于星形拓扑结构，每个端口连接的网络部分是同一个网络的不同网段，同时其只能在半双工方式下工作 由于多台计算机同时通信的情况必然会发生，因此集线器无法分割冲突域，集线器的所有端口都属于同一个冲突域，也就是说，如果同时有两个或多个端口输入，那么在输出时将会出现冲突 故而集线器在一个时钟周期内只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将会导致信息的碰撞，使得工作效率极差 同时，连接在集线器上的工作主机会平分带宽，例如一个带宽为 $10Mb/s$ 的集线器上连接了 $8$ 台主机，那么当这 $8$ 台主机同时工作时，每台主机真正拥有的带宽为： \\frac{10}{8}Mb/s=1.25Mb/s【物理层接口特性】物理层考虑的是如何在连接各个计算机的传输媒体上传输比特流，不考虑具体的传输每天，因此物理层应尽可能屏蔽各种物理设备的差异，使数据链路层只需要考虑本层的协议和服务 物理层的主要任务可以描述为确定与传输媒体的接口有关的特性，即： 机械特性：定义物理连接的边界点，规定物理连接时所采用的规格、引线的数目、引脚的数量、排列情况等 电气特性：规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率、距离限制等 功能特性：指明某条线上出现某一电平的电压表示何种意义，接口部件的信号线的用途等 规程特性：定义各条物理线路的工作规程和时序关系 【传输介质】概述传输介质，又称传输媒体，其是发送设备与接收设备之间的物理通路 传输介质可以分为导向传输介质和非导向传输介质，导向传输介质中电磁波被导向沿着固体媒介传播，非导向传输介质可以是空气、真空、海水等 双绞线双绞线是最古老、最常用的传输介质，其由两根采用一定规则并排绞合、相互绝缘的铜导线组成，其带宽取决于铜线的粗细与传输距离 为减少对相邻导线的电磁干扰，常采用绞合的方法，同时，可在双绞线外加一层由金属丝编织成的屏蔽层，即屏蔽双绞线（STP），无屏蔽层的双绞线就被称为非屏蔽双绞线（UTP） 双绞线价格便宜，是最常用的传输介质之一，常用于局域网和传统电话网中 在模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里，距离太远时，对于模拟传输，要用放大器放大衰减信号，对于数字传输，要用中继器将失真的信号整形 同轴电缆同轴电缆由铜质导体芯线、绝缘层、网状编织屏蔽层、塑料外层构成，其具有良好的抗干扰特性，被广泛应用于传输较高速率的数据，传输距离更远，但价格要比双绞线贵 根据阻抗数值的不同，通常讲讲同轴电缆分为 $50\\Omega$ 同轴电缆和 $75\\Omega$ 同轴电缆，其中 $50\\Omega$ 同轴电缆主要用于传送基带数字信号，又称基带同轴电缆，常用于局域网中；$75\\Omega$ 同轴电缆主要用于传送宽带信号，又称宽带同轴电缆，常用于有线电视系统中 光纤光纤，即光导纤维，其通过传递光脉冲来通信，有光脉冲表示 $1$，无光脉冲表示 $0$ 光纤主要由纤芯和包层构成，光波通过纤芯进行传导，包层相较于纤芯有较低的折射率，当高折射率的介质射向低折射率的介质时，其折射角大于入射角，因此，如果入射角足够大，就会出现全反射，即光线碰到包层会折射回纤芯，这个过程不断重复，光就沿着光纤传输下去 只要从纤芯中射到纤芯表面的光线的入射角大于某一临界角度，就可以产生全反射，因此，可以存在多条不同入射角度的光线在同一条光纤内传输，这种光纤被称为多模光纤，其光源为发光二极管，光脉冲在其中传输时会逐渐展宽，造成失真，因此多模光纤只适用于近距离传输 若光纤的直径减小到只有一个光的波长，光纤就像一根波导一样，使光纤一直向前传播，不会产生多次反射，这样的光纤被称为单模光纤，其光源为定向性极好的激光二极管，衰耗较小，适合远距离传输，但其制造成本很高 无线传输介质无线电波无线电波具有较强的穿透能力，可以传输很长的距离，目前被广泛应用于手机通信、无线局域网（WLAN）等 其是将信号向所有方向散播，这样在有效距离范围内的接收设备就无须正对某一方向来的无线电波发射者进行通信连接 视线介质视线介质，是指高带宽无线通信中的微波、红外线、激光，他们都需要在发送方和接收方间有一条视线通路，有很强的方向性，均是沿直线传播 不同的是，红外通信和激光通信都要将传输信号分别转换为各自的信号格式，即红外光信号、激光信号，再直接从空间中传播 微波通信的频率较高、频段范围也很宽，信道容量很大，其在地面传播距离有限，超过一定距离后要用中继站来接力 卫星通信就是利用地球同步卫星来作为中继站转发微波信号，可以克服地面微波通信距离的限制，三颗相距 $120^\\circ$ 的同步卫星几乎能覆盖整个地球表面，基本能实现全球通信，其通信容量大、距离远、覆盖广，但端到端的传播延迟较长","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"物理层交换技术","slug":"computer-networks/08.物理层交换技术","date":"2019-09-17T10:04:00.000Z","updated":"2021-08-23T12:44:53.324Z","comments":true,"path":"notes/computer-networks/66a2c84f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/66a2c84f.html","excerpt":"【概述】交换技术，是指各台主机之间、各台通信设备之间、主机与通信设备之间为交换信息采用的数据格式和交换装置的方式 常见的交换技术有：电路交换、报文交换、分组交换","text":"【概述】交换技术，是指各台主机之间、各台通信设备之间、主机与通信设备之间为交换信息采用的数据格式和交换装置的方式 常见的交换技术有：电路交换、报文交换、分组交换 下图给出了三种数据交换方式的比较 由图可以看出，若要传送的数据量很大，且发送时间远大于呼叫时间，采用电路交换比较合适；当端到端的通路由多段链路组成，采用分组交换较为合适 从提高整个网络的信道利用率来看，报文交换和分组交换优于电路交换，其中分组交换比报文交换时延小，适用于计算机间突发的数据通信 【电路交换】在进行数据传输前，两个结点间必须先建立一条专用的物理通信路径，其由通信双方间的交换设备和链路逐段连接而成，且可能经过诸多中间结点，该线路在整个数据传输期间一直被独占，直到通信结束后才被释放 由此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放 需要注意的是，当电路建立后，除了源结点与目的结点外，电路上的任何结点均采用直通式收发数据，即不存在存储转发所消耗的时间 电路交换的优缺点如下： 优点 缺点 通信时延小，数据量大时是否明显 建立连接耗时间长 有序传输，不存在失序问题 线路独占，信道利用率低 无冲突，不会出现争用物理信道的问题 灵活性差，通信双方连接通路上任一结点出现故障，必须重新建立连接 适用范围广，既可传模拟信号，又可传数字信号 数据直达，不同终端间的通信难以规格化 实时性强，通信双方连接一旦建立，可随时通信 难以进行差错控制 控制简单，交换设备的控制较为简单 【报文交换】报文交换数据交换的单位是报文，报文携带有目标地址、源地址等信息 报文交换在交换结点采用存储转发方式，即交换设备会将到来的报文缓存，在检查数据包是否正确后，根据查找表选择一条合适的空闲线路，将报文转发出去 报文交换的优缺点如下： 优点 缺点 无需建立连接，用户可随时发送报文 存在转发时延，即数据进入交换结点后要经历存储、转发这一过程，包括接收报文、检验正确性、排队等 动态分配线路，根据网络状况选择合适的线路转发报文 对报文大小无限制，要求网络结点要有较大的缓存空间 线路可靠性高，若某条线路出现故障，可重新选择另一条路径传输 线路利用率高，通信双方不是固定占有一条通信线路，而是在不同时间段内占有该条物理信道 提供多目标服务，一个报文可同时发送到多个目的地址 【分组交换】概述分组交换也采用存储转发方式，但其解决了报文交换中大报文传输的问题 分组交换限制了每次传送的数据块大小的上限，将大的数据块划分为合理的小数据块，再加上必要的控制信息，从而构成分组（Packet） 网络结点根据分组的控制信息将分组发送到下一结点，下一结点接收到分组后，暂存下了排队等待传输，然后再根据分组信息继续选择下一结点，直到到达目的结点 根据通信子网向端点系统提供的服务，分组交换还可进一步分为面向连接的虚电路方式、无连接的数据报方式，这两种服务方式均由网络层提供 分组交换的优缺点如下： 优点 缺点 无建立时延，用户可随时发送分组 存在传输时延，且要求交换结点具有更强的处理能力 线路利用率高，通信双方不是固定占有一条通信线路，而是在不同时间段内占有该条物理信道 要传送额外的控制信息，一定程度上降低了通信效率，增加了处理时延 结点的缓冲区大小固定，存储管理比报文交换简单 若采用数据报服务，可能会出现失序、丢失、重复分组 流水线方式传输，减少传输时间 若采用虚电路服务，有呼叫建立、数据传输、虚电路释放三个过程，较为繁琐 分组较短，减少出错几率与重发数据量 数据报方式当作为通信子网用户的端系统要发送一个报文时，在端系统中实现的高层协议会将报文拆为若干带序号的数据单元，并在网络层加上控制信息形成数据报分组（网络层 PDU），之后，在发送过程中，中间结点会尽快找到最佳路由，转发各个分组 值得注意的是，不同的分组可以走不同的路径，也可以按照不同的顺序到达目的结点，在到达目的结点后，会对分组按照编号进行排序 以下图为例，假定主机 $A$ 要向主机 $B$ 发送分组，那么采用数据报方式转发分组过程如下： 主机 $A$ 将分组逐个发往与其直相连的结点 $A$，交换结点 $A$ 会将收到的分组缓存 交换结点 $A$ 查找自己的转发表，由于不同时刻网络状态不同，因此转发表内容会改变，故有的分组转发给结点 $C$，也有的分组转发给结点 $D$ 网络中的其他结点收到分组后，与步骤 2 相似，类似的转发分组，直到分组到达目的主机 $B$ 可以发现，数据报方式具有以下特点： 发送分组前不需建立连接 网络尽最大努力交付，不保证传输可靠性 每个分组独立选择路由，分组不一定按序到达目的结点 分组在交换结点存储转发时需要排队等待，会带来一定的时延 网络具有冗余路径，对故障适应力强 收发双方不独占某一链路，信道利用率较高 虚电路方式虚电路方式是电路交换与数据报方式的结合，充分发挥了两种方法的优点，以达到最佳的数据交换效果 在分组发送前，要求发送方和接收方建立一条逻辑上相连的虚电路，并且一旦连接建立，虚电路对应的物理路径就固定了 与电路交换类型，整个通信过程分为三个阶段：虚电路建立、数据传输、虚电路释放 端系统每次建立虚电路时，会选择一个不曾使用过的虚电路号分配给该虚电路，以区别于系统中的其他虚电路 在传输数据时，每个数据分组不仅要有分组号、检验和等控制信息，还要有其要通过的虚电路号，以区别于其他虚电路上的分组 同时，在虚电路网络上的每个结点都维持着一张虚电路表，其每一项记录了一个打开的虚电路的信息 以下图为例，假定主机 $A$ 要向主机 $B$ 发送分组，那么采用虚电路方式转发分组过程如下： 主机 $A$ 与主机 $B$ 之间建立一条逻辑通路，主机 $A$ 发送一个特殊的呼叫请求分组，该分组通过中间结点发往主机 $B$，若主机 $B$ 同意建立连接，就发送呼叫应答分组进行回应 虚电路建立后，主机 $A$ 可以通过虚电路以存储转发的方式向主机 $B$ 发送数据，主机 $B$ 也可以通过虚电路以存储转发的方式向主机 $A$ 发送数据 数据传送完毕后，主机 $A$ 发送释放请求分组以申请拆除虚电路，若主机 $B$ 同意拆除，就发送释放应答分组，之后整个连接逐段断开 可以发现，虚电路方式具有以下特点： 虚电路的建立与拆除需要额外的时间开销，适用于长时间、频繁的数据交换 虚电路的路由选择体现在连接建立阶段，连接建立后，传输路径就确定了 虚电路提供可靠通信功能，能保证每个分组正确有序到达 虚电路可以对两个数据端点进行流量控制，当接收方来不及接收数据时，可通知发送方暂缓发送 当网络中某个结点出现故障时，所有经过该结点的虚电路将遭到破坏","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"通信基础","slug":"computer-networks/07.通信基础","date":"2019-09-13T10:01:00.000Z","updated":"2021-08-23T12:45:03.142Z","comments":true,"path":"notes/computer-networks/1748423c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/1748423c.html","excerpt":"【基本概念】数据、信号数据，是传送信息的实体，是有意义的符号序列","text":"【基本概念】数据、信号数据，是传送信息的实体，是有意义的符号序列 信号，是数据的电气或电磁表现，是数据在传输过程中的存在形式 数据和信号都可用模拟或数字来修饰，其中： 连续变化的数据或信号称为模拟数据或模拟信号 取值为有限的离散数值的数据或信号称为数字数据或数字信号 信源、信宿、信道数据通信，是指数字计算机或其他数字终端间的通信，一个数据通信系统可划分为信源、信宿、信道这三个部分 信源：产生、发送数据的源头 信宿：接收数据的终点 信道：信号的传输媒介，可视为一条线路的逻辑部件，一般表示某一方向传送信息的介质 信源与信宿都是计算机或终端的装置，一条通信线路包含一条发送信道和一条接收信道 一个通信系统模型可表示为下图 同时，信道按照传输信号可分为传送模拟信号的模拟信道与传送数字信号的数字信道；按照传输介质可分为无线信道和有线信道 传输方式数据传输方式可以分为串行传输和并行传输： 串行传输：将数据二进制从低位到高位一个一个比特按顺序传输，该方式速度慢，费用低，适用于远距离传输 并行传输：将数据的多个比特通过多条信道同时传输，该方式速度快，费用高，适用于短距离传输 信道上传输的信号可分为基带信号和宽带信号： 基带信号：将数字信号 $1$、$0$ 直接用两种不同电压表示 宽带信号：将基带信号进行调制，形成的频分复用模拟信号 由此，信道上的信号传输可分为基带传输与宽带传输： 基带传输：在数字信道上传输基带信号，直接表达了要传输信息的信号，具有近距离衰减小，信号不易发生变化的特点 宽带传输：在模拟信道上传输宽带信号，将基带信号载波调制后，将频率范围搬移到较高的频段，具有信号变化再大也可过滤出基带信号的特点 从通信双方信息的交互方式来看，有以下三种基本方式： 单工通信：单方向通信，没有反方向的交互，仅需一条信道 半双工通信：通信双方均可发送、接收信息，但任何一方都不可同时发送和接收，需要两条信道 全双工通信：通信双方可同时发送、接收信息，需要两条信道 码元码元，是数字通信中数字信号的计量单位，其用固定时长的信号波形（数字脉冲）来表示一位 $k$ 进制数字，代表不同离散数值的基本波形（离散状态有 $k$ 个），在该固定时长内的信号称为 $k$ 进制码元 $1$ 码元可以携带多个比特的信息量，对于 $k$ 进制码元来说，其可携带 $\\log_2 k$ 比特的信息量 此外，码元的固定时长称为码元宽度 波特率与比特率速率，也称数据率，是数据的传输速率，表示单位时间内传输的数据量，可用码元传输速率和信息传输速率表示 码元传输速率，又称码元速率、波特率，表示单位时间内数字通信系统所传输的码元个数（信号变化次数），单位是波特（Baud） 1 Baud 表示数字通信系统每秒传输一个码元，这里的码元是任意 $k$ 进制的，也就是说，码元速率与进制数 $k$ 无关，只与码元长度 $T$ 有关 信息传输速率，又称信息速率、比特率，表示单位时间内数字通信系统所传输的二进制码元个数（比特数），单位是比特/秒（b/s，bps） 若一个码元携带 n bit 的信息量，那么 M Baud 的码元速率所对应的比特率为 M × n bit/s 带宽带宽，在模拟信号系统中，指信号具有的频带宽度（最高频率与最低频率的差），单位是赫兹（Hz） 在数字信号系统中，表示单位时间内从网络一点到另一点所能通过 的最高数据率，即单位时间内通过链路的比特数量，单位是比特/秒（b/s，bps） 噪声与失真噪声，是指对信号的干扰，对于信道噪声与分散到通信系统中各处噪声的集中表示被称为噪声源 在码元传输速率、信号传输距离、噪声这三个因素的影响下，可能会造成失真，最常见的现象就是码间串扰，即接收端收到的波形失去了码元间的界限 【奈奎斯特定理与香农定理】奈奎斯特定理奈奎斯特定理，又称奈氏准则，其指出在理想低通信道（带宽有限无噪声）中的极限码元传输率与极限数据传输率 设 $W$ 是理想低通信道的带宽，$N$ 为每个码元离散电平的数目（多少种不同的码元），那么： 极限码元速率：$2W$ 波特 极限信息速率：$2W\\log_2N$ 比特/秒 由此，对于奈氏准则，可以得出以下结论： 任何信道中，码元传输速率存在上限，若超出该上限，会出现由传输过快所导致的码间串扰 信道的频带越宽，即能通过的信号高频分量越多，就可以以更高的速率进行码元的有效传输 同时，奈氏准则对码元传输速率作出了限制，但信息传输速率没有限制，即没有对一个码元可以对应多少二进制位做出限制，因此要提高数据的传输速率，就要让每个码元能携带更多比特的信息量，这就需要采用多元制的调制方法 香农定理香农定理给出了带宽受限且存在高斯白噪声干扰的信道的极限信息传输率 设 $W$ 是信道带宽，$S$ 为信道传输信号的平均功率，$N$ 为信道内部高斯白噪声功率 那么，信号平均功率与噪声平均功率 $\\frac{S}{N}$ 与信噪比存在如下关系： 信噪比=10\\log_{10}(\\frac{S}{N}) \\quad dB例如，当 $\\frac{S}{N}=1000$ 时，信噪比为 $30dB$ 进一步，信道的极限数据传输率为： W\\log_2(1+\\frac{S}{N}) \\quad bps对于香农定理，可以得出以下结论： 信道带宽或信道中的信噪比越大，极限信息传输速率越高 对一定带宽和一定信噪比的信道，极限信息传输速率上限是确定的 只要信息的传输速率低于信道的极限信息传输速率，就能找到某种方法来实现无差错的传输 相较于极限信息传输速率，实际信道能达到传输速率要低很多 【编码与调制】概述对于数据来说，无论是数字数据还是模拟数据，在传输之前，都必须将其在信源端转换为信号，之后在信宿端将信号转换为数据 将数据变换为数字信号的过程称为编码，将数据变换为模拟信号称为调制 相应的，将数字信号变换为数据的过程称为解码，将模拟信号变换为数据的过程称为解调 数字数据可以通过数字发送器转换为数字信号传输，也可以通过调制器转换为模拟信号传输；模拟数据可以通过 PCM 编码器转换为数字信号传输，也可以通过放大器调制器转换为模拟信号传输 由此，形成了以下四种编码方式： 数字数据编码为数字信号 数字数据调制为模拟信号 模拟数据编码为数字信号 模拟数据调制为模拟信号 数字数据编码为数字信号数字数据编码为数字信号常用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数据信号 对于这种编码方式，具体使用什么样的数字信号来表示 $0$ 与 $1$，就是所谓的编码 编码的规则有多种，原则上能有效地将 $0$ 与 $1$ 区分开即可，常见的编码方式有以下几种： 归零码（RZ）：高电平表 $1$，低电平表 $0$，每个时钟周期中间归零（接收方以归零跳变为基准确定时钟周期以同步，但归零占据大量带宽） 非归零码（NRZ）：高电平表 $1$，低电平表 $0$（由于不归零难以同步，需要提取知道时钟周期） 反向非归零码（NRZI）：电平不变表 $1$，电平翻转表 $0$（翻转信号本身即可作为同步机制，但全 $1$ 时无法同步） 曼彻斯特码：将一码元分为两间隔，前高后低表 $1$，前低后高表 $0$，或采用相反的规定（通过间隔跳变可实现同步，但频带宽度为原始基带宽度的两倍） 差分曼彻斯特码：将一码元分为两间隔，当前码元的前半个电平与上一码元后半个电平相同表 $1$，不同表 $0$（可自同步，同时具有抗干扰强的特点，常用于局域网传输） 4B/5B 码：将要发送数据流的每 $4$ 位作为一组，按照 $4B/5B$ 编码规则转换为相应的 $5$ 位码，$5$ 位码共 $32$ 种组合，$16$ 种对应不同的 $4$ 位码，$16$ 种作为控制码或保留（编码效率 $50\\%$） 数字数据调制为模拟信号数字数据调制技术，在发送端将数字数据转换为模拟信号，在接收端将模拟信号还原成数字数据，分别对应于调制解调器的调制、解调过程 基本的调制方法分为以下三种： 幅移键控（ASK）：通过改变载波信号振幅来表示 $0$ 与 $1$，载波的频率、相位不变，实现简单但抗干扰差 频移键控（FSK）：通过改变载波信号频率来表示 $0$ 与 $1$，载波的振幅、相位不变，实现简单且抗干扰强 相移键控（PSK）：通过改变载波信号相位来表示 $0$ 与 $1$，载波的频率、振幅不变，分为绝对调相和相对调相 此外，在频率相同的情况下，将 ASK 与 PSK 结合，形成叠加信号进行传输的方法称为正交振幅调制（QAM） 设波特率为 $B$，采用 $m$ 个相位，每个相位 $n$ 种振幅，那么 QAM 技术的数据传输率为： R=B\\log_2(mn) \\quad bps模拟数据编码为数字信号首先给出奈奎斯特采样定理：在将模拟信号转换为数字信号时，假设原始信号中最大频率为 $f$，那么采样频率 $f_c$ 必须大于等于最大频率 $f$ 的两倍，才可保证采样后的数字信号完整保留原始模拟信号的信息，即： f_c\\geq2f在进行模拟数据编码为数字信号时，最典型的例子就是对音频信号进行编码的脉冲调制（PCM），其主要包括采样、量化、编码三个步骤 采样：对模拟信号周期性扫描，将时间上的连续信号转为时间上的离散信号，当满足 $f_c\\geq 2f$ 时，所得的离散信号可以无失真地表示被采样的模拟数据 量化：将采样得到的电平幅值按照一定分级标度，转换为对应的数字值并进行取整，使连续的电平幅值转换为离散的数字量 编码：将量化的结果转换为与其对应的二进制编码 模拟数据调制为模拟信号对于模拟数据调制为模拟信号来说，由于要实现传输的有效性，就要使用较高的频率 为此，该种调制方式可以使用频分复用技术（FDM），充分利用带宽资源 最常见的例子是电话机将模拟的声音数据加载到模拟的载波信号中进行传输","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"TCP/IP 参考模型","slug":"computer-networks/06.TCP-IP参考模型","date":"2019-09-10T13:49:00.000Z","updated":"2021-08-23T12:45:17.961Z","comments":true,"path":"notes/computer-networks/34f7351d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/34f7351d.html","excerpt":"【TCP/IP 模型】ARPA 在研究 ARPAnet 时提出了 TCP/IP 模型，其由于得到广泛应用而成为事实上的国际标准 TCP/IP 模型从低到高依次为：网络接口层、网际层、传输层、应用层","text":"【TCP/IP 模型】ARPA 在研究 ARPAnet 时提出了 TCP/IP 模型，其由于得到广泛应用而成为事实上的国际标准 TCP/IP 模型从低到高依次为：网络接口层、网际层、传输层、应用层 其层次结构与各层主要协议如下图 网络接口层的任务是从结点接收 IP 分组并将其发送到指定的物理网络上，指出了主机必须使用某种协议与网络连接，以便能在其上传递 IP 分组，具体的物理网络 TCP/IP 则没有真正描述，可以是各种类型的局域网，其类似于 OSI 的物理层与链路层 网际层是 TCP/IP 的关键，其能够将分组发往任何网络并独立地选择路由，但其不保证各分组有序的到达，各个分组的有序交付由高层负责，同时，其定义了标准的分组格式与协议（IP 协议），其类似于 OSI 的网络层 传输层的功能同样与 OSI 的传输层类似，其能够使发送端与目的端主机上的对等实体可以进行会话，主要使用以下两种协议： 传输控制协议 TCP：数据传输单位是报文段，面向连接，提供可靠交付 用户数据报协议 UDP：数据传输单位是用户数据报，无连接，不提供可靠交付，只提供尽最大可能的交付 应用层包含了所有的高层协议，其类似于 OSI 的会话层、表示层、应用层 【TCP/IP 与 OSI 的对比】TCP/IP 与 OSI 均采用分层的体系结构，而且分层的功能大体相似，同时，两者均采用独立协议栈的概念，此外，均可以解决异构网络的互联，实现世界上不同厂家的计算机间的通信 两者的层次对应关系如下图 TCP/IP 与 OSI 之间还存在诸多不同： OSI 精确定义了服务、协议、接口这三个概念，符合现代的面向对象程序设计思想；TCP/IP 对这三个概念没有明确区分 OSI 产生在协议发明前，未偏向任何协议，通用性好；TCP/IP 首先出现的是协议，模型实际上是对已有协议的描述，不会出现协议不能匹配模型的情况 OSI 最初只考虑用一种标准公用数据网将各种不同的系统互联，后来才认识到网际协议 IP 的重要性，在网络层中单独划分一个子层来完成异构网络互联；TCP/IP 设计之初就考虑到异构网络互联问题，将网际协议 IP 作为一个单独的层次 OSI 在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信；TCP/IP 认为可靠性是端到端的问题，因此在网际层仅有一种无连接的通信模式，但在传输层支持无连接和面向连接两种方式 【五层体系结构模型】五层体系结构无论是 OSI 还是 TCP/IP，两者都是不完美的，存在诸多讨论与批评 在学习计算机网络时，往往采用折中的方法，综合 OSI 与 TCP/IP 的优点，采用如下图所示的五层体系结构 通信协议栈每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议 当用户要传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，自然语言会转化为用于通信的通信数据 通信数据到达传输层，作为传输层的数据部分 SDU，再加上传输层的控制信息 PCI，组成传输层的 PDU，交付给网络层 传输层的 PDU 交付给网络层后，就成为了网络层的 SDU，然后再加上网络层的 PCI，组成网络层的 PDU，交付给数据链路层 网络层的 PDU 交付给数据链路层后，就成为了数据链路层的 SDU，然后再加上数据链路层的 PCI，组成数据链路层的 PDU，交付给物理层 物理层的数据通过通信线路传输，到达接收方结点协议栈，接收方再逆向一层层的将数据拆解，将最终拆解完毕的数据提交给用户","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"ISO/OSI 参考模型","slug":"computer-networks/05.ISO-OSI参考模型","date":"2019-09-10T12:48:00.000Z","updated":"2021-08-23T12:43:37.861Z","comments":true,"path":"notes/computer-networks/a578908.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/a578908.html","excerpt":"【概述】国际标准化组织 ISO 提出的网络体系结构模型称为开放系统互连参考模型（OSI/RM），通常简称为 OSI 参考模型，其有七层，从下到上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 对于前三层来说，统称为通信子网，其是为了联网而附加的通信设备，用于完成数据的传输功能；对于高三层来说，统称为资源子网，其相当于计算机系统，完成数据的处理功能；传输层承上启下，将通信子网与资源子网连接起来","text":"【概述】国际标准化组织 ISO 提出的网络体系结构模型称为开放系统互连参考模型（OSI/RM），通常简称为 OSI 参考模型，其有七层，从下到上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 对于前三层来说，统称为通信子网，其是为了联网而附加的通信设备，用于完成数据的传输功能；对于高三层来说，统称为资源子网，其相当于计算机系统，完成数据的处理功能；传输层承上启下，将通信子网与资源子网连接起来 【物理层】物理层（Physical Layer）的传输单位是比特，其主要任务就是在物理媒体上为数据端设备透明地传输原始比特流 物理层主要定义数据终端设备（DTE）、数据通信设备（DCE）的物理与逻辑连接方法，因此物理层协议又称为物理层接口标准 具体来说，对于两个通信结点及其中间的一段通信链路，物理层完成了以下工作： 物理层规定了通信链路与通信结点的连接处电路接口的参数，如机械形状、尺寸、交换电路数量等 物理层规定了通信链路上传输的信号意义与电气特征，如收到信号 $A$ 代表数字 $0$ 物理层规定了通信链路的传输模式（单工、双工、半双工） 需要注意的是，传输信息所利用的物理媒体，如双绞线、光缆等，并不在物理层协议之内，其属于物理层协议之下，因此物理媒体常被当作第 $0$ 层 【数据链路层】数据链路层（Data Link Layer）的传输单位是帧，其主要任务是将网络层传下来的 IP 数据报组装成帧，具体功能可概括为：成帧、差错控制、流量控制、传输管理 由于外界噪声的干扰，原始的物理连接在传输比特流时可能会出现错误，若两结点间规定了数据链路层协议，就可以对比特流进行检验，将收到的错误信息丢弃，即差错控制 在两个相邻结点传输数据时，由于两结点性能不同，可能会造成发送结点的发送速度快于接收结点的接收速度，如果不加以控制，接收结点就会丢弃许多来不及接收的数据，从而造成传输线路效率的下降，协调两结点的发送速度与接收速度即流量控制 对于广播式网络来说，数据链路层还要对共享信道的访问进行控制，为此数据链路层存在一个独特的子层——介质访问子层，专门用于控制共享信道的访问，这个控制过程，即传输管理功能 【网络层】网络层（Network Layer）的传输单位是数据报，其关心的是通信子网的运行控制，主要任务是将分组从源端传到目的端，为分组交换网上不同主机提供通信服务，具体功能可概括为：路由选择、流量控制、拥塞控制、差错控制、网际互联 对于实际的网络，若要从源端传送到目的端，无疑会有多条可以选择的路径（路由），网络层会根据实际网络的情况，利用相应的路由算法计算一条合适的路径，使得分组可以顺利的到达目的端，这个过程即路由选择过程 如果网络中的结点均来不及接收分组，需要丢弃大量分组的话，那么网络就处于拥塞状态，在该状态下，网络中的结点无法正常通信，网络层会进行拥塞控制以缓解这种拥塞 因特网是全世界最大的互联网，其由大量的异构网络通过路由器相互连接，因此因特网主要的网络层协议是无连接的网际协议（Internet Protocol，IP）与诸多路由选择协议，故而因特网的网络层由称为 IP 层，其连接大量异构网络的过程即网际互联 【传输层】传输层（Transport Layer）的传输单位是报文段（TCP）或用户数据报（UDP），其主要任务是负责主机中两个进程间的通信，具体功能可概括为：为端到端连接提供可靠的传输服务、流量控制、差错控制、传输管理 数据链路层所提供的，是点到点的通信，一个点是指一个硬件地址或 IP 地址，网络中参与通信的主机是通过硬件地址或 IP 地址标识的，因此点到点通信可认为是主机到主机的通信 而传输层所提供的，是端到端的通信，在主机中，一个进程用一个端口号来标识，因此端到端通信可认为是进程到进程的通信 使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在，换句话说，传输层对高层屏蔽了通信子网的交替与变化 此外，由于一个主机可同时运行多个进程，因此传输层具有复用与分用的功能： 复用：多个应用层进程可同时使用传输层的服务 分用：运输层收到的数据可分别交付给应用层相应的进程 【会话层】会话层（Session Layer）允许不同主机上各进程间进行会话，其利用传输层所提供的端到端的服务，向表示层实体提供建立连接并在连接上有序传输数据的服务，这种传输数据的服务过程即会话，也称建立同步（SYN） 具体来说，会话层负责管理主机间的会话进程，包括建立、管理、终止进程间的会话 此外，其使用的校验点技术能够令会话在通信失败时从校验点继续恢复通信，实现数据同步，最典型的例子就是传输大文件时的断点传送 【表示层】表示层（Presentation Layer）主要定义了两通信系统中交换信息的表示方式 由于不同机器所采用的编码与表示方式不同，使用的数据结构也不同，为了使不同表示的数据间能够相互通信，表示层采用抽象的标准方法来定义数据结构，同时采用标准编码格式（如：JEPG、ASCII） 此外，数据压缩、数据加密、数据解密，也是表示层所提供的数据变换功能 【应用层】应用层（Application Layer）是 OSI 模型的最高层，其是用户与网络的界面，为特定类型的网络应用提供访问 OSI 环境的手段 由于用户的实际需求多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用需求，因此应用层是最复杂的一层，使用的协议也是最多的一层 常见的应用层协议有：FTP、SMTP、HTTP 等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"计算机网络体系结构","slug":"computer-networks/04.计算机网络体系结构","date":"2019-09-06T13:48:00.000Z","updated":"2021-08-23T12:43:22.855Z","comments":true,"path":"notes/computer-networks/507ba1e8.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/507ba1e8.html","excerpt":"【计算机网络的层次结构】体系结构计算机网络各层及其协议的集合称为计算机网络的体系结构（Architecture），其是计算机网络中层次、各层协议、各层接口的集合，是网络及其所完成功能的精确定义","text":"【计算机网络的层次结构】体系结构计算机网络各层及其协议的集合称为计算机网络的体系结构（Architecture），其是计算机网络中层次、各层协议、各层接口的集合，是网络及其所完成功能的精确定义 网络体系结构是用何种硬件、软件所实现，是一个遵循这种体系结构的实现问题，也就是说，体系结构是抽象的，实现是具体的 分层原则计算机网络的体系结构具有可分层的特性，其将复杂的大系统分为若干较易实现的层次，分层的基本原则如下： 各层相互独立，每层均实现一种相对独立的功能，以降低整个大系统的复杂度 各层之间界面清晰，易于理解，彼此交互尽可能的少 各层功能的精确定义独立于具体的实现方法，每层选用合适的技术实现 下层对上层有独立性，即上层单向使用下层所提供的服务 整个分层结构能够促进标准化工作 层次结构在计算机网络的分层结构中，第 $n$ 层中的活动元素称为 $n$ 层实体，其是任何可发送或接收信息的硬件或软件进程，不同机器上的同一层称为对等层，对等层的实体称为对等实体 对于 $n$ 层实体上所实现的服务，被 $n+1$ 层所利用，在这种情况下，$n$ 层被称为服务提供者，$n+1$ 层称为服务使用者 具体来说，层次结构具有以下含义： 第 $n$ 层实体使用第 $n-1$ 层的服务来实现自身所定义的功能，同时向第 $n+1$ 层提供本层的服务，该服务是第 $n$ 层及下面各层提供的服务总和 最底层仅提供服务，是整个层次结构基础；中间各层既是下一层的服务使用者，又是上一层的服务使用者；最高层面向用户提供服务 上层只能通过相邻层的接口来使用下一层的服务，无法调用其他层的服务，同时，下层所提供服务的实现细节对上层透明 两台主机通信时，对等层在逻辑上有一条直接信道，其表现为不经过下层就把信息传给对方 数据单位在计算机网络的分层结构中，每层有着自己的传输数据单位，其名称、大小、含义均不同 在整个体系结构的各个层次中，每个报文分为两部分：SDU、PCI，两者共同组成 PDU 服务数据单元 SDU：报文的数据部分，是为了完成用户所要求的功能而应传送的数据，第 $n$ 层的服务数据单元记为 n-SDU 协议控制信息 PCI：报文的控制信息部分，是控制协议操作的信息，第 $n$ 层的协议控制信息记为 n-PCI 协议数据单元 PDU：对等层次传送的数据单元，第 $n$ 层的协议数据单元记为 n-PDU 在实际的网络中，每层协议数据单元都有一个通俗的名称，在物理层中，称为比特；在链路层中，称为帧；在网络层中，称为分组；在传输层中，称为报文 在各层间传输数据时，对于发送方，会将第 $n+1$ 层收到的 PDU 作为第 $n$ 层的 SDU，再加上第 $n$ 层的 PCI，就构成了第 $n$ 层的 PDU，之后交给第 $n-1$ 层后作为 $SDU$ 发送，而接受方则进行相反的处理 综上，三者的关系如下： \\begin{align} n-PDU &= n-SDU+n-PCI\\\\ &=(n-1)-SDU \\end{align} 【协议、接口、服务】协议网络协议（Network Protocol），是为网络中数据交换而建立的规则、标准、约定，其是控制两个对等实体进行通信的规则集合 网络协议是水平上的概念，也就是说，不对等实体之间是不存在协议的 协议由语法、语义、同步三个要素组成： 语法：规定了传输数据的格式 语义：规定了要完成的功能，即发出何种控制信息、完成何种动作、做出何种应答 同步：规定了执行各种操作的条件、时序关系 接口接口（Interface），是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定，每层只能为紧邻的层次定义接口 在典型的接口中，同一结点相邻两层的实体通过服务访问点（Service Access Point，SAP）进行交互，服务通过 SAP 提供给上层使用，第 $n$ 层的 SAP 就是第 $n+1$ 层可以访问第 $n$ 层服务的位置 每个 SAP 都有一个能够标识的地址，但其实是一个抽象的逻辑接口 服务服务（Service），是下层为紧邻的上层所提供的功能调用 服务是垂直的概念，对等实体在协议的控制下，能够令本层为上层提供服务，同时要实现本层协议还要使用下层的服务 上层在使用下层所提供的服务时，必须要与下层进行命令交换，这些命令被称为服务原语，其划分为以下四类： 请求（Request）：由服务用户发往服务提供者，请求完成某项工作 证实（Confirmation）：由服务提供者发往服务用户，作为对请求的证实 指示（Indication）：由服务提供者发往服务用户，指示用户进行某项工作 响应（Response）：由服务用户发往服务提供者，作为对指示的响应 这 4 类服务原语的关系如下图所示 协议、服务、接口关系协议、服务、接口之间的关系如下图所示 【服务类型】计算机网络提供的服务，可以按照以下三种方式进行分类： 1.面向连接服务与无连接服务 面向连接服务：通信前双方需建立连接，分配相应资源，通信完成后释放连接与所占用的资源 无连接服务：通信双方在需要发送数据时可直接发送，由系统选定线路进行传输，是一种不可靠服务，无法保证通信的可靠性 2.可靠服务与不可靠服务 可靠服务：网络具有纠错、检错、应答机制，能够保证数据正确、可靠地传送到目的地 不可靠服务：网络只是尽量正确、可靠的传送，无法保证数据正确、可靠地传送到目的地，是一种尽最大可能交付的服务 对于不可靠服务来说，若想保证数据的正确性，应由用户或应用来进行保障，例如在收到信息后判断信息的正确性，根据正确性来对发送方进行反馈 3.有应答服务与无应答服务 有应答服务：是指接收方在收到数据后向发送方作出相应的应答，该应答由传输系统内部自动实现 无应答服务：是值接收方收到数据后不自动给出应答，若需要应答，则由高层实现","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"计算机网络性能指标","slug":"computer-networks/03.计算机网络性能指标","date":"2019-09-06T09:36:00.000Z","updated":"2021-08-28T14:00:23.447Z","comments":true,"path":"notes/computer-networks/d8e88f84.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/d8e88f84.html","excerpt":"【速率】速率（Speed），又称数据率或者比特率，是指连接到计算机网络上的主机在数字信道上传送数据的速率 其单位为比特/秒（b/s，bps）","text":"【速率】速率（Speed），又称数据率或者比特率，是指连接到计算机网络上的主机在数字信道上传送数据的速率 其单位为比特/秒（b/s，bps） 在数据率较高时，可用 kb/s、Mb/s、Gb/s 来表示，其中，对于 k、M、G 有： k=10^3,M=10^6,G=10^9此外，在计算机网络中，通常将最高数据率称为带宽 【带宽】带宽（Bandwidth），是通信领域中的概念 对于模拟信道来说，其表示信道中允许通过的信号频带范围，即信号的最高频率与最低频率差，单位是赫兹（Hz） 对于数字信道来说，其表示网络线路所能传送数据的能力，即数字信道所能传送的最高数据率，单位是比特/秒（b/s，bps） 【吞吐量】吞吐量（Throughput），是单位时间内通过某个网络、或信道、或接口的数据量 其大小受制于网络带宽或网络额定速率的限制 【时延】时延（Delay），是数据从网络的一端传送到另一端所需的总时间，其由发送时延、传播时延、处理时延、排队时延构成，即： 总时延=发送时延+传播时延+处理时延+排队时延1.发送时延 发送时延，又称传输时延，是结点将分组的所有比特推向传输链路所需的时间，即从发送分组的第一个比特起，到该分组最后一个比特发送完毕所需要的时间 其计算公式为： 发送时延=\\frac{分组长度}{信道宽度}值得注意的是，所谓的高速链路，其提高的是数据发送率，以此来减少数据的发送时延，并非是提高比特在链路上的传播速率 2.传播时延 传播时延，是电磁波在信道中传播一定距离花费的时间，即一个比特从链路的一端传播到另一端所需的时间 其计算公式为： 传播时延=\\frac{信道长度}{电磁波在信道上的传播速率}3.处理时延 处理时延，是数据在交换结点为存储转发而进行的一些必要的处理所花费的时间，例如：分析分组首部、从分组中提取数据、差错检验、寻找适当路由等 该时延受制于交换结点设备硬件的影响，可视为一个固定值 4.排队时延 排队时延，是指分组在进入路由器后需要于路由器的输入队列中排队等待处理，待路由器确定转发端口后，还要在输出队列中排队等待转发 该时延受制于网络状况与路由器实际情况，在计算总时延时一般忽略不计 当从结点 A 发往结点 B 时，四种时延产生的地方如下 【时延带宽积】时延带宽积（Bandwidth-delay Product），是指发送端发送的第一个比特即将到达终点时，发送端已经发送了多少个比特，其单位为比特（bit） 因此，其又被称为以比特为单位的链路长度，即： 时延带宽积=传播时延 \\times 信道带宽如图，考虑一个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面表示链路带宽，则时延带宽积表示为该管道可容纳的比特数量 【往返时延】往返时延（Round-Trip Time，RTT），是指从发送端发送数据开始，到发送端收到来自接收端的确认总共经历的时延，这里假设接收端收到发送端的数据后立即发送确认 在互联网中，往返时延还包括各中间结点的处理时延、排队时延、转发数据时的发送时延 【利用率】信道利用率，指出信道有百分之多少的时间是有数据通过的，完全空闲的信道利用率是 $0$ 其计算方式如下： 信道利用率=\\frac{有数据通过的时间}{总时间}需要注意的是，并非信道利用率越高越好 网络利用率，指出网络有百分之多少的时间是有数据通过的，其值即为全网络的信道利用率的加权平均值信道利用率并非越高越好 如下图所示，当某信道或某网络的利用率增大时，该信道引起的时延也就迅速增加 假设 $D_0$ 为网络空闲时的时延，$D$ 为网络当前的时延，$U$ 为网络利用率，则时延与网络利用率的关系如下： D=\\frac{D_0}{1-U}","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"计算机网络分类","slug":"computer-networks/02.计算机网络分类","date":"2019-09-03T15:14:00.000Z","updated":"2021-08-23T12:44:05.681Z","comments":true,"path":"notes/computer-networks/94664e0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/94664e0.html","excerpt":"【分布范围】按照网络的分布范围，网络可分为以下四类： 广域网 LAN：因特网的核心，采用交换技术，提供长距离通信，覆盖范围几十千米到几千千米 城域网 MAN：采用以太网技术，常并入局域网的范围进行讨论，覆盖范围 5km 到 50 km 局域网 LAN：采用广播技术，通过高速线路连接，覆盖范围几十米到几千米 个人区域网 PAN：采用无线技术，覆盖范围约 10m","text":"【分布范围】按照网络的分布范围，网络可分为以下四类： 广域网 LAN：因特网的核心，采用交换技术，提供长距离通信，覆盖范围几十千米到几千千米 城域网 MAN：采用以太网技术，常并入局域网的范围进行讨论，覆盖范围 5km 到 50 km 局域网 LAN：采用广播技术，通过高速线路连接，覆盖范围几十米到几千米 个人区域网 PAN：采用无线技术，覆盖范围约 10m 其中，局域网由于采用广播技术，其工作在链路层，不需要网络层，仅要求其能通过物理层的服务访问点来获取物理层所提供的服务，同时，广域网与局域网的通过路由器来进行互联 【传输技术】按照网络的传输技术，网络可分为以下两类： 广播式网络：采用广播技术，所有联网计算机共享一个公用信道 点对点网络：采用分组存储转发与路由选择机制，每条物理线路连接一对计算机 【拓扑结构】拓扑结构是指网络中结点（路由器、主机等）与通信线路间的几何拓扑关系表示的网络结构，根据结构的不同，可分为以下六类网络： 星形网络：每个终端设备以单独线路与中央设备连接，成本高，中心结点对故障敏感 环形网络：所有终端设备连接成一个环，环中信号单向传输，最典型的例子是令牌环状局域网 总线形网络：单根传输线将终端设备连接起来，建网容易，重负载时效率不高，总线任一处对故障敏感 树形网络：结点按照树结构进行连接，具有层状结构，父结点对故障敏感 网状形网络：每个结点至少有两条路径与其他结点相连，常用于广域网，可靠性高，但控制复杂成本高 混合形网络：根据实际需要对上述五种结构进行的混合拓扑结构 需要注意的是，网络拓扑结构取决于通信子网 【使用者】按照网络的使用者，可分为以下两类网络： 公用网：电信公司出资建造的大型网络，所有愿意按照公司规定缴纳费用的人均可使用 专用网：某部门为满足其特殊业务的需要而建造的网络，不向本单位外的人提供服务 【交换技术】交换技术是指各主机、各通信设备、主机与通信设备间为交换信息所采用的数据格式与交换装置的方式，按照交换技术，可将网络分为以下三类： 电路交换网络：源节点与目的结点间建立一条专用通路以传送数据，包括建立连接、传输数据、断开连接三个阶段 报文交换网络：采用存储转发机制，将数据分割成一个报文进行传输，整个报文传送到相邻结点全部存储后，再转发给下一结点，如此往复，直到到达目的结点 分组交换网络：采用存储转发机制，但与报文交换网络不同的是，其将数据分为较短的固定长度的数据分组一个个进行传输，每个分组传送到相邻结点存储后，立即转发给下一结点 【传输介质】传输介质可分为有线、无线两类，由此网络也可以分为： 有线网络：双绞线网络、同轴电缆网络等 无线网络：蓝牙、微波、无线电等","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"计算机网络概述","slug":"computer-networks/01.计算机网络概述","date":"2019-09-03T13:37:00.000Z","updated":"2021-08-23T12:44:13.934Z","comments":true,"path":"notes/computer-networks/7c4ca347.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-networks/7c4ca347.html","excerpt":"【计算机网络】计算机网络是将一个个分散的、具独立功能的计算机系统，利用通信设备、物理线路连接起来，并由功能完善的软件所实现的能够资源共享与信息传递的系统 在计算机网络的不同发展阶段，对计算机网络的定义也不同，可分为以下三类：","text":"【计算机网络】计算机网络是将一个个分散的、具独立功能的计算机系统，利用通信设备、物理线路连接起来，并由功能完善的软件所实现的能够资源共享与信息传递的系统 在计算机网络的不同发展阶段，对计算机网络的定义也不同，可分为以下三类： 在计算机网络发展的早期阶段，普遍认为只要是能够实现远程信息处理的系统，或者能够达到资源共享的系统，都是计算机网络，这种观点在广义上定义了一个计算机通信网络，其在物理结构上具有计算机网络的雏形 在当前阶段，普遍认为计算机网络是以能够相互共享资源的方式互联而成的自治计算机系统的集合，其目的是为了资源共享，网络的组成单元是分布在不同位置的独立的自治计算机，网络中所有的计算机都遵循网络协议这一统一规则 在未来网络发展追求的目标中，认为计算机网络是一个能为用户自动管理资源的网络操作系统，其能够调用用户所需的资源，整个网络就像一个大型计算机系统一样，对用户透明，用户使用网络就像使用一台单一的超级计算机，无需知道网络的存在，也无需知道资源的位置信息 【计算机网络的发展】计算机网络的发展经过了三个阶段 第一阶段的发展经过三个时期：阿帕网（ARPAnet）、互联网（internet）、因特网（Internet） 在美苏冷战时期，美国国防部高级研究计划局（ARPA）提出设计分散的指挥系统，其研究出了最早期的计算机网络阿帕网（ARPAnet），其是一个无线分组交换网与卫星通信网的网络，但其只能连接同一类型的网络 随着信息量的增长，希望能够实现不同网络的互联，由此出现了互联网（internet） 在 1983 年，阿帕网接受 TCP/IP 协议，选定 Internet 为主要的计算机通信系统，由此诞生了因特网（Internet） 简单来说，网络将多个计算机连接在一起，互联网将多个网络连接在一起，因特网，是世界上最大的互联网 第二阶段是具有三级结构的网络：主干网、地区网、校园网/企业网 自 1985 年起，美国国家科学基金会 NSF 围绕 6 个大型计算机中心建设计算机网络，即国家科学基金网 （NSFNET），该网络是三级结构，最底层是校园网、企业网，中间层是地区网，最顶层是校园网或企业网 第三阶段是具多层次 ISP 结构的网络 随着信息量的增长，传统的三级结构网络不足以面临信息量激增所带带来的问题，由此政府将网络业务承包给公司，即因特网服务提供商 ISP，其是一个面向广大用户综合提供互联网接入业务、信息业务、增值业务的公司（例如：中国移动、中国联通），其分为主干 ISP、地区 ISP、本地 ISP 【计算机网络标准化工作及相关组织】RFC 文档因特网的所有标准均以 RFC（Request For Comments）文档的形式在因特网上发布，但并非所有的 RFC 均是因特网标准，一个 RFC 文档在上升到因特网标准需要经过以下四个阶段： 因特网草案：该阶段的文档还不是 RFC 文档 建议标准：该阶段开始的文档正式成为 RFC 文档 草案标准：对建议标准的进一步修改、更正、完善 因特网标准：该阶段的 RFC 文档正式成为因特网标准 除上述的基本四个阶段外，还有实验的 RFC 文档、提供信息的 RFC 文档、历史的 RFC 文档 标准化组织在国际上，负责制定、实施相关网络标准的组织主要有以下几个： 国际标准化组织 ISO：主要制定网络标准、规范，其制定的最出名的标准为 ISO/OSI 参考模型 国际电信联盟 ITU：主要制定远程通信标准 国际电气电子工程师协会 IEEE：学术机构，其在通信领域制定的最出名的标准为 IEEE 802 标准 因特网工程任务组 IETF：主要制定因特网相关标准 RFC 文档 【计算机网络的功能】计算机网络具有以下五大功能： 数据通信：最基本、最重要，用于实现计算机间信息传输，将不同地理位置的计算机联系起来，统一调配、控制、管理 资源共享：软件、硬件、数据共享，使网络中的资源互通有无，极大提高资源利用率 分布式处理：当网络中某计算机负载过重时，可将其处理的某复杂任务分配给网络中其他计算机，通过利用空闲计算机资源以提高系统的利用率 提高可靠性：计算机网络中的各台计算机可以通过网络互为代替机 负载均衡：将工作任务均衡分配给网络中的各台计算机 【计算机网络的组成】组成部分从计算机网络的组成部分来看，一个完整的计算机网络包括：硬件、软件、协议三大部分 硬件，主要由主机（终端设备）、通信链路（双绞线、光缆等）、交换设备（路由器、交换机等）、通信处理机（网卡等）组成 软件，主要由各主机中用于实现资源共享与用户数据交换的各种工具软件，如网络操作系统、FTP 程序、聊天程序等 协议，是计算机网络的核心，其规定了网络传输数据时所遵循的规范 工作方式对于因特网来说，从其工作方式来看，其包括：边缘部分、核心部分两个部分 边缘部分由所有连接到因特网上、供用户使用的主机组成，用来数据通信和资源共享 核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性与交换服务 功能组成从计算机网络的功能组成来看，一个完整的计算机网络包括：通信子网、资源子网两大网络 通信子网由各种传输介质、通信设备、相应的网络协议组成，其令网络具有数据传输、数据交换、数据控制、数据存储的能力，从而令网络中计算机间能够进行数据通信 资源子网是实现资源共享功能的设备及其软件的集合，为网络用户提供其他计算机上的硬件资源、软件资源、数据资源的资源共享服务 从 ISO/OSI 网络体系结构上来看，通信子网与资源子网依靠传输层连接，两者具体包含如下： 通信子网：物理层（网桥）、链路层（交换机）、网络层（路由器） 资源子网：会话层、表示层、应用层（计算机软件）","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机网络","slug":"notes/computer-networks","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-networks/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"网络相关","slug":"network","permalink":"https://alex-mcavoy.github.io/tags/network/"},{"name":"计算机网络","slug":"computer-networks","permalink":"https://alex-mcavoy.github.io/tags/computer-networks/"}],"author":"Alex_McAvoy"},{"title":"支持向量回归","slug":"machine-learning/43.支持向量回归","date":"2019-08-21T11:35:00.000Z","updated":"2023-04-06T06:45:09.604Z","comments":true,"path":"artificial-intelligence/machine-learning/afd4765.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/afd4765.html","excerpt":"References: [ML] 支持向量回归 | SVR | SVM SVR（Support Vactor Regression）支持向量回归机 【引入】支持向量机是针对二分类问题提出的，其通过最大化间隔来找到一个分离超平面，使得绝大多数样本点位于两个决策边界的外侧","text":"References: [ML] 支持向量回归 | SVR | SVM SVR（Support Vactor Regression）支持向量回归机 【引入】支持向量机是针对二分类问题提出的，其通过最大化间隔来找到一个分离超平面，使得绝大多数样本点位于两个决策边界的外侧 而支持向量回归（Support Vector Regression）是支持向量机的一种改进，用于解决回归问题，其同样是考虑最大化间隔，但是考虑的是两个决策边界之间的点，使尽可能多的样本点位于间隔内 换句话说，SVM 要使超平面到最近的样本点的间隔最大，SVR 则要使超平面到最远的样本点的间隔最小 【假设形式】对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in \\mathcal{Y}$，支持向量机学习到的模型为 $f(\\mathbf{x})=\\boldsymbol{\\omega}\\cdot \\mathbf{x} +\\theta$，使得 $f(\\mathbf{x_i})\\simeq y_i$ 假设能容忍 $f(\\mathbf{x}_i)$ 与 $y_i$ 间最多有 $\\varepsilon$ 的偏差，即仅当 $f(\\mathbf{x}_i)$ 与 $y_i$ 之间差距的绝对值大于 $\\varepsilon$ 时才计算损失，这相当于以 $f(\\mathbf{x})$ 为中心，构建了一个宽度为 $2\\varepsilon$ 的间隔带，若训练样本落于该间隔带，则认为预测正确 由此，可给出支持向量回归的优化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2} ||\\boldsymbol{\\omega}||_2^2 \\\\ s.t. && | y_i-(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta) | \\leq \\varepsilon,&& i=1,2,\\cdots,n \\end{matrix}其中，$\\varepsilon&gt;0$ 是间隔带大小 通过求解最优化问题，可以得到超平面： S:\\boldsymbol{\\omega}^*\\cdot\\mathbf{x}+\\theta^* = 0以及相应的回归函数： f(\\mathbf{x}) = \\boldsymbol{\\omega}^*\\cdot\\mathbf{x} + \\theta^*【原始问题】为每个样本点 $(\\mathbf{x}_i,y_i)$ 引入松弛变量 $\\xi_i$ 和 $\\hat{\\xi_i}$，即每个样本点分别到两个决策边界的距离 此时，支持向量回归的优化问题可写为： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta,\\xi_i,\\hat{\\xi_i}} && \\frac{1}{2} ||\\boldsymbol{\\omega}||_2^2 +C\\sum\\limits_{i=1}^n (\\xi_i+\\hat{\\xi_i}) \\\\ s.t. && y_i-(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta) \\leq \\varepsilon + \\xi_i \\\\ && (\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)-y_i\\leq \\varepsilon+\\hat{\\xi_i} \\\\ && \\xi_i\\geq 0 \\\\ && \\hat{\\xi_i}\\geq 0,&& i=1,2,\\cdots,n \\end{matrix}即为支持向量回归的原始问题，其中，$C$ 为正则化常数 可以发现，支持向量回归只对间隔外的样本进行惩罚，当样本点位于间隔内，不计算其损失 【对偶问题】对偶问题的转化为求解支持向量回归的原始问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta,\\xi_i,\\hat{\\xi_i}} && \\frac{1}{2} ||\\boldsymbol{\\omega}||_2^2 +C\\sum\\limits_{i=1}^n (\\xi_i+\\hat{\\xi_i}) \\\\ s.t. && y_i-(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta) \\leq \\varepsilon + \\xi_i \\\\ && (\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)-y_i\\leq \\varepsilon+\\hat{\\xi_i} \\\\ && \\xi_i\\geq 0 \\\\ && \\hat{\\xi_i}\\geq 0,&& i=1,2,\\cdots,n \\end{matrix}应用拉格朗日对偶性，通过求解对偶问题来得到原始问题的最优解 首先，构建拉格朗日函数，即为每个不等式约束引入拉格朗日乘子 $\\lambda_i\\geq0$、$\\hat{\\lambda_i}\\geq 0$、$\\mu_i\\geq 0$、$\\hat{\\mu_i}\\geq 0$，即： \\begin{align*} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) =& \\frac{1}{2} ||\\boldsymbol{\\omega}||_2^2 + C\\sum_{i=1}^n (\\xi_i+\\hat{\\xi_i}) + \\sum_{i=1}^n \\lambda_i \\big( y_i-(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)-\\varepsilon-\\xi_i \\big) \\\\ &+\\sum_{i=1}^n \\hat{\\lambda_i} \\big( (\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)-y_i-\\varepsilon-\\hat{\\xi_i} \\big) -\\sum_{i=1}^n\\mu_i\\xi_i - \\sum_{i=1}^n\\hat{u_i}\\hat{\\xi_i} \\\\ \\end{align*}其中，$\\boldsymbol{\\lambda}=(\\lambda_1,\\lambda_2,\\dots,\\lambda_n)^T$、$\\hat{\\boldsymbol{\\lambda}}=(\\hat{\\lambda_1},\\hat{\\lambda_2},\\dots,\\hat{\\lambda_n})^T$、$\\boldsymbol{\\mu}=(\\mu_1,\\mu_2,\\dots,\\mu_n)^T$、$\\hat{\\boldsymbol{\\mu}}=(\\hat{\\mu_1},\\hat{\\mu_2},\\dots,\\hat{\\mu_n})^T$ 为拉格朗日乘子向量 此时，根据拉格朗日对偶性，原始问题的对偶问题就变为极大极小问题，即： \\max_{\\boldsymbol{\\lambda},\\hat{\\boldsymbol{\\lambda}},\\boldsymbol{\\mu},\\hat{\\boldsymbol{\\mu}}} \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\hat{\\boldsymbol{\\xi}}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}})因此，为了得到对偶问题的解，就要先求拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}})$ 对 $\\boldsymbol{\\omega}$、$\\theta$、$\\boldsymbol{\\xi}$、$\\hat{\\boldsymbol{\\xi}}$ 的极小，再求对 $\\boldsymbol{\\lambda}$、$\\hat{\\boldsymbol{\\lambda}}$、$\\boldsymbol{\\mu}$、$\\hat{\\boldsymbol{\\mu}}$ 的极大 注：关于拉格朗日函数与拉格朗日对偶性，详见 拉格朗日乘子法与对偶性 对偶问题中的极小问题对于对偶问题中的极小问题： \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\hat{\\boldsymbol{\\xi}}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}})令拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}})$ 分别对 $\\boldsymbol{\\omega}$、$\\theta$、$\\boldsymbol{\\xi}$、$\\hat{\\boldsymbol{\\xi}}$ 求偏导，并令其等于 $0$，即： \\begin{align*} \\triangledown_{\\boldsymbol{\\omega}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) &= \\boldsymbol{\\omega} - \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i}) \\mathbf{x}_i = 0 \\\\ \\triangledown_{\\boldsymbol{\\theta}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) &=\\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i}) = 0 \\\\ \\triangledown_{\\boldsymbol{\\xi_i}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) &=C -\\lambda_i -\\mu_i = 0 \\\\ \\triangledown_{\\boldsymbol{\\hat{\\xi_i}}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) &=C -\\hat{\\lambda_i} -\\hat{\\mu_i} = 0 \\\\ \\end{align*}可得： \\begin{gather*} \\boldsymbol{\\omega} = \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i}) \\mathbf{x}_i \\\\ \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i}) = 0 \\\\ C=\\lambda_i+\\mu_i \\\\ C=\\hat{\\lambda_i}+\\hat{\\mu_i} \\\\ \\end{gather*}将上式带回拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}})$ 中，有： \\begin{align*} &L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) \\\\ =& \\frac{1}{2} ||\\boldsymbol{\\omega}||_2^2 + C\\sum_{i=1}^n (\\xi_i+\\hat{\\xi_i}) + \\sum_{i=1}^n \\lambda_i \\big( y_i-(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)-\\varepsilon-\\xi_i \\big) \\\\ &+\\sum_{i=1}^n \\hat{\\lambda_i} \\big( (\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)-y_i-\\varepsilon-\\hat{\\xi_i} \\big) -\\sum_{i=1}^n\\mu_i\\xi_i - \\sum_{i=1}^n\\hat{u_i}\\hat{\\xi_i} \\\\ =& \\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^m(\\lambda_i-\\hat{\\lambda_i})(\\lambda_j-\\hat{\\lambda_j})\\mathbf{x}_i\\cdot\\mathbf{x}_j + \\sum_{i=1}^n ( C\\xi_i + C\\hat{\\xi_i} ) \\\\ &+ \\sum_{i=1}^n \\lambda_iy_i - \\sum_{i=1}^n\\lambda_i\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i-\\theta\\sum_{i=1}^n \\lambda_i - \\varepsilon\\sum_{i=1}^n \\lambda_i - \\sum_{i=1}^n\\lambda_i\\xi_i \\\\ &- \\sum_{i=1}^n \\hat{\\lambda_i}y_i + \\sum_{i=1}^n\\hat{\\lambda_i}\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i + \\theta\\sum_{i=1}^n \\hat{\\lambda_i} - \\varepsilon\\sum_{i=1}^n \\hat{\\lambda_i} - \\sum_{i=1}^n\\hat{\\lambda_i}\\hat{\\xi_i} \\\\ &- \\sum_{i=1}^n\\mu_i\\xi_i - \\sum_{i=1}^n\\hat{u_i}\\hat{\\xi_i} \\\\ =& \\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^m(\\lambda_i-\\hat{\\lambda_i})(\\lambda_j-\\hat{\\lambda_j})\\mathbf{x}_i\\cdot\\mathbf{x}_j-\\sum_{i=1}^n(\\lambda_i-\\hat{\\lambda_i})\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i \\\\ &+ \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i})y_i-\\theta\\sum_{i=1}^n(\\lambda_i-\\hat{\\lambda_i})-\\varepsilon\\sum_{i=1}^n(\\lambda_i+\\hat{\\lambda_i}) \\\\ &+ \\sum_{i=1}^n \\Big( (\\lambda_i+\\mu_i)\\xi_i + (\\hat{\\lambda_i}+\\hat{\\mu_i})\\hat{\\xi_i} \\Big) -\\sum_{i=1}^n(\\mu_i\\xi_i +\\lambda_i\\xi_i + \\hat{\\lambda_i}\\hat{\\xi_i} + \\hat{u_i}\\hat{\\xi_i}) \\\\ =& -\\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^m(\\lambda_i-\\hat{\\lambda_i})(\\lambda_j-\\hat{\\lambda_j})\\mathbf{x}_i\\cdot\\mathbf{x}_j + \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i})y_i - \\varepsilon\\sum_{i=1}^n(\\lambda_i+\\hat{\\lambda_i}) \\end{align*}故有： \\begin{align*} \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\hat{\\boldsymbol{\\xi}}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}}) =& -\\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^m(\\lambda_i-\\hat{\\lambda_i})(\\lambda_j-\\hat{\\lambda_j})\\mathbf{x}_i\\cdot\\mathbf{x}_j \\\\ &+ \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i})y_i - \\varepsilon\\sum_{i=1}^n(\\lambda_i+\\hat{\\lambda_i}) \\end{align*}对偶问题中的极大问题对于对偶问题中的极大问题： \\max_{\\boldsymbol{\\lambda},\\hat{\\boldsymbol{\\lambda}},\\boldsymbol{\\mu},\\hat{\\boldsymbol{\\mu}}} \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\hat{\\boldsymbol{\\xi}}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\hat{\\xi}},\\boldsymbol{\\lambda},\\boldsymbol{\\hat{\\lambda}},\\boldsymbol{\\mu},\\boldsymbol{\\hat{\\mu}})即为对偶问题，有： \\begin{matrix} \\max\\limits_{\\boldsymbol{\\lambda},\\hat{\\boldsymbol{\\lambda}}} && -\\frac{1}{2} \\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m(\\lambda_i-\\hat{\\lambda_i})(\\lambda_j-\\hat{\\lambda_j})\\mathbf{x}_i\\cdot\\mathbf{x}_j + \\sum\\limits_{i=1}^n (\\lambda_i-\\hat{\\lambda_i})y_i - \\varepsilon\\sum\\limits_{i=1}^n(\\lambda_i+\\hat{\\lambda_i}) \\\\ s.t. && \\sum\\limits_{i=1}^n(\\lambda_i-\\hat{\\lambda_i})= 0 \\\\ && 0\\leq \\lambda_i,\\hat{\\lambda_i} \\leq C,\\quad i=1,2,\\cdots,n \\end{matrix}假设上述的对偶问题对 $\\boldsymbol{\\lambda}$、$\\hat{\\boldsymbol{\\lambda}}$、$\\boldsymbol{\\xi}$、$\\hat{\\boldsymbol{\\xi}}$ 的一个解为 $\\boldsymbol{\\lambda}^* = (\\lambda_1^*,\\lambda_2^*,\\cdots,\\lambda_n^*)^T$， $\\hat{\\boldsymbol{\\lambda}}^* = (\\hat{\\lambda_1}^*,\\hat{\\lambda_2}^*,\\cdots,\\hat{\\lambda_n}^*)^T$、$\\boldsymbol{\\xi}^* = (\\xi_1^*,\\xi_2^*,\\cdots,\\xi_n^*)^T$， $\\hat{\\boldsymbol{\\xi}}^* = (\\hat{\\xi_1}^*,\\hat{\\xi_2}^*,\\cdots,\\hat{\\xi_n}^*)^T$、 可以发现，对偶问题满足 KKT 条件，即： \\begin{gather*} \\lambda_i^* \\big( \\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\xi_i^* \\big) = 0 \\\\ \\hat{\\lambda_i^*} \\big( \\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\hat{\\xi_i^*} \\big) = 0 \\\\ \\lambda_i^*\\hat{\\lambda_i^*} = 0 \\\\ \\xi_i^*\\hat{\\xi_i^*} = 0 \\\\ (C-\\lambda_i^*)\\xi_i^* = 0 \\\\ (C-\\hat{\\lambda_i^*})\\hat{\\xi_i^*} = 0 \\end{gather*}故而有： \\boldsymbol{\\omega}^* = \\sum_{i=1}^n (\\lambda_i-\\hat{\\lambda_i})\\mathbf{x}_i可以看出，当且仅当 $(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\xi_i^* =0$ 时，$\\lambda_i^*$ 可取非零值，当且仅当 $(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\hat{\\xi_i}^* =0$ 时，$\\hat{\\lambda_i}^*$ 可取非零值，换言之，仅当样本 $(\\mathbf{x}_i,y_i)$ 不落于 $\\varepsilon$ 间隔带时，相应的 $\\lambda_i$ 和 $\\hat{\\lambda_i}$ 才可取非零值 此外，约束 $(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\xi_i^* =0$ 和 $(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\hat{\\xi_i}^* =0$ 不能同时成立，否则有 $\\xi_i^*=\\hat{\\xi_i^*}=\\varepsilon$，因此 $\\lambda_i$ 和 $\\hat{\\lambda_i}$ 中至少有一个为零，即 $\\lambda_i\\hat{\\lambda_i}$ 而对于每个样本 $(\\mathbf{x}_i,y_i)$，都有 $(C-\\lambda_i^*)\\xi_i^* = 0$ 且 $(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-y_i -\\varepsilon-\\xi_i^* =0$，于是在得到 $\\lambda_i^*$ 后，若存在 $0&lt;\\lambda_i^*&lt;C$，那么必有 $\\xi_i^*=0$，进而对此 $i$ 有： \\theta^*= y_i+\\varepsilon - \\sum_{j=1}^n(\\lambda_i^*-\\hat{\\lambda_i^*})\\mathbf{x}_j\\cdot\\mathbf{x}_i理论上来说，可以任意选取满足 $0&lt;\\lambda_i^*&lt;C$ 的样本，通过上式得到 $\\theta$，但在实际应用中，常选取所有的满足 $0&lt;\\lambda_i^*&lt;C$ 的样本，求取相应的 $\\theta$ 后求其平均值 $\\overline{\\theta}$ 故而，当 $\\lambda_i-\\hat{\\lambda_i}\\neq0$ 时，有回归函数： f(\\mathbf{x}) = \\sum_{i=1}^n(\\lambda_i-\\hat{\\lambda_i})(\\mathbf{x}_i\\cdot\\mathbf{x}) + \\overline{\\theta}【非线性支持向量回归】对于回归函数： f(\\mathbf{x}) = \\sum_{i=1}^n(\\lambda_i-\\hat{\\lambda_i})(\\mathbf{x}_i\\cdot\\mathbf{x}) + \\overline{\\theta}若考虑到非线性问题，可以参照非线性支持向量机的思路，使用核方法进行特征构建，引入核函数即可，故非线性 SVR 可表示为： f(\\mathbf{x}) = \\sum_{i=1}^n(\\lambda_i-\\hat{\\lambda_i})K(\\mathbf{x}_i,\\mathbf{x}) + \\overline{\\theta}关于核方法，详见：特征构建与核方法 【sklearn 实现】线性支持向量回归以 sklearn 中的波士顿房价数据集为例，实现线性支持向量回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.svm import LinearSVRfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立线性支持向量回归模型 model = LinearSVR(random_state=0, tol=1e-05) # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model) 非线性支持向量回归以 sklearn 中的波士顿房价数据集为例，实现线性支持向量回归 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.svm import SVRfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立非线性SVR模型 # kernel可选： # - linear：线性核函数，与LinearSVR效果一致，但速度较慢 # - poly：多项式核函数，gamma为多项式的系数，degree为多项式的次数，coef0为多项式截距 # - rbf：高斯核函数，gamma为1/2σ # - sigmoid：sigmoid核函数，coef0为多项式截距 model = SVR(kernel='rbf', degree=3, C=1.0, epsilon=0.2) # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3,random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"非线性支持向量机","slug":"machine-learning/42.非线性支持向量机","date":"2019-08-20T11:13:00.000Z","updated":"2023-04-04T08:48:50.317Z","comments":true,"path":"artificial-intelligence/machine-learning/7fdaae18.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/7fdaae18.html","excerpt":"References： 非线性支持向量机（SVM）解析 | 统计学习方法学习笔记 | 数据分析 | 机器学习 核方法、核技巧和核函数 【引入】软隔支持向量机是用来解决训练集近似线性可分情况的二分类模型，但其无法处理线性不可分的情况","text":"References： 非线性支持向量机（SVM）解析 | 统计学习方法学习笔记 | 数据分析 | 机器学习 核方法、核技巧和核函数 【引入】软隔支持向量机是用来解决训练集近似线性可分情况的二分类模型，但其无法处理线性不可分的情况 为解决该问题，在软间隔支持向量机的基础上引入了核方法，通过一个非线性变换将输入空间对应于一个特征空间，从而使得在输入空间中的超曲面模型对应于特征空间中的超平面模型 这样，分类问题的学习任务通过在特征空间中求解软间隔支持向量机即可完成 关于核方法，详见：特征构建与核方法 【假设形式】非线性支持向量机（Non-linear Support Vector Machine）是将软间隔支持向量机的输入空间通过映射函数 $\\phi(\\mathbf{x})$ 变换到一个新的特征空间，并将输入空间的内积 $\\mathbf{x}_i\\cdot\\mathbf{x}_j$ 变换为特征空间中的内积 $\\phi(\\mathbf{x}_i)\\cdot\\phi(\\mathbf{x}_j)$，在新的特征空间中从训练样本中学习软间隔支持向量机 对于容量为 $n$ 的线性不可分的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 软间隔支持向量机学习算法的对偶问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\lambda}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && 0\\leq \\lambda_i \\leq C,&& i=1,2,\\cdots,n \\end{matrix}目标函数只涉及到输入实例与输入实例间的内积，将内积 $\\mathbf{x}_i\\cdot\\mathbf{x}_j$ 用正定核函数 $K(\\mathbf{x}_i,\\mathbf{x}_j)=\\phi(\\mathbf{x}_i)\\cdot\\phi(\\mathbf{x}_j)$ 来代替，此时对偶问题的目标函数为： W(\\boldsymbol{\\lambda}) = \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j K(\\mathbf{x}_i,\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i同样，分类决策函数中的内积也用核函数来代替： f(\\mathbf{x}) = \\text{sign} (\\sum_{i=1}^n \\lambda_i^*y_iK(\\mathbf{x}_i,\\mathbf{x})+\\theta^*)这样一来，当映射函数 $\\phi(\\mathbf{x})$ 是非线性函数时，学习到的含有核函数的支持向量机就是非线性分类模型，即非线性支持向量机 【核技巧】对于核方法来说，直接计算核函数 $K(\\mathbf{x},\\mathbf{z})$ 比较容易，而通过映射函数 $\\phi(\\mathbf{x})$ 和 $\\phi(\\mathbf{z})$ 计算 $K(\\mathbf{x},\\mathbf{z})$ 较为复杂 核技巧（Kernel Trick）是一种加速核方法的计算技巧，其在学习和预测中只显式的定义核函数 $K(\\mathbf{x},\\mathbf{z})$，不显式的定义 $\\phi(\\mathbf{x})$ 和 $\\phi(\\mathbf{z})$ ，从而避开分别计算 $\\phi(\\mathbf{x})$ 和 $\\phi(\\mathbf{z})$ 利用核技巧，在核函数 $K(\\mathbf{x},\\mathbf{z})$ 给定的情况下，可以将线性分类的学习方法应用到非线性分类问题中，对于支持向量机来说，可以将软间隔支持向量机扩展到非线性支持向量机 在实际应用中，往往依赖于领域知识来直接选择核函数，而核函数选择的有效性需要通过实验验证 【学习算法】下面给出非线性支持向量机的学习算法： 输入：容量为 $n$ 的线性不可分的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 输出：分类决策函数 算法步骤： Step1：选择适当的核函数 $K(\\mathbf{x},\\mathbf{z})$ 惩罚系数 $C&gt;0$，构造并求解如下约束最优化问题（原始问题的对偶问题） \\begin{matrix} \\min\\limits_{\\boldsymbol{\\lambda}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j K(\\mathbf{x}_i,\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && 0\\leq \\lambda_i \\leq C,&& i=1,2,\\cdots,n \\end{matrix}求得最优解 $\\boldsymbol{\\lambda}^* = (\\lambda_1^*,\\lambda_2^*,\\cdots,\\lambda_n^*)^T$ Step2：根据最优解 $\\boldsymbol{\\lambda}^*$，选择一个正分量 $0&lt;\\lambda_j^*&lt;C$，计算截距 $\\theta^*$： \\theta^* = y_j - \\sum_{i=1}^n \\lambda_i^* y_i K(\\mathbf{x_i},\\mathbf{x}_j)Step3：根据最优解 $\\boldsymbol{\\lambda}^*$ 和 $\\theta^*$，构建分类决策函数 f(\\mathbf{x}) = \\text{sign} (\\sum_{i=1}^n \\lambda_i^*y_iK(\\mathbf{x}_i,\\mathbf{x})+\\theta^*) 对于 Step1 中的约束最优化问题，当 $K(\\mathbf{x},\\mathbf{z})$ 是正定核函数时，其是一个凸二次规划问题，可以使用 SMO 算法求解，关于 SMO 算法，详见：序列最小最优化(SMO)算法 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现非线性支持向量机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.svm import SVCfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立非线性SVM模型 # kernel可选： # - linear：线性核函数，与LinearSVC效果一致，但速度较慢 # - poly：多项式核函数，gamma为多项式的系数，degree为多项式的次数，coef0为多项式截距 # - rbf：高斯核函数，gamma为1/2σ # - sigmoid：sigmoid核函数，coef0为多项式截距 model = SVC(kernel='rbf', gamma=0.2, random_state=1) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"特征构建与核方法","slug":"machine-learning/41.特征构建与核方法","date":"2019-08-19T07:45:00.000Z","updated":"2023-03-31T12:33:20.492Z","comments":true,"path":"artificial-intelligence/machine-learning/d69d1bb1.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/d69d1bb1.html","excerpt":"References: 对核函数(kernel)最通俗易懂的理解 机器学习笔记029 | 核函数 核方法、核技巧和核函数 【ML系列】“非线性”二元分类 【Cover 定理】在实际应用中，分类问题有许多是线性不可分的","text":"References: 对核函数(kernel)最通俗易懂的理解 机器学习笔记029 | 核函数 核方法、核技巧和核函数 【ML系列】“非线性”二元分类 【Cover 定理】在实际应用中，分类问题有许多是线性不可分的 对于这样的线性不可分问题，可以通过多项式回归结合 Logistic 回归来得到想要的结果： 举例来说，对于如下图的一维数据： 无法使用一根直线将数据区分，因为不管怎么分，都会出现错误分类的情况： 如果原来的数据是 $X=[x]$ ，给它增加一个维度 $x^2$，数据就从一维变成二维 $X=[x,x^2]$，此时提升维度后的数据集已经变为线性可分了，可以用 $y=x$ 来将数据分开： 回到一维中，使用 Logistic 回归可以得到分界线方程：$\\theta_1+\\theta_2x+\\theta_3x^2=0$，经过梯度下降优化后，可以得到曲线 $x^2-x=0$ 也就是说，多项式回归通过将数据从低维映射到高维，将原本线性不可分的情况变成了线性可分的情况 提升维度后，原本非线性的数据变成线性可分的数据，这在数学上是有严格证明的，即Cover 定理：当空间的维数 $D$ 越大时，在该空间的 $n$ 个数据点间的线性可分的概率就越大 需要的是，Cover 定理描述的是线性可分的概率，并非提供了提升维度就一定可以线性可分的依据 【特征构建】根据 Cover 定理，在面对低维且线性不可分的数据时，可以将数据从低维空间映射到高维空间从而提升线性可分的概率 举例来说，对于向量 $\\mathbf{x}=[1\\quad x_1\\quad x_2]$，使用多项式平方映射后，有： \\phi(\\mathbf{x}) = [1\\quad x_1\\quad x_2\\quad x_1x_2\\quad x_1^2\\quad x_2^2\\quad x_1^2x_2\\quad x_1x_2^2\\quad x_1^2x_2^2]在映射前的数据维度为 $3$，经过映射后提升成了 $9$，此时向量内的线性特征更加显著 这类将低维数据转变为高维的映射 $\\phi(\\mathbf{x})$ 被称为特征构建（Feature Build），映射后的向量被称为特征向量 使用多项式回归将数据从低维映射到高维，随着维度的增加，会导致计算量会以几何级数增加，为此，引入了核方法（Kernel Method），其是一种利用核函数（Kernel Function）将低维空间的非线性可分问题，转化为高维空间的线性可分问题的方法 【核函数】设输入空间 $\\mathcal{X}$ 是 $n$ 维欧氏空间 $\\mathbb{R}^n$ 的子集或离散集合，特征空间 $\\mathcal{H}$ 是希尔伯特空间，若存在一个从 $\\mathcal{X}$ 到 $\\mathcal{H}$ 的映射： \\phi(\\mathbf{x}):\\mathcal{X}\\rightarrow\\mathcal{H}使得对所有的 $\\mathbf{x},\\mathbf{z}\\in\\mathcal{X}$ 满足： K(\\mathbf{x},\\mathbf{z})=\\phi(\\mathbf{x})\\cdot\\phi(\\mathbf{z})则称 $K(\\mathbf{x},\\mathbf{z})$ 为核函数，$\\phi(\\cdot)$ 为映射函数，其中 $\\phi(\\mathbf{x})\\cdot\\phi(\\mathbf{z})$ 为 $\\phi(\\mathbf{x})$ 和 $\\phi(\\mathbf{z})$ 的内积 需要注意的是，对于给定的核函数 $K(\\mathbf{x},\\mathbf{z})$，特征空间 $\\mathcal{H}$ 和映射函数 $\\phi(\\cdot)$ 的取法不唯一，可以取不同的特征空间，在同一特征空间中也可以取不同的映射 【正定核】已知映射函数 $\\phi(\\cdot)$，可以通过 $\\phi(\\mathbf{x})$ 和 $\\phi(\\mathbf{z})$ 的内积来求得核函数 $K(\\mathbf{x},\\mathbf{z})$，那么能否不构造映射 $\\phi(\\cdot)$ 就能直接判断一个给定的函数 $K(\\mathbf{x},\\mathbf{z})$ 是否为核函数？或者说，函数 $K(\\mathbf{x},\\mathbf{z})$ 满足什么样的条件，才能成为核函数？ 再生核与再生核希尔伯特空间定义映射： \\phi:\\mathbf{x} \\rightarrow K(\\cdot,\\mathbf{x})根据这一映射，对任意 $\\mathbf{x}_i\\in \\mathcal{X},\\alpha_i\\in\\mathbb{R},i=1,2,\\cdots,m$，定义线性组合： f(\\cdot) = \\sum_{i=1}^m \\alpha_i K(\\cdot,\\mathbf{x}_i)考虑由上述线性组合为元素的集合 $S$，由于集合 $S$ 对加法和数乘运算是封闭的，因此 $S$ 构成一个向量空间 此时，对于向量空间上的任意线性组合 $f,g\\in S$ \\begin{align*} f(\\cdot) = \\sum_{i=1}^m \\alpha_i K(\\cdot,\\mathbf{x}_i) \\\\ g(\\cdot) = \\sum_{i=j}^l \\beta_j K(\\cdot,\\mathbf{z}_j) \\end{align*}在向量空间 $S$ 上定义内积运算： f\\cdot g = \\sum_{i=1}^m\\sum_{j=1}^l \\alpha_i\\beta_jK(\\mathbf{x}_i,\\mathbf{z}_j)此时，向量空间 $S$ 为一内积空间 进一步，根据内积运算，可导出范数： ||f|| = \\sqrt{f\\cdot f}故而内积空间 $S$ 是一个赋范向量空间 根据泛函分析理论，对于不完备的赋范向量空间 $S$，一定可以使其完备化，得到完备的赋范向量空间 $\\mathcal{H}$，即希尔伯特空间（Hilbert Space） 而对于赋范向量空间 $S$，其完备化后得到的希尔伯特空间 $\\mathcal{H}$，由于函数 $K(\\cdot,\\mathbf{x})$ 具备再生性，即： \\begin{gather*} K(\\cdot,\\mathbf{x})\\cdot f= f(\\mathbf{x}) \\\\ K(\\cdot,\\mathbf{x})\\cdot K(\\cdot,\\mathbf{z})=K(\\mathbf{x},\\mathbf{z}) \\end{gather*}故称函数 $K(\\cdot,\\mathbf{x})$ 为再生核（Reproducing Kernel），称希尔伯特空间 $\\mathcal{H}$ 为再生核希尔伯特空间（Reproducing Kernel Hilbert Space） 事实上，任何一个核函数，都隐式地定义了一个再生核希尔伯特空间 正定核设 $\\mathcal{X}\\subset \\mathbb{R}^n$，$K(\\mathbf{x},\\mathbf{z})$ 是定义在 $\\mathcal{X}\\times\\mathcal{X}$ 上的对称函数，若对 $\\forall\\mathbf{x}_i\\in \\mathcal{X},i=1,2,\\cdots,m$，$K(\\mathbf{x},\\mathbf{z})$ 对应的 Gram 矩阵 K = \\begin{bmatrix} K(\\mathbf{x}_1,\\mathbf{x}_1) & K(\\mathbf{x}_1,\\mathbf{x}_2) & \\cdots & K(\\mathbf{x}_1,\\mathbf{x}_m) \\\\ K(\\mathbf{x}_2,\\mathbf{x}_1) & K(\\mathbf{x}_2,\\mathbf{x}_2) & \\cdots & K(\\mathbf{x}_2,\\mathbf{x}_m) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ K(\\mathbf{x}_m,\\mathbf{x}_1) & K(\\mathbf{x}_m,\\mathbf{x}_2) & \\cdots & K(\\mathbf{x}_m,\\mathbf{x}_m) \\\\ \\end{bmatrix}是半正定矩阵，即对于任意非零实向量 $\\mathbf{a}$，有： \\mathbf{a}^TK\\mathbf{a}\\geq 0则称 $K(\\mathbf{x},\\mathbf{z})$ 是正定核 对于 $K(\\mathbf{x},\\mathbf{z})$，可以构造其从 $\\mathcal{X}$ 到某个希尔伯特空间 $\\mathcal{H}$ 的映射： \\phi:\\mathbf{x}\\rightarrow K(\\cdot,\\mathbf{x})根据函数 $K(\\cdot,\\mathbf{x})$ 的再生性，可得： K(\\mathbf{x},\\mathbf{z})=\\phi(\\mathbf{x})\\cdot\\phi(\\mathbf{z})即正定核 $K(\\mathbf{x},\\mathbf{z})$ 是定义在 $\\mathcal{X}\\times\\mathcal{X}$ 上的核函数 正定核在构造核函数是十分有用，但对于一个具体函数 $K(\\mathbf{x},\\mathbf{z})$ 来说，检验其是否为正定核函数并不容易，因为要求对任意有限输入集 $\\{\\mathbf{x}_1,\\mathbf{x}_2,\\cdots,\\mathbf{x}_m\\}$ 需要验证 $K$ 对应的 Gram 矩阵是半正定的 因此，在实际应用中，常采用已有的核函数 【常用核函数】常用的核函数如下： 线性核函数： $K(\\mathbf{x},\\mathbf{z})=\\mathbf{x}\\cdot\\mathbf{z}$ 多项式核函数：$K(\\mathbf{x},\\mathbf{z})=(\\mathbf{x}\\cdot\\mathbf{z}+1)^p$，其中 $p\\geq 1$ 为多项式的次数 高斯（径向基）核函数：$K(\\mathbf{x},\\mathbf{z})=\\exp(-\\frac{1}{2\\sigma}||\\mathbf{x}-\\mathbf{z}||^2_2)$，其中 $\\sigma&gt;0$ 为带宽 拉普拉斯核函数：$K(\\mathbf{x},\\mathbf{z})=\\exp(-\\frac{1}{\\sigma}||\\mathbf{x}-\\mathbf{z}||_2)$，其中 $\\sigma&gt;0$ 为带宽 Sigmoid 核函数：$K(\\mathbf{x},\\mathbf{z})=\\text{sigmoid}(\\beta\\mathbf{x}\\cdot\\mathbf{z}+\\theta)$，其中 $\\beta&gt;0,\\theta&lt;0$ 【表示定理】设 $\\mathcal{H}$ 为核函数 $K(\\mathbf{x},\\mathbf{z})$ 对应的再生核希尔伯特空间，$||h||_{\\mathcal{H}}$ 为再生核希尔伯特空间中关于 $h$ 的范数，对任意单调递增函数 $f(x)$ 和任意非负损失函数 $L(\\mathbf{x})$，对于优化问题： \\min_{h\\in\\mathcal{H}} \\quad F(h) = f(||h||_{\\mathcal{H}}) + L(h(\\mathbf{x}_1),h(\\mathbf{x}_2),\\cdots,h(\\mathbf{x}_n))的解可以写为： h^*(\\mathbf{x}) = \\sum_{i=1}^n \\lambda_iK(\\mathbf{x},\\mathbf{x}_i)上述定理即为表示定理（Representer Theorem），其说明了在高维甚至无限维的正则化泛函可以由数据样本张成的有限维空间表示，这避免了直接在高维空间进行优化 表示定理对损失函数没有任何限制，只要求正则化项 $f(x)$ 单调递增，甚至不要求 $f(x)$ 是凸函数 也就是说，对于一般的损失函数和正则化项，优化问题 $F(h)$ 的最优解 $h^*(\\mathbf{x})$ 都可以表示为核函数 $K(\\mathbf{x},\\mathbf{z})$ 的线性组合 由此，发展出一系列的基于核函数的核方法，即通过引入核函数进行核化，将线性学习模型扩展为非线性学习模型，最常见的就是非线性支持向量机和核线性判别分析","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"软间隔支持向量机","slug":"machine-learning/40.软间隔支持向量机","date":"2019-08-17T04:08:00.000Z","updated":"2023-04-04T08:47:23.316Z","comments":true,"path":"artificial-intelligence/machine-learning/141da982.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/141da982.html","excerpt":"References： 【机器学习】支持向量机 SVM（非常详细） 机器学习笔记（五）：支持向量机（SVM） 支持向量机（SVM）——原理篇 【引入】硬间隔支持向量机是用来解决训练集完全线性可分情况的二分类模型，但在实际应用中，由于实际获取的真实样本往往会存在噪声，使得训练数据不是清晰线性可分的，又或者即使找到了一个可以使不同类样本完全分开的超平面，也很难确定这个线性可分的结果是不是由于过拟合导致的","text":"References： 【机器学习】支持向量机 SVM（非常详细） 机器学习笔记（五）：支持向量机（SVM） 支持向量机（SVM）——原理篇 【引入】硬间隔支持向量机是用来解决训练集完全线性可分情况的二分类模型，但在实际应用中，由于实际获取的真实样本往往会存在噪声，使得训练数据不是清晰线性可分的，又或者即使找到了一个可以使不同类样本完全分开的超平面，也很难确定这个线性可分的结果是不是由于过拟合导致的 也就是说，训练集中存在一些特异点（Outlier），将这些特异点去除后，剩余大部分的样本点的集合是线性可分的，这被称为近似线性可分 对于近似线性可分的训练集，引入了软间隔（Soft Margin）这个概念，并将求解硬间隔最大化问题改为求解软间隔最大化问题，从而使得硬间隔支持向量机更一般化，能够对近似线性可分的数据进行处理 【假设形式】对于给定容量为 $n$ 的线性不可分训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 软间隔支持向量机（Soft Margin Support Vector Machines）对于线性不可分的训练集，通过求解软间隔最大化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi}} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum\\limits_{i=1}^n \\xi_i\\\\ s.t. && y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)\\geq 1-\\xi_i \\\\ && \\xi_i \\geq 0, && i=1,2,\\cdots,n \\end{matrix}其中，$\\xi_i\\geq 0$ 是为每个样本点 $(\\mathbf{x}_i,y_i)$ 引入的松弛变量，$C&gt;0$ 是惩罚系数 得到最优分离超平面： S: \\boldsymbol{\\omega}^*\\cdot \\mathbf{x}+\\theta^* = 0以及相应的分类决策函数： f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*+\\theta^*)由于现实中的训练数据往往存在噪声或特异点，是线性不可分的，因此软间隔支持向量机具有更广的适用性 同时，由于软间隔支持向量机是在硬间隔支持向量机基础上针对训练数据线性不可分时的改进，因此又称线性支持向量机（Linear Support Vector Machines） 也就是说，线性（软间隔）支持向量机包含线性可分（硬间隔）支持向量机 【软间隔支持向量机学习算法的原始形式】软间隔最大化软间隔最大化（Soft Margin Maximization）同样是找到使所有样本点的几何间隔的最小值最大的分离超平面，即寻找最大间隔分离超平面 对于硬间隔最大化中的原始问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 \\\\ s.t. && y_i ( \\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta)-1 \\geq 0 ,&& i=1,2,\\cdots,n \\end{matrix}线性不可分意味着某些样本点 $(\\mathbf{x}_i,y_i)$ 不能满足函数间隔大于等于 $1$ 的约束条件 $y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)-1\\geq 0$ 为解决这个问题，可以对每个样本点 $(\\mathbf{x}_i,y_i)$ 引入一个松弛变量 $\\xi_i\\geq 0$，使得函数间隔加上松弛变量大于等于 $1$，即： y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)\\geq 1-\\xi_i同时，对每个松弛变量 $\\xi_i$，支付一个代价 $\\xi_i$，使得目标函数由 $\\frac{1}{2}||\\boldsymbol{\\omega}||_2^2$ 变为： \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum_{i=1}^n \\xi_i其中，$C&gt;0$ 为惩罚系数，由具体的应用问题决定，$C$ 越大说明对误分类的惩罚越大 此时的目标函数有两层含义，一是使 $\\frac{1}{2}||\\boldsymbol{\\omega}||_2^2$ 尽量小，即令几何间隔尽量大，二是令误分类点的个数尽量小，并通过惩罚系数 $C$ 来调和二者的关系 于是可以得到约束最优化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum\\limits_{i=1}^n \\xi_i\\\\ s.t. && y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)\\geq 1-\\xi_i \\\\ && \\xi_i \\geq 0, && i=1,2,\\cdots,n \\end{matrix}上述的约束最优化问题是一个凸二次规划（Convex Quadratic Programming）问题，相对于硬间隔最大化，其被称为软间隔最大化 需要注意的是，对于上述的凸二次规划问题，关于 $(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi})$ 的解是存在的，同时 $\\boldsymbol{\\omega}$ 的解是唯一的，但 $\\theta$ 的解可能不唯一，其存在于一个区间中 关于硬间隔最大化，详见：硬间隔支持向量机 最大间隔法软间隔支持向量机的学习算法为最大间隔法 输入：容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 输出：最大间隔分离超平面、分类决策函数 算法步骤： Step1：构造并求解如下约束最优化问题 \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi}} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum\\limits_{i=1}^n \\xi_i\\\\ s.t. && y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)\\geq 1-\\xi_i \\\\ && \\xi_i \\geq 0, && i=1,2,\\cdots,n \\end{matrix}求得最优解 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$ Step2：根据最优解 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$，得到分离超平面 \\boldsymbol{\\omega}^* \\cdot \\mathbf{x} +\\theta^* = 0以及分类决策函数 f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*\\cdot\\mathbf{x}+\\theta^*)【软间隔支持向量机学习算法的对偶形式】对偶问题的转化为求解软间隔支持向量机的最优化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum\\limits_{i=1}^n \\xi_i\\\\ s.t. && y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)\\geq 1-\\xi_i \\\\ && \\xi_i \\geq 0, && i=1,2,\\cdots,n \\end{matrix}将其作为原始最优化问题，应用拉格朗日对偶性，通过求解对偶问题来得到原始问题的最优解 首先，构建拉格朗日函数，即为每一个不等式约束引入拉格朗日乘子 $\\lambda_i\\geq 0$ 和 $\\mu_i\\geq 0$，即： L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) = \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum_{i=1}^n\\xi_i - \\sum_{i=1}^n \\lambda_i( y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i + \\theta)-1+\\xi_i) -\\sum_{i=1}^n \\mu_i\\xi_i其中，$\\boldsymbol{\\lambda}=(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)^T$ 和 \\boldsymbol{\\mu}=(\\mu_1,\\mu_2,\\cdots,\\mu_n)^T 为拉格朗日乘子向量 此时，根据拉格朗日对偶性，原始问题的对偶问题就变为了极大极小问题，即： \\max_{\\boldsymbol{\\lambda},\\boldsymbol{\\mu}} \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})因此，为了得到对偶问题的解，就要先求拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 对 $\\boldsymbol{\\omega}$、$\\theta$、$\\boldsymbol{\\xi}$ 的极小，再求对 $\\boldsymbol{\\lambda}$、$\\boldsymbol{\\xi}$ 的极大 注：关于拉格朗日函数与拉格朗日对偶性，详见 拉格朗日乘子法与对偶性 对偶问题中的极小问题对于对偶问题中的极小问题： \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})令拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 分别对 $\\boldsymbol{\\omega}$、$\\theta$、$\\boldsymbol{\\xi}$ 求偏导，并令其等于 $0$，即： \\begin{align*} \\triangledown_{\\boldsymbol{\\omega}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) &= \\boldsymbol{\\omega} - \\sum_{i=1}^n \\lambda_i y_i \\mathbf{x}_i = 0 \\\\ \\triangledown_{\\theta} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) &= -\\sum_{i=1}^n \\lambda_i y_i = 0 \\\\ \\triangledown_{\\xi_i} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) &= C-\\lambda_i -\\mu_i= 0 \\end{align*}可得： \\begin{gather*} \\boldsymbol{\\omega} = \\sum_{i=1}^n \\lambda_i y_i \\mathbf{x}_i \\\\ \\sum_{i=1}^n \\lambda_i y_i = 0 \\\\ C-\\lambda_i-\\mu_i = 0 \\end{gather*}将上式带回拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 中，有： \\begin{align*} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) =& \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 + C\\sum_{i=1}^n\\xi_i - \\sum_{i=1}^n \\lambda_i( y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i + \\theta)-1+\\xi_i) -\\sum_{i=1}^n \\mu_i\\xi_i \\\\ =& \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum_{i=1}^n(\\lambda_i+\\mu_i) \\xi_i \\\\ &-\\sum_{i=1}^n\\lambda_i \\Big ( y_i \\big( (\\sum_{j=1}^n\\lambda_jy_j\\mathbf{x}_j)\\cdot \\mathbf{x}_i +\\theta \\big) -1 + \\xi_i \\Big) -\\sum_{i=1}^n\\mu_i\\xi_i \\\\ =& \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum_{i=1}^n(\\lambda_i+\\mu_i) \\xi_i \\\\ &-\\sum_{i=1}^n\\sum_{j=1}^n\\lambda_i\\lambda_jy_iy_j(\\mathbf{x}_j\\cdot \\mathbf{x}_i) + \\theta\\sum_{i=1}^n\\lambda_iy_i +\\sum_{i=1}^n\\lambda_i -\\sum_{i=1}^n\\lambda_i\\xi_i -\\sum_{i=1}^n\\mu_i\\xi_i \\\\ =& -\\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) +\\sum_{i=1}^n \\lambda_i \\end{align*}故有： \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) = -\\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum_{i=1}^n \\lambda_i对偶问题中的极大问题对于对偶问题中的极大问题： \\max_{\\boldsymbol{\\lambda},\\boldsymbol{\\mu}} \\min_{\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\xi},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})即为对偶问题，有： \\begin{matrix} \\max\\limits_{\\boldsymbol{\\lambda}} && -\\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && C-\\lambda_i-\\mu_i=0 \\\\ && \\lambda_i\\geq 0\\\\ && \\mu_i \\geq 0 ,&& i=1,2,\\cdots,n \\end{matrix}利用等式约束 $C-\\lambda_i-\\mu_i=0$，消去 $\\mu_i$，有： \\begin{matrix} \\max\\limits_{\\boldsymbol{\\lambda}} && -\\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && 0\\leq \\lambda_i \\leq C,\\quad i=1,2,\\cdots,n \\end{matrix}再将该问题的目标函数由求极大转为求极小，就得到如下的等价的对偶最优化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\lambda}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && 0\\leq \\lambda_i \\leq C,\\quad i=1,2,\\cdots,n \\end{matrix}可以发现，原始问题是凸优化问题，且 Slater 条件成立，那么，原始问题强对偶性成立，即求解原始问题可以转换为求解上述的对偶问题 假设上述的对偶问题对 $\\boldsymbol{\\lambda}$ 的一个解为 $\\boldsymbol{\\lambda}^* = (\\lambda_1^*,\\lambda_2^*,\\cdots,\\lambda_n^*)^T$，那么根据 KKT 条件，可得： \\begin{gather*} \\triangledown_{\\boldsymbol{\\omega}} L(\\boldsymbol{\\omega}^*,\\theta^*,\\boldsymbol{\\xi}^*,\\boldsymbol{\\lambda}^*,\\boldsymbol{\\mu}^*) = \\boldsymbol{\\omega}^* - \\sum_{i=1}^n \\lambda_i^* y_i \\mathbf{x}_i = 0 \\\\ \\triangledown_{\\theta} L(\\boldsymbol{\\omega}^*,\\theta^*,\\boldsymbol{\\xi}^*,\\boldsymbol{\\lambda}^*,\\boldsymbol{\\mu}^*) = -\\sum_{i=1}^n \\lambda_i^* y_i = 0 \\\\ \\triangledown_{\\boldsymbol{\\xi}} L(\\boldsymbol{\\omega}^*,\\theta^*,\\boldsymbol{\\xi}^*,\\boldsymbol{\\lambda}^*,\\boldsymbol{\\mu}^*) =C-\\boldsymbol{\\lambda}^*-\\boldsymbol{\\mu}^* = 0 \\\\ \\lambda_i^*(y_i(\\boldsymbol{\\omega}^*\\cdot \\mathbf{x}_i+\\theta^*)-1+\\xi_i^*) = 0 \\\\ \\mu_i^*\\xi_i^*=0 \\\\ y_i(\\boldsymbol{\\omega}^*\\cdot \\mathbf{x}_i+\\theta^*)-1+\\xi_i^* \\geq 0 \\\\ \\xi_i^* \\geq 0 \\\\ \\lambda_i^* \\geq 0 \\\\ \\mu_i^* \\geq 0, && i=1,2,\\cdots,n \\end{gather*}故而有： \\boldsymbol{\\omega}^* = \\sum_{i=1}^n \\lambda_i^* y_i\\mathbf{x}_i同时，若存在 $0&lt;\\lambda_j^*&lt;C$，对此 $j$ 有： y_j(\\boldsymbol{\\omega}^* \\cdot \\mathbf{x}_j+\\theta^*)-1=0将 $\\boldsymbol{\\omega}^* = \\sum\\limits_{i=1}^n \\lambda_i^* y_i\\mathbf{x}_i$ 带入到上式，并由 $y_j^2=1$，可得： \\theta^* = y_j - \\sum_{i=1}^n \\lambda_i^* y_i (\\mathbf{x_i}\\cdot \\mathbf{x}_j)故而，分离超平面可写为： \\sum_{i=1}^n \\lambda_i^* y_i(\\mathbf{x}\\cdot\\mathbf{x}_i) + \\theta^* =0分类决策函数可写为： f(\\mathbf{x}) = \\text{sign}\\Big(\\sum_{i=1}^n \\lambda_i^* y_i(\\mathbf{x}\\cdot\\mathbf{x}_i)+\\theta^*\\Big)对偶学习算法根据上述对偶问题的推导，可得到软间隔支持向量机的对偶学习算法 输入：容量为 $n$ 的近似线性可分的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 输出：最大间隔分离超平面、分类决策函数 算法步骤： Step1：选择惩罚系数 $C&gt;0$，构造并求解如下约束最优化问题（原始问题的对偶问题） \\begin{matrix} \\min\\limits_{\\boldsymbol{\\lambda}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && 0\\leq \\lambda_i \\leq C,&& i=1,2,\\cdots,n \\end{matrix}求得最优解 $\\boldsymbol{\\lambda}^* = (\\lambda_1^*,\\lambda_2^*,\\cdots,\\lambda_n^*)^T$ Step2：根据最优解 $\\boldsymbol{\\lambda}^*$，计算分离超平面的法向量 $\\boldsymbol{\\omega}^*$ 和截距 $\\theta^*$ 对于法向量 $\\boldsymbol{\\omega}^*$，有： \\boldsymbol{\\omega}^* = \\sum_{i=1}^n \\lambda_i^* y_i\\mathbf{x}_i选择最优解 $\\boldsymbol{\\lambda}^*$的一个分量 $\\lambda_j^*$，满足 $0&lt;\\lambda_j^*&lt;C$，计算截距 $\\theta^*$，有： \\theta^* = y_j - \\sum_{i=1}^n \\lambda_i^* y_i (\\mathbf{x_i}\\cdot \\mathbf{x}_j)Step3：根据最优解 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$，得到分离超平面 \\boldsymbol{\\omega}^* \\cdot \\mathbf{x} +\\theta^* = 0以及分类决策函数 f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*\\cdot\\mathbf{x}+\\theta^*) 对于 Step1 中的凸二次规划问题，可使用 SMO 算法来求解，关于 SMO 算法，详见：序列最小最优化(SMO)算法 在 Step2 中，对任一满足 $0&lt;\\lambda_j^*&lt;C$ 的 $\\lambda_j^*$，均可求出截距 $\\theta^*$，从理论上来说，原始问题对 $\\theta$ 的解可能不唯一，然而在实际应用中，往往只会出现上述算法叙述的情况 【支持向量与间隔边界】在线性不可分的情况下，对于对偶问题的解 $\\boldsymbol{\\lambda}^* = (\\lambda_1^*,\\lambda_2^*,\\cdots,\\lambda_n^*)^T$ 中对应 $\\lambda_i^*&gt;0$ 的样本点 $(\\mathbf{x}_i,y_i)$ 的实例 $\\mathbf{x_i}$ 称为软间隔的支持向量（Support Vector） 如图所示，红线标出的是支持向量 $\\mathbf{x}_i$ 到间隔边界的距离 $\\frac{1}{||\\boldsymbol{\\omega}_2^2||}\\xi_i$ 此外，分类决策函数： f(\\mathbf{x}) = \\text{sign}\\Big(\\sum_{i=1}^n \\lambda_i^* y_i(\\mathbf{x}\\cdot\\mathbf{x}_i)+\\theta^*\\Big)根据 KKT 条件，对于任意样本 $(\\mathbf{x}_i,y_i)$，总有 $\\lambda_i=0$ 或 $y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)=1-\\xi_i$ 当 $\\lambda_i=0$ 时，该样本不会在分类决策函数 $f(\\mathbf{x})$ 求和中出现，也就不会对 $f(\\mathbf{x})$ 造成任何影响 当 $\\lambda_i&gt;0$ 时，必有 $y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)=1-\\xi_i$，所对应的样本点正好位于间隔边界上，是一个支持向量 若 \\lambda_i","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"序列最小最优化(SMO)算法","slug":"convex-optimization/14.序列最小最优化(SMO)算法","date":"2019-08-16T07:38:00.000Z","updated":"2023-03-25T06:52:32.211Z","comments":true,"path":"mathematics/convex-optimization/1f33dd66.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/convex-optimization/1f33dd66.html","excerpt":"【概述】序列最小最优化（Sequential Minimal Optimization，SMO）算法，是用于快速求解凸二次规划问题的算法，其主要针对于支持向量机的对偶问题 对于凸优化问题：","text":"【概述】序列最小最优化（Sequential Minimal Optimization，SMO）算法，是用于快速求解凸二次规划问题的算法，其主要针对于支持向量机的对偶问题 对于凸优化问题： \\begin{matrix} \\min\\limits_{\\mathbf{x}} && f(\\mathbf{x}) \\\\ s.t. && g_i(\\mathbf{x})\\leq 0 ,&& i=1,2,\\cdots,k \\\\ && h_i(\\mathbf{x}) = 0, && i=1,2,\\cdots,l \\end{matrix}其中，目标函数 $f(\\mathbf{x})$ 和约束函数 $g_i(\\mathbf{x})$ 都是 $\\mathbb{R}^n$ 上的连续可微的凸函数，约束函数 $h_i(\\mathbf{x})$ 是 $\\mathbb{R}^n$ 上的仿射函数，即满足 $f(\\mathbf{x}) = \\mathbf{a}\\cdot \\mathbf{x} + b$，其中，$\\mathbf{a}\\in \\mathbb{R}^n,b\\in \\mathbb{R},\\mathbf{x}\\in \\mathbb{R}^{n}$ 当目标函数 $f(\\mathbf{x})$ 是二次函数且约束函数 $g_i(\\mathbf{x})$ 是仿射函数时，上述的凸优化问题即凸二次规划问题（Convex Quadratic Programming） 【SMO 算法的基本思想】对于容量为 $n$ 的样本集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{-1,+1\\}$ SMO 算法要对如下的凸二次规划的对偶问题进行求解： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\alpha}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\alpha_i\\alpha_j y_i y_j K (\\mathbf{x}_i,\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\alpha_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\alpha_i y_i= 0 \\\\ && 0\\leq \\alpha_i \\leq C ,\\quad i=1,2,\\cdots,n \\end{matrix}其中，$\\boldsymbol{\\alpha}=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_n)^T$ 为拉格朗日乘子向量，一个变量 $\\alpha_i$ 对应于一个样本点 $(\\mathbf{x}_i,y_i)$ SMO 算法是一种启发式算法，其基本思路是： 若所有变量的解均满足最优化问题的 KKT 条件，由于 KKT 条件是最优化问题的充分必要条件，那么这个最优化问题的解就得到了 否则，选择两个变量，固定其他变量，针对这两个变量构建一个二次规划子问题，并进行解析求解，直到所有变量满足 KKT 条件为止 由于构建的二次规划子问题会使得原始二次规划问题的目标函数值更小，因此关于这两个变量的解会更接近原始二次规划问题的解 对于选择的两个变量，一个是违反 KKT 条件最严重的那个，另一个是由约束条件自动确定的，假设 $\\alpha_1$ 和 $\\alpha_2$ 是选择的两个变量，$\\alpha_3,\\alpha_4,\\cdots,\\alpha_n$ 固定，那么通过上述的凸二次规划的对偶问题的等式约束 $\\sum\\limits_{i=1}^n\\alpha_i y_i=0$，可得： \\alpha_1 = -y_1\\sum_{i=2}^n \\alpha_i y_i如此一来，如果 $\\alpha_2$ 确定，那么 $\\alpha_1$ 也随之确定，因此，可以将原问题不断分解为子问题，并对子问题进行求解时同时更新两个变量，直到得到子问题的解，进而达到求解原问题的目的 综上所述，整个 SMO 算法包括两个部分：求解两个变量二次规划的解析方法、选择变量的启发式方法 注：关于 KKT 条件，详见 拉格朗日乘子法与对偶性 【两个变量二次规划的求解方法】最优化问题的子问题假设选择的两个变量是 $\\alpha_1$ 和 $\\alpha_2$，固定其他变量 $\\alpha_i,i=3,4,\\cdots,n$ 于是，SMO 的最优化问题的子问题的优化目标函数可写为： \\begin{align*} W(\\alpha_1,\\alpha_2) =& \\frac{1}{2}K_{11}\\alpha_1^2 + \\frac{1}{2} K_{22}\\alpha_2^2 + y_1y_2K_{12}\\alpha_1\\alpha_2 -(\\alpha_1+\\alpha_2) \\\\ &+ y_1\\alpha_1\\sum\\limits_{i=3}^n y_i\\alpha_iK_{i1} + y_2\\alpha_2\\sum\\limits_{i=3}^n y_i\\alpha_iK_{i2} \\end{align*}故，SMO 的最优化问题的子问题为： \\begin{matrix} \\min\\limits_{\\alpha_1,\\alpha_2} && W(\\alpha_1,\\alpha_2) \\\\ s.t. && \\alpha_1y_1 + \\alpha_2y_2 = -\\sum\\limits_{i=3}^n y_i\\alpha_i = \\varsigma \\\\ && 0\\leq \\alpha_i \\leq C ,\\quad i=1,2 \\end{matrix}其中，$K_{ij} = K(\\mathbf{x}_i,\\mathbf{x}_j)$，$\\varsigma$ 为常数，同时，最优化目标函数式中省略了不含 $\\alpha_1,\\alpha_2$ 的常数项 约束条件的分析为求解上述的两个变量的二次规划子问题，首先分析约束条件，然后在该约束条件下求极小 由于只有两个变量 $\\alpha_1,\\alpha_2$，约束条件可以用二维空间中的图形来表示 对于不等式约束 $0\\leq \\alpha_i \\leq C$，其使得 $\\alpha_1,\\alpha_2$ 在 $[0,C]\\times[0,C]$ 内，对于等式约束 $\\alpha_1y_1 + \\alpha_2y_2 = -\\sum\\limits_{i=3}^n y_i\\alpha_i = \\varsigma$，其使得 $\\alpha_1,\\alpha_2$ 在平行于 $[0,C]\\times[0,C]$ 的对角线的直线上 因此，要求的实际上是目标函数在一条平行于对角线的线段上的最优值，这使得对这两个变量的最优化问题成为了单变量的优化问题 单变量的最优化问题不妨将上述的单变量优化问题假设为对变量 $\\alpha_2$ 的最优化问题，同时，假设二次规划子问题的初始可行解为 $\\alpha_1^{\\text{old}}$ 和 $\\alpha_2^{\\text{old}}$，最优解为 $\\alpha_1^{\\text{new}}$ 和 $\\alpha_2^{\\text{new}}$，并且假设在沿着约束方向未经剪辑时 $\\alpha_2$ 的最优解为 $\\alpha_2^{\\text{new,unc}}$ 由于最优解 $\\alpha_2^{\\text{new}}$ 需要满足不等式约束 $0\\leq \\alpha_i \\leq C$，因此最优解 $\\alpha_2^{\\text{new}}$ 的取值范围要满足： L\\leq \\alpha_2^{\\text{new}} \\leq H其中，$L$ 与 $H$ 是 $\\alpha_2^{\\text{new}}$ 所在的对角线端点的界 若 $y_1\\neq y_2$，则： L = \\max(0,\\alpha_2^{\\text{old}}-\\alpha_1^{\\text{old}}), \\quad H = \\min(C,C+\\alpha_2^{\\text{old}}-\\alpha_1^{\\text{old}}) 若 $y_1 = y_2$，则： L = \\max(0,\\alpha_2^{\\text{old}}+\\alpha_1^{\\text{old}}-C), \\quad H = \\min(C,\\alpha_2^{\\text{old}}+\\alpha_1^{\\text{old}}) 最优化问题子问题的解记： g(\\mathbf{x}) = \\sum_{i=1}^n \\alpha_i y_i K(\\mathbf{x}_i,\\mathbf{x}) +\\theta那么，有： \\begin{align*} v_i &= \\sum_{j=3}^n \\alpha_j y_j K_{ij} \\\\ &= g(\\mathbf{x}_i) - \\sum_{j=1}^2 \\alpha_j y_j K_{ij} -\\theta,\\quad i=1,2 \\end{align*}于是，优化的目标函数可写为： \\begin{align*} W(\\alpha_1,\\alpha_2) =& \\frac{1}{2}K_{11}\\alpha_1^2 + \\frac{1}{2} K_{22}\\alpha_2^2 + y_1y_2K_{12}\\alpha_1\\alpha_2 -(\\alpha_1+\\alpha_2) \\\\ &+ y_1\\alpha_1\\sum\\limits_{i=3}^n y_i\\alpha_iK_{i1} + y_2\\alpha_2\\sum\\limits_{i=3}^n y_i\\alpha_iK_{i2} \\\\ =& \\frac{1}{2}K_{11}\\alpha_1^2 + \\frac{1}{2} K_{22}\\alpha_2^2 + y_1y_2K_{12}\\alpha_1\\alpha_2 -(\\alpha_1+\\alpha_2) \\\\ &+ y_1\\alpha_1v_1 + y_2\\alpha_2v_2 \\end{align*}根据等式条件约束 $\\alpha_1y_1 + \\alpha_2y_2 = \\varsigma$ 与 $y_i^2= 1$ 有： \\alpha_1 = \\frac{1}{y_1}(\\varsigma -\\alpha_2 y_2)=y_1(\\varsigma -\\alpha_2 y_2)将其带回目标函数 $W(\\alpha_1,\\alpha_2)$，可得只是 $\\alpha_2$ 的函数的目标函数，即： \\begin{align*} W(\\alpha_2) =& \\frac{1}{2}K_{11}\\alpha_1^2 + \\frac{1}{2} K_{22}\\alpha_2^2 + y_1y_2K_{12}\\alpha_1\\alpha_2 -(\\alpha_1+\\alpha_2) \\\\ &+ y_1\\alpha_1v_1 + y_2\\alpha_2v_2 \\\\ =& \\frac{1}{2}K_{11}(\\varsigma -\\alpha_2 y_2)^2 + \\frac{1}{2} K_{22}\\alpha_2^2 + y_2K_{12}(\\varsigma -\\alpha_2 y_2)\\alpha_2 \\\\ &- (\\varsigma -\\alpha_2 y_2)y_1 -\\alpha_2 + (\\varsigma -\\alpha_2 y_2)v_1 + y_2\\alpha_2v_2 \\end{align*}对 $W(\\alpha_2)$ 求关于 $\\alpha_2$ 的偏导数，有： \\begin{align*} \\frac{\\partial W}{\\partial{\\alpha_2}} = K_{11}\\alpha_2 + K_{22}\\alpha_2 -2K_{12}\\alpha_2- K_{11}\\varsigma y_2 + K_{12}\\varsigma y_2 + y_1y_2 -1 - v_1y_2+v_2y_2 \\end{align*}令 $\\frac{\\partial W}{\\partial{\\alpha_2}}=0$，有： \\begin{align*} & (K_{11}+K_{22}-2K_{12})\\alpha_2 \\\\ =& y_2\\big(y_2-y_1+\\varsigma K_{11} - \\varsigma K_{12} + v_1-v_2\\big) \\\\ =& y_2\\Big[y_2-y_1+\\varsigma K_{11} - \\varsigma K_{12} + \\big(g(\\mathbf{x}_1) - \\sum_{j=1}^2 \\alpha_j y_j K_{1j} -\\theta \\big) - \\big(g(\\mathbf{x}_2) - \\sum_{j=1}^2 \\alpha_j y_j K_{2j} -\\theta \\big)\\Big] \\end{align*}令： E_i = g(\\mathbf{x}_i)-y_i = \\big(\\sum_{j=1}^n \\alpha_j y_j K_{ji}+\\theta\\big)-y_i ,\\quad i=1,2为函数 $g(\\mathbf{x})$ 对输入 $\\mathbf{x}_i$ 的预测值与真实输入 $y_i$ 的差，并将 $\\varsigma = \\alpha_1^{\\text{old}}y_1 + \\alpha_2^{\\text{old}}y_2$ 带入，则有： \\begin{align*} &(K_{11}+K_{22}-2K_{12})\\alpha_2^{\\text{new,unc}} \\\\ &= y_2 \\big( (K_{11}+K_{22}-2K_{12})\\alpha_2^{\\text{old}}y_2 + y_2-y_1 + g(\\mathbf{x}_1) - g(\\mathbf{x}_2) \\big) \\\\ &= (K_{11}+K_{22}-2K_{12})\\alpha_2^{\\text{old}} + y_2(E_1-E_2) \\end{align*}令 $\\eta = K_{11}+K_{22}-2K_{12}$，则有： \\alpha_2^{\\text{new,unc}} = \\alpha_2^{\\text{old}} + \\frac{y_2(E_1-E_2)}{\\eta}即沿着约束方向未经剪辑的 $\\alpha_2$ 的解，也就是不考虑不等式约束 $0\\leq \\alpha_i \\leq C$ 的最优解 $\\alpha_2^{\\text{new,unc}}$ 那么，经剪辑后 $\\alpha_2$ 的解为： \\alpha_2^{\\text{new}} = \\left\\{ \\begin{align*} H, && \\alpha_2^{\\text{new,unc}}>H \\\\ \\alpha_2^{\\text{new,unc}}, && L\\leq \\alpha_2^{\\text{new,unc}} \\leq H\\\\ L, && \\alpha_2^{\\text{new,unc}}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"凸优化","slug":"mathematics/convex-optimization","permalink":"https://alex-mcavoy.github.io/categories/mathematics/convex-optimization/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"凸优化","slug":"convex-optimization","permalink":"https://alex-mcavoy.github.io/tags/convex-optimization/"}],"author":"Alex_McAvoy"},{"title":"硬间隔支持向量机","slug":"machine-learning/39.硬间隔支持向量机","date":"2019-08-15T03:31:00.000Z","updated":"2023-04-04T08:47:04.235Z","comments":true,"path":"artificial-intelligence/machine-learning/cfe76bf2.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/cfe76bf2.html","excerpt":"References： 【机器学习】支持向量机 SVM（非常详细） 机器学习笔记（五）：支持向量机（SVM） 支持向量机（SVM）——原理篇 【假设形式】对于给定容量为 $n$ 的线性可分训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$","text":"References： 【机器学习】支持向量机 SVM（非常详细） 机器学习笔记（五）：支持向量机（SVM） 支持向量机（SVM）——原理篇 【假设形式】对于给定容量为 $n$ 的线性可分训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 硬间隔支持向量机（Hard Margin Support Vector Machines）对于线性可分的训练集，通过求解硬间隔最大化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 \\\\ s.t. && y_i ( \\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta)-1 \\geq 0 ,&& i=1,2,\\cdots,n \\end{matrix}来求解唯一的最优分离超平面： S: \\boldsymbol{\\omega}^*\\cdot \\mathbf{x}+\\theta^* = 0以及相应的分类决策函数： f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*+\\theta^*)由于训练集是线性可分的，因此又称线性可分支持向量机（Linear Support Vector Machines in Linearly Separable Case） 【硬间隔支持向量机学习算法的原始形式】硬间隔最大化硬间隔最大化（Hard Margin Maximization）是找到使所有样本点的几何间隔的最小值最大的分离超平面，即寻找最大间隔分离超平面 其直观解释是：对于训练集找到分离超平面，意味着以充分大的确信度对训练集进行分类，也就是说，不仅将正负样本点分开，而且对最难分的样本点（距离分离超平面最近的点）也有足够大的确信度将它们分开 下面考虑如何求得一个最大间隔分离超平面 对于给定容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本点 $(\\mathbf{x}_i,y_i)$ 的几何间隔为： \\gamma_i = y_i \\big( \\frac{1}{||\\boldsymbol{\\omega}||_2}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta) \\big)分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本集 $D$ 的中所有样本点的几何间隔的最小值为： \\gamma = \\min_{i=1,2,\\cdots,n} \\hat{\\gamma}_i具体来说，寻找最大间隔分离超平面可以表示为下面的约束最优化问题 \\begin{matrix} \\max\\limits_{\\boldsymbol{\\omega},\\theta} && \\gamma \\\\ s.t. && y_i \\big( \\frac{1}{||\\boldsymbol{\\omega}||_2}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta) \\big) \\geq \\gamma ,&& i=1,2,\\cdots,n \\end{matrix}即希望最大化超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于训练集的几何间隔 $\\gamma$，同时约束超平面 $S$ 关于每个训练样本点的几何间隔至少是 $\\gamma$ 考虑到几何间隔和函数间隔的关系： \\begin{align*} \\gamma_i &= \\frac{1}{||\\boldsymbol{\\omega}||_2} \\hat{\\gamma_i} \\\\ \\gamma &= \\frac{1}{||\\boldsymbol{\\omega}||_2} \\hat{\\gamma} \\end{align*}约束最优化问题可改写为： \\begin{matrix} \\max\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{\\hat{\\gamma}}{||\\boldsymbol{\\omega}||_2} \\\\ s.t. && y_i ( \\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta) \\geq \\hat{\\gamma} ,&& i=1,2,\\cdots,n \\end{matrix}其中，函数间隔 $\\hat{\\gamma}$ 的取值并不影响最优化问题的解 假设将 $\\boldsymbol{\\omega}$ 和 $\\theta$ 等比例的改变为 $k \\boldsymbol{\\omega}$ 和 $k\\theta$，此时函数间隔就变为 $k\\hat{\\gamma}$，这一改变对上面的最优化问题的不等式约束没有任何影响，对目标函数的优化也没有影响 也就是说，其产生了一个等价的最优化问题，这样可以取函数间隔 $\\hat{\\gamma}=1$，而最大化 $\\frac{1}{||\\boldsymbol{\\omega}||_2} $ 和最小化 $\\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 $ 是等价的（此处乘以 $\\frac{1}{2}$ 是为了后续求偏导方便），于是可以得到如下等价的约束最优化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 \\\\ s.t. && y_i ( \\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta)-1 \\geq 0 ,&& i=1,2,\\cdots,n \\end{matrix}可以发现，其是一个凸二次规划（Convex Quadratic Programming）问题 关于函数间隔和几何间隔，详见：线性可分与几何间隔 最大间隔法硬间隔支持向量机的学习算法为最大间隔法 输入：线性可分的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 输出：最大间隔分离超平面、分类决策函数 算法步骤： Step1：构造并求解如下约束最优化问题 \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 \\\\ s.t. && y_i ( \\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta)-1 \\geq 0 ,&& i=1,2,\\cdots,n \\end{matrix}求得最优解 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$ Step2：根据最优解 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$，得到分离超平面 \\boldsymbol{\\omega}^* \\cdot \\mathbf{x} +\\theta^* = 0以及分类决策函数 f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*\\cdot\\mathbf{x}+\\theta^*)【硬间隔支持向量机学习算法的对偶形式】对偶问题的转化为求解硬间隔支持向量机的原始问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\omega},\\theta} && \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 \\\\ s.t. && y_i ( \\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta)-1 \\geq 0 ,&& i=1,2,\\cdots,n \\end{matrix}将其作为原始最优化问题，应用拉格朗日对偶性，通过求解对偶问题来得到原始问题的最优解，这样做的好处有两点：对偶问题更容易求解、容易引入核函数，进而推广到非线性分类问题 首先，构建拉格朗日函数，即为每一个不等式约束引入拉格朗日乘子 $\\lambda_i\\geq 0$，即： L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda}) = \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 - \\sum_{i=1}^n \\lambda_i y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i + \\theta) + \\sum_{i=1}^n \\lambda_i其中，$\\boldsymbol{\\lambda}=(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)^T$ 为拉格朗日乘子向量 此时，根据拉格朗日对偶性，原始问题的对偶问题就变为了极大极小问题，即： \\max_{\\boldsymbol{\\lambda}} \\min_{\\boldsymbol{\\omega},\\theta} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda})因此，为了得到对偶问题的解，就要先求拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda})$ 对 $\\boldsymbol{\\omega}$ 和 $\\theta$ 的极小，再求对 $\\boldsymbol{\\lambda}$ 的极大 注：关于拉格朗日函数与拉格朗日对偶性，详见 拉格朗日乘子法与对偶性 对偶问题中的极小问题对于对偶问题中的极小问题： \\min_{\\boldsymbol{\\omega},\\theta} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda})令拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda})$ 分别对 $\\boldsymbol{\\omega}$ 和 $\\theta$ 求偏导，并令其等于 $0$，即： \\begin{align*} \\triangledown_{\\boldsymbol{\\omega}} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda}) &= \\boldsymbol{\\omega} - \\sum_{i=1}^n \\lambda_i y_i \\mathbf{x}_i = 0 \\\\ \\triangledown_{\\theta} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda}) &= -\\sum_{i=1}^n \\lambda_i y_i = 0 \\end{align*}可得： \\begin{gather*} \\boldsymbol{\\omega} = \\sum_{i=1}^n \\lambda_i y_i \\mathbf{x}_i \\\\ \\sum_{i=1}^n \\lambda_i y_i = 0 \\end{gather*}将上式带回拉格朗日函数 $L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda})$ 中，有： \\begin{align*} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda}) &= \\frac{1}{2}||\\boldsymbol{\\omega}||_2^2 - \\sum_{i=1}^n \\lambda_i y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i + \\theta) + \\sum_{i=1}^n \\lambda_i \\\\ &= \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\sum_{i=1}^n \\lambda_iy_i \\Big( \\big(\\sum_{j=1}^n \\lambda_j y_j\\mathbf{x}_j\\big) \\cdot \\mathbf{x}_i +\\theta \\Big) + \\sum_{i=1}^n \\lambda_i \\\\ &= \\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j)-\\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\theta\\sum_{i=1}^n\\lambda_i y_i + \\sum_{i=1}^n \\lambda_i \\\\ &= -\\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum_{i=1}^n \\lambda_i \\end{align*}故有： \\min_{\\boldsymbol{\\omega},\\theta} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda}) = -\\frac{1}{2} \\sum_{i=1}^n \\sum_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum_{i=1}^n \\lambda_i对偶问题中的极大问题对于对偶问题中的极大问题： \\max_{\\boldsymbol{\\lambda}} \\min_{\\boldsymbol{\\omega},\\theta} L(\\boldsymbol{\\omega},\\theta,\\boldsymbol{\\lambda})即为对偶问题，有： \\begin{matrix} \\max\\limits_{\\boldsymbol{\\lambda}} && -\\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) + \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && \\lambda_i \\geq 0 ,\\quad i=1,2,\\cdots,n \\end{matrix}将该问题的目标函数由求极大转为求极小，就得到如下的等价的对偶最优化问题： \\begin{matrix} \\min\\limits_{\\boldsymbol{\\lambda}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && \\lambda_i \\geq 0 ,\\quad i=1,2,\\cdots,n \\end{matrix}可以发现，原始问题是凸优化问题，且 Slater 条件成立，那么，原始问题强对偶性成立，即求解原始问题可以转换为求解上述的对偶问题 假设上述的对偶问题对 $\\boldsymbol{\\lambda}$ 的解为 $\\boldsymbol{\\lambda}^* = (\\lambda_1^*,\\lambda_2^*,\\cdots,\\lambda_n^*)^T$，那么根据 KKT 条件，可得： \\begin{gather*} \\triangledown_{\\boldsymbol{\\omega}} L(\\boldsymbol{\\omega}^*,\\theta^*,\\boldsymbol{\\lambda}^*) = \\boldsymbol{\\omega}^* - \\sum_{i=1}^n \\lambda_i^* y_i \\mathbf{x}_i = 0 \\\\ \\triangledown_{\\theta} L(\\boldsymbol{\\omega}^*,\\theta^*,\\boldsymbol{\\lambda}^*)= -\\sum_{i=1}^n \\lambda_i^* y_i = 0 \\\\ \\lambda_i^*(y_i(\\boldsymbol{\\omega}^*\\cdot \\mathbf{x}_i+\\theta^*)-1) = 0 \\\\ y_i(\\boldsymbol{\\omega}^*\\cdot \\mathbf{x}_i+\\theta^*)-1 \\geq 0 \\\\ \\lambda_i^* \\geq 0,\\quad i=1,2,\\cdots,n \\end{gather*}故而有： \\boldsymbol{\\omega}^* = \\sum_{i=1}^n \\lambda_i^* y_i\\mathbf{x}_i同时，其中至少有一个 $\\lambda_j^*&gt;0$，对此 $j$ 有： y_j(\\boldsymbol{\\omega}^* \\cdot \\mathbf{x}_j+\\theta^*)-1=0将 $\\boldsymbol{\\omega}^* = \\sum\\limits_{i=1}^n \\lambda_i^* y_i\\mathbf{x}_i$ 带入到上式，并由 $y_j^2=1$，可得： \\theta^* = y_j - \\sum_{i=1}^n \\lambda_i^* y_i (\\mathbf{x_i}\\cdot \\mathbf{x}_j)故而，分离超平面可写为： \\sum_{i=1}^n \\lambda_i^* y_i(\\mathbf{x}\\cdot\\mathbf{x}_i) + \\theta^* =0分类决策函数可写为： f(\\mathbf{x}) = \\text{sign}\\Big(\\sum_{i=1}^n \\lambda_i^* y_i(\\mathbf{x}\\cdot\\mathbf{x}_i)+\\theta^*\\Big)对偶学习算法根据上述对偶问题的推导，可得到硬间隔支持向量机的对偶学习算法 输入：线性可分的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 输出：最大间隔分离超平面、分类决策函数 算法步骤： Step1：构造并求解如下约束最优化问题（原始问题的对偶问题） \\begin{matrix} \\min\\limits_{\\boldsymbol{\\lambda}} && \\frac{1}{2} \\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n \\lambda_i\\lambda_j y_i y_j (\\mathbf{x}_i\\cdot\\mathbf{x}_j) - \\sum\\limits_{i=1}^n \\lambda_i \\\\ s.t. && \\sum\\limits_{i=1}^n\\lambda_i y_i= 0 \\\\ && \\lambda_i \\geq 0 ,\\quad i=1,2,\\cdots,n \\end{matrix}求得最优解 $\\boldsymbol{\\lambda}^*$ Step2：根据最优解 $\\boldsymbol{\\lambda}^*$，计算分离超平面的法向量 $\\boldsymbol{\\omega}^*$ 和截距 $\\theta^*$ 对于法向量 $\\boldsymbol{\\omega}^*$，有： \\boldsymbol{\\omega}^* = \\sum_{i=1}^n \\lambda_i^* y_i\\mathbf{x}_i选择最优解 $\\boldsymbol{\\lambda}^*$的一个正分量 $\\lambda_j^*&gt;0$，计算截距 $\\theta^*$，有： \\theta^* = y_j - \\sum_{i=1}^n \\lambda_i^* y_i (\\mathbf{x_i}\\cdot \\mathbf{x}_j)Step3：根据最优解 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$，得到分离超平面 \\boldsymbol{\\omega}^* \\cdot \\mathbf{x} +\\theta^* = 0以及分类决策函数 f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*\\cdot\\mathbf{x}+\\theta^*) 对于 Step1 中的凸二次规划问题，可使用 SMO 算法来求解，关于 SMO 算法，详见：序列最小最优化(SMO)算法 【支持向量与间隔边界】在线性可分的情况下，对于训练集中与分离超平面距离最近的样本点 $(\\mathbf{x}_i,y_i)$ 的实例 $\\mathbf{x}_i$，被称为硬间隔的支持向量（Support Vector），即： y_i(\\boldsymbol{\\omega}\\mathbf{x}_i+\\theta)-1=0对于 $y_i=1$ 的正例点，支持向量位于超平面： H_1 : \\boldsymbol{\\omega} \\cdot \\mathbf{x} + \\theta =1对于 $y_i=-1$ 的负例点，支持向量位于超平面： H_2 : \\boldsymbol{\\omega} \\cdot \\mathbf{x} + \\theta = -1如图所示，在 $H_1$ 和 $H_2$ 上的点就是支持向量 可以发现，$H_1$ 与 $H_2$ 平行，两者之间形成一条长带，且没有样本点位于这条长带中，分离超平面与它们平行且位于它们中央 长带的宽度，即 $H_1$ 与 $H_2$ 间的距离被称为间隔（Margin），其依赖于超平面的法向量 $\\boldsymbol{\\omega}$，等于 $\\frac{2}{||\\boldsymbol{\\omega}||_2}$，此外，称 $H_1$ 和 $H_2$ 为间隔边界（Margin Border） 在决定这个位于两类训练样本的正中间的分离超平面时，只有支持向量起作用，如果移动支持向量将改变所求的解 此外，对于分类决策函数： f(\\mathbf{x}) = \\text{sign}\\Big(\\sum_{i=1}^n \\lambda_i^* y_i(\\mathbf{x}\\cdot\\mathbf{x}_i)+\\theta^*\\Big)根据 KKT 条件，对于任意样本 $(\\mathbf{x}_i,y_i)$，总有 $\\lambda_i=0$ 或 $y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)=1$ 当 $\\lambda_i=0$ 时，该样本不会在分类决策函数 $f(\\mathbf{x})$ 的求和中出现，也就不会对 $f(\\mathbf{x})$ 造成任何影响 当 $\\lambda_i&gt;0$ 时，必有 $y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)=1$，所对应的样本点正好位于间隔边界上，是一个支持向量 也就是说，硬间隔支持向量机的分类决策函数只依赖于支持向量，即训练数据中对应于 $\\lambda_i&gt;0$ 的样本点 $(\\mathbf{x}_i,y_i)$，其他样本点对 $\\boldsymbol{\\omega}^*$ 和 $\\theta^*$ 没有影响","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"支持向量机概述","slug":"machine-learning/38.支持向量机概述","date":"2019-08-14T12:58:00.000Z","updated":"2023-04-04T08:46:46.076Z","comments":true,"path":"artificial-intelligence/machine-learning/280b588e.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/280b588e.html","excerpt":"【引入】在 单层感知机 中介绍了单层感知机，其能够处理线性可分问题，同时，根据 Novikoff 定理可知，感知机学习算法的原始形式是迭代收敛的 但单层感知机的学习算法是以误分类样本点到超平面 $S$ 的总几何间隔作为损失函数，其存在诸多解，这些解既依赖于参数 $\\boldsymbol{\\omega}$ 和阈值 $\\theta$ 初值的选择，也依赖于迭代过程中误分类点的选择顺序","text":"【引入】在 单层感知机 中介绍了单层感知机，其能够处理线性可分问题，同时，根据 Novikoff 定理可知，感知机学习算法的原始形式是迭代收敛的 但单层感知机的学习算法是以误分类样本点到超平面 $S$ 的总几何间隔作为损失函数，其存在诸多解，这些解既依赖于参数 $\\boldsymbol{\\omega}$ 和阈值 $\\theta$ 初值的选择，也依赖于迭代过程中误分类点的选择顺序 如下图所示，对于线性可分的样本集而言，能够将样本集划分开的分离超平面可能有无穷多个 直观上来看，应该去找位于两类训练样本的正中间的分离超平面，这个超平面对未见样本的泛化能力是最强的 【支持向量机模型】支持向量机（Support Vector Machines，SVM）是感知机的进阶算法，也是一种二分类的线性分类模型，其本质上是寻找特征空间 $\\mathbb{R}^n$ 中的一个超平面 $S:\\boldsymbol{\\omega}\\cdot \\mathbf{x}+\\theta=0$，将特征空间划分为两个部分，使得位于两部分的点被分为正负两类 设输入空间 $\\mathcal{X}\\in \\mathbb{R}^{n}$，输出空间 $\\mathcal{Y}=\\{-1,+1\\}$，输入 $\\mathbf{x}=(x^{(1)},x^{(2)},…,x^{(n)})\\in\\mathcal{X}$ 为实例的特征向量，对应于输入空间的点，输出 $y\\in\\mathcal{Y}$ 为实例的类别 支持向量机的分类决策函数为： f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)其中，$\\boldsymbol{\\omega}\\in \\mathbb{R}^{n}$ 为权值（Weight），$\\theta\\in \\mathbb{R}$ 为阈值（Threshold），$\\boldsymbol{\\omega}\\cdot \\mathbf{x}$ 表示 $\\boldsymbol{\\omega}$ 与 $\\mathbf{x}$ 的内积 可以发现，支持向量机的分类决策函数与感知机的分类决策函数一致，但不同的是，感知机的学习算法是以误分类样本点到超平面 $S$ 的总几何间隔作为损失函数，支持向量机的学习算法是寻找能够正确划分训练集且使几何间隔最大的分离超平面，即两者的损失函数不同 【支持向量机的类型】支持向量机的学习策略是间隔最大化，根据训练数据的实际情况，可分为以下三类： 1）硬间隔支持向量机（Hard Margin Support Vector Machines） 当训练数据线性可分时，通过硬间隔最大化来求解唯一的最优分离超平面： S: \\boldsymbol{\\omega}^*\\cdot \\mathbf{x}+\\theta^* = 0以及相应的分类决策函数： f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*+\\theta^*)关于硬间隔支持向量机，详见：硬间隔支持向量机 2）软间隔支持向量机 当训练数据近似可分时，通过软间隔最大化来求解唯一的最优分离超平面： S: \\boldsymbol{\\omega}^*\\cdot \\mathbf{x}+\\theta^* = 0以及相应的分类决策函数： f(\\mathbf{x}) = \\text{sign}(\\boldsymbol{\\omega}^*+\\theta^*)关于硬间隔支持向量机，详见：软间隔支持向量机 3）非线性支持向量机 当训练数据线性不可分时，通过核方法在软间隔支持向量机的基础上来求解分类决策函数： f(\\mathbf{x}) = \\text{sign} (\\sum_{i=1}^n \\lambda_i^*y_iK(\\mathbf{x}_i,\\mathbf{x})+\\theta^*)关于非线性支持向量机，详见：非线性支持向量机 【支持向量机的学习策略】支持向量机的学习策略可以形式化为一个求解凸二次规划（Convex Quadratic Programming）的问题，也等价于正则化的铰链损失函数的最小化问题，其学习算法就是求解凸二次规划的最优算法 凸二次规划问题具有全局最优解且有许多最优化算法可用于这一问题的求解，但当训练样本容量 $n$ 很大时，这些算法往往会变得十分低效，以致无法使用 目前，针对这一问题，已经提出了许多快速求解凸二次规划问题的算法，在支持向量机中，最常用的是 SMO 算法 关于 SMO 算法，详见：序列最小最优化(SMO)算法","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"反向传播算法","slug":"deep-learning/01.反向传播算法","date":"2019-08-13T04:52:00.000Z","updated":"2023-03-31T12:22:38.287Z","comments":true,"path":"artificial-intelligence/deep-learning/437097cd.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/deep-learning/437097cd.html","excerpt":"【概述】反向传播（Error Back Propagation，BP）算法，是迄今为止最成功的神经网络训练算法，其不仅可用于多层前馈神经网络中，还可用于其他神经网络，但通常说到 BP 网络时，一般是指用 BP 算法所训练的多层前馈神经网络，此外，在实际应用中，当使用神经网络建模时，大多使用 BP 算法进行训练 BP 算法是一种迭代学习算法，在迭代的每一轮中采用感知机学习算法对参数进行更新，其仍是基于梯度下降法，以目标的负梯度方向对参数进行调整","text":"【概述】反向传播（Error Back Propagation，BP）算法，是迄今为止最成功的神经网络训练算法，其不仅可用于多层前馈神经网络中，还可用于其他神经网络，但通常说到 BP 网络时，一般是指用 BP 算法所训练的多层前馈神经网络，此外，在实际应用中，当使用神经网络建模时，大多使用 BP 算法进行训练 BP 算法是一种迭代学习算法，在迭代的每一轮中采用感知机学习算法对参数进行更新，其仍是基于梯度下降法，以目标的负梯度方向对参数进行调整 【符号假设】对于给定的容量为 $N$ 的样本集 $D=\\{(\\mathbf{x}_1,\\mathbf{y}_1),(\\mathbf{x}_2,\\mathbf{y}_2),…,(\\mathbf{x}_N,\\mathbf{y}_N)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $n$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $\\mathbf{y}_i$ 具有 $m$ 个特征值，即：$\\mathbf{y}_i=(y_i^{(1)},y_i^{(2)},…,y_i^{(m)})\\in\\mathcal{Y}=\\mathbb{R}^{m}$，也就是说，输入样本由 $n$ 个特征描述，输出为 $m$ 维实值向量 为便于讨论，下图给出了一个拥有 $n$ 个输入神经元、$H$ 个隐藏层神经元、$m$ 个输出神经元的多层前馈网络结构 其中，输入层第 $i$ 个神经元与隐藏层第 $h$ 个神经元的连接权用 $v_{ih}$ 表示，隐藏层第 $h$ 个神经元与输出层第 $j$ 个神经元的连接权用 $w_{hj}$ 表示，隐藏层第 $h$ 个神经元阈值用 $\\gamma_h$ 表示，输出层第 $j$ 个神经元阈值用 $\\theta_j$ 表示 可以发现，网络中有 $(n+m+1)H+m$ 个参数要确定，即： 输入层到隐藏层的 $n\\times H$ 个权值（输入层第 $i$ 个到隐藏层第 $h$ 个：$v_{ih}$） 隐藏层到输出层的 $H\\times m$ 个权值（隐藏层第 $h$ 个到输出层第 $j$ 个： $w_{hj}$） $H$ 个隐藏层神经元的阈值（隐藏层第 $h$ 个：$\\gamma_h$） $m$ 个输出层神经元的阈值（输出层第 $j$ 个：$\\theta_j$） 记隐藏层第 $h$ 个神经元收到的输入为 $\\alpha_h=\\sum\\limits_{i=1}^nv_{ih}x^{(i)}$，隐藏层第 $h$ 个神经元的输出为 $b_h = f(\\alpha_h-\\gamma_h)$，输出层第 $j$ 个神经元收到的输入为 $\\beta_j=\\sum\\limits_{h=1}^Hw_{hj}b_h$ 【损失函数】假设隐藏层与输出层神经元所使用的激活函数 $f(\\cdot)$ 均使用 sigmoid 函数，那么，对于训练集给出的某一输入样本 $(\\mathbf{x}_k,\\mathbf{y}_k)$，其通过神经网络的输出为 $\\hat{\\mathbf{y}}_k=(\\hat{y_k}^{(1)},\\hat{y_k}^{(2)},…,\\hat{y_k}^{(m)})$ 根据 MP 神经元，有： \\begin{align*} \\hat{y}_k^{(j)} &=f(\\beta_j-\\theta_j) \\\\ &= \\text{sigmoid} \\Big( \\sum\\limits_{h=1}^Hw_{hj}b_h-\\theta_j \\Big) \\\\ &= \\text{sigmoid} \\Big( \\sum\\limits_{h=1}^Hw_{hj}f(\\alpha_h-\\gamma_h) - \\theta_j \\Big) \\\\ &= \\text{sigmoid} \\Big( \\sum\\limits_{h=1}^Hw_{hj}f \\big(\\sum\\limits_{i=1}^nv_{ih}x^{(i)}-\\gamma_h \\big) - \\theta_j \\Big) \\end{align*}这个过程被称为多层前馈神经网络的前向传播（Forward propagation，FP） 此时，神经网络在输入样本 $(\\mathbf{x}_k,\\mathbf{y}_k)$ 上的均方误差为： MSE_{k}=\\frac{1}{m}\\sum_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2为便于求导，对 $MSE_k$ 整体乘以 $\\frac{m}{2}$，此时得到的函数为每一样本的损失函数，即： \\begin{align*} E_k &= \\frac{1}{2}\\sum_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2 \\\\ &= \\frac{1}{2} \\sum_{j=1}^m \\Big( \\text{sigmoid} \\Big( \\sum\\limits_{h=1}^Hw_{hj}f \\big(\\sum\\limits_{i=1}^nv_{ih}x^{(i)}-\\gamma_h \\big) - \\theta_j \\Big) -y_k^{(j)} \\Big)^2 \\end{align*} 【参数更新估计式】BP 算法基于梯度下降法，以目标的负梯度方向对参数进行更新估计，对于任意参数 $v$，其更新估计式为： v=v+\\triangle v值得注意的是，参数更新的方向是从后向前，即先更新输出层的连接权与阈值 $\\triangle w_{hj}$ 与 $\\triangle \\theta_j$，再更新隐藏层的连接权与阈值 $\\triangle v_{ih}$ 与 $\\triangle \\gamma_h$，这也是算法被称为反向传播的原因 那么，对于损失函数 $E_k$，给定学习率 $\\eta$，有： \\begin{matrix} \\triangle w_{hj} = -\\eta\\frac{\\partial E_k}{\\partial w_{hj}} & \\triangle v_{ih} = -\\eta\\frac{\\partial E_k}{\\partial v_{jh}} \\\\ \\triangle \\theta_j = -\\eta\\frac{\\partial E_k}{\\partial \\theta_j} & \\triangle \\gamma_h = -\\eta\\frac{\\partial E_k}{\\partial \\gamma_h} \\\\ \\end{matrix}经过推导，可得： \\begin{matrix} \\triangle w_{hj} = \\eta g_jb_h & \\triangle v_{ih} = \\eta e_hx_i \\\\ \\triangle \\theta_j = -\\eta g_j & \\triangle \\gamma_h = -\\eta e_h \\\\ \\end{matrix}其中，$g_j$ 为输出层神经元的梯度项，$e_h$ 为隐藏层神经元的梯度项，有： \\begin{matrix} g_j = \\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)}) \\\\ e_h = b_h(1-b_h)\\sum\\limits_{j=1}^mw_{hj}g_j \\end{matrix}关于具体的推导过程，见：附：详细推导 【算法流程】输入：容量为 $N$ 的样本集 $D=\\{(\\mathbf{x}_1,\\mathbf{y}_1),(\\mathbf{x}_2,\\mathbf{y}_2),…,(\\mathbf{x}_N,\\mathbf{y}_N)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $n$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $\\mathbf{y}_i$ 具有 $m$ 个特征值，即：$\\mathbf{y}_i=(y_i^{(1)},y_i^{(2)},…,y_i^{(m)})\\in\\mathcal{Y}=\\mathbb{R}^{m}$，学习率 $0&lt;\\eta\\leq1$ 输出：连接权与阈值确定的多层前馈神经网络 算法步骤： Step1：在 $(0,1)$ 范围内，随机初始化网络中所有的连接权与阈值 Step：对于训练集中的每个样本，执行以下步骤： 1）根据下式，计算当前样本的输出 $\\hat{\\mathbf{y}}_k=(\\hat{y_k}^{(1)},\\hat{y_k}^{(2)},…,\\hat{y_k}^{(m)})$ \\hat{y}_k^{(j)}=f(\\beta_j-\\theta_j)2）根据下式，计算输出层神经元的梯度项 $g_j$ g_j = \\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)})3）根据下式，计算隐藏层神经元的梯度项 $e_h$ e_h = b_h(1-b_h)\\sum\\limits_{j=1}^mw_{hj}g_j4）根据下述的参数更新估计式，更新连接权 $w_{hj},v_{ih}$ 与阈值 $\\theta_j,\\gamma_h$ \\begin{matrix} \\triangle w_{hj} = \\eta g_jb_h & \\triangle v_{ih} = \\eta e_hx_i \\\\ \\triangle \\theta_j = -\\eta g_j & \\triangle \\gamma_h = -\\eta e_h \\\\ \\end{matrix}Step3：重复 Step2，直到训练集的累计误差 $E$ 达到要求的值 E=\\frac{1}{N}\\sum_{k=1}^N E_k 通过上述算法流程可以发现，对于每个训练集中的每个训练样本，BP 算法先将输入提供给输入层单元，然后逐层将信号前传，直到产生输出层结果（步骤 Step2.1） 之后，再计算输出层的误差（步骤 Step2.2），将误差逆向传播至隐藏层（步骤 Step2.3），根据隐藏层神经元的误差对连接权和阈值进行调整（步骤 Step2.4） 下图给出了一个多层前馈神经网络的 FP 与 BP 的完整过程 【过拟合】对于一个隐藏层包含足够多的神经元的多层前馈神经网络，能够以任意精度逼近任意复杂度的连续函数，但如何设置隐藏层神经元个数仍然是个未解问题，在实际应用中，常采用试错法来解决 正因为多层前馈神经网络强大的表示能力，BP 神经网络经常会出现过拟合 为避免过拟合问题的发生，常采用以下策略进行缓解： 正则化（Regularizatoin）：在目标函数中增加用于描述网络复杂度的部分 随机失活（Dropout）：训练过程中，每次按一定的概率随机地删除一部分隐藏单元，删除概率一般设为 50% 提前终止（Early Stoping）：在模型对训练数据集迭代收敛前，通过停止迭代来防止过拟合 关于上述策略的详细介绍，详见：机器学习的模型选择 【附：详细推导】输出层连接权 $\\triangle w_{hj}$对于损失函数 $E_k$，给定学习率 $\\eta$，有： \\triangle w_{hj} = -\\eta\\frac{\\partial E_k}{\\partial w_{hj}}由于隐藏层第 $h$ 个神经元到输出层第 $j$ 个神经元的权值 $w_{hj}$，先影响到第 $j$ 个输出层神经元的输入 $\\beta_j$，再影响到其输出值 $\\hat{y}_k^{(j)}$，最后再影响到 $E_k$ 根据影响过程，可将求导部分进行拆分，有： \\frac{\\partial E_k}{\\partial w_{hj}}=\\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot \\frac{\\partial \\beta_j}{ \\partial w_{hj}}进一步，考虑到 $\\beta_j$ 为输出层第 $j$ 个神经元收到的输入，$\\hat{y}_k^{(j)}$ 为第 $k$ 个训练样本的第 $j$ 个输出单元的输出，$E_k$ 为网络的损失函数，即： \\begin{matrix} \\beta_j=\\sum\\limits_{h=1}^Hw_{hj}b_h \\\\ \\hat{y}_k^{(j)}=f(\\beta_j-\\theta_j) \\\\ E_k=\\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2 \\end{matrix}因此，有： \\begin{align*} \\frac{\\partial E_k}{\\partial w_{hj}} &= \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot \\frac{\\partial \\beta_j}{ \\partial w_{hj}} \\\\ &= \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot b_h \\\\ &= \\frac{\\partial \\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial f(\\beta_j-\\theta_j)}{\\partial \\beta_j} \\cdot b_h \\\\ &= (\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f'_{\\beta_j}(\\beta_j-\\theta_j) \\cdot b_h \\\\ \\end{align*}由于激活函数 $f(\\cdot)$ 为 sigmoid 函数，其导数为： f'(x)=f(x)(1-f(x))故有： \\begin{align*} \\frac{\\partial E_k}{\\partial w_{hj}} &= (\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f'_{\\beta_j}(\\beta_j-\\theta_j) \\cdot b_h \\\\ &= (\\hat{y}_k^{(j)}-y_k^{(j)}) f(\\beta_j-\\theta_j)(1-f(\\beta_j-\\theta_j))b_h \\\\ &= (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})b_h \\\\ &= -\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)})b_h \\end{align*}记 $g_j=\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)})$，有： \\frac{\\partial E_k}{\\partial w_{hj}}=-g_jb_h即： \\begin{align*} \\triangle w_{hj} &= -\\eta\\frac{\\partial E_k}{\\partial w_{hj}} \\\\ &= -\\eta \\cdot (-g_jb_h) \\\\ &= \\eta g_jb_h \\end{align*}输出层阈值 $\\triangle \\theta_j$对于损失函数 $E_k$，给定学习率 $\\eta$，有： \\triangle \\theta_j = -\\eta\\frac{\\partial E_k}{\\partial \\theta_j}仿照输出层连接权的拆分过程，可将求导部分进行拆分，有： \\frac{\\partial E_k}{\\partial \\theta_j}=\\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\theta_j}进一步，考虑到 $\\hat{y}_k^{(j)}$ 为第 $k$ 个训练样本的第 $j$ 个输出单元的输出，$E_k$ 为网络的损失函数，即： \\begin{matrix} \\hat{y}_k^{(j)}=f(\\beta_j-\\theta_j) \\\\ E_k=\\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2 \\end{matrix}因此，有： \\begin{align*} \\frac{\\partial E_k}{\\partial \\theta_j} &= \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\theta_j} \\\\ &= \\frac{\\partial \\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial f(\\beta_j-\\theta_j)}{\\partial \\theta_j} \\\\ &= (\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot [-f'_{\\theta_j}(\\beta_j-\\theta_j)] \\\\ \\end{align*}由于激活函数 $f(\\cdot)$ 为 sigmoid 函数，其导数为： f'(x)=f(x)(1-f(x))故有： \\begin{align*} \\frac{\\partial E_k}{\\partial \\theta_j} &= -(\\hat{y}_k^{(j)}-y_k^{(j)}) f'_{\\theta_j}(\\beta_j-\\theta_j) \\\\ &= -(\\hat{y}_k^{(j)}-y_k^{(j)}) f(\\beta_j-\\theta_j)(1-f(\\beta_j-\\theta_j)) \\\\ &= -(\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\\\ &= \\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)}) \\end{align*}记 $g_j=\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)})$，有： \\frac{\\partial E_k}{\\partial \\theta_j}=g_j即： \\begin{align*} \\triangle \\theta_j &= -\\eta\\frac{\\partial E_k}{\\partial \\theta_j} \\\\ &= -\\eta g_j \\end{align*}隐藏层连接权 $\\triangle v_{ih}$对于损失函数 $E_k$，给定学习率 $\\eta$，有： \\triangle v_{ih} = -\\eta\\frac{\\partial E_k}{\\partial v_{jh}}由于隐藏层第 $h$ 个神经元到输出层第 $j$ 个神经元的权值 $v_{jh}$，先影响到第 $h$ 个隐藏层神经元的输入 $\\alpha_h$，再影响到其输出值 $b_h$，之后再影响输出层第 $j$ 个神经元收到的输入 $\\beta_j$，继而影响到其输出值 $\\hat{y}_k^{(j)}$，最后再影响到 $E_k$根据影响过程，可将求导部分进行拆分，有： \\frac{\\partial E_k}{\\partial v_{ih}} = \\bigl[ -\\sum_{j=1}^m \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot \\frac{\\partial \\beta_j}{\\partial b_h}\\bigr] \\cdot \\frac{\\partial b_h}{\\partial \\alpha_h} \\cdot \\frac{\\partial \\alpha_h}{ \\partial v_{ih}}进一步，考虑到 $b_h$ 为隐藏层第 $h$ 个神经元的输出，$\\alpha_h$ 为隐藏层第 $h$ 个神经元收到的输入，$\\beta_j$ 为输出层第 $j$ 个神经元收到的输入，$\\hat{y}_k^{(j)}$ 为第 $k$ 个训练样本的第 $j$ 个输出单元的输出，$E_k$ 为网络的损失函数，即： \\begin{matrix} \\alpha_h=\\sum\\limits_{i=1}^nv_{ih}x^{(i)} \\\\ \\beta_j=\\sum\\limits_{h=1}^Hw_{hj}b_h\\\\ b_h = f(\\alpha_h-\\gamma_h)\\\\ \\hat{y}_k^{(j)}=f(\\beta_j-\\theta_j)\\\\ E_k=\\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2 \\end{matrix}因此，有： \\begin{align*} \\frac{\\partial E_k}{\\partial v_{ih}} &= \\bigl[ \\sum_{j=1}^m \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot \\frac{\\partial \\beta_j}{\\partial b_h}\\bigr] \\cdot \\frac{\\partial b_h}{\\partial \\alpha_h} \\cdot \\frac{\\partial \\alpha_h}{ \\partial v_{ih}} \\\\ &= \\bigl[ \\sum_{j=1}^m \\frac{\\partial \\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial f(\\beta_j-\\theta_j)}{\\partial \\beta_j} \\cdot w_{hj} \\bigr] \\cdot f'_{\\alpha_h}(\\alpha_h-\\gamma_h) \\cdot x^{(i)} \\\\ &= \\bigl[ \\sum_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f'_{\\beta_j}(\\beta_j-\\theta_j)\\cdot w_{hj} \\bigr] \\cdot f'_{\\alpha_h}(\\alpha_h-\\gamma_h) \\cdot x^{(i)} \\\\ \\end{align*}由于激活函数 $f(\\cdot)$ 为 sigmoid 函数，其导数为： f'(x)=f(x)(1-f(x))故有： \\begin{align*} \\frac{\\partial E_k}{\\partial v_{ih}} &= \\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f'_{\\beta_j}(\\beta_j-\\theta_j) \\cdot w_{hj} \\bigr]\\cdot f'_{\\alpha_h}(\\alpha_h-\\gamma_h) \\cdot x^{(i)} \\\\ &= \\bigl[\\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f(\\beta_j-\\theta_j)\\cdot(1-f(\\beta_j-\\theta_j)) \\cdot w_{hj} \\bigr] f'_{\\alpha_h}(\\alpha_h-\\gamma_h) \\cdot x^{(i)} \\\\ &= \\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\cdot w_{hj} \\bigr] \\cdot f'_{\\alpha_h}(\\alpha_h-\\gamma_h) \\cdot x^{(i)} \\\\ &= \\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\cdot w_{hj} \\bigr]\\cdot f(\\alpha_h-\\gamma_h)\\cdot(1-f(\\alpha_h-\\gamma_h)) \\cdot x^{(i)} \\\\ &= \\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\cdot w_{hj} \\bigr]\\cdot b_h(1-b_h) \\cdot x^{(i)} \\\\ &= -x^{(i)}\\cdot b_h(1-b_h)\\sum_{j=1}^m \\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)}) w_{hj} \\end{align*}记 $g_j=\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)})$，有： \\frac{\\partial E_k}{\\partial v_{ih}} = -x^{(i)}\\cdot b_h(1-b_h)\\sum_{j=1}^mw_{hj}g_j记 $e_h=b_h(1-b_h)\\sum\\limits_{j=1}^mw_{hj}g_j$，有： \\frac{\\partial E_k}{\\partial v_{ih}}=-e_h x^{(i)}即： \\begin{align*} \\triangle v_{ih} &= -\\eta\\frac{\\partial E_k}{\\partial v_{ih}} \\\\ &= -\\eta \\cdot (-e_h x^{(i)}) \\\\ &= \\eta e_h x^{(i)} \\end{align*}隐藏层阈值 $\\triangle \\gamma_h$对于损失函数 $E_k$，给定学习率 $\\eta$，有： \\triangle \\gamma_h = -\\eta\\frac{\\partial E_k}{\\partial \\gamma_h}仿照输出层连接权的拆分过程，可将求导部分进行拆分，有： \\frac{\\partial E_k}{\\partial \\gamma_h} = \\bigl[ -\\sum_{j=1}^m \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot \\frac{\\partial \\beta_j}{\\partial b_h}\\bigr] \\cdot \\frac{\\partial b_h}{\\partial \\gamma_h}进一步，考虑到 $b_h$ 为隐藏层第 $h$ 个神经元的输出，$\\beta_j$ 为输出层第 $j$ 个神经元收到的输入，$\\hat{y}_k^{(j)}$ 为第 $k$ 个训练样本的第 $j$ 个输出单元的输出，$E_k$ 为网络的损失函数，即： \\begin{matrix} \\beta_j=\\sum\\limits_{h=1}^Hw_{hj}b_h\\\\ b_h = f(\\alpha_h-\\gamma_h)\\\\ \\hat{y}_k^{(j)}=f(\\beta_j-\\theta_j)\\\\ E_k=\\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2 \\end{matrix}因此，有： \\begin{align*} \\frac{\\partial E_k}{\\partial \\gamma_h} &= \\bigl[ \\sum_{j=1}^m \\frac{\\partial E_k}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial \\hat{y}_k^{(j)}}{\\partial \\beta_j} \\cdot \\frac{\\partial \\beta_j}{\\partial b_h}\\bigr] \\cdot \\frac{\\partial b_h}{\\partial \\gamma_h} \\\\ &= \\bigl[ \\sum_{j=1}^m \\frac{\\partial \\frac{1}{2}\\sum\\limits_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)})^2}{\\partial \\hat{y}_k^{(j)}} \\cdot \\frac{\\partial f(\\beta_j-\\theta_j)}{\\partial \\beta_j} \\cdot w_{hj} \\bigr] \\cdot [-f'_{\\gamma_h}(\\alpha_h-\\gamma_h)] \\\\ &= \\bigl[ \\sum_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f'_{\\beta_j}(\\beta_j-\\theta_j)\\cdot w_{hj} \\bigr] \\cdot [-f'_{\\gamma_h}(\\alpha_h-\\gamma_h)] \\\\ \\end{align*}由于激活函数 $f(\\cdot)$ 为 sigmoid 函数，其导数为： f'(x)=f(x)(1-f(x))故有： \\begin{align*} \\frac{\\partial E_k}{\\partial \\gamma_h} &= \\bigl[ \\sum_{j=1}^m(\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f'_{\\beta_j}(\\beta_j-\\theta_j)\\cdot w_{hj} \\bigr] \\cdot [-f'_{\\gamma_h}(\\alpha_h-\\gamma_h)] \\\\ &= \\bigl[\\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)}) \\cdot f(\\beta_j-\\theta_j)\\cdot(1-f(\\beta_j-\\theta_j)) \\cdot w_{hj} \\bigr] \\cdot [-f'_{\\gamma_h}(\\alpha_h-\\gamma_h)] \\\\ &= \\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\cdot w_{hj} \\bigr] \\cdot [-f'_{\\gamma_h}(\\alpha_h-\\gamma_h)] \\\\ &= \\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\cdot w_{hj} \\bigr]\\cdot f(\\alpha_h-\\gamma_h)\\cdot [-f'_{\\gamma_h}(\\alpha_h-\\gamma_h)] \\\\ &= -\\bigl[ \\sum_{j=1}^m (\\hat{y}_k^{(j)}-y_k^{(j)})\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)}) \\cdot w_{hj} \\bigr]\\cdot b_h(1-b_h)\\\\ &= b_h(1-b_h)\\sum_{j=1}^m \\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)}) w_{hj} \\end{align*}记 $g_j=\\hat{y}_k^{(j)}(1-\\hat{y}_k^{(j)})(y_k^{(j)}-\\hat{y}_k^{(j)})$，有： \\frac{\\partial E_k}{\\partial \\gamma_h} = b_h(1-b_h)\\sum_{j=1}^mw_{hj}g_j记 $e_h=b_h(1-b_h)\\sum\\limits_{j=1}^mw_{hj}g_j$，有： \\frac{\\partial E_k}{\\partial \\gamma_h}=e_h即： \\begin{align*} \\triangle \\gamma_h &= -\\eta\\frac{\\partial E_k}{\\partial v_{ih}} \\\\ &= -\\eta \\cdot e_h\\\\ \\end{align*}点击返回","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"深度学习","slug":"artificial-intelligence/deep-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/deep-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"深度学习","slug":"deep-learning","permalink":"https://alex-mcavoy.github.io/tags/deep-learning/"}],"author":"Alex_McAvoy"},{"title":"多层感知机","slug":"machine-learning/37.多层感知机","date":"2019-08-11T07:20:00.000Z","updated":"2023-04-04T08:46:24.664Z","comments":true,"path":"artificial-intelligence/machine-learning/c3f7cdb7.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/c3f7cdb7.html","excerpt":"【引入】在 单层感知机 中，介绍了单层感知机模型： f(\\mathbf{x})=\\text{sign}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)其可以处理线性可分的二分类问题","text":"【引入】在 单层感知机 中，介绍了单层感知机模型： f(\\mathbf{x})=\\text{sign}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)其可以处理线性可分的二分类问题 与（AND）、或（OR）、非（NOT）均可认为是一线性可分问题，即这三种逻辑电路均可使用单层感知机来实现 而对于异或（XOR）来说，其是一个线性不可分问题，无法使用单层感知机来实现，考虑到异或可以通过与、或、非来组合实现： a⊕b = (¬a ∧ b) ∨ (a ∧¬b)那么，借鉴这种思想，将多个感知机进行连接，形成层级结构，由此有了多层感知机（Muti-Layer Perceptron，MLP） 【从与或非到异或】与门与门，是具有两个输入和一个输出的门电路，在两个输入均为 $1$ 时输出 $1$，其他情况输出 $0$ 其真值表如下： $x_1$ $x_2$ $y$ $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ $0$ $1$ $1$ $1$ 若想使用感知机来表示与门，需要做的就是确定参数 $\\omega_1,\\omega_2$ 与阈值 $\\theta$，使得在给定二值输入时，感知机的输出能够满足真值表 满足真值表条件的参数的选择方案有无数种，这里选取较为简单的一种，即： \\begin{matrix} \\omega_1=1 & \\omega_2=1 & \\theta=-2 \\end{matrix}此时，有： y=\\text{sign}(x_1+x_2-2)仅当 $x_1=x_2=1$ 时，有 $y=1$ 其分离超平面如下： 或门或门，是具有两个输入和一个输出的门电路，在两个输入中的任意一个为 $1$ 时输出 $1$，在两个输入全为 $0$ 时输出 $0$ 其真值表如下： $x_1$ $x_2$ $y$ $0$ $0$ $0$ $0$ $1$ $1$ $1$ $0$ $1$ $1$ $1$ $1$ 若想使用感知机来表示或门，需要做的就是确定参数 $\\omega_1,\\omega_2$ 与阈值 $\\theta$，使得在给定二值输入时，感知机的输出能够满足真值表 满足真值表条件的参数的选择方案有无数种，这里选取较为简单的一种，即： \\begin{matrix} \\omega_1=1 & \\omega_2=1 & \\theta=-0.5 \\end{matrix}此时，有： y=\\text{sign}(x_1+x_2-0.5)当 $x_1=1$ 或 $x_2=1$ 时，有 $y=1$ 其分离超平面如下： 非门非门，是具有一个输入和一个输出的门电路，在输入为 $1$ 时输出 $0$，输入为 $0$ 时输出 $1$ 其真值表如下： $x$ $y$ $0$ $1$ $1$ $0$ 若想使用感知机来表示非门，需要做的就是确定参数 $\\omega$ 与阈值 $\\theta$，使得在给定输入时，感知机的输出能够满足真值表 满足真值表条件的参数的选择方案有无数种，这里选取较为简单的一种，即： \\begin{matrix} \\omega=-1 & \\theta=0.5 \\end{matrix}此时，有： y=\\text{sign}(-x+0.5)当 $x=1$ 时，有 $y=0$；当 $x=0$ 时，有 $y=1$ 其分离超平面如下： 异或门异或门，是具有两个输入和一个输出的门电路，在两个输入相同时输出 $0$，在两个输入不同时输出 $1$ 其真值表如下： $x_1$ $x_2$ $y$ $0$ $0$ $0$ $0$ $1$ $1$ $1$ $0$ $1$ $1$ $1$ $0$ 其分离超平面如下： 可以看出，若想将其分开，只能通过如下图的曲线来分割 可以发现，异或问题是一个非线性可分问题，单层感知机无法进行实现 在数字电路中，异或门可以通过与门、非门、或门的组合来实现 根据上面的数字电路图，给出真值表： $x_1$ $x_2$ $s_1$ $s_2$ $y$ $0$ $0$ $1$ $0$ $0$ $0$ $1$ $1$ $1$ $1$ $1$ $0$ $1$ $1$ $1$ $1$ $1$ $0$ $1$ $0$ 那么，参考真值表，可以构建出如下由 MP 神经元构成的网络图，即最简单的多层感知机 其中，第 $0$ 层为输入层（Input Layer），该层不涉及到计算；第 $1$ 层用于处理数据，被称为隐藏层（Hidden Layer），第 $2$ 层为输出层（Output Layer），将隐藏层的输出进行处理，作为整个多层感知机的输出 【多层感知机】多层感知机（Multi-Layer Perceptron，MLP），也叫人工神经网络（Artificial Neural Network，ANN），是最简单的神经网络结构，其除了输入层和输出层外，中间可以有多个隐藏层，最简单的 MLP 只包含一个隐藏层 如上图所示的多层感知机，每层神经元与下一层神经元完全互连，且神经元间不存在同层连接与跨层连接，这样的神经网络结构被称为多层前馈神经网络（Multi-layer Feedforward Neural Networks） 对于多层前馈神经网络来说，输入层用于接收外接输入，隐藏层与输出层对输入进行处理，并由输出层输出，因此，上图所示的多层感知机，其层数为 $2$，一般称为两层网络 第 $0$ 层为输入层，该层不涉及到计算；第 $1$ 层为隐藏层，含有 $5$ 个 MP 神经元；第 $2$ 层为输出层，含有 $3$ 个 MP 神经元 设第 $1$ 层权重为 $W_h$，阈值为 $\\theta_h$，激活函数为 $f(\\cdot)$，则该多层感知机隐藏层的输出为： H=f(XW_h+\\theta_h)设第 $2$ 层权重为 $W_o$，阈值为 $\\theta_o$，则该多层感知机的输出为： \\begin{matrix} O=HW_o+\\theta_o \\end{matrix}将上述两个式子联立，可得： O=f(XW_h+\\theta_h)W_o+\\theta_o在分类问题中，通常会将输出层的输出单元个数设为 $1$ ，并对输出 $O$ 进行 softmax 运算，将输出转换为分类概率 多层感知机的学习过程，就是根据训练数据来调整神经元间的连接权重以及每个神经元的阈值，除了使用随机梯度下降法、牛顿法等迭代算法外，由于多层感知机是最基础的神经网络，其还可使用 BP 算法 关于 BP 算法，详见：反向传播算法 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现多层感知机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.neural_network import MLPClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立MLP模型，优化算法采用L-BFGS # solver可选： # - lbfgs：L-BFGS，在小数据上表现较好 # - adam：Adam，鲁棒性较好 # - sgd：SGD，在参数调整较优时会有最佳表现 model = MLPClassifier(solver='lbfgs', alpha=1e-5,hidden_layer_sizes=(30,20), random_state=1) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"单层感知机","slug":"machine-learning/36.单层感知机","date":"2019-08-10T05:33:00.000Z","updated":"2023-04-04T08:46:06.178Z","comments":true,"path":"artificial-intelligence/machine-learning/18592060.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/18592060.html","excerpt":"【概述】感知机（Perceptron）是神经网络和支持向量机的起源算法，从结构上来讲，其分为单层感知机（Single Layer Perceptron）和多层感知机（Multi-Layer Perceptron） 单层感知机就是 MP 神经元，其一般用于处理线性可分问题，多层感知机是多个 MP 神经元的累叠，通过增加层数来处理线性不可分问题","text":"【概述】感知机（Perceptron）是神经网络和支持向量机的起源算法，从结构上来讲，其分为单层感知机（Single Layer Perceptron）和多层感知机（Multi-Layer Perceptron） 单层感知机就是 MP 神经元，其一般用于处理线性可分问题，多层感知机是多个 MP 神经元的累叠，通过增加层数来处理线性不可分问题 单层感知机与 MP 神经元最主要的区别，在于感知机引入了损失函数与参数学习的过程，这是为什么将感知机称为最初的神经网络模型的原因 本文仅介绍单层感知机，为便于表述，以下内容所提到的感知机，均为单层感知机 【单层感知机模型】假设形式单层感知机是一种二分类的线性分类模型，其本质上是寻找特征空间 $\\mathbb{R}^{n}$ 中的一个超平面 $S:\\boldsymbol{\\omega}\\cdot \\mathbf{x}+\\theta=0$，将特征空间划分为两个部分，使得位于两部分的点被分为正负两类 设输入空间 $\\mathcal{X}\\in \\mathbb{R}^{n}$，输出空间 $\\mathcal{Y}=\\{-1,+1\\}$，输入 $\\mathbf{x}=(x^{(1)},x^{(2)},…,x^{(n)})\\in\\mathcal{X}$ 为实例的特征向量，对应于输入空间的点，输出 $y\\in\\mathcal{Y}$ 为实例的类别 在感知机中，激活函数一般使用 $\\text{sign}(\\cdot)$ 函数： f(\\mathbf{x})=\\text{sign}(\\boldsymbol{\\omega}\\cdot \\mathbf{x}+\\theta)=\\left\\{\\begin{array}{rl} +1, & \\boldsymbol{\\omega}\\cdot \\mathbf{x}+\\theta \\geq 0\\\\ -1, & \\boldsymbol{\\omega}\\cdot \\mathbf{x}+\\theta0由此，误分类样本 $(\\mathbf{x}_j,y_j)$ 到超平面 $S$ 的几何间隔为： \\gamma_j=-\\frac{1}{||\\boldsymbol{\\omega}||_2} y_j (\\boldsymbol{\\omega}\\cdot\\mathbf{x}_j+\\theta)那么，假设超平面 $S$ 的误分类点的集合为 $E$，则所有误分类点到超平面 $S$ 的总几何间隔为： \\gamma_{M}=-\\frac{1}{||\\boldsymbol{\\omega}||_2} \\sum_{\\mathbf{x}_j\\in E}y_j (\\boldsymbol{\\omega}\\cdot\\mathbf{x}_j+\\theta)于是，对于给定训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_N,y_N)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $n$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 对于误分类点集 $E=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_M,y_M)\\},M\\leq N$，第 $j$ 组样本中的输入 $\\mathbf{x}_j$ 具有 $n$ 个特征值，即：$\\mathbf{x}_j=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $y_j\\in\\mathcal{Y}=\\{+1,-1\\}$ 不考虑 $\\frac{1}{||\\boldsymbol{\\omega}||_2} $，感知机 $f(\\mathbf{x})=\\text{sign}(\\boldsymbol{\\omega}\\cdot \\mathbf{x}+\\theta)$ 的损失函数为： L(\\boldsymbol{\\omega},\\theta)=-\\sum_{j=1}^M y_j (\\boldsymbol{\\omega}\\cdot\\mathbf{x}_j+\\theta)显然，$L(\\boldsymbol{\\omega},\\theta)$ 是非负的，若没有误分类点，则 $L(\\boldsymbol{\\omega},\\theta)=0$，同时，误分类点越少，误分类点就距离超平面越近，损失函数值也就越小 【单层感知机学习算法】原始形式与对偶形式对于感知机模型，其损失函数为： L(\\boldsymbol{\\omega},\\theta)=-\\sum_{j=1}^M y_j (\\boldsymbol{\\omega}\\cdot\\mathbf{x}_j+\\theta)这时感知机学习问题就转换为求解损失函数的最优化问题，即： \\boldsymbol{\\omega}^*,\\theta^* = \\arg \\min_{\\boldsymbol{\\omega},\\theta}L(\\boldsymbol{\\omega},\\theta)对于上述的损失函数极小化问题，感知机学习算法一般选用随机梯度下降法进行求解，存在两种方法：原始形式、对偶形式 感知机学习算法的原始形式开始时，随机选取一个超平面 $\\boldsymbol{\\omega}_0,\\theta_0$，一般取 $\\boldsymbol{\\omega}_0=0,\\theta_0=0$ 然后用梯度下降法不断地极小化损失函数，极小化过程中，每次随机选取一个误分类点使其梯度下降 假设误分类点集合 $M$ 是固定的，那么损失函数 $L(\\boldsymbol{\\omega},\\theta)$ 的梯度由以下公式给出： \\left\\{\\begin{array}{rl} \\triangledown_{\\boldsymbol{\\omega}}L(\\boldsymbol{\\omega},\\theta) &=& -\\sum\\limits_{j=1}^M y_j\\mathbf{x}_j \\\\ \\triangledown_{\\theta}L(\\boldsymbol{\\omega},\\theta) &=& -\\sum\\limits_{j=1}^M y_j \\end{array} \\right.在误分类点集合 $E$ 中，随机选取一个误分类点 $(\\mathbf{x}_j,y_j)$，对 $\\boldsymbol{\\omega}$ 和 $\\theta$ 进行更新，有： \\left\\{\\begin{array}{rl} \\boldsymbol{\\omega}' &=& \\boldsymbol{\\omega} + \\alpha y_j\\mathbf{x}_j \\\\ \\theta' &=& \\theta + \\alpha y_j \\end{array} \\right.其中，$0&lt;\\alpha\\leq1$ 为学习率 这样，通过上述的更新公式，可以不断迭代以使损失函数 $L(\\boldsymbol{\\omega},\\theta)$ 不断减小，直到为 $0$ 也就是说，当一个样本点被误分类，即位于分离超平面的错误一侧时，就调整 $\\boldsymbol{\\omega}$ 与 $\\theta$ 的值，使超平面向该误分类点一侧移动，以减少该误分类点与超平面的距离，直到超平面越过该误分类点使其被正确分类 下面给出感知机学习算法的原始形式算法流程 输入：训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_N,y_N)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $n$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$，学习率 $0&lt;\\alpha\\leq1$ 输出：参数 $\\boldsymbol{\\omega}$，阈值 $\\theta$，感知机模型 $f(\\mathbf{x})=\\text{sign}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta)$ 算法步骤： 随机选取参数与阈值的初值 $\\boldsymbol{\\omega}_0,\\theta_0$ 在训练集中随机选取样本 $(\\mathbf{x}_i,y_i)$ 若 $y_i(\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta)\\leq 0$，更新 $\\boldsymbol{\\omega}$ 与 $\\theta$ \\left\\{\\begin{array}{rl} \\boldsymbol{\\omega} &=& \\boldsymbol{\\omega} + \\alpha y_i\\mathbf{x}_i \\\\ \\theta &=& \\theta + \\alpha y_i \\end{array} \\right. 转至步骤 2，直到训练集中没有误分类点 感知机学习算法的对偶形式对偶形式的基本想法是：将参数 $\\boldsymbol{\\omega}$ 和阈值 $\\theta$ 表示为样本特征 $\\mathbf{x}_i$ 和样本类别 $y_i$ 的线性组合形式，通过求解其系数来求得 $\\boldsymbol{\\omega}$ 和 $\\theta$ 不失一般性，假设原始形式的初值均为 $0$，即： \\boldsymbol{\\omega}_0=0,\\theta_0=0对于误分点 $(\\mathbf{x}_i,y_i)$，通过以下迭代公式对 $\\boldsymbol{\\omega}$ 和 $\\theta$ 进行修改 \\left\\{\\begin{array}{rl} \\boldsymbol{\\omega} &=& \\boldsymbol{\\omega}+\\alpha y_i\\mathbf{x}_i \\\\ \\theta &=& \\theta+\\alpha y_i \\end{array} \\right.假设修改 $n$ 次，则 $\\boldsymbol{\\omega}$ 和 $\\theta$ 关于 $(\\mathbf{x}_i,y_i)$ 的增量分别是 $n_i\\alpha y_i\\mathbf{x}_i$ 与 $n_i\\alpha y_i$，那么，最后学习到的 $\\boldsymbol{\\omega}$ 和 $\\theta$ 可以表示为： \\left\\{\\begin{array}{rl} \\boldsymbol{\\omega} &=& \\sum\\limits_{i=1}^N n_i\\alpha y_i\\mathbf{x}_i \\\\ \\theta &=& \\sum\\limits_{i=1}^N n_i\\alpha y_i \\end{array} \\right.当 $\\alpha=1$ 时，$\\boldsymbol{\\omega}$ 和 $\\theta$ 被表示第 $i$ 个样本点由于误分类而进行更新的次数 更新次数越多，意味着样本点距离超平面越近，也就越难被分类 下面给出感知机学习算法的对偶形式算法流程 输入：线性可分训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_N,y_N)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $n$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$，学习率 $0&lt;\\alpha\\leq1$ 输出：参数 $\\boldsymbol{\\eta}=\\alpha(n_1,n_2,\\cdots,n_N)^T$，阈值 $\\theta$，感知机模型 $f(\\mathbf{x})=\\text{sign} \\big( (\\sum\\limits_{i=1}^N \\eta_i y_i\\mathbf{x}_i) \\cdot\\mathbf{x}+\\theta \\big)$ 算法步骤： 选取增量与阈值的初值 $\\boldsymbol{\\eta}_0,\\theta_0$，取 $\\boldsymbol{\\eta}_0=0,\\theta_0=0$ 在训练集中随机选取样本 $(\\mathbf{x}_i,y_i)$ 若 $y_i \\big( (\\sum\\limits_{j=1}^N\\eta_j y_j\\mathbf{x}_j)\\cdot\\mathbf{x}_i+\\theta \\big) \\leq 0$，更新 $\\eta_i$ 与 $\\theta$ \\left\\{\\begin{array}{rl} \\eta_j &=& \\eta_j + \\alpha \\\\ \\theta &=& \\theta + \\alpha y_i \\end{array} \\right. 转至步骤 2，直到训练集中没有误分类点 由于对偶形式中训练样本仅以内积的形式出现，为处理方便，通常预先将训练集中样本间的内积计算出来并以矩阵的形式存储，这个矩阵是一个半正定矩阵，被称为格拉姆矩阵（Gram Matrix），即： G = [ \\mathbf{x}_i\\cdot \\mathbf{x}_j ]_{N\\times N}时间复杂度分析原始形式与对偶形式则两种方法在寻找误分类样本点的过程是一样的，只是在找到一个误分点时两者后续的参数更新方法不同，这就导致了两者的时间复杂度不同 对于样本数量为 $N$，特征数量为 $n$ 的训练集，两者时间复杂度如下： 原始形式：每次计算 $\\boldsymbol{\\omega}\\cdot\\mathbf{x}$，计算该内积的复杂度为 $O(n)$ 对偶形式：提前将 $\\mathbf{x}_i$ 与 $\\mathbf{x}_j$ 的内积存储在 Gram 矩阵中，因此只需要扫描一遍数据集，找到一个误分点后直接加上，时间复杂度为 $O(N)$ 因此，选择哪种计算方法取决于训练集的样本数量和特征数量的大小 【感知机学习算法的收敛性】对于线性可分数据集，感知机学习算法的原始形式收敛，即：经过有限次迭代后，可以得到一个训练集完全正确划分的分离超平面及感知机模型 首先将阈值 $\\theta$ 并入权重 $\\boldsymbol{\\omega}$ 中，记作： W=(\\boldsymbol{\\omega}^T,\\theta)^T同时，将输入向量 $\\mathbf{x}$ 进行扩充，加入常数 $1$，记作： X=(\\mathbf{x}^T,1)^T由此，$W,X\\in \\mathbb{R}^{n+1}$，且有： WX=\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta设训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_N,y_N)\\}$ 是线性可分的，那么根据数据集的线性可分性，存在超平面 $S$ 可将训练集完全正确分开，设该超平面为： W_{opt}X=\\boldsymbol{\\omega}_{opt}\\cdot\\mathbf{x}+\\theta_{opt}=0取 $||W_{opt}||_2=1$，对于有限的 $i=1,2,…,N$，均有： y_i(W_{opt}X_i)=y_i(\\boldsymbol{\\omega}_{opt}\\cdot \\mathbf{x}_i+\\theta_{opt})>0令： \\gamma=\\min_i \\{y_i(\\boldsymbol{\\omega}_{opt}\\mathbf{x}_i+\\theta_{opt})\\}故有： y_i(W_{opt}X_i)=y_i(\\boldsymbol{\\omega}_{opt}\\cdot\\mathbf{x}_i+\\theta)\\geq \\gamma=\\min_i \\{y_i(\\boldsymbol{\\omega}_{opt}\\mathbf{x}_i+\\theta_{opt})\\}感知机学习算法一般从 $\\boldsymbol{\\omega}=0,\\theta=0$ 开始迭代，当样本被误分类时，更新权重与阈值 取 $W_{k-1}$ 为第 $k$ 个误分类样本之前的扩充权重向量，即： W_{k-1}=(\\boldsymbol{\\omega}_{k-1}^T,\\theta_{k-1})^T假设 $(\\mathbf{x}_j,y_j)$ 是第 $k$ 个被误分类，即被 $W_{k-1}=(\\boldsymbol{\\omega}_{k-1}^T,\\theta_{k-1})^T$ 误分类的样本，则其满足： y_j(W_{k-1}X_j)=y_j(\\boldsymbol{\\omega}_{k-1}\\cdot x_j+\\theta_{k-1})\\leq0且权重 $\\boldsymbol{\\omega}$ 与阈值 $\\theta$ 的更新为： \\left\\{\\begin{array}{rl} \\boldsymbol{\\omega}_k &=& \\boldsymbol{\\omega}_{k-1} + \\alpha y_j\\mathbf{x}_j \\\\ \\theta_k &=& \\theta_{k-1} + \\alpha y_j \\end{array} \\right.即： W_k=W_{k-1}+\\alpha y_jX_j考虑将训练集线性可分的超平面 $S:W_{opt}X=0$，有： \\begin{align*} W_kW_{opt} &= W_{k-1}W_{opt}+\\alpha y_jW_{opt}X_j \\\\ &\\geq W_{k-1}W_{opt}+\\alpha\\cdot\\min_j \\{y_jW_{opt}X_j\\} \\end{align*}由于 $\\min\\limits_j\\{y_jW_{opt}X_j\\}=\\min\\limits_j \\{y_j(\\boldsymbol{\\omega}_{opt}\\mathbf{x}_j+\\theta_{opt})\\}=\\gamma$，故有： W_kW_{opt}\\geq W_{k-1}W_{opt}+\\alpha\\gamma根据上式进行递推，有： \\begin{align*} W_kW_{opt} &\\geq W_{k-1}W_{opt}+\\alpha\\gamma \\\\ &\\geq W_{k-2}W_{opt}+2\\alpha\\gamma \\\\ &\\geq ...\\\\ &\\geq k\\alpha\\gamma \\end{align*}即： W_kW_{opt}\\geq k\\alpha\\gamma进一步，考虑到： W_k=W_{k-1}+\\alpha y_jX_j对其两边同取 $l_2$ 范数的平方，有： ||W_k||_2^2 = ||W_{k-1}||_2^2+2\\alpha y_iW_{k-1}X_j+\\alpha^2||X_j||_2^2根据第 $k$ 个被误分类样本所满足的条件： y_j(W_{k-1}X_j)=y_j(\\boldsymbol{\\omega}_{k-1}\\cdot x_j+\\theta_{k-1})\\leq0有： 2\\alpha y_jW_{k-1}X_j\\leq0故： \\begin{align*} ||W_k||_2^2 &= ||W_{k-1}||_2^2 + 2\\alpha y_iW_{k-1}X_j + \\alpha^2||X_j||_2^2 \\\\ &\\leq ||W_{k-1}||_2^2 + \\alpha^2||X_j||_2^2 \\end{align*}令 $R=\\max\\limits_{1\\leq i\\leq N}||X_i||_2$，则有： \\begin{align*} ||W_k||_2^2 &= ||W_{k-1}||_2^2 + 2\\alpha y_iW_{k-1}X_j + \\alpha^2||X_j||_2^2 \\\\ &\\leq ||W_{k-1}||_2^2 + \\alpha^2||X_j||_2^2 \\\\ &\\leq ||W_{k-1}||_2^2 + \\alpha^2R^2 \\end{align*}结合递推不等式： W_k=W_{k-1}+\\alpha y_jX_j故有： \\begin{align*} ||W_k||_2^2 &= ||W_{k-1}||_2^2 + 2\\alpha y_iW_{k-1}X_j + \\alpha^2||X_j||_2^2 \\\\ &\\leq ||W_{k-1}||_2^2 + \\alpha^2||X_j||_2^2 \\\\ &\\leq ||W_{k-1}||_2^2 + \\alpha^2R^2 \\\\ &\\leq ||W_{k-2}||_2^2 + 2\\alpha^2R^2 \\\\ &\\leq ...\\\\ &\\leq k\\alpha^2R^2 \\end{align*}即： ||W_k||_2^2\\leq k\\alpha^2R^2根据 $W_kW_{opt}\\geq k\\alpha\\gamma$，结合上式，有： k\\alpha\\gamma \\leq W_kW_{opt} \\leq ||W_k||_2||W_{opt}||_2\\leq \\sqrt{k}\\alpha R即： k^2\\gamma^2\\leq kR^2故有： k\\leq (\\frac{R}{\\gamma})^2 上述推导过程即为，Novikoff 定理的证明过程，其内容表述如下： 设训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_N,y_N)\\}$ 是是线性可分的，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $n$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^n$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$，则： 存在满足条件 $||W_{opt}||_2=1$ 的超平面 $S:W_{opt}X=\\boldsymbol{\\omega}_{opt}\\cdot\\mathbf{x}+\\theta_{opt}=0$ 将训练集完全正确分开，且存在 $\\gamma&gt;0$，对所有的 $i=1,2,…,N$，有： y_i(W_{opt}X_i)=y_i(\\boldsymbol{\\omega}_{opt}\\cdot\\mathbf{x}_i+\\theta_{opt})\\geq \\gamma 令 $R=\\max\\limits_{i}||X_i||_2$，则感知机学习算法原始形式在训练集上的误分类次数 $k$ 满足以下不等式： k\\leq (\\frac{R}{\\gamma})^2 该定理表明，分离超平面下样本点的函数间隔 $y_i(\\boldsymbol{\\omega}_{opt}\\cdot\\mathbf{x}_i+\\theta_{opt})$ 存在下界，误分类次数 $k$ 存在上界，经过有限次搜索可以找到将训练集完全正确分开的分离超平面 也就是说，当训练集线性可分时，感知机学习算法原始形式是迭代收敛的 而当训练集线性不可分时，感知机学习算法原始形式是不迭代收敛的，迭代结果会发生震荡，为处理训练集线性不可分的情况，由此出现了多层感知机（Multi-Layer Perceptron） 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现感知机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.linear_model import Perceptronfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立感知机模型 # tol参数设置一个特定值，当本次迭代损失与上次迭代损失的差小于一个特定值时，停止迭代；若设置为None，将会一直迭代，直至差为0 model = Perceptron(tol=None) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"线性可分与几何间隔","slug":"machine-learning/35.线性可分与几何间隔","date":"2019-08-09T03:03:00.000Z","updated":"2023-03-31T12:33:30.569Z","comments":true,"path":"artificial-intelligence/machine-learning/1f0eefc7.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/1f0eefc7.html","excerpt":"【线性可分与分离超平面】在二维空间上，两类点被一条直线完全分开称为线性可分","text":"【线性可分与分离超平面】在二维空间上，两类点被一条直线完全分开称为线性可分 从二维空间扩展到多维空间中，其数学定义为： 对于 $n$ 维欧氏空间中的两个点集 $D_0$ 和 $D_1$，若存在 $n$ 维向量 $\\boldsymbol{\\omega}$ 和实数 $\\theta$，使得所有属于 $D_0$ 的点 $\\mathbf{x}_i$ 都有 $\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta&gt;0$，所有属于 $D_1$ 的点 $\\mathbf{x}_j$ 都有 $\\boldsymbol{\\omega}\\cdot\\mathbf{x}_j+\\theta&lt;0$，则称 $D_0$ 和 $D_1$ 线性可分（Linearly Separable），否则称为线性不可分（Linearly Inseparable） 此时，线性方程 $\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta=0$ 构成一个将点集 $D_0$ 和 $D_1$ 完全正确划分的分离超平面（Separating Hyperplane），其中，权值 $\\boldsymbol{\\omega}$ 为分离超平面的法向量，偏置 $\\theta$ 是分离超平面的截距 【线性可分数据集】对于给定的容量为 $n$ 的样本集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^n$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 若存在某个分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 能够将训练集的正样本点与负样本点完全正确地划分到分离超平面的两侧，即： 对于所有的 $y_i=+1$ 的样本，有：$\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta&gt;0$ 对于所有的 $y_i=-1$ 的样本，有：$\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta&lt;0$ 则称训练集 $D$ 是线性可分的数据集，否则，称训练集 $D$ 为线性不可分的数据集 【函数间隔与几何间隔】函数间隔一般来说，一个点与分离超平面的距离，可以表示分类预测的确信程度 在分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 确定的情况下，$|\\boldsymbol{\\omega}\\cdot\\mathbf{x}_0+\\theta|$ 表示输入空间 $\\mathbb{R}^n$ 中任意一点 $\\mathbf{x}_0$ 到超平面 $S$ 的距离，此时，通过判断 $\\boldsymbol{\\omega}\\cdot\\mathbf{x}_0+\\theta$ 的符号与类标记 $y_0$ 的符号是否一致，即可表示分类是否正确 为此，定义函数间隔（Functional Margin），来表示分类预测的正确性以及确信度 对于给定容量为 $n$ 的样本集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 则分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本点 $(\\mathbf{x}_i,y_i)$ 的函数间隔定义为： \\hat{\\gamma_i} = y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)那么分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本集 $D$ 的中所有样本点的函数间隔的最小值为： \\hat{\\gamma} = \\min_{i=1,2,\\cdots,n} \\hat{\\gamma}_i几何间隔在选择分离超平面时，只有函数间隔还不够，因为只要成比例的改变 $\\boldsymbol{\\omega}$ 和 $\\theta$，函数间隔也会成比例的改变（此时超平面不变），例如，将 $\\boldsymbol{\\omega}$ 和 $\\theta$ 改为 $2\\boldsymbol{\\omega}$ 和 $2\\theta$，此时函数间隔 $\\hat{\\gamma}_i$ 也变为原来的两倍 为此，可以使用 $L2$ 范数对分离超平面 $S$ 的法向量 $\\boldsymbol{\\omega}$ 进行约束，此时函数间隔就成了几何间隔（Geometric Margin） 对于给定容量为 $n$ 的样本集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x}_i$ 具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}=\\{+1,-1\\}$ 则分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本点 $(\\mathbf{x}_i,y_i)$ 的几何间隔定义为： \\gamma_i = y_i \\big( \\frac{1}{||\\boldsymbol{\\omega}||_2}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta) \\big)那么分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本集 $D$ 的中所有样本点的几何间隔的最小值为： \\gamma = \\min_{i=1,2,\\cdots,n} \\hat{\\gamma}_i此时，分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本点 $(\\mathbf{x}_i,y_i)$ 的几何间隔就是样本点到分离超平面的带符号的距离，当样本点被分离超平面正确分类时，就是样本点到分离超平面的距离 如图所示，$\\boldsymbol{\\omega}$ 为分离超平面的法向量，对于样本 $A$，$\\gamma_i$ 为其到分离超平面 $S$ 的几何间隔 函数间隔与几何间隔的关系分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本点 $(\\mathbf{x}_i,y_i)$ 的函数间隔为： \\hat{\\gamma_i} = y_i(\\boldsymbol{\\omega}\\cdot \\mathbf{x}_i+\\theta)分离超平面 $S:\\boldsymbol{\\omega}\\cdot\\mathbf{x}+\\theta=0$ 关于样本点 $(\\mathbf{x}_i,y_i)$ 的几何间隔为： \\gamma_i = y_i \\big( \\frac{1}{||\\boldsymbol{\\omega}||_2}(\\boldsymbol{\\omega}\\cdot\\mathbf{x}_i+\\theta) \\big)两者有如下的关系： \\begin{align*} \\gamma_i &= \\frac{1}{||\\boldsymbol{\\omega}||_2} \\hat{\\gamma_i} \\\\ \\gamma &= \\frac{1}{||\\boldsymbol{\\omega}||_2} \\hat{\\gamma} \\end{align*}当法向量 $\\boldsymbol{\\omega}$ 的 $L2$ 范数为 $1$，即 $||\\boldsymbol{\\omega}||_2$ 时，函数间隔与几何间隔相等 同时，对于法向量 $\\boldsymbol{\\omega}$ 和截距 $\\theta$ 成比例改变时，函数间隔也按该比例进行改变，但几何间隔不变","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"MP 神经元","slug":"machine-learning/34.MP神经元","date":"2019-08-09T03:03:00.000Z","updated":"2023-03-31T12:43:25.214Z","comments":true,"path":"artificial-intelligence/machine-learning/aa378dc.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/aa378dc.html","excerpt":"【概述】MP 神经元是由 McCulloch 与 Pitts 于 1943 年发表的神经元模型，其是按照生物神经元的结构与工作原理所构造的一个抽象与简单的模型，简单模拟了神经元的反应流程 在目前的神经网络中，最基本的单元就是神经元（Neuron），即 MP 神经元","text":"【概述】MP 神经元是由 McCulloch 与 Pitts 于 1943 年发表的神经元模型，其是按照生物神经元的结构与工作原理所构造的一个抽象与简单的模型，简单模拟了神经元的反应流程 在目前的神经网络中，最基本的单元就是神经元（Neuron），即 MP 神经元 而神经网络训练的过程，实际上就是根据训练样本调整 MP 神经元权重和阈值的过程 【生物神经元】对于生物神经网络来说，可以概括出以下特点： 每个神经元都是一个多输入单输出的信号处理单元 神经元输入分为兴奋性输入、抑制性输入两种类型 神经元具有空间整合特性与阈值特性 神经元输入与输出间存在固定的时延，主要取决于突触延搁 【MP 神经元结构】上图展示了生物神经元的基本结构，仿照生物神经元的结构，忽略时间整合作用、不应期等复杂因素，同时将神经元突触时延与强度作为常数，可建立出如下图所示的 MP 神经元 【从生物神经元到 MP 神经元】下面，将生物神经元与 MP 神经元进行对比： 生物神经元 MP 神经元 神经元 $j$ 输入信号 $x_i$ 刺激的不同强度 $w_{ij}$ 突触 $w_{ij}x_i$ 汇聚电信号的细胞膜 $\\sum$ 膜电位 $\\sum\\limits_{i=1}^nw_{ij}x_i$ 外界刺激达到什么程度神经元才会被激活 $\\theta_j$ 神经元被激活释放脉冲 $f(\\cdot)$ 输出信号 $y_j$ 结合 MP 神经元的结构图来看，对于某个 MP 神经元 $j$ 来说，其可同时接收多个输入信号 $x_i$，代表外界刺激 由于生物神经元具有不同的突触性质与强度，用权值 $w_{ij}$ 表示，其正负模拟了生物神经元中的兴奋与抑制，其大小模拟了生物神经元中突触的不同连接强度，由此，输入信号 $x_i$ 与权值 $w_{ij}$ 模拟了生物神经元的突触部分 在生物神经元中，会将多个突触末梢的电信号在细胞膜中进行汇聚，在 MP 神经元中使用 $\\sum$ 函数来代表，$\\sum\\limits_{i=1}^nw_{ij}x_i$ 就是将所有突触末端的刺激进行汇聚，将多个值合并为一个值，由此代表生物神经元汇聚后的膜电位 生物神经元只有在受到外界刺激一定程度后才会被激活，由此设置了阈值（Threshold）又称偏置（Bias） $\\theta_j$，高于阈值电平的部分为整个神经元的净激活（Net Activation）值，即： net_j=\\sum_{i=1}^nw_{ij}x_i-\\theta_j考虑到只有当输入总和超过阈值时，神经元才会被激活释放脉冲，为此，使用 $f(\\cdot)$ 来表示激活函数，用来确定是否产生神经元的输出 因此，整个 MP 神经元可用如下公式表达： \\begin{align*} y_j &= f(net_j)\\\\ &= f(\\sum_{i=1}^nw_{ij}x_i-\\theta_j) \\end{align*}注：关于激活函数 $f(\\cdot)$，详见 常见的激活函数 【MP 神经元的表示】对于 MP 神经元： y_j=f(\\sum_{i=1}^nw_{ij}x_i-\\theta_j)如果将阈值 $\\theta_j$ 看作一个输入为 $x_0=-1$ 且连接权重为 $w_{0j}$ 的哑结点，那么权重 $w_{ij}$ 和与阈值 $\\theta_j$ 可进行统一，即： y_j=f(\\sum_{i=0}^nw_{ij}x_i)进一步，用 $X$ 表示输入向量，用 $W$ 表示权重向量，即： \\begin{matrix} X=[x_0,x_1,...,x_n],W=\\begin{bmatrix} w_{0j} \\\\ w_{1j} \\\\ \\vdots w_{nj} \\end{bmatrix} \\end{matrix}则 MP 神经元的净激活为： net_j=XW则整个 MP 神经元可表示为： y_j=f(XW)若 $net_j&gt;0$，则神经元处于兴奋状态，若 $net_j&lt;0$，则神经元处于抑制状态","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"决策树的剪枝策略","slug":"machine-learning/33.决策树的剪枝策略","date":"2019-08-07T05:44:00.000Z","updated":"2023-03-31T12:33:34.118Z","comments":true,"path":"artificial-intelligence/machine-learning/1a3614c.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/1a3614c.html","excerpt":"【概述】剪枝（Pruning）是决策树处理过拟合的主要手段，即通过主动去掉一些分支来降低过拟合的风险 决策树剪枝的基本策略有预剪枝（Pre-Pruning）、后剪枝（Post-Pruning）两种，在实际应用中，往往使用后剪枝策略更多一些","text":"【概述】剪枝（Pruning）是决策树处理过拟合的主要手段，即通过主动去掉一些分支来降低过拟合的风险 决策树剪枝的基本策略有预剪枝（Pre-Pruning）、后剪枝（Post-Pruning）两种，在实际应用中，往往使用后剪枝策略更多一些 【预剪枝】预剪枝是在决策树生成过程中进行的剪枝，其基于贪心策略，不仅可以降低过拟合的风险，而且还可以减少训练时间，但可能会出现欠拟合现象 预剪枝是在决策树生成过程中进行的剪枝，常用的方法有： 提前设定决策树的高度，当达到这个高度时，停止构建决策树 当达到某节点的实例具有相同的特征向量，停止树的生长 提前设定阈值，当达到某个节点的样例个数小于该阈值的时，停止树的生长（该方法无法用于数据量较小的训练样例） 提前设定阈值，每次扩展决策树后，计算其对系统性能的增益，若小于该阈值，则停止生长 对每个结点在划分前进行估计，若当前结点的划分无法使决策树的泛化性能提升，则停止划分，并将当前结点标记为叶结点 【后剪枝】后剪枝是在决策树生成之后，对于一棵完整的决策树，按照树的前序遍历或后序遍历的顺序，对分支结点进行考察，若分支结点对应的子树替换为叶结点能够带来决策树的泛化性能提升，则将子树替换为叶结点 目前主要应用的后剪枝方法有三种： 误差降低剪枝（Reduced Error Pruning，REP） 悲观错误剪枝（Pessimistic Error Pruning，PEP） 代价复杂度剪枝（Cost-Complexity Pruning，CCP） 此外，常见的后剪枝方法还有：基于错误的剪枝（Error-Based Pruning，EBP）、最小错误剪枝（Minimum Error Pruning，MEP）、临界值剪枝（Critical Value Pruning，CVP）、最优剪枝（Optimal Pruning，OPP）等，这里不再详细介绍 【误差降低剪枝】剪枝策略误差降低剪枝（Reduced Error Pruning，REP）是最简单粗暴的后剪枝方法，在利用训练样本生成决策树后，按照树的后序遍历算法，对于每个分支结点计算修剪前后在验证集上的分类错误率，来决定是否修剪该结点 算法流程如下： 按照树的后序遍历顺序，依次决定 $n$ 个分支节点是否需要被修剪 对于第 $i$ 个分支结点，假设要删除该分支结点的子树，使其成为叶结点，并赋予训练样本最常见的分类 用验证样本计算修剪前、修剪后分类的错误率 当修剪后的分类错误率小于等于修剪前的分类错误率时，删除该节点下的子树 当 $i=n$ 时，终止算法，否则，令 $i=i+1$，执行步骤 2 误差降低剪枝使用了与训练集、测试集独立的验证集，验证集中的样本没有参与决策树的生成过程，一定程度上可以解决过拟合问题，但也可能会产生过剪枝的问题 实例以下图为例，假设某训练集产生的决策树如下： 其中，T4 结点中 13 和 7 表示该节点覆盖的样本中目标变量为 1 和 0 的个数 假设用这个决策树拟合验证样本后的结果如下： 按照 T5、T6、T4 的顺序，计算修剪前后的错误率，依次决定每个节点是否需要被修剪： 【悲观错误剪枝】剪枝策略在 C4.5 中，所使用的剪枝策略，就是悲观错误剪枝（Pessimistic Error Pruning，PEP）策略 PEP 也是根据剪枝前后分类的错误率来决定是否剪枝，但与 REP 不同的是，PEP 不需要使用验证集，且 PEP 是按照树的前序遍历顺序剪枝的 设 $T$ 为考虑是否剪枝的分支结点，$t$ 为该结点下的叶结点，$N_t$ 表示叶结点 $t$ 覆盖的样本个数，$e_t$ 表示叶结点 $t$ 的错误分类样本个数，那么分支结点 $T$ 的分类错误率为： E(T_t)=\\frac{\\sum_{t\\in T}(e_t+\\frac{1}{2})}{N_T}其中，$\\frac{1}{2}$ 是经验性惩罚因子，这是因为生成决策树与剪枝时使用的是相同的训练样本，那么对于每个结点，剪枝后分类错误率一定是会上升的，故而在计算分类错误率时，每个结点都要加上一个惩罚因子 对于分类错误率 $E(T_t)$，其含义是：每一个样本有 $E(T_t)$ 的概率分类错误，$1- E(T_t)$ 的概率分类正确，可以认为分类错误的次数服从伯努利分布，其误判次数为： E(T_t)\\cdot N_T标准差为： \\sqrt{N_T\\cdot E(T_t)\\cdot (1-E(T_t))}如果对分支结点 $T$ 进行剪枝，当 $T$ 成为叶结点后的分类错误率为： E(T)=\\frac{e_T+\\frac{1}{2}}{N_T}一般规定，当子树的误判次数大于对应叶节点的误判个数时，就决定剪枝，即满足下式就进行剪枝： E(T_t)\\cdot N_T+\\sqrt{N_T\\cdot E(T_t)\\cdot (1-E(T_t))}\\geq E(T)\\cdot N_T悲观错误剪枝的准确度较高，且不需要分离训练样本和验证样本，对样本量较少的情况比较有利 同时，每棵子树最多只需要访问一次，效率较高，但是由于方向是树的前序遍历方向，可能会造成某些不必要的剪枝 实例以误差降低剪枝中的例子为例 考虑 T4 结点其错误分类样本个数，有： e(T_4)=7对于其叶结点的错误分类样本个数，有： e(T_7)=0,e(T_8)=2,e(T_9)=1,e(T_{10})=1则错误率为： E(T_t)=\\frac{(0+2+1+1)+4\\cdot\\frac{1}{2}}{20}=0.3标准差： S_e=\\sqrt{(20\\cdot 0.3\\cdot(1-0.3)}=2.05当 $T$ 成为叶结点后的分类错误率为： E(T)=\\frac{7}{20}根据悲观错误剪枝的判断式： E(T_t)\\cdot N_T+\\sqrt{N_T\\cdot E(T_t)\\cdot (1-E(T_t))}\\geq E(T)\\cdot N_T有： 0.3\\cdot20+2.05\\geq \\frac{7}{20}\\cdot20因此根据结点 T4 需要剪枝 【代价复杂度剪枝】概述在 CART 中，所使用的剪枝策略，就是代价复杂度剪枝（Cost-Complexity Pruning，CCP）策略，其按照树的后序遍历顺序从生成算法产生的决策树底端开始剪枝，根据剪枝的顺序，得到一系列的剪枝树 $\\{T_0, T_1, T_2,…, T_m\\}$，其中 $T_0$ 为原始决策树，$T_m$ 为根结点，$T_{i+1}$ 为 $T_i$ 剪枝后的结果，然后通过交叉验证法在独立的验证集上对剪枝树序列进行测试，从中选择最优子树 代价函数对于任意子树 $T$，其叶结点个数为 $|T|$，取代价复杂度参数 $\\alpha\\geq 0$ ，树 $T$ 的代价函数定义为： C_{\\alpha}(T) = C(T)+\\alpha|T|在上述公式中，$C(T)$ 表示对训练数据的预测误差，用于表示模型与训练数据的拟合程度；$|T|$ 表示模型复杂度，即子树的叶结点个数；$\\alpha$ 为代价复杂度参数，用于权衡训练数据的拟合程度和模型复杂度 对于固定的 $\\alpha$，一点存在使代价函数 $C_a(T)$ 最小的子树 $T_{\\alpha}$，$T_{\\alpha}$ 在代价函数 $C_{\\alpha}$ 最小的意义下是最优的，因此，剪枝就是在代价复杂度参数 $\\alpha$ 确定时，选择代价函数最小的模型 对于代价复杂度参数 $\\alpha$ 来说，$\\alpha$ 越大，最优子树 $T_{\\alpha}$ 就越小；$\\alpha$ 越小，最优子树 $\\alpha$ 就越大；在极端情况下，当 $\\alpha=0$ 时，仅考虑模型与训练数据的拟合程度 $C_T$，不考虑模型的复杂度 $|T|$，此时整体树是最优的；当 $\\alpha\\rightarrow\\infty$ 时，不考虑模型与训练数据的拟合程度 $C_T$，仅考虑模型的复杂度 $|T|$，此时由根结点组成的单结点树是最优的 代价复杂度参数下面给出代价复杂度参数 $\\alpha$ 的定义： 设 $T$ 为考虑是否剪枝的分支结点，$t$ 为该结点下的叶结点，$e_T$ 表示结点 $T$ 的分类错误率，$p_T$ 表示 $T$ 结点所覆盖的样本数占总样本数的比例，$|T_t|$ 表示 $T$ 结点下叶结点的个数 那么，对于结点 $T$ 下错误分类的样本个数占总样本个数的比例为： R(T)=e_T\\cdot p_T对于结点 $T$ 下的所有叶结点 $t$，错误分类的样本个数占总样本个数的比例为： R(T_t)=\\sum_{t\\in T}e_t\\cdot p_t则，代价复杂度参数定义为： \\alpha=\\frac{R(T)-R(T_t)}{T_t-1}同样以误差降低剪枝中的例子为例，给出代价复杂度参数 $\\alpha$ 的计算实例 假设总样本数为 $60$，考虑 T4 结点，有： R(T)=\\frac{7}{20}\\cdot \\frac{20}{60}=\\frac{7}{60}对于 T4 结点之下的所有叶结点，有： R(T_t)=\\frac{0}{6}\\cdot\\frac{6}{60}+\\frac{2}{6}\\cdot\\frac{6}{60}+\\frac{1}{3}\\cdot\\frac{3}{60}+\\frac{1}{5}\\cdot\\frac{5}{60}=\\frac{4}{60}此时，代价复杂度参数为： \\alpha=\\frac{\\frac{7}{60}-\\frac{4}{60}}{4-1}=\\frac{1}{60}子树序列的生成在有了代价函数和代价复杂度参数后，开始循环地对子树进行剪枝，算法流程如下： 输入：CART 生成的决策树 $T_0$ 输出：决策树子树序列 $\\{T_1,T_2,…,T_m\\}$ 令 $k=0$，$T=T_0$，$\\alpha=+\\infty$ 按照树的后序遍历的顺序，计算子树 $T$ 的所有分支结点 $T_t$ 的代价复杂度参数 $\\alpha$ 选择最小的代价复杂度参数 $\\alpha_{min}$ 所对应的分支结点 $T_{min}$ 进行剪枝，得到子树 $T$（若多个分支结点具有相同最小的代价复杂度参数，则选择结点数最多的分支结点进行剪枝） 令 $k=k+1$，$\\alpha_k=\\alpha_{min}$，$T_k=T$ 若 $T_k$ 不是由根结点及两个叶结点构成的树，则返回步骤 2，继续进行剪枝，否则令 $T_k=T_m$ 选取最优决策树对于剪枝得到的决策树子树序列 $\\{T_1,T_2,…,T_m\\}$，利用独立的验证集，测试子树序列中各子树的基尼指数 具有最小基尼指数的决策树，即最优决策树","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"决策树的 CART 生成算法","slug":"machine-learning/32.决策树的CART生成算法","date":"2019-08-06T01:09:00.000Z","updated":"2023-04-05T14:17:04.089Z","comments":true,"path":"artificial-intelligence/machine-learning/729a7bb2.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/729a7bb2.html","excerpt":"Reference 回归树（Regression Tree） Regression Tree 回归树 决策树(分类树、回归树） 【机器学习】决策树（上）——ID3、C4.5、CART（非常详细） 决策树—ID3、C4.5、CART 【概述】对于 ID3 和 C4.5 来说，它们只能用来解决分类为问题，因此都是分类决策树","text":"Reference 回归树（Regression Tree） Regression Tree 回归树 决策树(分类树、回归树） 【机器学习】决策树（上）——ID3、C4.5、CART（非常详细） 决策树—ID3、C4.5、CART 【概述】对于 ID3 和 C4.5 来说，它们只能用来解决分类为问题，因此都是分类决策树 而分类与回归树（Classification and Regression Tree，CART）既可以用于分类也可以用于回归，只是在生成决策树的过程中，所选取的特征选择的标准不同 其假设决策树是二叉树，分支结点的取值为 是 和 否，左分支取值为 是，右分支取值为 否 其等价于递归地二分每个特征，将输入空间分为有限个单元，并在这些单元上确定预测的概率分布，即输入给定的条件下输出的条件概率分布 与 C4.5 一样，CART 算法由以下两步组成： 决策树生成：使用基尼系数或均方误差作为特征选择的标准，基于训练集生成决策树 决策树剪枝：采用代价复杂度剪枝策略，利用验证集对已生成的树进行剪枝 【CART 分类树】使用 CART 来构建分类树的流程，与 ID3 和 C4.5 相似，只是采用了基尼指数作为特征选择的标准 下面直接给出 CART 生成分类树的算法： 输入：训练集 $D$ 输出：决策树 根据训练集，从根结点开始，递归地对每个结点进行以下操作，构建一棵二叉决策树： Step1：设当前结点的训练集为 $D$，计算现有特征对该数据集的基尼指数 此时，对每一个特征 $A$，对其可能取的每个值 $a$，根据样本点对 $A=a$ 的测试为 是、否，将 $D$ 分割成 $D_1$ 和 $D_2$ 两个部分，利用下式计算 $A=a$ 时的基尼指数 Gini(G,A)=\\frac{|D_1|}{|D|}Gini(D_1)+\\frac{|D_2|}{|D|}Gini(D_2)Step2：在所有可能的特征 $A$ 以及它们所有可能的切分点 $a$ 中，选择基尼指数最小的特征及其对应的切分点，作为最优特征和最优切分点 根据最优特征与最优切分点，从现结点生成两个子结点，将训练集依照特征分配到两个子结点中 Step3：对两个子结点递归地调用 Step1 与 Step2，直到满足停止条件 Step4：生成 CART 决策树 【CART 回归树】假设形式回归树，就是用树模型处理回归问题，此时采用均方误差作为特征选择的标准 对于给定容量为 $n$ 的训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出为 $y_i$，其是一个连续变量 回归问题的目标是构造一个函数 $f(\\mathbf{x})$ 能够拟合数据集 $D$ 中的元素，使得均方误差 MSE 最小，即： \\min \\quad \\frac{1}{n}\\sum_{i=1}^n (f(\\mathbf{x}_i)-y_i)^2一棵回归树对应着整个特征空间上递归地二分类的划分，在每一个划分单元上都有一个输出值，下面用数学语言来进行描述： 假设对于给定训练集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，用该训练集构建好的一棵 CART 回归树有 $K$ 个叶结点，这意味着将输入空间划分为 $K$ 个单元 $R_1,R_2,…,R_K$，且 CART 最多会有 $K$ 个不同的预测值，即每一个叶结点都对应一个单元 $R_k$，同时该单元输出一个预测值 用 $c_k$ 表示第 $k$ 个叶结点的预测值，其一般是该叶结点所含训练集样本输出的均值，即： c_k = \\text{average} (y_i|\\mathbf{x}_i\\in R_k)则回归树的模型表示为： f(\\mathbf{x}_i)=\\sum_{j=1}^Kc_k\\mathbb{I}(\\mathbf{x}_i\\in R_k)此时，CART 最小化 MSE 公式如下： \\min \\quad \\frac{1}{n}\\sum_{k=1}^K\\sum_{\\mathbf{x}_i\\in R_k}(c_k-y_i)^2划分过程根据 CART 是二叉树的特征，在每一次划分中，都需要进行一次特征选择，同时将该特征空间一分为二的切分，使得模型在训练集上 MSE 最小，即每个叶结点的 MSE 之和最小 也就是说，要确定两方面的内容： 选择哪一个特征来进行划分 对于指定的划分特征，选择什么样的切分点 针对上述的两个问题，采用启发式方法，选择输入 $\\mathbf{x}_i$ 的第 $j$ 个特征 $x_i^{(j)}$与其取值 $s$，作为切分变量（Splitting Variable）和切分点（Splitting Point） 此时，切分变量和切分点将父结点的输入空间一分为二，即： \\left\\{\\begin{array}{rl} R_1(j,s)=\\{\\mathbf{x}_i|x_i^{(j)}\\leq s\\} \\\\ R_2(j,s)=\\{\\mathbf{x}_i|x_i^{(j)}>s\\} \\end{array}\\right.进一步，寻找最优切分变量 $j$ 和最优切分点 $s$，即求解如下公式： \\min_{j,s} \\bigl[ \\min_{c_1}\\sum\\limits_{\\mathbf{x}_i\\in R_1(j,s)}(c_1-y_i)^2+\\min_{c_2}\\sum\\limits_{\\mathbf{x}_i\\in R_2(j,s)}(c_2-y_i)^2 \\bigr]该公式说明了，在要求切分点 $s$ 两边区域的均方差尽量小的同时，保证两区域的最小均方差的和是最小的 对于每一个特征 $j$ 进行遍历，每一个 $j$ 的取值都能通过上式得到一个最优切分点 $s$，以及此时求出的上式的值 $A_{j,s}$，最终比较所有的 $A_{j,s}$，选择其中最小的那个对应的 $(j,s)$ 作为最优切分变量和切分点，将特征空间划分为两个部分 此时，对于最小化公式中的 $c_1$ 和 $c_2$，取最优值： \\left\\{\\begin{array}{rl} \\hat{c_1}=\\text{ave}(y_i|\\mathbf{x}_i\\in R_1) \\\\ \\hat{c_2}=\\text{ave}(y_i|\\mathbf{x}_i\\in R_2) \\end{array}\\right.之后，对两个子空间 $R_1$、$R_2$ 重复上述划分过程，直到满足停止条件为止，生成一棵决策树 最小二乘回归树生成算法按照上述过程生成的决策树，称为最小二乘回归树（Least Squares Regression tree），下面给出最小二乘回归树生成算法： 输入：训练集 $D$ 输出：决策树 $f(\\mathbf{x})$ 在训练集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域的输出值，构建二叉决策树： 1.选择最优切分变量 $j$ 和切分点 $s$，求解： \\min_{j,s} \\bigl[ \\min_{c_1}\\sum\\limits_{\\mathbf{x}_i\\in R_1(j,s)}(y_i-c_1)^2+\\min_{c_2}\\sum\\limits_{\\mathbf{x}_i\\in R_2(j,s)}(y_i-c_2)^2 \\bigr]遍历特征 $j$，对固定的切分变量 $j$ 扫描切分点 $s$，选择使上式达到最小值的 $(j,s)$ 对 2.用选定的 $(j,s)$ 对，划分区域 \\left\\{\\begin{array}{rl} R_1(j,s)=\\{\\mathbf{x}_i|x_i^{(j)}\\leq s\\} \\\\ R_2(j,s)=\\{\\mathbf{x}_i|x_i^{(j)}>s\\} \\end{array}\\right.3.根据划分的 $R_1$、$R_2$ 区域，确定相应的输出值 \\left\\{\\begin{array}{rl} \\hat{c_1}=\\text{ave}(y_i|\\mathbf{x}_i\\in R_1) \\\\ \\hat{c_2}=\\text{ave}(y_i|\\mathbf{x}_i\\in R_2) \\end{array}\\right.4.递归的对两个子区域执行步骤 1、2、3，直到满足停止条件 5.将输入空间划分为 $K$ 个区域 $R_1,R_2,…,R_K$，生成决策树 f(\\mathbf{x}_i)=\\sum_{k=1}^K\\hat{c_k}\\mathbb{I}(\\mathbf{x}_i\\in R_k)【CART 剪枝】CART 算法使用的剪枝策略是代价复杂度剪枝策略，其由两步组成： 从生成算法产生的决策树 $T_0$ 底端开始不断剪枝，直到 $T_0$ 的根结点，形成一个子树序列 $\\{T_0,T_1,…,T_n\\}$ 在独立的验证数据集上，对子树序列进行测试，从中选择最优子树 关于代价复杂度剪枝的具体介绍，详见：决策树的剪枝策略 【ID3 和 C4.5 无法处理回归问题的原因】CART 是一棵二叉树，那么只要回归树不是一棵二叉树，那么就不是 CART 树 在分类问题中，ID3、C4.5 和 CART 的区别就在于特征选择的策略不同，信息增益、信息增益比、基尼指数 在回归问题中，用均方误差最小的准则求解每个特征上的最优输出值，这种情况下，分类时的 ID3、C4.5、CART 之间的区别就没了，那么问题就变成每个父结点划分成多少个子结点的问题了 因此，如果还是二叉树，那么就认为是 CART 回归树，否则就不是","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"决策树的 ID3 与 C4.5 生成算法","slug":"machine-learning/31.决策树的ID3与C4.5生成算法","date":"2019-08-05T08:01:00.000Z","updated":"2023-03-31T12:43:21.745Z","comments":true,"path":"artificial-intelligence/machine-learning/c6faa205.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/c6faa205.html","excerpt":"Reference 【机器学习】决策树（上）——ID3、C4.5、CART 决策树—ID3、C4.5、CART 【ID3 算法】概述","text":"Reference 【机器学习】决策树（上）——ID3、C4.5、CART 决策树—ID3、C4.5、CART 【ID3 算法】概述ID3 相当于用极大似然估计进行概率模型的选择，其核心是在决策树各结点上使用信息增益作为量化标准来选择特征，递归地构建决策树 具体方法是：从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点，再对子结点递归的调用以上方法，构建决策树，直到所有特征的信息增益均很小或没有特征可以选择为止 ID3 的做法是每次选取当前最佳的特征来分割数据，并按照该特征的所有可能取值来切分，也就是说，如果一个特征有 3 种取值，那么数据将被切分成 3 份，一旦按照某特征切分后，该特征在之后的算法执行过程中将不会再起作用 归结来说，除上述探讨的问题外，ID3 存在以下问题： 无法直接处理连续型数据 采用信息增益作为特征选择的准则，可能对特征取值数较多的特征有偏好 没有考虑数据存在缺失值的情况 没有剪枝策略，生成的决策树结构可能过于复杂，容易发生过拟合现象 算法流程ID3 的算法流程如下： 初始化特征集合 $A$、数据集 $D$ 计算数据集 $D$ 的信息熵 $H(D)$ 与所有特征的条件熵 $H(D|A_i)$ 根据 $H(D)$ 与 $H(D|A_i)$ 计算信息增益 $g(D|A_i)$，选择信息增益最大的特征 $A_g$ 作为当前决策结点 更新数据集 $D$ 和特征集 $A$，即删除上一步所使用的特征 $A_g$，并按 $A_g$ 的取值来划分不同的数据子集 若数据子集包含单一特征，则为叶结点，否则，对新划分的数据子集重复第 2、3、4 步，直到所有特征的信息增益均很小或没有特征可以选择为止 实例以 信息增益与信息增益比 中的实例为例，即对于下表： 各特征的信息增益如下： \\begin{matrix} g(D,A_1)=H(D)-H(D|A_1) = 0.083\\\\ g(D,A_2)=H(D)-H(D|A_2) = 0.324\\\\ g(D,A_3)=H(D)-H(D|A_3) = 0.420\\\\ g(D,A_4)=H(D)-H(D|A_4) = 0.363 \\end{matrix}选择信息增益最大的特征，是否有房子 $A_3$，作为根结点的特征，其有两个取值 是、否，据此将训练集 $D$ 划分为两个子集 $D_1$ 和 $D_2$ 对于 $D_1$ 来说，其分类结果只有同一类 是 的样本点，因此其成为一个叶结点，该叶结点的类标记为 是 对于 $D_2$ 来说，要进一步从特征 $A_1$、$A_2$、$A_4$ 中选择新的特征，计算各特征的信息增益： \\begin{matrix} g(D_2,A_1)=H(D)-H(D|A_1) = 0.251\\\\ g(D_2,A_2)=H(D)-H(D|A_2) = 0.918\\\\ g(D_2,A_4)=H(D)-H(D|A_4) = 0.474 \\end{matrix}选择信息增益最大的特征，是否有工作 $A_2$，作为分支结点的特征，其有两个取值 是、否，据此将训练集 $D_2$ 划分为两个子集 $D_{21}$ 和 $D_{22}$ 对于 $D_{21}$ 来说，其分类结果只有同一类 是 的样本点，因此其成为一个叶结点，该叶结点的类标记为 是 对于 $D_{22}$ 来说，其分类结果只有同一类 否 的样本点，因此其成为一个叶结点，该叶结点的类标记为 否 据此，生成一个如下图的决策树，其只用了两个特征 【C4.5 算法】概述对于 ID3 来说，其存在以下四点缺陷： 无法直接处理连续型数据 采用信息增益作为特征选择的准则，可能对特征取值数较多的特征有偏好 没有考虑数据存在缺失值的情况 没有剪枝策略，生成的决策树结构可能过于复杂，容易发生过拟合现象 C4.5 严格来说是 ID3 的改进算法，其通过对 ID3 的改进，一定程度上解决了上述的四个问题： 采用了连续特征离散化的方法，将连续型特征转为离散型特征，但这种转换过程可能会破坏连续型变量的内在性质 采用了信息增益比作为特征选择的标准，以校正信息增益偏向取值较多的特征的问题 通过计算概率的方式，将信息增益的计算式进行了推广，从而解决缺失值处理的问题 采用悲观剪枝策略对决策树进行后剪枝 C4.5 相较于 ID3 来说，准确率更高，实现也简单，但对数据进行了多次顺序扫描与排序，效率较低，仅适合小规模的数据集 连续特征离散化C4.5 采用了连续特征离散化的策略，将连续型数据进行处理，最简单的离散化策略是利用二分法对连续特征进行处理 对于给定 $n$ 个样本的数据集 $D$ 和在 $D$ 上的连续型特征 $a$，假定 $a$ 在 $D$ 上出现 $m$ 个不同的取值，将这些值按照升序排序，记为 $\\{a_1,a_2,…,a_m\\}$ 取相邻两样本值的平均值作为划分点，一共有 $m-1$ 个划分点，其中第 $i$ 个划分点记为： T_i=\\frac{a_i+a_{i+1}}{2}对于这 $m-1$ 个划分点，分别计算以该点作为二元分类点时的信息增益，以信息增益最大的点作为该连续特征的二元离散分类点 简单来说，当取得信息增益最大的点为 $a_t$，则小于 $a_t$ 的值为 类别1，大于 $a_t$ 的值为 类别2，这样就做到了连续特征的离散化 要注意的是，与离散型数据不同的是，若当前结点为连续值，则该值还可参与子结点的特征选择过程 缺失值处理在实际应用中，尤其是在样本特征数目众多的情况下，经常会遇到不完整的样本，即样本的某些特征值存在缺失 如果简单地放弃不完整的样本，仅使用无缺失的数据来学习，这无疑是对数据的极大浪费，为此，需要对缺失值进行处理 对于缺失值的处理可以分为两个子问题： 在特征值缺失的情况下，如何进行特征选择，即如何计算特征的信息增益率 给定划分特征后，对于缺失该特征值的样本如何处理，即将这个样本划分到哪个结点中 在给出上述两个问题答案前，先给出以下记号： 对于给定的分为 $K$ 类的具有 $|D|$ 个样本的训练集 $D$，存在一个具有 $n$ 个取值的特征 $A$ 令 $\\tilde{D}$ 表示 $D$ 中在特征 $A$ 上没有缺失值的样本子集，用 $\\tilde{D_k}$ 表示在该子集上根据样本类别所划分的第 $k$ 个子集，用 $\\tilde{D}^i$ 表示在 $\\tilde{D}$ 上根据特征 $A$ 的取值 $A_i$ 所划分的第 $i$ 个子集 同时，为每一个样本 $\\vec{x}$ 赋予一个权重 $w_\\vec{x}$ 用 $\\rho$ 表示无缺失值样本所占的比例，即： \\rho=\\frac{\\sum\\limits_{\\vec{x}\\in\\tilde{D}}w_\\vec{x}}{\\sum\\limits_{\\vec{x}\\in D}w_\\vec{x}}用 $\\tilde{p_k}$ 表示无缺失值样本中第 $k$ 类所占的比例，即： \\tilde{p_k}=\\frac{\\sum\\limits_{\\vec{x}\\in\\tilde{D_k}}w_\\vec{x}}{\\sum\\limits_{\\vec{x}\\in \\tilde{D}}w_\\vec{x}},\\quad 1\\leq k\\leq K用 $\\tilde{r_i}$ 表示无缺失值样本中在特征 $A$ 上取值为 $A_i$ 的样本所占的比例，即： \\tilde{r_i}=\\frac{\\sum\\limits_{\\vec{x}\\in\\tilde{D}^i}w_\\vec{x}}{\\sum\\limits_{\\vec{x}\\in \\tilde{D}}w_\\vec{x}},\\quad 1\\leq i\\leq n显然，有： \\sum\\limits_{k=1}^K \\tilde{p_k}=1,\\quad \\sum\\limits_{i=1}^n \\tilde{r_i}=1 对于第一个问题，显然可以利用 $\\tilde{D}$ 来计算特征 $A$ 的信息增益率 基于上述定义，将信息增益的计算式进行推广，有： \\begin{align*} G(D,A) &= \\rho\\cdot G(\\tilde{D},A) \\\\ &= \\rho\\cdot[H(\\tilde{D})-\\sum_{i=1}^n\\tilde{r_i}H(\\tilde{D}^i)] \\\\ &= \\rho\\cdot \\bigl[ -\\sum_{k=1}^K\\tilde{p_k}\\log_2\\tilde{p_k} -\\sum_{=1}^n\\tilde{r_i}H(\\tilde{D}^i) \\bigr] \\end{align*}对于第二个问题，根据样本 $\\vec{x}$ 在划分特征 $A$ 上的取值是否已知，分为两种情况： 已知：将 $\\vec{x}$ 划入与其取值对应的子结点，且样本权值在子结点中保持为 $w_{\\vec{x}}$ 未知：将 $\\vec{x}$ 同时划入所有子结点，且样本权值 $w_{\\vec{x}}$ 在与特征值 $A_i$ 的对应的子结点中调整为 $\\tilde{r_i}\\cdot w_{\\vec{x}}$ 对于未知的情况，其本质就是让同一个样本以不同的概率划分到不同的子结点中 剪枝策略C4.5 采用的悲观剪枝方法，用递归的方式按照树的后序遍历算法，从下向上针对每一个分支结点，评估用一个最佳叶结点去代替这棵子树是否有益 如果剪枝后与剪枝前相比其错误率是保持或者下降，则这棵子树就可以被替换掉，C4.5 通过训练集上的错误分类数量来估算未知样本上的错误率 后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树，但同时其训练时间会大的多 关于悲观剪枝算法的详细介绍，见：决策树的剪枝策略","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"基尼指数","slug":"information-theory/04.基尼指数","date":"2019-08-02T15:15:00.000Z","updated":"2023-03-16T15:26:49.577Z","comments":true,"path":"mathematics/information-theory/9690b9de.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/information-theory/9690b9de.html","excerpt":"【概率分布的基尼指数】基尼指数表示在样本集合中一个随机选中的样本被分错的概率，与信息熵相似，基尼指数越大，样本集合 $D$ 的不确定性也就越大 假设有 $K$ 个类，样本点属于第 $k$ 类的概率为 $p_k$，则概率分布的基尼指数定义为：","text":"【概率分布的基尼指数】基尼指数表示在样本集合中一个随机选中的样本被分错的概率，与信息熵相似，基尼指数越大，样本集合 $D$ 的不确定性也就越大 假设有 $K$ 个类，样本点属于第 $k$ 类的概率为 $p_k$，则概率分布的基尼指数定义为： \\begin{align*} Gini(p) &=\\sum_{k=1}^Kp_k(1-p_k) \\\\ &= 1-\\sum_{k=1}^Kp_k^2 \\end{align*}如下图，显示了在二分类问题中，基尼指数 $Gini(p)$、半信息熵 $\\frac{1}{2}H(p)$ 与分类误差率的关系，其中横坐标为概率 $p$，纵坐标为损失 可以看出，基尼指数与半信息熵的曲线十分接近，均可来近似的表示分类误差率 根据泰勒公式，$\\ln(x)=-1+x+o(x)$，因此： \\begin{align*} H(X) &=-\\sum_{k=1}^Kp_k\\ln p_k\\\\ &\\approx \\sum_{k=1}^Kp_k(1-p_k) \\end{align*}也就是说，基尼指数，可以理解为信息熵的一阶泰勒展开 【二分类的基尼指数】对于二分类问题来说，若样本点属于第一个类的概率为 $p$，则其属于第二个类的概率为 $1-p$，相应地，基尼指数为： \\begin{align*} Gini(p) &= 1-\\sum_{k=1}^Kp_k^2 \\\\ &= 1-p^2-(1-p)^2 \\\\ &= 1-p^2-1+2p-p^2 \\\\ &= 2p-2p^2 \\\\ &= 2p(1-p) \\end{align*}【多分类的基尼指数】对于给定的样本集合 $D$，其样本数为 $|D|$，分为 $K$ 类，属于第 $k$ 类的样本子集 $C_k$ 的样本数为 $|C_k|$，则基尼指数为： Gini(D)=1-\\sum_{k=1}^K\\bigl(\\frac{|C_k|}{|D|}\\bigr)^2若样本集合 $D$ 根据特征 $A$ 可能取值 $a_i$，被分割为 $D_1,D_2,…,D_m$ 的 $m$ 个部分，记 $D_i$ 中属于类 $C_k$ 的样本集合为 $D_{ik}$，其样本数为 $|D_{ik}|$，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数为： \\begin{align*} Gini(D,A) &=\\sum_{i=1}^m\\frac{|D_i|}{|D|}Gini(D_i) \\\\ &= \\sum_{i=1}^m\\frac{|D_i|}{|D|}\\bigl[1-\\sum_{k=1}^K\\bigl(\\frac{|D_{ik}|}{|D_i|}\\bigr)^2\\bigr]\\\\ \\end{align*}特别地，对于二分类问题，在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为： Gini(D,A)=\\frac{|D_1|}{|D|}Gini(D_1)+\\frac{|D_2|}{|D|}Gini(D_2)基尼指数 $Gini(D)$ 表示样本集合 $D$ 的不确定性，而基尼指数 $Gini(D,A)$ 表示了经过 $A=a_i$ 分割后集合 $D$ 的不确定性","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"信息论","slug":"mathematics/information-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/information-theory/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"信息论","slug":"information-theory","permalink":"https://alex-mcavoy.github.io/tags/information-theory/"}],"author":"Alex_McAvoy"},{"title":"信息增益与信息增益比","slug":"information-theory/03.信息增益与信息增益比","date":"2019-08-02T14:56:00.000Z","updated":"2023-03-16T15:14:46.402Z","comments":true,"path":"mathematics/information-theory/ff75e46a.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/information-theory/ff75e46a.html","excerpt":"【信息增益与互信息】在决策树中，信息增益（Information Gain）表示在知道了特征 $X$ 的信息后，使得使类 $Y$ 的信息的不确定性减少了的程度 信息增益是针对特征而言的，因此，特征 $A$ 对于训练集 $D$ 的信息增益 $g(D,A)$，被定义为：训练集 $D$ 的经验信息熵 $H(D)$ 与给定条件下特征 $A$ 与训练集 $D$ 的经验条件熵 $H(D|A)$ 的差，即：","text":"【信息增益与互信息】在决策树中，信息增益（Information Gain）表示在知道了特征 $X$ 的信息后，使得使类 $Y$ 的信息的不确定性减少了的程度 信息增益是针对特征而言的，因此，特征 $A$ 对于训练集 $D$ 的信息增益 $g(D,A)$，被定义为：训练集 $D$ 的经验信息熵 $H(D)$ 与给定条件下特征 $A$ 与训练集 $D$ 的经验条件熵 $H(D|A)$ 的差，即： g(D,A)=H(D)-H(D|A)而对于二维离散型随机变量 $(X,Y)$ 来说，信息熵 $H(X)$ 与条件熵 $H(X|Y)$ 的差被定义为互信息 $I(X,Y)$，也就是说，在决策树中，信息增益就是训练数据集中类与特征的互信息 对于训练集 $D$ 而言，其每个特征都有一个信息增益值，在出现训练集经验信息熵大（分类困难）时，信息增益值会偏大，反之信息增益值会偏小，而信息增益值大的特征，具有更强的分类能力 【信息增益算法】对于样本容量为 $|D|$ 的训练集 $D$，设其有 $K$ 个类 $C_k,k=1,2,…,K$，每个类中的样本个数为 $|C_k|$，则有： \\sum_{k=1}^K|C_k|=|D|设特征 $A$ 有 $n$ 个不同的取值 $\\{a_1,a_2,…,a_n\\}$，根据特征 $A$ 的取值将 $D$ 划分为 $n$ 个子集 $D_1,D_2,…,D_n$，并用 $|D_i|$ 表示划分子集 $D_i$ 中的样本数，同样有： \\sum_{i=1}^n|D_i|=|D|记子集 $D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$，其样本数为 $|D_{ik}|$，即： D_{ik}=D_i\\cap C_k 下面给出计算信息增益的算法： 输入：训练集 $D$ 与特征 $A$ 输出：特征 $A$ 对于训练集 $D$ 的信息增益 $g(D,A)$ 1.计算训练集 $D$ 的经验信息熵 \\begin{align*} H(D) &= -\\sum_{k=1}^Kp_k\\log p_k \\\\ &= -\\sum_{k=1}^K\\frac{|C_k|}{|D|}\\log\\frac{|C_k|}{|D|} \\end{align*}2.计算特征 $A$ 对训练集 $D$ 的经验条件熵 $H(D|A)$ \\begin{align*} H(D|A) &= -\\sum_{i=1}^np(a_i)H(D|A=a_i)\\\\ &= -\\sum_{i=1}^n p(a_i) \\sum_{k=1}^K p(C_k|a_i)\\log p(C_k|a_i) \\\\ &= -\\sum_{i=1}^n \\frac{|D_i|}{|D|} \\sum_{k=1}^K \\frac{|D_{ik}|}{|D_i|}\\log(\\frac{|D_{ik}|}{|D_i|}) \\\\ \\end{align*}3.计算信息增益 $g(D,A)$ g(D,A) = H(D)-H(D|A)【信息增益比】当以信息增益作为划分训练集的特征时，存在偏向于选择取值较多的特征的问题，使用信息增益比（Information Gain Radio）可以对这个问题进行校正，使得偏向于选择取值较少的特征，这是特征选择的另一个标准 对于训练集 $D$ 关于特征 $A$ 的信息熵 $H_A(D)$，有： \\begin{align*} H_A(D) &= -\\sum_{x}p(x)\\log p(x) \\\\ &=-\\sum_{i=1}^n\\frac{|D_i|}{|D|}\\log\\frac{|D_i|}{|D|} \\end{align*}其中，$|D|$ 是训练集的样本个数，$|D_i|$ 是特征 $A$ 上第 $i$ 个取值的个数，$n$ 是特征 $A$ 的取值个数 简单来说，$H_A(D)$ 是将特征 $A$ 作为一个随机变量，其取值是 $A$ 的各个特征值，而求得的信息熵 对于特征 $A$ 与训练集 $D$ 的信息增益比 $g_R(D,A)$，其被定义为信息增益 $g(D,A)$ 与训练集 $D$ 关于特征 $A$ 的信息熵 $H_A(D)$ 的比，即： g_R(D,A) = \\frac{g(D,A)}{H_A(D)}可以发现，信息增益比的本质，是在信息增益的基础上乘以一个惩罚参数 $\\frac{1}{H_A(D)}$，当特征 $A$ 取值数量 $n$ 较大时，惩罚参数较小；当特征 $A$ 取值数量 $n$ 较小时，惩罚参数较大 基于上述问题，在使用信息增益比时，并不是直接选择信息增益率最大的特征，而是使用一种启发式方法： 在候选特征中找出信息增益高于平均水平的特征 在这些高于平均水平的特征中再选择信息增益率最高的特征作为特征选择的标准 【实例】信息增益以下表为例，计算信息增益 在上表中，有 $|D|=15$ 个数据，存在 $A=4$ 个特征，分别用 $A_1$、$A_2$、$A_3$、$A_4$ 来表示年龄、有无工作、有无房子、信贷情况，最终分类结果只有两类，即放贷、不放贷，有：$K=2$ 根据统计，9 个数据结果为放贷，6 个数据结果为不放贷，记放贷为 $C_1$ 类，不放贷为 $C_2$ 类 1.计算信息经验熵： \\begin{align*} H(D) &= -\\sum_{k=1}^K\\frac{|C_k|}{|D|}\\log\\frac{|C_k|}{|D|} \\\\ &= -(\\frac{|C_1|}{|D|}\\log\\frac{|C_1|}{|D|}+\\frac{|C_2|}{|D|}\\log \\frac{|C_2|}{|D|}) \\\\ &= -(\\frac{|9|}{|15|}\\log\\frac{|9|}{|15|}+\\frac{|6|}{|15|}\\log \\frac{|6|}{|15|}) \\\\ &= 0.971 \\end{align*}2.计算各特征的经验条件熵： 对于年龄 $A_1$，其有三个取值：青年、中年、老年，划分子集后有 $|D_1|=5$，$|D_2|=5$，$|D_3|=5$，这三个子集属于放贷类 $C_1$ 的样本集合分别有 $|D_{11}|=2$，$|D_{21}|=3$，$|D_{31}|=4$ 个样本，属于不放贷类 $C_2$ 的样本集合分别有 $|D_{12}|=3$，$|D_{22}|=2$，$|D_{32}|=1$ 个样本，则： \\begin{align*} H(D|A_1) &= -\\sum_{i=1}^n \\frac{|D_i|}{|D|} \\sum_{k=1}^K \\frac{|D_{ik}|}{|D_i|}\\log(\\frac{|D_{ik}|}{|D_i|}) \\\\ &= -\\bigl[\\frac{5}{15}(\\frac{2}{5}\\log\\frac{2}{5}+\\frac{3}{5}\\log\\frac{3}{5})+\\frac{5}{15}(\\frac{3}{5}\\log\\frac{3}{5}+\\frac{2}{5}\\log\\frac{2}{5}) \\\\ & \\quad+ \\frac{5}{15}(\\frac{4}{5}\\log\\frac{4}{5}+\\frac{1}{5}\\log\\frac{1}{5})\\bigr] \\\\ &= 0.888 \\end{align*}对于有无工作 $A_2$，其有两个取值：有、无，划分子集后有 $|D_1|=5$，$|D_2|=10$，这两个子集属于放贷类 $C_1$ 的样本集合分别有 $|D_{11}|=5$，$|D_{21}|=0$ 个样本，属于不放贷类 $C_2$ 的样本集合分别有 $|D_{12}|=4$，$|D_{22}|=6$ 个样本，则： \\begin{align*} H(D|A_2) &= -\\sum_{i=1}^n \\frac{|D_i|}{|D|} \\sum_{k=1}^K \\frac{|D_{ik}|}{|D_i|}\\log(\\frac{|D_{ik}|}{|D_i|}) \\\\ &= -\\bigl[\\frac{5}{15}(\\frac{5}{5}\\log\\frac{5}{5}+\\frac{0}{5}\\log\\frac{0}{5})+\\frac{10}{15}(\\frac{4}{10}\\log\\frac{4}{10}+\\frac{6}{10}\\log\\frac{6}{10}) \\\\ &= 0.647 \\end{align*}对于有无房子 $A_3$，其有两个取值：有、无，划分子集后有 $|D_1|=6$，$|D_2|=9$，这两个子集属于放贷类 $C_1$ 的样本集合分别有 $|D_{11}|=6$，$|D_{21}|=0$ 个样本，属于不放贷类 $C_2$ 的样本集合分别有 $|D_{12}|=3$，$|D_{22}|=6$ 个样本，则： \\begin{align*} H(D|A_3) &= -\\sum_{i=1}^n \\frac{|D_i|}{|D|} \\sum_{k=1}^K \\frac{|D_{ik}|}{|D_i|}\\log(\\frac{|D_{ik}|}{|D_i|}) \\\\ &= -\\bigl[\\frac{6}{15}(\\frac{6}{6}\\log\\frac{6}{6}+\\frac{0}{6}\\log\\frac{0}{6}) + \\frac{9}{15}(\\frac{3}{9}\\log\\frac{3}{9}+\\frac{6}{9}\\log\\frac{6}{9}) \\\\ &= 0.551 \\end{align*}对于信贷情况 $A_4$，其有三个取值：一般、好、非常好，划分子集后有 $|D_1|=5$，$|D_2|=6$，$|D_3|=4$，这三个子集属于放贷类 $C_1$ 的样本集合分别有 $|D_{11}|=1$，$|D_{21}|=4$，$|D_{31}|=4$ 个样本，属于不放贷类 $C_2$ 的样本集合分别有 $|D_{12}|=4$，$|D_{22}|=2$，$|D_{32}|=0$ 个样本，则： \\begin{align*} H(D|A_4) &= -\\sum_{i=1}^n \\frac{|D_i|}{|D|} \\sum_{k=1}^K \\frac{|D_{ik}|}{|D_i|}\\log(\\frac{|D_{ik}|}{|D_i|}) \\\\ &= -\\bigl[\\frac{5}{15}(\\frac{1}{5}\\log\\frac{1}{5}+\\frac{4}{5}\\log\\frac{4}{5}) + \\frac{6}{15}(\\frac{4}{6}\\log\\frac{4}{6}+\\frac{2}{6}\\log\\frac{2}{6}) \\\\ & \\quad+ \\frac{4}{15}(\\frac{4}{4}\\log\\frac{4}{4}+\\frac{0}{4}\\log\\frac{0}{4})\\bigr] \\\\ &= 0.608 \\end{align*}3.计算各特征的信息增益 \\begin{matrix} g(D,A_1)=H(D)-H(D|A_1) = 0.083\\\\ g(D,A_2)=H(D)-H(D|A_2) = 0.324\\\\ g(D,A_3)=H(D)-H(D|A_3) = 0.420\\\\ g(D,A_4)=H(D)-H(D|A_4) = 0.363 \\end{matrix}此时，选择信息增益最大的 $A_3$ 作为最优特征 信息增益比以上例的信息增益为基础，继续计算信息增益比 1.计算平均信息增益，选择高于平均水平的信息增益 \\begin{align*} \\bar{g}(D,A) &= \\frac{1}{n}\\sum\\limits_{i=1}^ng(D,A_i) \\\\ &= \\frac{1}{4}\\cdot 1.19 \\\\ &= 0.298 \\end{align*}此时，高于 $\\bar{g}(D,A)$ 的有： \\begin{matrix} g(D,A_2)= 0.324\\\\ g(D,A_3)= 0.420\\\\ g(D,A_4)= 0.363 \\end{matrix}2.计算训练集关于各特征的信息熵 对于特征 $A_2$，其有两个取值：有、无，划分子集后有 $|D_1|=5$，$|D_2|=10$，此时： \\begin{align*} H_{A_2}(D) &= -\\sum_{i=1}^n\\frac{|D_i|}{|D|}\\log\\frac{|D_i|}{|D|} \\\\ &=-( \\frac{5}{15}\\log\\frac{5}{15}+\\frac{10}{15}\\log\\frac{10}{15}) \\\\ &= 0.918 \\end{align*}对于特征 $A_3$，其有两个取值：有、无，划分子集后有 $|D_1|=6$，$|D_2|=9$，此时： \\begin{align*} H_{A_3}(D) &= -\\sum_{i=1}^n\\frac{|D_i|}{|D|}\\log\\frac{|D_i|}{|D|} \\\\ &= -(\\frac{6}{15}\\log\\frac{6}{15}+\\frac{9}{15}\\log\\frac{9}{15}) \\\\ &= 0.971 \\end{align*}对于特征 $A_4$，其有三个取值：一般、好、非常好，划分子集后有 $|D_1|=5$，$|D_2|=6$，$|D_3|=4$，此时： \\begin{align*} H_{A_4}(D) &= -\\sum_{i=1}^n\\frac{|D_i|}{|D|}\\log\\frac{|D_i|}{|D|} \\\\ &= -(\\frac{5}{15}\\log\\frac{5}{15}+\\frac{6}{15}\\log\\frac{6}{15}+\\frac{4}{15}\\log\\frac{4}{15}) \\\\ &= 1.566 \\end{align*}3.计算各特征的信息增益比 \\begin{matrix} g_R(D,A_2)=\\frac{g(D,A_2)}{H_{A_2}(D)}= 0.353 \\\\ g_R(D,A_3)=\\frac{g(D,A_3)}{H_{A_3}(D)}= 0.433 \\\\ g_R(D,A_4)=\\frac{g(D,A_4)}{H_{A_4}(D)}= 0.232 \\\\ \\end{matrix}此时，选择信息增益比最大的 $A_3$ 作为最优特征","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"信息论","slug":"mathematics/information-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/information-theory/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"信息论","slug":"information-theory","permalink":"https://alex-mcavoy.github.io/tags/information-theory/"}],"author":"Alex_McAvoy"},{"title":"决策树概述","slug":"machine-learning/30.决策树概述","date":"2019-08-02T06:02:00.000Z","updated":"2023-04-01T14:47:17.776Z","comments":true,"path":"artificial-intelligence/machine-learning/8ddc7426.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/8ddc7426.html","excerpt":"【概述】决策树（Decision Tree）是一种用于分类或回归的机器学习方法，对于复杂的预测问题，通过建立树模型产生分支结点，依照规则递归地分割数据集，使得问题从结构上划分为不同的子问题 决策树本质是从训练集中归纳出一组规则，在给出一个新的输入后，根据规则给出相应的输出，由于与训练集不矛盾的决策树可能有多个，需要选择一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力","text":"【概述】决策树（Decision Tree）是一种用于分类或回归的机器学习方法，对于复杂的预测问题，通过建立树模型产生分支结点，依照规则递归地分割数据集，使得问题从结构上划分为不同的子问题 决策树本质是从训练集中归纳出一组规则，在给出一个新的输入后，根据规则给出相应的输出，由于与训练集不矛盾的决策树可能有多个，需要选择一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力 从另一个角度来看，决策树是由训练集估计的条件概率模型，而基于特征空间划分的条件概率模型有无穷多个，选择的条件概率模型不仅要对训练数据有很好的拟合，而且对未知数据有很好的预测 根据所处理数据的类型，决策树可以分为以下两种： 分类决策树：处理的数据是离散值，用来解决分类问题 回归决策树：处理的数据是连续值，用来解决回归问题 此外，还有一种由 CART 决策树生成算法构建的分类与回归树（Classification and Regression Trees），其既可以处理分类问题，也可以处理回归问题 【决策树结构】一般地，一棵决策树包含一个根结点、若干分支结点、若干叶结点 其中，根结点包含样本全集，叶结点对应决策结果，分支结点对应于一个属性测试 从根结点到每个叶结点的路径对应了一个判定测试序列（if-then 规则），路径上的分支结点的特征对应着规则的条件，叶结点对应着规则的结论 随着树深度不断地增加，分支结点的子集会越来越小，问题也逐渐简化，当分支结点的深度或问题的规模满足一定的停止条件时，分支结点会停止分裂 举例来说，为了预测明天是否适合出去打羽毛球，采集了过去 14 天的数据，数据特征包括天气、温度、湿度、风力，如下表所示： 下图是可能的决策树分裂方案之一： 其中，根结点是天气，分支结点是湿度、风力，叶结点是适合、不适合 【决策树学习】学习步骤决策树学习通常包括特征选择、决策树生成、决策树剪枝三个步骤： 特征选择：选择最优的特征作为决策结点 决策树生成：即决策树的构建，仅考虑局部最优，对应模型的局部选择 决策树剪枝：对生成的决策树进行简化，考虑全局最优，对应模型的全局选择 特征选择如果利用一个特征进行预测的结果与随机选取的结果没有很大的差别，那么这个特征是与预测无关的 为提高决策树学习的效率，要对其进行特征选择，即在决策树学习开始的时候，对特征进行选择，只留下对训练数据有足够分类能力的特征 具体来说，对于一般的决策树，通常采用信息增益（information Gain）或信息增益比（information Gain Radio）作为特征选择的标准；对于分类与回归树 CART 来说，通常采用基尼指数（Gini Index）作为特征选择的标准 关于信息增益与信息增益比，详见：信息增益与信息增益比 关于基尼指数，详见：基尼指数 决策树生成生成过程决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练集进行分割，使得各子数据集有一个最好的分类的过程 这一过程对应着特征空间的划分，也对应着决策树的构建，具体步骤如下： 构建根结点，将所有训练数据都放在根结点 选择一个最优特征，按该特征将训练集分割为若干子集，使得各子集有一个在当前条件下最好的分类 若各子集已经被基本正确分类，那么构建叶结点，并将这些子集分到对应的叶结点中去 若各子集不能被基本正确分类，那么就对这些子集选择新的最优特征，继续进行分割，建立相应的结点 按步骤 2 不断的进行递归，直到所有训练子集被基本正确分类，或没有合适的特征为止 在决策树构建完毕后，每个子集都被分到叶结点上，即都有了明确的类 生成算法常见的决策树生成算法有：ID3、C4.5、CART 关于 ID3 与 C4.5 生成算法，详见：决策树的 ID3 与 C4.5 生成算法 关于 CART 生成算法，详见：决策树的 CART 生成算法 其中，ID3 是最基础的决策树生成算法，其不存在决策树剪枝这个过程，C4.5 在 ID3 的基础上进行了若干改进，其中一项改进就是进行了剪枝 此外，ID3 无法对连续值进行处理，C4.5 在 ID3 的基础上采用连续特征离散化策略，将连续型特征转为离散型特征，但这种转换过程可能会破坏连续型变量的内在性质，也就是说，ID3 与 C4.5 所生成的决策树，都是分类决策树，只能用来处理分类问题 进一步，在 C4.5 的基础上又有了 CART，其是分类回归树，既可以用于处理分类问题，也可以用于回归问题 决策树的剪枝以上方法生成的决策树可能对训练数据有着很好的分类能力，但对未知的测试数据却未必有很好的分类能力，即可能出现过拟合现象 为此，需要对生成的决策树自下而上的进行剪枝，将决策树进行简化，从而使得具有更好的泛化能力 具体来说，就是去掉过于细分的叶结点，使其退回父结点甚至更高的结点，然后将父结点或更高的结点改为叶结点 关于决策树的剪枝策略：点击这里 【决策树结点停止分裂的条件】无论是使用 ID3、C4.5 还是使用 CART，在构建决策树时，决策树不可能不限制地生长，总有停止分裂的时候 最极端的情况是当结点分裂到只剩下一个数据点时自动结束分裂，但这种情况下决策树的结构过于复杂，而且预测的精度不高 一般情况下，为降低决策树复杂度，并提高预测的精度，会适当提前终止节点的分裂 常见的决策树结点停止分裂的条件有： 1.最小节点数 当节点的数据量小于一个指定的数量时，不继续分裂 有两个原因： 数据量较少时，再做分裂容易强化噪声数据的作用 提前结束分裂，在一定程度上有利于降低过拟合的影响 2.熵或者基尼值小于阀值 熵和基尼指数的大小表示数据的复杂程度，当熵或者基尼值过小时，表示数据的纯度比较大，如果熵或者基尼值小于一定程度数，结点停止分裂 3.决策树的深度达到指定的条件 结点的深度可以理解为结点与决策树跟结点的距离，例如：根结点的子结点的深度为 $1$，因为这些结点与跟结点的距离为 $1$，子结点的深度要比父结点的深度大 $1$ 决策树的深度是所有叶结点的最大深度，当深度到达指定的上限大小时，停止分裂 4.所有特征已经使用完毕，不能继续进行分裂 被动式停止分裂的条件，当已经没有可分的属性时，直接将当前节点设置为叶结点 【sklearn 实现】sklearn.tree在 sklearn.tree 中，存在两个关于决策树的方法，这两种方法所采用的算法都是 CART 算法，一个用来处理回归问题，另一个用来处理分类问题： DecisionTreeRegressor()：处理回归问题 DecisionTreeClassifier()：处理分类问题 两个方法的参数一致，使用方法相似，二者唯一的区别是用于处理分类问题的 DecisionTreeClassifier() 相较于 DecisionTreeRegressor() 多了一个 class_weight 参数 决策树结构可视化sklearn 中没有提供决策树的可视化，其仅能让训练的模型保存到 dot 文件中 1234from sklearn.tree import export_graphvizwith open(\"out.dot\", \"w\") as f: f = export_graphviz(model, out_file = f, feature_names = ['a', 'b', 'c', 'd']) 之后，一般使用 graphviz 来进行可视化，其部署主要包括 graphviz 的安装和 Python 的 graphviz 插件的安装 安装 graphviz：点击这里 设置环境变量：将 安装目录/Graphviz/bin 加入 PATH 中 安装 graphviz 插件：pip install graphviz 安装 pydotplus 插件： pip install pydotplus 此时，环境配置完成，若仍然找不到 graphviz，加入以下代码即可： 12import osos.environ[\"PATH\"] += os.pathsep + \"安装目录/Graphviz/bin/\" 有两种方法生成决策树的可视化 方案一：生成 pdf 12345import pydotplus from sklearn.tree import export_graphvizdot_data = export_graphviz(model, out_file=None) graph = pydotplus.graph_from_dot_data(dot_data) graph.write_pdf(\"out.pdf\") 方案二：直接在 Jupyter 中显示 1234567891011121314from IPython.display import Image from sklearn.tree import export_graphvizimport pydotplus import osos.environ[\"PATH\"] += os.pathsep + \"安装目录/Graphviz/bin/\"dot_data = export_graphviz(model, out_file=None, feature_names=['a', 'b', 'c', 'd'], class_names=['calss1','calss2','calss3'], filled=True, rounded=True, special_characters=True) graph = pydotplus.graph_from_dot_data(dot_data) Image(graph.create_png()) 实现以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现决策树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立决策树模型 model = DecisionTreeClassifier(criterion='entropy', max_depth=4) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators # 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show()# 可视化决策树结构def visualization_tree(way = \"pdf\"): from sklearn.tree import export_graphviz import pydotplus # 生成pdf文件 if way == \"pdf\": # 将模型保存为dot文件 with open(\"out.dot\", \"w\") as f: f = export_graphviz(model, out_file = f, feature_names = [\"petal length\", \"petal width\"]) # 将dot文件进行可视化，存为pdf dot_data = export_graphviz(model, out_file=None) graph = pydotplus.graph_from_dot_data(dot_data) graph.write_pdf(\"out.pdf\") # 在jupyter中可视化 if way == \"jupyter\": from IPython.display import Image import os os.environ[\"PATH\"] += os.pathsep + \"I:/Graphviz/bin/\" dot_data = export_graphviz(model, out_file=None, feature_names=[\"petal length\", \"petal width\"], filled=True, rounded=True, special_characters=True) graph = pydotplus.graph_from_dot_data(dot_data) return Image(graph.create_png())if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150)) # 可视化决策树结构 visualization_tree(\"pdf\")","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"EM 算法","slug":"convex-optimization/13.EM算法","date":"2019-07-26T04:25:00.000Z","updated":"2023-03-12T12:35:59.735Z","comments":true,"path":"mathematics/convex-optimization/90a5934.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/convex-optimization/90a5934.html","excerpt":"Reference： EM算法原理及推导 【机器学习】EM——期望最大（非常详细） EM算法详解 【机器学习基础】EM算法详解及其收敛性证明 【概述】如果概率模型的变量都是观测变量（Observable Variable），又称显变量，即可以直接观测到的变量，那么当给定数据时，可以直接使用极大似然估计，或使用贝叶斯估计来估计模型的参数","text":"Reference： EM算法原理及推导 【机器学习】EM——期望最大（非常详细） EM算法详解 【机器学习基础】EM算法详解及其收敛性证明 【概述】如果概率模型的变量都是观测变量（Observable Variable），又称显变量，即可以直接观测到的变量，那么当给定数据时，可以直接使用极大似然估计，或使用贝叶斯估计来估计模型的参数 但实际应用中，概率模型概率模型有时既含有观测变量，又含有潜在变量（Latent Variable），又称隐变量，即无法直接观测或测量的变量，此时就无法使用极大似然估计或贝叶斯估计来估价模型的参数 期望极大（Expectation Maximization，EM）算法，用于含有隐变量的概率模型参数的极大似然估计法，其是一种迭代算法，每次迭代由两步组成： E 步（Expectation-Step）：通过观测变量和现有模型来估计参数，然后用这个估计的参数值来计算似然函数的期望值 M 步（Maximization-Step）：寻找似然函数最大化时对应的参数 【EM 算法的导出】对数似然函数的极大化对于给定的容量为 $n$ 的样本集 $D=\\{(\\mathbf{x}_1,y_1),(\\mathbf{x}_2,y_2),…,(\\mathbf{x}_n,y_n)\\}$，每组样本中的输入 $\\mathbf{x}_i$ 为观测变量，具有 $m$ 个特征值，即：$\\mathbf{x}_i=(x_i^{(1)},x_i^{(2)},\\cdots,x_i^{(m)})\\in \\mathbb{R}^m$，存在未观察到的隐变量集 $Z=(z_1,z_2,\\cdots,z_n)$，即上述样本属于哪个分布是未知的，现有模型为 $f(\\mathbf{x}_i;\\boldsymbol{\\theta})$，要求出样本的模型参数 $\\boldsymbol{\\theta}$ 使得 $f(\\mathbf{x}_i;\\boldsymbol{\\theta})\\simeq y_i$ 设 $X=(\\mathbf{x}_1,\\mathbf{x}_2,\\cdots,\\mathbf{x}_n)$ 为观测变量集，那么观测变量的似然函数为： L(X;\\boldsymbol{\\theta})=L(\\mathbf{x}_1,\\mathbf{x}_2,\\cdots,\\mathbf{x}_n;\\boldsymbol{\\theta}) = \\prod_{i=1}^n p(\\mathbf{x}_i;\\boldsymbol{\\theta})相应地，对数似然函数为： \\ln L(X;\\boldsymbol{\\theta}) = \\ln \\Big(\\prod_{i=1}^n p(\\mathbf{x}_i;\\boldsymbol{\\theta})\\Big) = \\sum_{i=1}^n \\ln p(\\mathbf{x}_i;\\boldsymbol{\\theta})可以通过极大似然估计来求解最优模型参数 $\\boldsymbol{\\theta}^*$，即： \\boldsymbol{\\theta}^* = \\arg\\max_{\\boldsymbol{\\theta}} \\sum_{i=1}^n \\ln p(\\mathbf{x}_i;\\boldsymbol{\\theta})但由于隐变量集 $Z$ 的存在，需要对每个样本的每个可能的 $z$ 求联合概率分布之和，于是对数似然函数 $\\ln L(X;\\boldsymbol{\\theta})$ 有： \\begin{align*} \\ln L(X;\\boldsymbol{\\theta}) &= \\ln \\sum_Z L(X,Z;\\boldsymbol{\\theta}) \\\\ &= \\ln \\Big( \\prod_{i=1}^n \\sum_{z}^Z p(\\mathbf{x}_i,z;\\boldsymbol{\\theta}) \\Big) \\\\ &= \\sum_{i=1}^n \\ln \\sum_z^Z p(\\mathbf{x}_i,z;\\boldsymbol{\\theta}) \\end{align*}此时对模型参数 $\\boldsymbol{\\theta}$ 进行极大似然估计，就变为： \\begin{align*} \\boldsymbol{\\theta}^* &= \\arg\\max_{\\boldsymbol{\\theta}} \\sum_{i=1}^n \\ln p(\\mathbf{x}_i;\\boldsymbol{\\theta}) \\\\ &= \\arg\\max_{\\boldsymbol{\\theta}} \\sum_{i=1}^n \\ln \\sum_{z}^Zp(\\mathbf{x}_i,z;\\boldsymbol{\\theta}) \\end{align*}可以发现，对上式进行极大化的主要困难在于其中含有隐变量 $z$，并有包含和的对数，虽然可以使用梯度下降法来求解，但随着隐变量的数目的增加，求和项会以指数级上升，会给梯度计算带来麻烦 一个方法是构造一个容易优化的、关于对数似然函数的下界函数，通过不断优化这个下界，通过非梯度方法来迭代逼近最优参数 $\\boldsymbol{\\theta}^*$ 对数似然函数的下界引入一个未知的、关于隐变量 $Z$ 的某种概率分布 $Q(Z)$，且满足条件： \\sum_z^Z Q(z) = 1,\\quad Q(z)\\geq 0于是，对于对数似然函数，有： \\sum_{i=1}^n \\ln \\sum_{z}^Zp(\\mathbf{x}_i,z;\\boldsymbol{\\theta}) = \\sum_{i=1}^n \\ln \\sum_{z}^Z Q(z) \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)}由于 $\\ln(\\cdot)$ 的二阶导数小于 $0$，因此原函数为上凸函数，那么根据 Jensen 不等式，有： \\begin{align*} \\sum_{i=1}^n \\ln \\sum_{z}^Zp(\\mathbf{x}_i,z;\\boldsymbol{\\theta}) &= \\sum_{i=1}^n \\ln \\sum_{z}^Z Q(z) \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)} \\\\ &\\geq \\sum_{i=1}^n \\sum_{z}^Z Q(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)} \\end{align*}注：这里用到的是 $\\ln \\sum\\limits_z \\lambda_z f_z \\geq \\sum\\limits_z \\lambda \\ln f_z$，其中 $\\lambda_z\\geq 0,\\sum\\limits_z\\lambda_z =1$，关于 Jensen 不等式详见 改进的迭代尺度法 IIS 此时，即得到了对数似然函数 $\\ln L(X;\\boldsymbol{\\theta})$ 的下界： J(Z,Q;\\boldsymbol{\\theta}) =\\sum_{i=1}^n \\sum_{z}^Z Q(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)}可以发现，$\\sum\\limits_{z}^Z Q(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)}$ 是 $ \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)}$ 关于隐变量 $z$ 的数学期望，也就是说，确定对数似然函数 $\\ln L(X;\\boldsymbol{\\theta})$ 下界 $J(Z,Q;\\boldsymbol{\\theta})$ 的过程，就是 EM 算法中的 E 步 对数似然函数下界的优化在得到对数似然函数的下界 $J(Z,Q;\\boldsymbol{\\theta})$ 后，就可以通过不断优化这个下界来使得 $\\ln L(X;\\boldsymbol{\\theta})$ 不断提高，那么，一个关键问题是，对于关于隐变量 $Z$ 的某种概率分布 $Q(Z)$ 应当如何选择？ 假设参数 $\\boldsymbol{\\theta}$ 已经给定，那么 $J(Z,Q;\\boldsymbol{\\theta})$ 的值取决于 $Q(z)$ 和 $p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})$，就可以通过调整这两个概率使得下界 $J(Z,Q;\\boldsymbol{\\theta})$ 不断上升，从而逼近 $\\ln L(X;\\boldsymbol{\\theta})$ 的真实值，当不等式变为等式时，说明调整后的下界 $J(Z,Q;\\boldsymbol{\\theta})$ 能够等价于对数似然函数 $\\ln L(X;\\boldsymbol{\\theta})$ 对于对数似然函数 $\\ln L(X;\\boldsymbol{\\theta})$ 和下界 $J(Z,Q;\\boldsymbol{\\theta})$ ： \\ln L(X;\\boldsymbol{\\theta}) = \\sum_{i=1}^n \\ln \\sum_{z}^Z Q(z) \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)} \\geq \\sum_{i=1}^n \\sum_{z}^Z Q(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)} =J(Z,Q;\\boldsymbol{\\theta})当且仅当 $X=\\mathbb{E}[X]$，即下式 $c$ 为常数时成立 \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)}=c由于 $Q(z)$ 是一个分布，满足 $\\sum\\limits_z^Z Q(z)=1$，因此有： \\sum_z^Z p(\\mathbf{x}_i,z;\\boldsymbol{\\theta}) = \\sum_z^Z Q(z)c=c于是，对于 $Q(z)$，有： \\begin{align*} Q(z) &= \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{\\sum\\limits_z^Z p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})} \\\\ &= \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{ p(\\mathbf{x}_i;\\boldsymbol{\\theta})} \\\\ &= p(z|\\mathbf{x}_i;\\boldsymbol{\\theta}) \\end{align*}也就是说，在固定了参数 $\\boldsymbol{\\theta}$ 后，使下界 $J(Z,Q;\\boldsymbol{\\theta})$ 提高的 $Q(z)$ 即后验概率 如果 $Q(z)=p(z|\\mathbf{x}_i;\\boldsymbol{\\theta})$，那么 $J(Z,Q;\\boldsymbol{\\theta})$ 就是包含隐变量的对数似然函数的一个下界，只需要最大化这个下界，就是在极大化对数似然函数 $L(X;\\boldsymbol{\\theta})$，因此只需最大化下式即可 \\boldsymbol{\\theta}^* = \\arg\\max_{\\boldsymbol{\\theta}} \\sum_{i=1}^n \\sum_z^Z Q(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q(z)}上式也即 EM 算法中的 M 步 【EM 算法流程】输入：观测变量 $X=(\\mathbf{x}_1,\\mathbf{x}_2,\\cdots,\\mathbf{x}_n)$，联合分布 $P(X,Z;\\boldsymbol{\\theta})$，条件分布 $P(Z|X;\\boldsymbol{\\theta})$ 输出：模型参数 $\\boldsymbol{\\theta}=(\\theta^{(0)},\\theta^{(1)},\\cdots,\\theta^{(m)})$ 算法流程： Step1：随机初始化模型参数 $\\boldsymbol{\\theta}$ 的初值 $\\boldsymbol{\\theta}_0$ Step2：E 步，确定第 $k+1$ 次迭代的下界 1）记 $\\boldsymbol{\\theta}_k$ 为第 $k$ 次迭代参数 $\\boldsymbol{\\theta}$ 的估计值，在第 $k+1$ 次迭代时，计算联合分布的条件概率期望 Q_k(z) = p(z|x_i,\\boldsymbol{\\theta}_k)2）在计算出 $Q_k(z)$ 后，确定第 $k+1$ 次迭代的下界 J(Z,Q_k;\\boldsymbol{\\theta}) = \\sum_{i=1}^n \\sum_z^Z Q_k(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q_k(z)}Step3：M 步，极大化第 $k+1$ 次迭代的下界，从而确定第 $k+1$ 次迭代的参数的估计值 $\\boldsymbol{\\theta}_{k+1}$ \\boldsymbol{\\theta}_{k+1} = \\arg\\max_{\\boldsymbol{\\theta}} \\sum_{i=1}^n \\sum_z^Z Q_k(z) \\ln \\frac{p(\\mathbf{x}_i,z;\\boldsymbol{\\theta})}{Q_k(z)}Step4：重复 Step2 与 Step 3，直到 $\\boldsymbol{\\theta}_{k+1}$ 收敛，即 ||\\boldsymbol{\\theta}_{k+1}-\\boldsymbol{\\theta}_{k} ||","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"凸优化","slug":"mathematics/convex-optimization","permalink":"https://alex-mcavoy.github.io/categories/mathematics/convex-optimization/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"凸优化","slug":"convex-optimization","permalink":"https://alex-mcavoy.github.io/tags/convex-optimization/"}],"author":"Ale\\mathbf{x}_McAvoy"},{"title":"半朴素贝叶斯","slug":"machine-learning/29.半朴素贝叶斯","date":"2019-07-23T03:18:00.000Z","updated":"2023-03-31T12:43:19.136Z","comments":true,"path":"artificial-intelligence/machine-learning/cb24fd43.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/cb24fd43.html","excerpt":"Reference 西瓜书读书笔记——第七章：贝叶斯分类器 贝叶斯算法小总结 半朴素贝叶斯分类器 【概述】在 朴素贝叶斯 中介绍了朴素贝叶斯分类器与其所假设的条件独立性，但该假设过于强势，在实际模型中有时并不满足，即样本的很多特征可能存在关联关系，并不独立","text":"Reference 西瓜书读书笔记——第七章：贝叶斯分类器 贝叶斯算法小总结 半朴素贝叶斯分类器 【概述】在 朴素贝叶斯 中介绍了朴素贝叶斯分类器与其所假设的条件独立性，但该假设过于强势，在实际模型中有时并不满足，即样本的很多特征可能存在关联关系，并不独立 为解决上述问题，在朴素贝叶斯的基础上引入了限制条件：允许某些特征间存在依赖关系，即半朴素贝叶斯（Semi-naive Bayes） 半朴素贝叶斯适当地考虑一部分特征间的相互依赖信息，这样既不需要进行完全联合概率计算，又不至于彻底忽略了较强的属性依赖关系 如下图，显示了朴素贝叶斯和两种半朴素贝叶斯分类器所考虑的特征依赖关系 【ODE 策略】独依赖估计（One-dependent Estimator，ODE）是半朴素贝叶斯中最常用的策略，即假设每个特征在类别之外最多依赖一个其他特征，即： P(Y=c_k|\\mathbb{x})\\propto P(Y=c_k)\\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k,a^{(j)})其中，$a^{(j)}$ 为特征 $x^{(j)}$ 的父特征，即 $x^{(j)}$ 所依赖的特征 此时，对于每个特征 $x^{(j)}$，可以采用贝叶斯估计的方法来估计 $P(X^{(j)}=x^{(j)}|Y=c_k,a^{(j)})$ 的概率 于是，问题的关键就转化为如何确定每个特征的父特征，由此产生了不同的独依赖分类模型 【独依赖分类模型】SPODE 模型超父独依赖估计（Super-parent One-dependent Estimator，SPODE）模型，是最简单的 ODE 策略的实现 SPODE 假设所有特征都依赖于同一个特征，这个特征被称为超父（Super Parent），之后通过交叉验证的方法来确定超父特征 在确定超父特征 $X^{(f)}$ 后，概率公式变为： P(Y=c_k|\\mathbb{x})\\propto P(Y=c_k)\\prod_{j=1}^{n} {P(X^{(j)}=x^{(j)}|Y=c_k,X^{(f)}=x^{(f)})}在下图 SPODE 模型的特征依赖关系中，$x^{(1)}$ 即为超父特征 AODE 模型平均独依赖估计（Averaged One-Dependent Estimator，AODE）模型是一种基于集成学习机制的独依赖分类器 与 SPODE 通过模型选择超父特征不同，其通过将每个特征分别作为超父来构建 SPODE，然后将有足够训练数据支撑的 SPODE 集成后作为最终结果，即： P(Y=c_k|\\mathbb{x})\\propto \\sum_{\\begin{matrix}i=1\\\\N_{x^{(i)}}\\geq \\alpha'\\end{matrix}}^n P(Y=c_k,X^{(i)}=x^{(i)}) \\prod_{j=1}^{n} {P(X^{(j)}=x^{(j)}|Y=c_k,X^{(j)}=x^{(i)})}其中，$N_{x^{(i)}}$ 为第 $i$ 个特征上取值为 $x^{(i)}$ 的样本数量，$\\alpha’$ 为阈值参数 显然，AODE 需要估计 $P(Y=c_k,X^{(i)}=x^{(i)})$ 与 $P(X^{(j)}=x^{(j)}|Y=c_k,X^{(j)}=x^{(i)})$，计算公式如下： \\begin{matrix} \\hat{P}(Y=c_k,X^{(i)}=x^{(i)})=\\frac{N_{c_k}^{x^{(i)}}+1}{n+KN^{(i)}} \\\\ \\hat{P}(X^{(j)}=x^{(j)}|Y=c_k,X^{(j)}=x^{(i)})=\\frac{N^{x^{(i)},x^{(j)}}_{c_k}+1}{N^{x^{(i)}}_{c_k}+N^{(j)}} \\end{matrix}其中，各参数含义如下： $N_{c_k}^{x^{(i)}}$：第 $i$ 个特征 $X^{(i)}$ 取值为 $x^{(i)}$ 且属于类别 $c_k$ 的样本个数 $N_{c_k}^{x^{(i)},x^{(j)}}$：第 $i$ 个特征 $X^{(i)}$ 和第 $j$ 个特征 $X^{(j)}$ 分别取值 $x^{(i)}$ 和 $x^{(j)}$ 且类别为 $c_k$ 的样本个数 $N^{(i)}$：第 $i$ 个特征可能的取值数 $N^{(j)}$：第 $j$ 个特征可能的取值数 $n$：样本个数 $K$：类别取值个数 TAN 模型树扩展朴素贝叶斯（Tree Augmented Naive Bayes，TAN）与 SPODE 模型类似，也是假设每个特征只依赖于一个特征，但与 SPODE 不同的是，其并不是统一的依赖于一个超父 其将 $m$ 个特征视为 $m$ 个结点，对于任意两个结点建立无向边，以构建一个无向完全图，同时，每条边的权重设为两条边的条件互信息（Conditional Mutual Information）： I(x^{(i)};x^{(j)}|y) = \\sum_{c_k\\in\\mathcal{Y}} \\sum_{x^{(i)}\\in\\mathcal{X}} \\sum_{x^{(j)}\\in\\mathcal{X}} P(x^{(i)},x^{(j)},c_k) \\log{\\frac {P(c_k)P(x^{(i)},x^{(j)},c_k)}{P(x^{(i)},c_k)P(x^{(j)},c_k)}}关于条件互信息，详见：信息熵与互信息 观察上式可知，其刻画了特征 $x^{(i)}$ 和 $x^{(j)}$ 在已知类别 $c_k$ 的情况下的相关性，即： 若 $P(x^{(i)},x^{(j)},c_k)=P(x^{(i)},c_k)P(x^{(j)},c_k)$，则 $I(x^{(i)};x^{(j)}|y)=0$，此时 $x^{(i)}$ 与 $x^{(j)}$ 无关 若 $P(x^{(i)},x^{(j)},c_k) &gt; P(x^{(i)},c_k)P(x^{(j)},c_k)$，则 $I(x^{(i)};x^{(j)}|y)&gt;0$，此时 $x^{(i)}$ 与 $x^{(j)}$ 正相关 若 $P(x^{(i)},x^{(j)},c_k) &lt; P(x^{(i)},c_k)P(x^{(j)},c_k)$，则 $I(x^{(i)};x^{(j)}|y)&lt;0$，此时 $x^{(i)}$ 与 $x^{(j)}$ 负相关 之后，对于建立好的无向完全图，根据最大带权生成树（Maximum Weighted Spanning Tree）算法，挑选根结点，同时根据特征 $x^{(i)}$ 和 $x^{(j)}$ 的相关性，将无向边设为有向边 最后，加入类别结点 $y$，增加类别结点 $y$ 到每个特征的有向边 这样一来，即可像 AODE 模型中一样计算概率，只是每个特征有着自己独特的父类","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"朴素贝叶斯","slug":"machine-learning/28.朴素贝叶斯","date":"2019-07-22T06:36:00.000Z","updated":"2023-04-01T15:13:18.343Z","comments":true,"path":"artificial-intelligence/machine-learning/f77f0066.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/f77f0066.html","excerpt":"Reference 【辨析】先验概率、后验概率、似然概率 带你理解朴素贝叶斯分类算法 算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification) 贝叶斯估计 平滑处理—拉普拉斯（Laplace Smoothing） Naive Bayes classifier Additive smoothing 【概述】贝叶斯分类模型是基于贝叶斯定理与特征条件独立假设的分类模型，朴素贝叶斯（Naive Bayes）是贝叶斯分类模型中最简单、最常见的一种分类方法，该方法从概率论的角度来进行分类预测，实现简单，预测效率高","text":"Reference 【辨析】先验概率、后验概率、似然概率 带你理解朴素贝叶斯分类算法 算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification) 贝叶斯估计 平滑处理—拉普拉斯（Laplace Smoothing） Naive Bayes classifier Additive smoothing 【概述】贝叶斯分类模型是基于贝叶斯定理与特征条件独立假设的分类模型，朴素贝叶斯（Naive Bayes）是贝叶斯分类模型中最简单、最常见的一种分类方法，该方法从概率论的角度来进行分类预测，实现简单，预测效率高 贝叶斯定理、贝叶斯分类模型、朴素贝叶斯三者关系如下： 之所以叫做朴素贝叶斯，一方面是其基于贝叶斯定理，另一方面，朴素是指其基于特征独立性假设，各特征不会相互影响，大大减少了计算概率的难度 该方法的基本思想是：对于给定的训练集，当要根据多个特征对数据进行分类时，通常假设这些特征相互独立，然后利用条件概率乘法法则得到每一个分类的概率，对于给定的输入样本 $\\mathbf{x}$，利用模型求出后验概率最大的作为预测输出 $y$ 【贝叶斯公式】假设事件 $A$ 发生的概率为 $P(A)$，事件 $B$ 发生的概率为 $P(B)$，在事件 $B$ 发生的情况下，事件 $A$ 发生的概率为 $P(A|B)$，则事件 $A$ 发生的情况下事件 $B$ 发生的概率为： \\begin{align*} P(B|A) &= \\frac{P(AB)}{P(A)} \\\\ &= \\frac{P(A|B)P(B)}{P(A)} \\end{align*}其中，$P(B|A)$ 称为后验概率（Posterior Probability），$P(A)$、$P(B)$ 称为先验概率（Prior Probability），$P(A|B)$ 称为似然概率（Likelihood） 对于分类算法来说，令数据特征为事件 $A$，令类别为事件 $B$，则此时贝叶斯公式可表达为如下形式： P(类别|特征)=\\frac{P(特征|类别)P(类别)}{P(特征)}为便于表述，记数据特征为 $\\mathbb{x}$，记类别为 $c$，那么有： P(c|\\mathbb{x}) = \\frac{P(\\mathbb{x}|c) P(c)}{P(\\mathbb{x})}进一步，对于先验概率 $P(c)$ 和 $P(\\mathbb{x})$，表示类别的先验概率 $P(类别)$ 称为类先验概率（Class Prior Probability），表示做出预测的先验概率 $P(特征)$ 称为预测先验概率（Predictor Prior Probability） 【朴素贝叶斯分类器】朴素贝叶斯模型设输入空间 $\\mathcal{X}\\subseteq \\mathbb{R}^m $ 为 $m$ 维向量的集合，输出空间为类标记集合 $\\mathcal{Y}=\\{c_1,c_2,…,c_K\\}$，输入为特征向量 $\\mathbf{x}\\in \\mathcal{X}$，输出为类标记 $y\\in \\mathcal{Y}$，$X$ 是定义在输入空间 $\\mathcal{X}$ 上的随机向量，$Y$ 是定义在输出空间 $\\mathcal{Y}$ 上的随机变量，$P(X,Y)$ 是 $X$ 和 $Y$ 的联合概率分布 已知给定的训练集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$ 由 $P(X,Y)$ 独立同分布产生，对于第 $i$ 组样本对，输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{X} \\subseteq \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}= \\{c_1,c_2,…,c_K\\}$ 为实例的类别 根据训练集 $T$ 可知，类标记的先验概率分布为： P(Y=c_k),\\quad k=1,2,...,K亦可知在训练集 $T$ 上输入 $\\mathbf{x}_i$ 的条件概率分布为： P(X=\\mathbf{x}_i|Y=c_k) = P(X^{(1)}=x_i^{(1)},...,X^{(m)}=x_i^{(m)}|Y=c_k),\\quad k=1,2,...,K对于 $P(X=\\mathbf{x}_i|Y=c_k)$，假设 $\\mathbf{x}$ 的各分量 $x_i^{(j)}$ 可取值的个数为 $S_j,j=1,2,…,m$，又由于 $Y$ 可取值个数为 $K$，那么参数的个数为： K\\prod _{j=1}^nS_j可以发现，条件概率分布 $P(X=\\mathbf{x_i}|Y=c_k)$ 有着指数级的参数，对其进行参数估计是不可行的，为此，作条件独立性假设 也就是说，假设用于分类的特征在类确定的条件下都是独立的，此时，在训练集 $T$ 上输入 $\\mathbf{x}_i$ 的条件概率分布为： \\begin{align*} P(X=\\mathbf{x}_i|Y=c_k) =& P(X^{(1)}=x^{(1)}_i,...,X^{(m)}=x^{(m)}_i|Y=c_k) \\\\ =&\\prod_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_k) \\end{align*}另一方面，根据全概率公式： P(A)=\\sum_{i=1}^nP(A|B_i)P(B_i)在训练集 $T$ 上输入 $\\mathbf{x}_i$ 的概率分布为： P(X=\\mathbb{x_i}) = \\sum_{k=1}^K P(X=\\mathbb{x}_i|Y=c_k)P(Y=c_k)这样，根据朴素贝叶斯公式，当给定一个新的输入 $\\mathbb{x}\\in\\mathbb{R}^m$ 时，即可计算出该输入所属类别 $c_k$ 的后验概率分布，即： \\begin{align*} P(Y=c_k|X=\\mathbb{x}) &= \\frac{P(X=\\mathbb{x}|Y=c_k) P(Y=c_k)}{P(X=\\mathbb{x})} \\\\ &= \\frac{P(Y=c_k) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_k)}{\\sum\\limits_{k'=1}^K \\Big[ P(X=\\mathbb{x}|Y=c_{k'}) P(Y=c_{k'})\\Big]} \\\\ &= \\frac{P(Y=c_k) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_k)}{\\sum\\limits_{k'=1}^K \\Bigg[ P(Y=c_{k'}) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_{k'}) \\Bigg] } \\end{align*}由此，对于给定新的输入 $\\mathbb{x}\\in\\mathbb{R}^m$，朴素贝叶斯分类器即可表示为： y=\\arg\\max_{c_k} \\frac{P(Y=c_k) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_k)}{\\sum\\limits_{k'=1}^K \\Bigg[ P(Y=c_{k'}) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_{k'}) \\Bigg] }可以注意到，上式中，分母对所有的 $c_k$ 都是相同的，将分母忽略，即有： \\hat{y}=\\arg\\max_{c_k} P(Y=c_k) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_k)此时，模型学习意味着估计类先验概率 $P(Y=c_k)$ 与似然概率 $P(X^{(j)}=x^{(j)}|Y=c_k)$ 后验概率最大化与期望风险最小化对于分类决策函数 $\\hat{y}=f(\\mathbf{x})$，假设使用 0-1 损失函数： L(y,f(x))= \\left\\{\\begin{array}{rl} 1, & y \\neq f(x)\\\\ 0, & y = f(x) \\end{array}\\right.对于联合分布 $P(X,Y)$，取条件期望，此时期望风险函数为： \\begin{align*} R_{exp}(f) &= E[L(Y,f(X))] \\\\ &= E_X\\sum_{k=1}^KL(c_k,f(X))P(c_k|X) \\end{align*}为使期望风险最小化，只需对 $X=\\mathbb{x}$ 逐个极小化，有： \\begin{align*} \\hat{y} &= \\arg \\min_{y\\in\\mathcal{Y}}\\sum_{k=1}^K L(c_k,y)P(c_k|X=\\mathbb{x}) \\\\ &= \\arg \\min_{y\\in\\mathcal{Y}}\\sum_{k=1}^K P(y\\neq c_k|X=\\mathbb{x}) \\\\ &= \\arg \\min_{y\\in\\mathcal{Y}}[1-P(y=c_k|X=\\mathbb{x})] \\\\ &= \\arg \\max_{y\\in\\mathcal{Y}}P(y=c_k|X=\\mathbb{x}) \\end{align*}可以发现，在朴素贝叶斯中，期望风险最小化与后验概率最大化是等价的 【朴素贝叶斯参数估计】概述对于朴素贝叶斯分类器： \\hat{y}=\\arg\\max_{c_k} P(Y=c_k) \\prod\\limits_{j=1}^m P(X^{(j)}=x^{(j)}|Y=c_k)模型学习意味着对类先验概率 $P(Y=c_k)$ 与似然概率 $P(X^{(j)}=x^{(j)}|Y=c_k)$ 进行参数估计，此时，可以使用极大似然估计来进行参数估计 由于离散型随机变量是直接将频率当做概率，因此若一个属性未出现时，计算得出的概率为 $0$ 为避免这种错误，可以使用贝叶斯估计，通过引入 $\\lambda=1$ 进行拉普拉斯平滑修正，即假设特征值和类别的均匀分布，但当样本数目足够大时，该影响会被消除 极大似然估计朴素贝叶斯的学习就意味着对类先验概率 $P(Y=c_k)$ 与似然概率 $P(X^{(j)}=x^{(j)}|Y=c_k)$ 进行参数估计 对于类先验概率 $P(Y=c_k)$，可以通过对训练集进行经验统计而得出，对于样本容量为 $n$ 的训练集，有： P(Y=c_k)=\\frac{1}{n}\\sum_{i=1}^n I(y_i=c_k)对于似然概率 $P(X^{(j)}=x^{(j)}|Y=c_k)$，根据贝叶斯公式，可写为： P(X^{(j)}=x^{(j)}|Y=c_k)=\\frac{P(Y=c_k|X^{(j)}=x^{(j)})P(X^{(j)}=x^{(j)})}{P(Y=c_k)}对于分子，根据条件概率公式，有： P(Y=c_k|X^{(j)}=x^{(j)})P(X^{(j)}=x^{(j)})=P(X^{(j)}=x^{(j)},Y=c_k)假设第 $j$ 个特征 $x^{(j)}$ 可能取值的集合为 $\\{a^{(j)}_1,a^{(j)}_2,…,a^{(j)}_{S_j}\\}$，其中，$a^{(j)}_l$ 代表第 $j$ 个特征可能取的第 $l$ 个值，$S_j$ 代表第 $j$ 个特征可取值的数量，那么有： P(X^{(j)}=x^{(j)},Y=c_k)=\\frac{1}{n}\\sum\\limits_{i=1}^n I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)其中，$j=1,2,…,n$，$l=1,2,…,S_j$，$k=1,2,…,K$ 于是，似然概率为： \\begin{align*} P(X^{(j)}=a^{(j)}_l|Y=c_k)&= \\frac{P(Y=c_k|X^{(j)}=x^{(j)})P(X^{(j)}=x^{(j)})}{P(Y=c_k)} \\\\ &= \\frac{P(X^{(j)}=x^{(j)},Y=c_k)}{P(Y=c_k)} \\\\ &= \\frac{\\frac{1}{n}\\sum\\limits_{i=1}^n I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)}{\\frac{1}{n}\\sum\\limits_{i=1}^n I(y_i=c_k)} \\\\ &= \\frac{\\sum\\limits_{i=1}^n I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)}{\\sum\\limits_{i=1}^N I(y_i=c_k)} \\end{align*}即： P(X^{(j)}=a^{(j)}_l|Y=c_k) = \\frac{\\sum\\limits_{i=1}^N I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)}{\\sum\\limits_{i=1}^N I(y_i=c_k)}其中，$j=1,2,…,n$，$l=1,2,…,S_j$，$k=1,2,…,K$ 贝叶斯估计与极大似然估计相似，对于贝叶斯估计，设 $\\lambda\\geq0$，则对于类先验概率 $P(Y=c_k)$，有： P_{\\lambda}(Y=c_k)=\\frac{1}{n+\\lambda K}\\bigl[\\sum\\limits_{i=1}^n I(y_i=c_k) + \\lambda \\bigr]进一步，假设第 $j$ 个特征 $x^{(j)}$ 可能取值的集合为 $\\{a^{(j)}_1,a^{(j)}_2,…,a^{(j)}_{S_j}\\}$，其中，$a^{(j)}_l$ 代表第 $j$ 个特征可能取的第 $l$ 个值，$S_j$ 代表第 $j$ 个特征可取值的数量，那么有： P_{\\lambda}(X^{(j)}=a^{(j)}_l|Y=c_k)=\\frac{\\sum\\limits_{i=1}^n I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)+\\lambda }{\\sum\\limits_{i=1}^n I(y_i=c_k)+\\lambda S_j}其中，$j=1,2,…,n$，$l=1,2,…,S_j$，$k=1,2,…,K$ 可以发现，贝叶斯估计等价于在随机变量各个取值的频数上赋予一个正数 $\\lambda\\geq0$，而当 $\\lambda=0$ 时，即为极大似然估计 一般来说，常取 $\\lambda=1$，此时称为拉普拉斯平滑（Laplace smoothing） 那么，对于任意的 $l$ 和 $k$，有： \\begin{matrix} P_{\\lambda}(X^{(j)}=a^{(j)}_l|Y=c_k)>0 \\\\ \\sum\\limits_{l=1}^{L}P(X^{(j)}=a^{(j)}_l|Y=c_k)=1 \\end{matrix}【实例】问题描述现给出一个身高为 高，体重为 中，鞋码为 中 的数据，根据下图中的数据，判断这个数据是男是女 问题分析设特征：身高为 高 为 $A_1$，体重为 中 为 $A_2$，鞋码为 中 为 $A_3$，类别：男 $C_1$，女 $C_2$ 首先要求在 $A_1,A_2,A_3$ 下 $C_k$ 的概率，即： P(C_k|A_1A_2A_3)=\\frac{P(A_1A_2A_3|C_k)P(C_k)}{P(A_1A_2A_3)}由于类别仅有两种，因此仅需计算 $P(C_1|A_1A_2A_3)$ 和 $P(C_2|A_1A_2A_3)$，然后输出较大的概率所对应的分类 根据朴素贝叶斯模型： y=\\arg \\max_{c_k}P(Y=c_k)\\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)这就等价于求 $P(A_1A_2A_3|C_k)P(C_k)$ 的最大值 极大似然估计假设 $A_i$ 之间是相互独立的，那么有： P(A_1A_2A_3|C_j)=P(A_1|C_j)P(A_2|C_j)P(A_3|C_j)对于先验概率 $P(Y=c_k)$，其极大似然估计为： P(Y=c_k)=\\frac{1}{n}\\sum_{i=1}^n I(y_i=c_k)根据数据集，可得： \\begin{matrix} P(Y=C_1)=\\frac{4}{8}=\\frac{1}{2} & P(Y=C_2)=\\frac{4}{8}=\\frac{1}{2} \\end{matrix}对于似然概率 $P(X^{(j)}=a_{jl}|Y=c_k)$ ，其极大似然估计为： P(X^{(j)}=a^{(j)}_l|Y=c_k) = \\frac{\\sum\\limits_{i=1}^n I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)}{\\sum\\limits_{i=1}^n I(y_i=c_k)}根据数据集，可得： \\begin{matrix} P(X^{(1)}=A_1|Y=C_1)=\\frac{2}{4}=\\frac{1}{2} & P(X^{(1)}=A_1|Y=C_2)=\\frac{0}{4}=0\\\\ P(X^{(2)}=A_2|Y=C_1)=\\frac{2}{4}=\\frac{1}{2} & P(X^{(2)}=A_2|Y=C_2)=\\frac{2}{4}=\\frac{1}{2}\\\\ P(X^{(3)}=A_3|Y=C_1)=\\frac{1}{4}\\:\\:\\:\\:\\:\\:\\:\\:\\: & P(X^{(3)}=A_3|Y=C_2)=\\frac{2}{4}=\\frac{1}{2} \\end{matrix}因此，由朴素贝叶斯模型： y=\\arg \\max_{c_k}P(Y=c_k)\\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)：可得： P(A_1A_2A_3|C_1)P(C_1)=\\frac{1}{16}>P(A_1A_2A_3|C_2)P(C_2)=0综上，对于给定身高为 高，体重为 中，鞋码为 中 的数据，应是 $C_1$ 类别，为男性 贝叶斯估计假设 $A_i$ 之间是相互独立的，那么有： P(A_1A_2A_3|C_j)=P(A_1|C_j)P(A_2|C_j)P(A_3|C_j)对于先验概率 $P(Y=c_k)$，其贝叶斯估计为： P_{\\lambda}(Y=c_k)=\\frac{\\sum\\limits_{i=1}^n I(y_i=c_k) + \\lambda}{N+\\lambda K}根据数据集，可得： \\begin{matrix} P(Y=C_1)=\\frac{4+1}{8+2}=\\frac{1}{2} & P(Y=C_2)=\\frac{4+1}{8+2}=\\frac{1}{2} \\end{matrix}对于似然概率 $P(X^{(j)}=a^{(j)}_l|Y=c_k)$ ，其贝叶斯估计为： P_{\\lambda}(X^{(j)}=a^{(j)}_l|Y=c_k)=\\frac{\\sum\\limits_{i=1}^n I(x_i^{(j)}=a^{(j)}_l,y_i=c_k)+\\lambda }{\\sum\\limits_{i=1}^n I(y_i=c_k)+\\lambda S_j}根据数据集，可得： \\begin{matrix} P(X^{(1)}=A_1|Y=C_1)=\\frac{2+1}{4+3}=\\frac{3}{7} & P(X^{(1)}=A_1|Y=C_2)=\\frac{0+1}{4+3}=\\frac{1}{7}\\\\ P(X^{(2)}=A_2|Y=C_1)=\\frac{2+1}{4+3}=\\frac{3}{7} & P(X^{(2)}=A_2|Y=C_2)=\\frac{2+1}{4+3}=\\frac{3}{7}\\\\ P(X^{(3)}=A_3|Y=C_1)=\\frac{1+1}{4+3}=\\frac{2}{7} & P(X^{(3)}=A_3|Y=C_2)=\\frac{2+1}{4+3}=\\frac{3}{7} \\end{matrix}因此，由朴素贝叶斯模型： y=\\arg \\max_{c_k}P(Y=c_k)\\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)：可得： P(A_1A_2A_3|C_1)P(C_1)=\\frac{18}{343}>P(A_1A_2A_3|C_2)P(C_2)=\\frac{9}{343}综上，对于给定身高为 高，体重为 中，鞋码为 中 的数据，应是 $C_1$ 类别，为男性 【sklearn 实现】概述sklearn 中提供了若干朴素贝叶斯的实现算法，对于不同的朴素贝叶斯实现，主要是对 $P(X^{(j)}=x^{(j)}|Y=c_k)$ 的分布假设不同，以采用不同的参数估计方式 对于朴素贝叶斯来说，其主要就是计算似然概率 $P(X^{(j)}=x^{(j)}|Y=c_k)$，一旦似然概率确定，最终所属每个类别的概率自然也就轻易得出 常用的两种朴素贝叶斯为： 高斯朴素贝叶斯：GaussianNB() 伯努利朴素贝叶斯：BernoulliNB() 高斯朴素贝叶斯高斯朴素贝叶斯适用于连续型随机变量，其假设各特征 $x^{(j)}$ 在各类别 $c_k$ 下服从正态分布，因此算法内部使用正态分布的概率密度函数来计算概率，即： P(X^{(j)}=x^{(j)}|Y=c_k)=\\frac{1}{\\sqrt{2\\pi\\sigma_{c_k}^2}}exp\\bigl(-\\frac{(x^{(j)-\\mu_{c_k}})^2}{2\\sigma_{c_k}^2}\\bigr)其中，参数含义如下： $\\mu_{c_k}$：在类别 $c_k$ 的样本中，特征 $x^{(j)}$ 的均值 $\\sigma_{c_k}$：在类别 $c_k$ 的样本中，特征 $x^{(j)}$ 的标准差 以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现高斯朴素贝叶斯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.naive_bayes import GaussianNBfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train, X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立高斯朴素贝叶斯模型 model = GaussianNB() # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150)) 伯努利朴素贝叶斯伯努利朴素贝叶斯适用于离散型随机变量，其假设各特征 $x^{(j)}$ 在各类别 $c_k$ 下服从 n 重伯努利分布，因此算法内部会首先对特征值 $x^{(j)}$ 进行二值化处理，之后依照如下公式进行概率计算： P(X^{(j)}=x^{(j)}|Y=c_k)=P(X^{(j)}=1|Y=c_k)+(1-x^{(j)})(1-P(X^{(j)}=1|Y=c_k))在训练集中，会进行如下估计： \\begin{matrix} P(X^{(j)}=1|Y=c_k)=\\frac{N_{c_k}^{(j)}+\\alpha}{N_{c_k}+2\\alpha} \\\\ P(X^{(j)}=0|Y=c_k)=1-P(X^{(j)}=1|Y=c_k) \\end{matrix}其中，参数含义如下： $N_{c_k}^{(j)}$：第 $j$ 个特征中属于类别 $c_k$，且特征值为 $1$ 的样本个数 $N_{c_k}$：属于类别 $c_k$ 的样本个数 $\\alpha$：平滑系数 以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现伯努利朴素贝叶斯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.naive_bayes import BernoulliNBfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train, X_test): sc = MinMaxScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立伯努利朴素贝叶斯模型 model = BernoulliNB(alpha=0.15, binarize=0.5) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"改进的迭代尺度法(IIS)","slug":"convex-optimization/12.改进的迭代尺度法(IIS)","date":"2019-07-21T05:28:00.000Z","updated":"2023-03-23T07:38:34.333Z","comments":true,"path":"mathematics/convex-optimization/346416ed.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/convex-optimization/346416ed.html","excerpt":"【概述】改进的迭代尺度法（Improve Iterative Scaling，IIS）是一种专用于最大熵模型学习的最优化算法，其是在通用迭代尺度法（Generalized Iterative Scaling，GIS）的基础上改进得来的 关于最大熵模型，详见：最大熵模型","text":"【概述】改进的迭代尺度法（Improve Iterative Scaling，IIS）是一种专用于最大熵模型学习的最优化算法，其是在通用迭代尺度法（Generalized Iterative Scaling，GIS）的基础上改进得来的 关于最大熵模型，详见：最大熵模型 已知最大熵模型为： p_{\\boldsymbol{\\omega}}(y|x)=\\frac{1}{Z_{\\boldsymbol{\\omega}}(x)}\\exp\\bigl[\\sum_{j=1}^m \\omega^{(j)}f_j(x,y)\\bigr]其中，规范化因子 $Z_{\\boldsymbol{\\omega}}(x)$ 为： Z_{\\boldsymbol{\\omega}}(x)=\\sum_{y\\in Y} \\exp \\Big[\\sum_{j=1}^m \\omega^{(j)}f_j(x,y)\\Big]对数似然函数为： L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}}) = \\sum_{x\\in X,y\\in Y}\\tilde{p}(x,y)\\sum_{j=1}^m\\omega^{(j)}f_j(x,y)-\\sum_{x\\in X}\\tilde{p}(x)\\log Z_{\\boldsymbol{\\omega}}(x)目标是通过极大似然估计学习模型参数，求对数似然函数的极大值 $\\hat{\\boldsymbol{\\omega}}$ 【基本思想】IIS 的基本思想是假设最大熵模型当前的参数向量是 $\\mathbf{\\omega}=(\\omega^{(1)},\\omega^{(2)},…,\\omega^{(m)})^T$，希望找到一个新的参数向量 $\\boldsymbol{\\omega}+\\boldsymbol{\\delta}=(\\omega^{(1)}+\\delta^{(1)},\\omega^{(2)}+\\delta^{(2)},…,\\omega^{(m)}+\\delta^{(m)})^T$，使得模型的对数似然函数值增大 若存在一种参数向量更新的方法：$\\tau : \\boldsymbol{\\omega} \\rightarrow \\boldsymbol{\\omega}+\\boldsymbol{\\delta}$，那么就可以重复使用这一方法，直到寻找到对数似然函数的最大值 【对数似然函数改变量】对于给定的经验分布 $\\tilde{p}(x,y)$，参数模型从 $\\boldsymbol{\\omega}$ 到 $\\boldsymbol{\\omega}+\\boldsymbol{\\delta}$，对数似然函数的改变量为： \\begin{align*} L(\\boldsymbol{\\omega}+\\boldsymbol{\\delta})-L(\\boldsymbol{\\omega}) &= \\sum_{x,y}\\tilde{p}(x,y)\\log p_{\\boldsymbol{\\omega}+\\boldsymbol{\\delta}}(y|x)-\\sum_{x,y}\\tilde{p}(x,y)\\log p_{\\boldsymbol{\\omega}}(y|x) \\\\\\ &= \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y) - \\sum_x \\tilde{p}(x)\\log \\frac{Z_{\\boldsymbol{\\omega}+\\boldsymbol{\\delta}}(x)}{Z_{\\boldsymbol{\\omega}}(x)} \\end{align*}利用对数不等式： -\\log \\alpha\\geq 1-\\alpha,\\quad \\alpha >0可以求出对数似然函数改变量的下界： \\begin{align*} & L(\\boldsymbol{\\omega}+\\boldsymbol{\\delta})-L(\\boldsymbol{\\omega}) \\\\ \\geq& \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y) +1 - \\sum_x \\tilde{p}(x)\\log \\frac{Z_{\\boldsymbol{\\omega}+\\boldsymbol{\\delta}}(x)}{Z_{\\boldsymbol{\\omega}}(x)} \\\\ =& \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y) +1 - \\sum_x \\tilde{p}(x)\\sum_yp_{\\boldsymbol{\\omega}}(y|x) \\exp \\sum_{j=1}^m \\delta^{(j)} f_j(x,y) \\\\ \\end{align*}将右端记为 $A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$，有： A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega}) =\\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y) +1 - \\sum_x \\tilde{p}(x)\\sum_yp_\\boldsymbol{\\omega}(y|x) \\exp \\sum_{j=1}^m \\delta^{(j)} f_j(x,y)则： L(\\boldsymbol{\\omega}+\\boldsymbol{\\delta})-L(\\boldsymbol{\\omega})\\geq A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})即 $A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ 是对数似然函数改变量的一个下界 【下界的提高】若能找到适当的 $\\boldsymbol{\\delta}$ 使得下界 $A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ 增大，那么对数似然函数也会增大 但 $\\boldsymbol{\\delta}$ 是一个含有 $m$ 个分量的向量，不易同时优化，IIS 每次只优化其中的一个变量 $\\delta^{(j)}$，固定其他变量 $\\delta^{(t)},t\\neq j$ 为达到这一目的，IIS 进一步降低下界 $A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ ，即引进一个函数量 $F(x,y)$，其是一个二值函数，表示所有特征在 $(x,y)$ 中出现的次数，即： F(x,y) = \\sum_{j=1}^mf_j(x,y)这样一来，$A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ 可以改写为： \\begin{align*} A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega}) =& \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y) +1 \\\\ &- \\sum_x \\tilde{p}(x)\\sum_yp_\\boldsymbol{\\omega}(y|x) \\exp \\Big[F(x,y) \\sum_{i=j}^m \\frac{\\delta^{(j)} f_j(x,y)}{F(x,y)} \\Big] \\end{align*}利用指数函数的凸性，对任意 $j$，有： \\frac{f_j(x,y)}{F(x,y)}\\geq 0且满足： \\sum_{j=1}^m \\frac{f_j(x,y)}{F(x,y)}=1 根据凸函数性质的 Jensen 不等式，有： \\exp\\Big[\\sum_{j=1}^m\\frac{f_j(x,y)}{F(x,y)}\\delta^{(j)}F(x,y)\\Big] \\leq \\sum_{j=1}^m\\frac{f_i(x,y)}{F(x,y)}\\exp\\Big[\\delta^{(j)}F(x,y)\\Big]PS：关于 Jensen 不等式，见：附：关于 Jensen 不等式 此时，$A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ 可以改写为： \\begin{align*} A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega}) \\geq& \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y)+1 \\\\ &-\\sum_x\\tilde{p}(x)\\sum_yp_{\\boldsymbol{\\omega}}(y|x)\\sum_{j=1}^m\\frac{f_j(x,y)}{F(x,y)}\\exp\\big[\\delta^{(j)}F(x,y)\\big] \\end{align*}记不等式右端为 $B(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$，其是对数似然函数改变量的一个新的下界，其相较于 $A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ 更加的宽松，即： \\begin{align*} B(\\boldsymbol{\\delta}|\\boldsymbol{\\omega}) =& \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\delta^{(j)}f_j(x,y)+1 \\\\ &- \\sum_x\\tilde{p}(x)\\sum_yp_{\\boldsymbol{\\omega}}(y|x)\\sum_{j=1}^m\\frac{f_j(x,y)}{F(x,y)}\\exp\\big[\\delta^{(j)}F(x,y)\\big] \\end{align*}于是得到： L(\\boldsymbol{\\omega}+\\boldsymbol{\\delta})-L(\\boldsymbol{\\omega})\\geq A(\\boldsymbol{\\delta}|\\boldsymbol{\\omega}) \\geq B(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})对 $B(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})$ 求关于 $\\delta^{(j)}$ 的偏导数： \\begin{align*} \\frac{\\partial B(\\boldsymbol{\\delta}|\\boldsymbol{\\omega})}{\\partial \\delta^{(j)}} =& \\sum_{x,y}\\tilde{p}(x,y)f_j(x,y)-\\sum_x\\tilde{p}(x)\\sum_{y}p_{\\boldsymbol{\\omega}}(y|x)f_j(x,y) \\exp\\big[\\delta^{(j)}F(x,y)\\big] \\\\ \\end{align*}此时，该式除 $\\delta^{(j)}$ 外不含任何其他变量，令偏导为 $0$ 可得： \\sum_{x,y}\\tilde{p}(x)p_{\\boldsymbol{\\omega}}(y|x)f_j(x,y) \\exp\\big[\\delta^{(j)}F(x,y)\\big] = E_{\\tilde{p}}(f_j)最后，依次对 $\\delta^{(j)}$ 求解方程即可得到 $\\boldsymbol{\\delta}$ 【算法流程】输入：特征函数 $f_1,f_2,…,f_n$；经验分布 $\\tilde{P}(X,Y)$；最大熵模型 $p_{\\boldsymbol{\\omega}}(y|x)$ 输出：最优参数值 $\\boldsymbol{\\omega}^{*}$；最优模型 $p_{\\boldsymbol{\\omega}^{*}}(y|x)$ 算法流程： Step1.对所有的 $j\\in\\{1,2,…,m\\}$，取初值 $\\omega^{(j)}=0$ Step2.对每一 $j\\in\\{1,2,…,m\\}$： 1）令 $\\delta^{(j)}$ 为下列方程的解 \\sum_{x,y}\\tilde{p}(x)p(y|x)f_j(x,y) \\exp\\big[\\delta^{(j)}F(x,y)\\big]=E_{\\tilde{p}}(f_j)其中，F(x,y)=\\sum\\limits_{j=1}^mf_j(x,y) 2）更新 $\\omega^{(j)}$ 的值：$\\omega^{(j)}=\\omega^{(j)}+\\delta^{(j)}$ Step3.若存在未收敛的 $\\omega^{(j)}$，重复步骤 2 可以发现，上述算法的关键步骤是 Step2 的步骤 1），即求解 $\\delta^{(j)}$ 的过程 若 $F(x,y)$ 是一个常数，即对任意的 $x$ 与 $y$，满足： F(x,y)=M则解 $\\delta^{(j)}$ 可表示为： \\delta^{(j)}=\\frac{1}{M}\\log \\frac{E_{\\tilde{p}}(f_j)}{E_{p}(f_j)}此时，对于 $M$ 来说，可将其视为梯度下降法中的学习速率，同时，IIS 等同于通用迭代尺度法 GIS 若 $F(x,y)$ 不是一个常数，则必须通过数值计算的方法来求 $\\delta^{(j)}$，此时，通常选用牛顿迭代法来求 $\\delta^{(j)}$ 即用 $g(\\delta^{(j)})=0$ 来表示方程 $\\sum\\limits_{x,y}\\tilde{p}(x)p(y|x)f_j(x,y)\\exp\\big[\\delta^{(j)}F(x,y)\\big]=E_{\\tilde{p}}(f_j)$ 的解，利用牛顿迭代法对下列公式进行迭代： \\delta_{k+1}^{(j)}=\\delta_k^{(j)}-\\frac{g(\\delta_{k}^{(j)})}{g'(\\delta_{k}^{(j)})}通过迭代可得到 $(\\delta^{(j)})^*$，使得 $g((\\delta^{(j)})^*)=0$ 【附：关于 Jensen 不等式】基本形式若 $f(x)$ 是区间 $[a,b]$ 上的下凸函数，对任意的 $x_1,x_2,…,x_n\\in [a,b]$，有： \\frac{1}{n}\\sum_{i=1}^nf(x_i)\\geq f(\\frac{1}{n}\\sum\\limits_{i=1}^nx_i)仅当 $x_1=x_2=…=x_n$ 时，等号成立 注：若为上凸函数，不等号反向 加权形式若 $f(x)$ 是区间 $[a,b]$ 上的下凸函数，对任意的 $x_1,x_2,…,x_n\\in [a,b]$，且对任意 $a_i&gt;0$，满足 $\\lambda_1+\\lambda_2+…+\\lambda_n=1$，有： \\sum_{i=1}^n\\lambda_if(x_i)\\geq f(\\sum\\limits_{i=1}^n\\lambda_ix_i)注：若为上凸函数，不等号反向 点击返回","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"凸优化","slug":"mathematics/convex-optimization","permalink":"https://alex-mcavoy.github.io/categories/mathematics/convex-optimization/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"凸优化","slug":"convex-optimization","permalink":"https://alex-mcavoy.github.io/tags/convex-optimization/"}],"author":"Alex_McAvoy"},{"title":"最大熵模型","slug":"machine-learning/27.最大熵模型","date":"2019-07-19T05:40:00.000Z","updated":"2023-03-31T12:33:44.416Z","comments":true,"path":"artificial-intelligence/machine-learning/ba8a14c4.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/ba8a14c4.html","excerpt":"Reference 详解最大熵模型 最大熵模型原理 深入机器学习系列21-最大熵模型 二十一.最大熵模型原理 最大熵模型中的对数似然函数表示法解释 最大熵模型中的对数似然函数的解释 【最大熵模型的导出】判别分类模型","text":"Reference 详解最大熵模型 最大熵模型原理 深入机器学习系列21-最大熵模型 二十一.最大熵模型原理 最大熵模型中的对数似然函数表示法解释 最大熵模型中的对数似然函数的解释 【最大熵模型的导出】判别分类模型假设分类模型为一判别模型，选用条件概率分布 $P(Y|X)$ 作为预测模型，$X\\in\\mathcal{X}\\subseteq \\mathbb{R}^n $ 为输入，$Y\\in\\mathcal{Y}\\subseteq \\mathbb{R}^n $ 为输出 该模型的含义为：对于给定的输入 $X$，以 $P(Y|X)$ 的概率输出 $Y$ 特征函数特征函数（Feature Function）用于描述输入 $x$ 与输出 $y$ 之间的某一事实，其定义为： f(x,y)=\\left\\{\\begin{array}{rl} 1,& x,y\\:\\:满足某一事实 \\\\ 0,& 否则 \\end{array}\\right.其是一个二值函数，用于将数据集数学化 举例来说，对于如下数据集： 取第一列为 $x$，第二列为 $y$，可以为该数据集写出一些特征函数，例如： f(x,y)=\\left\\{\\begin{array}{rl} 1,& if:\\:x=cloudy\\:\\:and\\:\\:y=outdoor \\\\ 0,& else \\end{array}\\right.如此，可以为每个 &lt;特征，标签&gt; 对都做一个如上的特征函数，以实现数据集数学化 经验分布对于给定训练集，可将训练数据当做由随机变量 $(X,Y)$ 产生的，那么可根据训练数据来确定联合分布 $P(X,Y)$ 的经验分布 $\\tilde{P}(X,Y)$ 与边缘分布 $P(X)$ 的经验分布 $\\tilde{P}(X)$ 记 $v(X=x,Y=y)$ 为训练集中样本 $(x,y)$ 的出现频数，$v(X=x)$ 为训练集中输入 $x$ 的出现频数，$n$ 为样本容量，则对于两个经验分布，有： \\begin{gather*} \\tilde{P}(X=x,Y=y)=\\frac{v(X=x,Y=y)}{n} \\\\ \\tilde{P}(X=x)=\\frac{v(X=x)}{n} \\end{gather*}约束条件对于来自参数空间 $\\mathcal{X}$ 的离散随机变量 $X$，其概率分布为： P(X=x_i)=p_i,\\quad i=1,2,...,n对于随机变量 $X$，其数学期望为 $E(X)=\\sum\\limits_{i=1}^nx_ip_i$，若 $Y=f(X)$，则关于 $X$ 的函数 $Y$ 的期望为： E(Y)=\\sum_{i=1}^nf(x_i)p_i按照期望的定义，对于任意的特征函数 $f(x,y)$，用 $E_{\\tilde{p}}(f)$ 表示特征函数 $f(x,y)$ 关于经验分布 $\\tilde{P}(X,Y)$ 的期望，有： E_{\\tilde{p}}(f)=\\sum_{x\\in X}\\sum_{y\\in Y}\\tilde{p}(x,y)f(x,y)对于任意的特征函数 $f(x,y)$，用 $E_p(f)$ 表示特征函数 $f(x,y)$ 关于判别模型 $P(Y|X)$ 的期望，有： E_p(f)=\\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)f(x,y)对于判别模型 $P(Y|X)$，希望关于经验分布 $\\tilde{P}(X,Y)$ 的期望 $E_{\\tilde{p}}(f)$ 应该与从训练集中得到的关于经验分布 $\\tilde{P}(X)$ 的期望 $E_p(f)$ 是一致的，为此，提出特征约束： E_p(f)=E_{\\tilde{p}}(f)即： \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)f(x,y)=\\sum_{x\\in X}\\sum_{y\\in Y}\\tilde{p}(x,y)f(x,y)上式即为最大熵模型中要满足的约束条件 需要注意的是，由于特征函数是对数据集实现数学化的，每个 &lt;特征，标签&gt; 对都会做一个特征函数，因此，若有 $m$ 个特征的话，就有 $m$ 个特征函数 $f_j(x,y)$ ，相应地，有 $m$ 个约束条件 满足所有约束条件的模型集合为： \\mathcal{C}\\equiv\\{p\\in\\mathcal{P}|E_p(f_j)=E_{\\tilde{p}}(f_j),j=1,2,...,m\\}最大熵模型对于给定的训练集 $T$，目标是根据最大熵原理，选择一个最优的分类器 对于从训练集获得的特征函数和约束条件，将信息熵的概念应用到条件分布中，条件概率分布 $p(Y|X)$ 上的条件熵为： H(Y|X) = -\\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)\\log p(y|x)此时，在约束条件的模型集合 $\\mathcal{C}$ 中，条件熵最大的模型，即为最大熵模型 要注意的是，式中的对数取自然对数 【最大熵模型】约束最优化问题最大熵模型的学习过程，即求解最大熵模型的过程，其可以形式化为约束最优化问题 对于给定的训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}= \\{c_1,c_2,…,c_K\\}$ 为实例的类别，特征函数 $f_j(x^{(j)},y),j=1,2,…,m$ 最大熵模型的学习等价于下述的约束最优化问题，即求取最大的条件熵使得边际概率和为 $1$，同时特征期望相同： \\begin{gather*} \\max_{p\\in \\mathcal{C}} & H(Y|X)=-\\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)\\log p(y|x) \\\\ s.t. & \\left\\{\\begin{array}{rl} \\sum\\limits_{y\\in Y}p(y|x) &=& 1 &\\\\ E_p(f_j) &=& E_{\\tilde{p}}(f_j), & j=1,2,...,m \\end{array}\\right. \\end{gather*}按照最优化问题的习惯，将最大化问题改写为等价的最小化问题： \\begin{gather*} \\min_{p\\in \\mathcal{C}} & -H(Y|X)=\\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)\\log p(y|x) \\\\ s.t. & \\left\\{\\begin{array}{rl} 1-\\sum\\limits_{y\\in Y}p(y|x) &=& 0& \\\\ E_{\\tilde{p}}(f_j) - E_p(f_j) &=& 0, & j=1,2,...,m \\end{array}\\right. \\end{gather*}此时，求解最小化问题所得出的解，即最大熵模型学习的解 最大熵模型对于上述的约束最优化问题，使用拉格朗日乘子法进行求解，关于拉格朗日乘子法，详见：拉格朗日乘子法与对偶性 首先，引入拉格朗日乘子 $\\boldsymbol{\\omega} = \\{\\omega^{(0)},\\omega^{(1)},…,\\omega^{(m)}\\}$，并定义拉格朗日函数： \\begin{align*} L(p,\\boldsymbol{\\omega}) \\equiv& -H(Y|X) + \\omega^{(0)}\\bigl[1-\\sum_{y\\in Y} p(y|x)\\bigr] + \\sum_{j=1}^m \\omega^{(j)}\\bigl[E_{\\tilde{p}}(f_j)-E_p(f_j)\\bigr] \\\\ =& \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)\\log p(y|x) + \\omega^{(0)}\\bigl[1-\\sum_{y\\in Y} p(y|x)\\bigr] \\\\ &+ \\sum_{j=1}^m \\omega^{(j)}\\Big[ \\sum_{x\\in X}\\sum_{y\\in Y} \\tilde{p}(x,y)f_j(x,y) - \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)f_j(x,y) \\Big] \\end{align*}此时，最优化的原始问题为： \\min_{p\\in\\mathcal{C}}\\:\\max_{\\boldsymbol{\\omega}}\\:L(p,\\boldsymbol{\\omega})其对偶问题为： \\max_{\\boldsymbol{\\omega}}\\:\\min_{p\\in\\mathcal{C}}\\:L(p,\\boldsymbol{\\omega})由于拉格朗日函数 $L(p,\\boldsymbol{\\omega})$ 是 $p$ 的凸函数，且其满足 Slater 条件，故原始问题的解与对偶问题的解是等价的，进而可以通过求解对偶问题来求解原始问题 对于对偶问题内部的极小化问题 $\\min\\limits_{p\\in\\mathcal{C}}\\:L(p,\\boldsymbol{\\omega})$，其是 $\\boldsymbol{\\omega}$ 的函数，将其记为 $\\psi(\\boldsymbol{\\omega})$，即对偶函数，有： \\psi(\\boldsymbol{\\omega})= \\min\\limits_{p\\in\\mathcal{C}}\\:L(p,\\boldsymbol{\\omega}) = L(p_{\\boldsymbol\\omega},\\boldsymbol\\omega)将对偶函数 $\\psi(\\boldsymbol{\\omega})$ 解记为 $p_{\\boldsymbol{\\omega}}$，有： p_{\\boldsymbol{\\omega}} = \\arg\\min_{p\\in\\mathcal{C}}L(p,\\boldsymbol{\\omega}) = p_{\\boldsymbol{\\omega}}(y|x)具体地，计算 $L(p,\\boldsymbol{\\omega})$ 对 $p(y|x)$ 的偏导数，即： \\begin{align*} \\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(y|x)} =& \\sum_{x\\in X} \\tilde{p}(x) \\sum_{y\\in Y} \\log p(y|x) + \\sum_{x\\in X} \\tilde{p}(x) - \\sum_{y\\in Y} \\omega^{(0)} \\\\ &- \\sum_{x\\in X} p(x) \\sum_{j=1}^m \\omega^{(j)} \\sum_{y \\in Y} f_j(x,y) \\\\ =& \\sum_{x\\in X,y\\in Y} \\tilde{p}(x)\\log p(y|x) + \\sum_{x\\in X} \\tilde{p}(x) -\\sum_{y\\in Y} \\omega^{(0)}\\\\ &- \\sum_{x\\in X,y\\in Y}\\tilde{p}(x)\\sum_{j=1}^m \\omega^{(j)}f_j(x,y) \\\\ =& \\sum_{x\\in X,y\\in Y} \\tilde{p}(x)\\Big[ \\log p(y|x) + 1 - \\omega^{(0)} - \\sum_{j=1}^m \\omega^{(j)}f_j(x,y) \\Big] \\end{align*}令偏导数 $\\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(y|x)}=0$，即： \\sum_{x\\in X,y\\in Y}\\tilde{p}(x)\\bigl[ \\log p(y|x)+1-\\omega^{(0)}-\\sum_{j=1}^m \\omega^{(j)}f_j(x,y) \\bigr]=0在已知 $\\tilde{p}(x)&gt;0$ 的情况下，有： \\log p(y|x)+1-\\omega^{(0)}-\\sum_{j=1}^m \\omega^{(j)}f_j(x,y) = 0即： \\log p(y|x) = \\sum_{j=1}^m \\omega^{(j)}f_j(x,y)+\\omega^{(0)}-1可得： p(y|x) = \\exp \\Big[ \\sum_{j=1}^m \\omega^{(j)}f_j(x,y)+\\omega^{(0)}-1 \\Big]即： p(y|x)=\\frac{\\exp \\Big[ \\sum_{j=1}^m \\omega^{(j)}f_j(x,y) \\Big]}{\\exp\\Big[1-\\omega^{(0)}\\Big]}由于 $\\sum\\limits_{y\\in Y} p(y|x)=1$，根据等概率原则可得： \\exp\\Big[1-\\omega^{(0)}\\Big] = \\sum_{y\\in Y} \\exp \\Big[ \\sum_{j=1}^m \\omega^{(j)}f_j(x,y) \\Big]记 $Z_{\\boldsymbol\\omega}(x)=\\sum\\limits_{y\\in Y} \\exp \\Big[ \\sum\\limits_{j=1}^m \\omega^{(j)}f_j(x,y) \\Big]$，称为规范化因子，其具有归一化的作用，保证了 $p_{\\boldsymbol{\\omega}}(y|x)$ 是概率，那么有： p_{\\boldsymbol{\\omega}}(y|x) = \\frac{1}{Z_{\\boldsymbol\\omega}(x)} \\exp\\Big[\\sum_{j=1}^m\\omega^{(j)}f_j(x,y)\\Big]此时所得到的对偶函数 $\\psi(\\boldsymbol{\\omega})$ 的解 $p_{\\boldsymbol{\\omega}}=p_{\\boldsymbol{\\omega}}(y|x)$ 即为最大熵模型 【最大熵模型的学习】对偶函数的极大化对于最大熵模型的约束最优化问题，内部的极小化问题的求解得到了关于 $\\boldsymbol{\\omega}$ 的对偶函数 $\\psi(\\boldsymbol{\\omega})$，此时，只需对最大熵模型进行学习，即对对偶问题的外部极大化问题进行处理 将极大化问题的解记为 $\\boldsymbol{\\omega}^{*}$，有： \\boldsymbol{\\omega}^{*}=\\arg \\max_{\\boldsymbol{\\omega}} \\psi(\\boldsymbol{\\omega})将 $p_{\\boldsymbol{\\omega}}(y|x)$ 代入到对偶函数 $\\psi(\\boldsymbol{\\omega})$ 中，可得： \\begin{align*} \\psi(\\boldsymbol{\\omega}) =& \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)\\log p(y|x) + \\omega^{(0)}\\bigl[1-\\sum_{y\\in Y} p(y|x)\\bigr] \\\\ &+ \\sum_{j=1}^m \\omega^{(j)}\\Big[ \\sum_{x\\in X}\\sum_{y\\in Y} \\tilde{p}(x,y)f_j(x,y) - \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p(y|x)f_j(x,y) \\Big] \\\\ =& \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p_{\\boldsymbol{\\omega}}(y|x)\\log p_{\\boldsymbol{\\omega}}(y|x) + \\omega^{(0)}\\bigl[1-\\sum_{y\\in Y} p_{\\boldsymbol{\\omega}}(y|x)\\bigr] \\\\ &+ \\sum_{j=1}^m \\omega^{(j)}\\Big[ \\sum_{x\\in X}\\sum_{y\\in Y} \\tilde{p}(x,y)f_j(x,y) - \\sum_{x\\in X}\\tilde{p}(x)\\sum_{y\\in Y}p_{\\boldsymbol{\\omega}}(y|x)f_j(x,y) \\Big] \\end{align*}由于 $\\sum\\limits_{y\\in Y} p(y|x)=1$，故有： \\begin{align*} \\psi(\\boldsymbol{\\omega}) =& \\sum_{x\\in X,y\\in Y} \\tilde{p}(x) \\log p_{\\boldsymbol{\\omega}}(y|x) + \\sum_{j=1}^m \\omega^{(j)} \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)f_j(x,y) \\\\\\ &- \\sum_{j=1}^m\\omega^{(j)}\\sum_{x\\in X,y\\in Y} \\tilde{p}(x)f_j(x,y) \\end{align*}又因为： \\log p_{\\boldsymbol{\\omega}}(y|x) = \\sum_{j=1}^m \\omega^{(j)}f_j(x,y) - \\log Z_{\\boldsymbol{\\omega}} (x)则有： \\begin{align*} \\psi(\\boldsymbol{\\omega}) =& \\sum_{x\\in X,y\\in Y} \\tilde{p}(x) \\Big[ \\sum_{j=1}^m \\omega^{(j)}f_j(x,y) - \\log Z_{\\boldsymbol{\\omega}} (x) \\Big] \\\\ &+ \\sum_{j=1}^m \\omega^{(j)} \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)f_j(x,y) - \\sum_{j=1}^m\\omega^{(j)}\\sum_{x\\in X,y\\in Y} \\tilde{p}(x)f_j(x,y) \\end{align*}化简得： \\psi(\\boldsymbol{\\omega}) = \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\sum_{j=1}^m \\omega^{(j)} f_j(x,y) - \\sum_{x\\in X} \\tilde{p}(x) \\log Z_{\\boldsymbol{\\omega}}(x)故极大化问题为： \\boldsymbol{\\omega}^{*}=\\arg \\max_{\\boldsymbol{\\omega}} \\Big [\\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\sum_{j=1}^m \\omega^{(j)} f_j(x,y) - \\sum_{x\\in X} \\tilde{p}(x) \\log Z_{\\boldsymbol{\\omega}}(x) \\Big]最大熵模型的极大似然估计假设样本集大小为 $n$，对于样本具体观测值 $x_1,x_2,…,x_n$，假设其取值有 $K$ 个，分别为 $v_1,v_2,…,v_K$，用 $C(X=v_i)$ 表示在观测值中样本 $v_i$ 出现的频数，那么似然函数可写为： L(x_1,x_2,...,x_n;\\theta) = \\prod_{k=1}^K p(v_k;\\theta)^{C(X=v_k)}对上式两边同时开 $\\frac{1}{n}$ 次方，可得： L(x_1,x_2,...,x_n;\\theta)^{\\frac{1}{n}} = \\prod_{k=1}^k p(v_k;\\theta)^\\frac{C(X=v_k)}{n}由于经验概率 $\\tilde{p}(x)=\\frac{C(X=v_k)}{n}$，故有： L(x_1,x_2,...,x_n;\\theta)^{\\frac{1}{n}} = \\prod_{x\\in X} p(x;\\theta)^{\\tilde{p}(x)}显然，对 $L(x_1,x_2,…,x_n;\\theta)^{\\frac{1}{n}}$ 求极大值与对 $L(x_1,x_2,…,x_n;\\theta)$ 求极大值的优化结果是相同的，那么，最终的极大似然函数可表示为： L(x;\\theta) = \\prod_{x\\in X} p(x;\\theta)^{\\tilde{p}(x)}当已知训练数据的经验概率分布为 $\\tilde{p}(X,Y)$ 时，有： \\begin{align*} L_{\\tilde{p}} &= \\log \\prod_{x\\in X,y\\in Y} p(x,y)^{\\tilde{p}(x,y)} \\\\ &= \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y) \\log p(x,y) \\\\ &= \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y) \\log \\big[ \\tilde{p}(x)p(y|x) \\big] \\\\ &= \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\log p(y|x) + \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\log \\tilde{p}(x) \\end{align*}其中，对于第二项 $\\sum\\limits_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\log \\tilde{p}(x)$，一旦样本集确定，经验分布 $\\tilde{p}(x,y)$ 与 $\\tilde{p}(x)$ 可直接算出，故该项为一常数，忽略即可，故而最终的对数似然函数为： L_{\\tilde{p}}=\\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y) \\log p(y|x) 当条件概率分布 $p(y|x)$ 为最大熵模型 $p_{\\boldsymbol{\\omega}}(y|x) = \\frac{1}{Z_{\\boldsymbol\\omega}(x)} \\exp\\Big[\\sum_{j=1}^m\\omega^{(j)}f_j(x,y)\\Big]$ 时，对数似然函数为： \\begin{align*} L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}}) &= \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\log p_{\\boldsymbol{\\omega}}(y|x) \\\\ &= \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\sum_{j=1}^m \\omega^{(j)} f_j(x,y)-\\sum_{x\\in X,y\\in Y}\\tilde{p}(x,y)\\log Z_{\\boldsymbol{\\omega}} (x) \\\\ &= \\sum_{x\\in X,y\\in Y} \\tilde{p}(x,y)\\sum_{j=1}^m \\omega^{(j)} f_j(x,y)-\\sum_{x\\in X}\\tilde{p}(x)\\log Z_{\\boldsymbol{\\omega}} (x) \\\\ \\end{align*}可以发现，对数似然函数 $L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}}) $ 与对偶函数 $\\psi(\\boldsymbol{\\omega}) $ 相等，即： L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}}) = \\psi(\\boldsymbol{\\omega})接着，考虑对偶函数 $\\psi(\\boldsymbol{\\omega})$，有： \\begin{align*} \\psi(\\boldsymbol{\\omega}) &= -\\sum_x\\tilde{p}(x)\\log Z_{\\boldsymbol{\\omega}}(x)+\\sum_{j=1}^m\\omega^{(j)}E_{\\tilde{p}}(f_j) \\\\ &= -\\sum_x\\tilde{p}(x)\\log Z_{\\boldsymbol{\\omega}}(x)+\\sum_{j=m}^n\\omega^{(j)}\\sum_{x,y}\\tilde{p}(x,y)f_j(x,y)\\\\ &= \\sum_{x,y}\\tilde{p}(x,y)\\sum_{j=1}^m\\omega^{(j)}f_j(x,y)-\\sum_x\\tilde{p}(x)\\log Z_{\\boldsymbol{\\omega}}(x) \\end{align*}可以发现，最大熵模型 $p_{\\boldsymbol{\\omega}}(y|x)$ 的对数似然函数与对偶函数 $\\psi(\\boldsymbol{\\omega})$ 等价，即： \\psi(\\boldsymbol{\\omega})=L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}})因此，最大熵模型学习中的对偶函数 $\\psi(\\boldsymbol{\\omega})$ 极大化等价于最大熵模型的极大似然估计，这样对最大熵模型的学习问题就转化成了具体求解对数似然函数极大化或求解对偶函数极大化的问题，即： \\max_{\\boldsymbol{\\omega}}\\sum_{x\\in X,y\\in Y}\\tilde{p}(x,y)\\sum_{j=1}^m\\omega^{(j)}f_j(x,y)-\\sum_{x\\in X}\\tilde{p}(x)\\log Z_{\\boldsymbol{\\omega}}(x)【最大熵模型学习的最优化算法】由于在最大熵模型中，对偶函数的极大化等价于最大熵模型的极大似然估计，那么最大熵模型的学习问题就转换为具体求解对偶函数 $\\psi(\\boldsymbol{\\omega})$ 极大化或对数似然函数 $L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}})$ 极大化的问题，即： \\boldsymbol{\\omega}^{*} = \\arg \\max_{\\boldsymbol{\\omega}} \\psi(\\boldsymbol{\\omega}) = \\arg \\max_{\\boldsymbol{\\omega}} L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}})虽然对偶函数 $\\psi(\\boldsymbol{\\omega})=L_{\\tilde{p}}(p_{\\boldsymbol{\\omega}})$ 是一个光滑的凸函数，但由于其规范化因子 $Z_{\\boldsymbol\\omega}(x)=\\sum\\limits_{y\\in Y} \\exp \\Big[ \\sum\\limits_{j=1}^m \\omega^{(j)}f_j(x,y) \\Big]$ 中存在指数函数，几乎不可能有解析解，换言之，即使有解析解，但最终仍要求数值解 对于上述的问题，可以使用梯度下降法、牛顿法、拟牛顿法、迭代尺度法、改进的迭代尺度法等最优化方法，其中，改进的迭代尺度法（Improved Iterative Scaling，IIS）是专门用于最大熵模型学习的最优化算法 关于 IIS，详见：改进的迭代尺度法 【实例】假设随机变量 $X$ 有 5 个取值 $\\{A,B,C,D,E\\}$，对应取值的概率分别为 $P(A)$、$P(B)$、$P(C)$、$P(D)$、$P(E)$，存在如下约束条件： \\begin{gather*} P(A)+P(B)=\\frac{3}{10}\\\\ P(A)+P(B)+P(C)+P(D)+P(E)=1 \\end{gather*}要求学习最大熵模型 为表示方便，令 $x_1$、$x_2$、$x_3$、$x_4$、$x_5$ 表示 $A$、$B$、$C$、$D$、$E$ 于是，关于经验分布 $\\tilde{P}(X)$ 的期望为： E_{\\tilde{p}}=p(x_1)+p(x_2)关于模型 $P(Y|X)$ 与经验分布 $\\tilde{P}(X)$ 的期望为： E_p=\\tilde{p}(x_1)+\\tilde{p}(x_2)=\\frac{3}{10}此时，最大熵模型学习的最优化问题为： \\begin{gather*} \\min_{p\\in\\mathcal{C}} & -H(p)=\\sum_{i=1}^5 p(x_i)\\log p(x_i) \\\\ s.t. & \\left\\{\\begin{array}{rl} \\sum\\limits_{i=1}^5 p(x_i) &= \\sum\\limits_{i=1}^5 \\tilde{p}(x_i) = 1 \\\\ E_{\\tilde{p}}-E_p &= 0 \\end{array}\\right. \\end{gather*}引入拉格朗日乘子 $\\omega^{(0)}$、$\\omega^{(1)}$，并定义拉格朗日函数： L(p,\\boldsymbol{\\omega})=\\sum_{i=1}^5p(x_i)\\log p(x_i) + \\omega^{(0)}\\bigl[ 1-\\sum_{i=1}^5p(x_i)\\bigr] + \\omega^{(1)}\\bigl[ p(x_1)+p(x_2)-\\frac{3}{10}\\bigr]根据拉格朗日对偶性，通过求解对偶问题来得到原始问题的解，即求解： \\max_{\\boldsymbol{\\omega}}\\:\\min_{p\\in \\mathcal{C}}\\:L(p,\\boldsymbol{\\omega})首先求解 $L(p,\\boldsymbol{\\omega})$ 关于 $p$ 的极小化问题 $\\psi(\\boldsymbol{\\omega})$ ，求偏导数 $\\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(x)}$，有： \\begin{gather*} \\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(x_1)} &=& \\log p(x_1)+1 - \\omega^{(0)} + \\omega^{(1)} \\\\ \\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(x_2)} &=& \\log p(x_2)+1 - \\omega^{(0)} + \\omega^{(1)} \\\\ \\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(x_3)} &=& \\log p(x_3)+1 - \\omega^{(0)} \\\\ \\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(x_4)} &=& \\log p(x_4)+1 - \\omega^{(0)} \\\\ \\frac{\\partial L(p,\\boldsymbol{\\omega})}{\\partial p(x_5)} &=& \\log p(x_5)+1 - \\omega^{(0)} \\end{gather*}令各项偏导数为 $0$，有： \\begin{gather*} p(x_1)=p(x_2)=e^{\\omega^{(0)}-\\omega^{(1)}-1}\\\\ p(x_3)=p(x_4)=p(x_5)=e^{\\omega^{(0)}-1} \\end{gather*}故对偶函数为： \\psi(\\boldsymbol{\\omega})=-2e^{\\omega^{(0)}-\\omega^{(1)}-1}-3e^{\\omega^{(0)}-1}-\\frac{3}{10}\\omega^{(1)}+\\omega^{(0)}接着，解 $\\psi(\\boldsymbol{\\omega})$ 的关于 $\\boldsymbol{\\omega}$ 的极大化问题 分别求 $\\psi(\\boldsymbol{\\omega})$ 对 $\\omega^{(0)}$、$\\omega^{(1)}$ 的偏导，并令其为 $0$，联立后有： \\begin{gather*} e^{\\omega^{(0)}-\\omega^{(1)}-1}=\\frac{3}{20}\\\\ e^{\\omega^{(0)}-1}=\\frac{7}{30} \\end{gather*}故可得所要求的概率分布为： \\begin{gather*} p(x_1)=p(x_2)=\\frac{3}{20}\\\\ p(x_3)=p(x_4)=p(x_5)=\\frac{7}{30} \\end{gather*}【实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现最大熵模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom collections import defaultdictimport mathfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 特征重建def features_rebuild(old_features): ''' 最大熵模型f(x,y)中的x是一个单独的特征，不是n维特征向量 为此，要对每个维度加一个区分特征 具体来说，将原来feature的(a0,a1,a2,...)变成(0_a0,1_a1,2_a2,...)的形式 ''' new_features = [] for feature in old_features: new_feature = [] for i, f in enumerate(feature): new_feature.append(str(i) + '_' + str(f)) new_features.append(new_feature) return new_featuresclass MaxEnt(object): def init_params(self, X, Y): self.X_ = X self.Y_ = set() self.cal_Vxy(X, Y) self.N = len(X) # 数据集大小 self.n = len(self.Vxy) # 数据集中样本(x,y)的个数 self.M = 10000.0 # 设置IIS算法中的学习速率M self.build_dict() self.cal_pxy() # 建立id:(x,y)字典和(x,y):id字典 def build_dict(self): self.id2xy = &#123;&#125; self.xy2id = &#123;&#125; for i, (x, y) in enumerate(self.Vxy): self.id2xy[i] = (x, y) self.xy2id[(x, y)] = i # 计算样本(x,y)出现的频数v(X=x,Y=y) def cal_Vxy(self, X, Y): self.Vxy = defaultdict(int) for i in range(len(X)): x_, y = X[i], Y[i] self.Y_.add(y) for x in x_: self.Vxy[(x, y)] += 1 # 计算联合分布p(X,Y)的经验分布p~(X,Y) def cal_pxy(self): self.pxy = defaultdict(float) for id in range(self.n): (x, y) = self.id2xy[id] self.pxy[id] = float(self.Vxy[(x, y)]) / float(self.N) # 计算规范化因子Zw(x)未加和前的单项Zw(x/yi) def cal_Zx(self, X, y): result = 0.0 for x in X: if (x,y) in self.xy2id: id = self.xy2id[(x, y)] result += self.w[id] return (math.exp(result), y) # 计算条件概率p(Y|X) def cal_pyx(self, X): pyxs = [(self.cal_Zx(X, y)) for y in self.Y_] Zwx = sum([prob for prob, y in pyxs]) return [(prob / Zwx, y) for prob, y in pyxs] # 计算未加和的前的特征函数f(x,y)关于模型p(Y|X)与经验分布p~(X)的期望值Ep(f)的单项Ep(f_i) def cal_Epfi(self): self.Epfi = [0.0 for i in range(self.n)] for i, X in enumerate(self.X_): pyxs = self.cal_pyx(X) for x in X: for pyx, y in pyxs: if (x,y) in self.xy2id: id = self.xy2id[(x, y)] self.Epfi[id] += pyx * (1.0 / self.N) # IIS算法 def fit(self, X, Y): self.init_params(X, Y) # 初始化参数 max_iteration = 500 # 设置最大迭代次数 # step1：初始化参数值wi=0 self.w = [0.0 for i in range(self.n)] # step2：对每一参数进行操作 for times in range(max_iteration): # step2.a：计算δi detas = [] self.cal_Epfi() for i in range(self.n): # 指定的特征函数为指示函数，因此E~p(fi)等于p(X,y) deta = 1 / self.M * math.log(self.pxy[i] / self.Epfi[i]) detas.append(deta) # step2.b：更新wi self.w = [self.w[i] + detas[i] for i in range(self.n)] # 预测 def predict(self, testset): results = [] for test in testset: result = self.cal_pyx(test) results.append(max(result, key=lambda x: x[0])[1]) return results # 模型训练def train_model(X_train_std, y_train): # 建立最大熵模型 model = MaxEnt() # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): for i in range(0,150): X[i][0] = X[i][0].replace(\"0_\",\"\") X[i][1] = X[i][1].replace(\"1_\",\"\") X = X.astype(float) # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == '__main__': # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 特征重建 X_train_std = features_rebuild(X_train_std) X_test_std = features_rebuild(X_test_std) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"最大熵原理","slug":"information-theory/02.最大熵原理","date":"2019-07-18T07:34:00.000Z","updated":"2023-03-10T12:34:42.682Z","comments":true,"path":"mathematics/information-theory/81ddb601.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/information-theory/81ddb601.html","excerpt":"【最大熵原理】在 信息熵与互信息 中对信息熵进行了介绍，而最大熵原理，就是认为：在所有可能的概率分布中，熵最大的模型是最好的模型 对于来自参数空间 $\\mathcal{X}$ 的离散随机变量 $X$，其概率分布为：","text":"【最大熵原理】在 信息熵与互信息 中对信息熵进行了介绍，而最大熵原理，就是认为：在所有可能的概率分布中，熵最大的模型是最好的模型 对于来自参数空间 $\\mathcal{X}$ 的离散随机变量 $X$，其概率分布为： P(X=x_i)=p_i,\\quad i=1,2,...,n则信息熵为： H(X)=-\\sum_{i=1}^n p_i\\log p_i其取值范围为： 0\\leq H(X) \\leq \\log n当 $X$ 只有一个分类时，信息熵取最小值 $H(X)=0$；而当 $X$ 的分布为均匀分布，即 $X$ 中 $n$ 个分类出现的概率相同时，信息熵取最大值 $H(X)=\\log n$，此时 $p_i=\\frac{1}{n}$ 也就是说，所谓最大熵原理，就是在求解概率模型时，在满足约束条件的情况下，对于未知情况不做任何的主观假设，即将不确定部分视为等可能的，此时求得的模型为熵最大模型 【几何解释】对于概率模型集合 $\\mathcal{P}$，用欧式空间中的单纯形（Simplex）表示 具体来说，对于有 $k$ 个取值的离散型随机变量，使用 $k-1$ 维单纯形来表示，在单纯形中，一个点代表一个模型，整个单纯形代表了模型集合 举例来说，假设随机变量 $X$ 其可能的取值有：$\\{A,B,C\\}$，将使用 2 维单纯形来表示随机变量 $X$，并将随机变量 $X$ 的三个取值 $A$、$B$、$C$ 设为 2 维单纯形的三个顶点 设单纯形中任意一点 $P$ 到三边距离和为 $1$（在正三角形中，恒等于三角形的高），点到边的距离为对应取值的概率 若给定概率 $P(A)=P(B)=P(C)=\\frac{1}{3}$，则可用单纯形表示为： 同理，若给定概率 $P(A)=1,P(B)=P(C)=0$，则可用单纯形表示为： 一条直线对应一个约束条件，直线的交集对应于满足所有约束条件的模型集合 学习的目的，就是在所有可能的模型集合中，选择最优模型，最大熵原理，给出了最优模型选择的一个准则 【实例】举例来说，假设随机变量 $X$ 其可能的取值有：$\\{A,B,C,D,E\\}$，现在要估计其取各个值的概率 $P(A)$ 、$P(B)$ 、$P(C)$ 、$P(D)$ 、$P(E)$ 已知的是，这些概率值满足以下约束条件： P(A)+P(B)+P(C)+P(D)+P(E)=1满足这个约束条件的概率分布有无穷个，在没有任何信息的情况下，若仍要对概率分布进行估计，将 $X$ 的各取值的概率视为均等的，即： P(A)=P(B)=P(C)=P(D)=P(E)=\\frac{1}{5}此时，在等概率的情况下，熵最大 进一步，若给出了某些约束条件，则在给定约束条件的基础上，对其他缺少的未知信息的情况下，认为其他是等概率的 具体来说，在上例的基础上，给出了约束条件： P(A)+P(B)=\\frac{3}{10}此时，可认为 $A$、$B$ 是等概率的， $C$、$D$、$E$ 是等概率的，即有： \\begin{gather*} P(A)=P(B)=\\frac{3}{20}\\\\ P(C)=P(D)=P(E)=\\frac{7}{30} \\end{gather*}","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"信息论","slug":"mathematics/information-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/information-theory/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"信息论","slug":"information-theory","permalink":"https://alex-mcavoy.github.io/tags/information-theory/"}],"author":"Alex_McAvoy"},{"title":"拉格朗日乘子法与对偶性","slug":"convex-optimization/11.拉格朗日乘子法与对偶性","date":"2019-07-14T06:02:00.000Z","updated":"2023-03-23T06:38:40.731Z","comments":true,"path":"mathematics/convex-optimization/763e2d04.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/convex-optimization/763e2d04.html","excerpt":"Reference 拉格朗日乘数 拉格朗日乘数法 —— 通俗理解 真正理解拉格朗日乘子法和 KKT 条件 支持向量机原理详解(二): 拉格朗日对偶函数，SVM的对偶问题 拉格朗日乘子法与对偶问题 拉格朗日乘子法与拉格朗日对偶性 约束优化&amp;拉格朗日乘子法&amp;拉格朗日对偶解法的关系 机器学习算法系列（二）：拉格朗日对偶性 对偶和KKT条件 凸优化（slater条件探讨） Slater与KKT条件 Slater条件理解和证明 【概述】拉格朗日乘子法（Lagrange Multipliers）是一种寻找多元函数在一组约束下的极值的方法，将含有 $d$ 个变量与 $k$ 个约束条件的最优化问题，转换为具有 $d+k$ 个变量的无约束最优化问题来求解","text":"Reference 拉格朗日乘数 拉格朗日乘数法 —— 通俗理解 真正理解拉格朗日乘子法和 KKT 条件 支持向量机原理详解(二): 拉格朗日对偶函数，SVM的对偶问题 拉格朗日乘子法与对偶问题 拉格朗日乘子法与拉格朗日对偶性 约束优化&amp;拉格朗日乘子法&amp;拉格朗日对偶解法的关系 机器学习算法系列（二）：拉格朗日对偶性 对偶和KKT条件 凸优化（slater条件探讨） Slater与KKT条件 Slater条件理解和证明 【概述】拉格朗日乘子法（Lagrange Multipliers）是一种寻找多元函数在一组约束下的极值的方法，将含有 $d$ 个变量与 $k$ 个约束条件的最优化问题，转换为具有 $d+k$ 个变量的无约束最优化问题来求解 从数学意义上来讲，是通过引入拉格朗日乘子来建立极值条件，对 $d$ 个变量分别求偏导对应 $d$ 个方程，然后再加上 $k$ 个约束条件对应 $k$ 个拉格朗日乘子，从而构成了包含 $d+k$ 个变量的 $d+k$ 个方程的方程组问题，进一步就能根据求解方程组的方法来对最优化问题进行求解 【约束条件下的最优化问题】等式约束假设 $\\mathbf{x}$ 为 $d$ 维向量，要寻找 $\\mathbf{x}$ 的某个取值，使得目标函数 $f(\\mathbf{x})$ 最小，且满足 $g(\\mathbf{x})=0$ 的约束，即： \\begin{gather*} \\mathbf{x^{*}} = &\\arg \\min_{\\mathbf{x}} f(\\mathbf{x}) \\\\ s.t. & g(\\mathbf{x}^{*})=0 \\end{gather*}从几何的角度来看，该问题的目标，是在由方程 $g(\\mathbf{x})=0$ 确定的 $d-1$ 维曲面上，寻找使目标函数 $f(\\mathbf{x})$ 最小化的点，此时，可得到以下两条结论： 对于约束曲面上的任意点 $\\mathbf{x}$，该点的梯度 $\\triangledown g(\\mathbf{x})$ 与约束曲面正交 在最优点 $\\mathbf{x}^{*}$，目标函数在该点的梯度 $\\triangledown f(\\mathbf{x}^{*})$ 与约束曲面正交 如下图，图中用蓝线画出了目标函数 $f(x,y)$ 的一系列的等值面，用绿线画出了表示约束条件 $g(x,y)$ 的约束曲面 直观上来看，最优解 $\\mathbf{x}^*$ 一定位于约束曲面上某处与等值面相切的位置，否则，一定会沿着约束曲面移动到目标函数更小的等值面上，即 $\\triangledown f(\\mathbf{x})$ 和 $\\triangledown g(\\mathbf{x})$ 的方向必定相同或相反，故有： \\triangledown f(\\mathbf{x}^*)+\\lambda\\triangledown g(\\mathbf{x}^*)=0其中，$\\lambda$ 被称为拉格朗日乘子 接着，定义拉格朗日函数： L(\\mathbf{x},\\lambda)=f(\\mathbf{x})+\\lambda g(\\mathbf{x})不难发现，$L(\\mathbf{x},\\lambda)$ 的极值条件刚好就是最优解 $\\mathbf{x}^*$ 满足以下两个条件： \\left\\{\\begin{array}{rl} \\frac{\\partial L}{\\partial \\mathbf{x}} &=& \\triangledown f+\\lambda\\triangledown g=0\\\\ \\frac{\\partial L}{\\partial \\lambda} &=& g(x)=0 \\end{array}\\right.此时，原等式的约束最优化问题，就转化为对拉格朗日函数 $L(\\mathbf{x},\\lambda)$ 的无约束优化问题 不等式约束进一步，考虑不等式约束 $h(\\mathbf{x})\\leq 0$，有： \\begin{gather*} \\mathbf{x}^{*}=& \\arg \\min_{\\mathbf{x}} f(\\mathbf{x}) \\\\ s.t. & h(\\mathbf{x}^{*})\\leq 0 \\end{gather*}如下图，图中的阴影部分代表不等式约束 $h(\\mathbf{x})$ 的可行域 可根据目标函数 $f(\\mathbf{x})$ 的最优解 $\\mathbf{x}^{*}$ 是否在可行域内将这类不等式约束优化问题分为两类： $h(\\mathbf{x})&lt;0$：最优解 $\\mathbf{x}^{*}$ 在可行域内，此时不等式约束不起作用，只需求解 $f(\\mathbf{x})$ 的极值即可 $h(\\mathbf{x})=0$：最优解 $\\mathbf{x}^{*}$ 在可行域边界上，此时不等式约束退化为等式约束 构造不等式约束下的拉格朗日函数： L(\\mathbf{x},\\mu)=f(\\mathbf{x})+\\mu h(\\mathbf{x})对于 $h(\\mathbf{x})&lt;0$ 的情况，等价于令 $\\mu=0$ 然后求 $L(\\mathbf{x},\\mu)$ 的极值，即： \\left\\{\\begin{align*} \\frac{\\partial L}{\\partial \\mathbf{x}} &= \\triangledown f=0 \\\\ u &= 0 \\\\ h(\\mathbf{x}) &< 0 \\end{align*}\\right.对于 $h(\\mathbf{x})=0$ 的情况，若要在边界上取极小值，等值面 $f(\\mathbf{x})$ 的梯度必定是指向 $h(\\mathbf{x})0$，则： \\left\\{\\begin{align*} \\frac{\\partial L}{\\partial \\mathbf{x}} &= \\triangledown f+\\mu \\triangledown h =0 \\\\ \\mu &> 0\\\\ h(\\mathbf{x}) &=0 \\end{align*}\\right.联立上述两种情况，可得到不等式约束的一般形式，称为 KKT（Karush-Kuhn-Tucker）条件 \\left\\{\\begin{align*} \\frac{\\partial L}{\\partial \\mathbf{x}} &= \\triangledown f+\\mu \\triangledown h =0 \\\\ \\mu &\\geq 0\\\\ h(\\mathbf{x}) &\\leq 0 \\\\ \\mu h(\\mathbf{x}) &=0 \\end{align*}\\right.【拉格朗日对偶性】主问题将上述的等式约束与不等式约束进行推广，考虑具有 $n$ 个等式约束和 $m$ 个不等式约束，且可行域 $\\mathbb{D}\\subset \\mathbb{R}^{d}$ 非空的优化问题： \\begin{gather*} \\mathbf{x}^{*} = & \\arg \\min_{\\mathbf{x}} f(\\mathbf{x}) &\\\\ s.t. & g_i(\\mathbf{x}^{*})=0,& i=1,2,...,n\\\\ & h_j(\\mathbf{x}^{*})\\leq0,& j=1,2,...,m \\end{gather*}原始问题在主问题的基础上，引入拉格朗日乘子： \\begin{matrix} \\boldsymbol{\\lambda}=(\\lambda_1,\\lambda_2,...,\\lambda_n)^T\\\\ \\boldsymbol{\\mu}=(\\mu_1,\\mu_2,...,\\mu_m)^T \\end{matrix}此时，即可构造出广义拉格朗日函数（Generalized Lagrange Function）： L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})=f(\\mathbf{x})+\\sum_{i=1}^n\\lambda_ig_i(\\mathbf{x})+\\sum_{j=1}^m\\mu_jh_j(\\mathbf{x})则其 KKT 条件为： \\left\\{\\begin{align*} \\frac{\\partial L}{\\partial \\mathbf{x}} &= \\triangledown f+\\sum\\limits_{i=1}^n \\lambda_i\\triangledown g_i+ \\sum\\limits_{j=1}^m \\mu_j \\triangledown h_j =0 \\\\ \\frac{\\partial L}{\\partial \\lambda_i} &=g_i(\\mathbf{x})=0 \\\\ \\lambda_i &\\neq 0\\\\ \\mu_j &\\geq 0\\\\ h_j(\\mathbf{x}) &\\leq 0 \\\\ \\mu_j h_j(\\mathbf{x}) &=0 \\end{align*}\\right.这就是 KKT 条件下求极值的必要条件，即最优化问题的原始问题（Primal Problem） 其中，第一个条件是取极值的必要条件，第二个条件是原等式约束条件，第三个条件是等式约束的系数约束，第四个条件是不等式约束的系数约束，第五个条件是原不等式约束条件，第六个条件是互补松弛条件 对于互补松弛条件来说，其直观解释如下：要求 $L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 的最小值，那么一定是三个项同时取最小值的情况，而第三项取最小值时，就是其等于 $0$ 的情况 但由于该原始问题不一定是凸优化问题，为此，引入了其对偶问题（Dual Problem）来辅助求解 对偶问题设拉格朗日函数的对偶函数 $\\Gamma:\\mathbb{R}^{m}\\times \\mathbb{R}^{n}\\mapsto \\mathbb{R}$ 定义为： \\begin{align*} \\Gamma(\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) &= \\inf_{\\mathbf{x} \\in \\mathbb{D}} L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) \\\\ &= \\inf_{\\mathbf{x} \\in \\mathbb{D}} \\Big( f(\\mathbf{x}) + \\sum_{i=1}^n \\lambda_i g_i (\\mathbf{x}) + \\sum_{j=1}^m \\mu_j h_j(\\mathbf{x}) \\Big) \\end{align*}其具体含义是：对于给定的 $\\boldsymbol{\\lambda}$ 和 $\\boldsymbol{\\mu}$，在可行域 $\\mathbb{D}$ 内变动 $\\mathbf{x}$，函数 $L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 取值的下界即为 $\\Gamma$ 的值 可以发现，如果将 $\\boldsymbol{\\lambda}$、$\\boldsymbol{\\mu}$ 当做变量，即 $\\boldsymbol{\\lambda}$、$\\boldsymbol{\\mu}$ 不受 KKT 条件的约束，并将 $\\mathbf{x}$ 当做参数，那么，无论在可行域 $\\mathbb{D}$ 内如何变动 $\\mathbf{x}$，$\\Gamma(\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 都是一个仿射函数（最高次数为 $1$ 的多项式函数） 此时，对偶函数是一族关于 $(\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 的仿射函数的逐点下确界，即使原始问题不是凸的，对偶函数也是凹函数，这样一来，对偶问题就都是凸优化问题 如下图，右侧的红线为逐点取最小值得到的函数图形 下面证明在什么新的约束条件下，对偶函数能够给出主问题最优值的下确界 对于原始问题可行域 $\\mathbb{D}$ ，若 $\\tilde{\\mathbf{x}}\\in \\mathbb{D}$，则对任意 $\\boldsymbol{\\mu}\\succeq 0$ 和 $\\boldsymbol{\\lambda}$，结合原始问题的约束条件 $g_i(\\tilde{\\mathbf{x}})=0$ 和 $h_j(\\tilde{\\mathbf{x}})\\leq 0$，有： \\sum_{i=1}^n\\lambda_ig_i(\\mathbf{x})+\\sum_{j=1}^m\\mu_jh_j(\\mathbf{x})\\leq 0进而对拉格朗日对偶函数 $\\Gamma(\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$ 有： \\begin{align*} \\Gamma(\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) &= \\inf_{\\mathbf{x}\\in \\mathbb{D}} L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) \\\\ &\\leq L(\\tilde{\\mathbf{x}},\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) \\\\ &\\leq f(\\tilde{\\mathbf{x}}) \\end{align*}也就是说，原始问题的最小值大于等于对偶问题的最大值 若主问题的最优解为 $\\mathbf{x}^{*}=\\mathbf{p}^{*}$，则对任意的 $\\boldsymbol{\\mu}\\succeq 0$ 和 $\\boldsymbol{\\lambda}$ 都有： \\Gamma(\\boldsymbol{\\lambda},\\boldsymbol{\\mu})\\leq \\mathbf{p}^*也就是说，当满足 $\\boldsymbol{\\mu}\\succeq 0$ 时，对偶函数给出了主问题最优值的下界，于是，可以利用这个对偶函数 $\\Gamma$ 的最大值去逼近主问题中的最优解 $\\mathbf{p}^{*}$ 显然，对偶函数 $\\Gamma$ 的最大值是趋近于 $\\mathbf{p}^{*}$ 的值，由此引出了一个最优化问题： \\begin{gather*} (\\boldsymbol{\\lambda}^{*},\\boldsymbol{\\mu}^{*}) = & \\arg \\max_{\\boldsymbol{\\lambda},\\boldsymbol{\\mu}} \\Gamma(\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) \\\\ s.t. & \\boldsymbol{\\mu}\\succeq 0 \\end{gather*}这就是原始问题的对偶问题，其中 $\\boldsymbol{\\lambda}$ 和 $\\boldsymbol{\\mu}$ 被称为对偶变量（Dual Variable） 将原始问题转换为对偶问题后，可以发现，约束条件变少了，只剩下 $m$ 个不等式约束，这无疑极大的简化了计算，且对偶问题一定是凸优化问题 关于如何获得对偶函数表达式： 令 $\\frac{\\partial L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})}{\\partial \\mathbf{x}}=0$，以得到 $\\mathbf{x}$ 关于 $\\boldsymbol{\\lambda}$、$\\boldsymbol{\\mu}$ 的表达式 将 $\\mathbf{x}$ 关于 $\\boldsymbol{\\lambda}$、$\\boldsymbol{\\mu}$ 的表达式带回 $L(\\mathbf{x},\\boldsymbol{\\lambda},\\boldsymbol{\\mu})$，即可得到对偶函数的表达式 弱对偶性与最优对偶间隙设拉格朗日对偶问题的最优解为 $d^{*}$，则有： d^*\\leq p^*即使原始问题不是凸优化问题，这个不等式仍然成立，该性质即被称为弱对偶性（Weak Duality） 可以发现，有： 若 $p^{*}=-\\infty$，则：$d^{*}=-\\infty$ 若 $d^{*}=+\\infty$，则：$p^{*}=+\\infty$ 同时，对于主问题的最优解 $p^{*}$ 与获得了凸优化属性的对偶问题的最优解 $d^{*}$ 的非负差值 $p^{*}-d^{*}$，被称为最优对偶间隙（Duality Gap），其说明了原始解和对偶解对应的目标函数值的差距，差距越小说明最优解的上界和下界越小，也就是说越来越靠近最优解 强对偶性与 Slater 条件设拉格朗日对偶问题的最优解为 $d^{*}$，若有： d^*= p^*则称强对偶性（Strong Duality）成立 在强对偶性成立的情况下，将拉格朗日函数分别对原变量和对偶变量求导，再令导数为 $0$，即可得到原变量和对偶变量的数值关系 对于一般的优化问题来说，强对偶性一般不成立，但若原始问题是凸优化问题，且 Slater 条件成立，即：存在一点 $\\mathbf{x} \\in \\mathbb{D}$ 使得不等式约束 $h(\\mathbf{x})\\leq0$ 严格成立，那么强对偶性成立 简单来说，如果原始问题是凸优化问题，且至少存在绝对一个绝对可行点（一个可以让所有不等式约束都不取等号的可行点），那么就具有强对偶性 需要补充的是，Slater 条件是强对偶性成立的充分条件，KKT 条件是强对偶性成立的必要条件","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"凸优化","slug":"mathematics/convex-optimization","permalink":"https://alex-mcavoy.github.io/categories/mathematics/convex-optimization/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"凸优化","slug":"convex-optimization","permalink":"https://alex-mcavoy.github.io/tags/convex-optimization/"}],"author":"Alex_McAvoy"},{"title":"信息熵与互信息","slug":"information-theory/01.信息熵与互信息","date":"2019-07-13T02:50:00.000Z","updated":"2023-03-10T13:10:55.708Z","comments":true,"path":"mathematics/information-theory/d9f8f63d.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/information-theory/d9f8f63d.html","excerpt":"Reference 信息熵是什么？ - D.Han的回答 - 知乎 信息熵公式的由来 互信息(Mutual Information) 详解机器学习中的熵、条件熵、相对熵和交叉熵 一文搞懂交叉熵在机器学习中的使用，透彻理解交叉熵背后的直觉 条件互信息的理解(Conditional Mutual Information) 条件互信息 【信息熵】信息熵","text":"Reference 信息熵是什么？ - D.Han的回答 - 知乎 信息熵公式的由来 互信息(Mutual Information) 详解机器学习中的熵、条件熵、相对熵和交叉熵 一文搞懂交叉熵在机器学习中的使用，透彻理解交叉熵背后的直觉 条件互信息的理解(Conditional Mutual Information) 条件互信息 【信息熵】信息熵定义熵（Entropy）最早是由物理学家克劳修斯提出的，用于描述一个系统混乱程度的度量，系统越混乱，熵越大 随着时代的发展，熵这一概念被香农引入到信息论中，即信息熵（Information Entropy），其将信息熵定义为信息中排除了冗余后的平均信息量 信息熵是信息量大小的度量，常用于描述离散随机变量的不确定性，不确定性越大，信息熵越大 设 $X$ 是来自于参数空间 $\\mathcal{X}$ 的离散随机变量，其概率分布为： P(X=x)=p(x)则离散随机变量 $X$ 的信息熵定义为： \\begin{align*} H(X) &= \\sum_{x\\in X}p(x)\\log \\frac{1}{p(x)} \\\\ &= -\\sum_{x\\in X}p(x)\\log p(x) \\end{align*}其中，上式中的对数 $\\log$ 是以 $2$ 为底或以 $e$ 为底的对数，此时熵的单位分别称为 比特(bit)、纳特(nat) 需要注意的是，当信息熵的概率是由数据估计得到时，其被称为经验信息熵（Empirical Entropy） 取值范围信息熵越大代表随机变量的不确定性越大，当变量可取值的个数一定时，其取每种值的概率分布越平均，熵值就越大 当取值种类为 $n$ 时，信息熵的取值范围为： 0\\leq H(X) \\leq \\log n当 $X$ 只有一个分类时，信息熵取最小值 $H(X)=0$；而当 $X$ 中 $n$ 个分类出现的概率相同，即 $p(x)=\\frac{1}{n}$ 时，信息熵取最大值 $H(X)=\\log n$ 性质香农给出了信息熵的三个性质： 单调性：发生概率越高的事件，其携带的信息量越低 非负性：信息熵可看作一种广度量，必有 $H(X)\\geq 0$ 累加性：多随机事件同时发生存在的总不确定性的量度，可以表示为各事件不确定性量度的和 其中，对累加性的解释如下： 考虑到信息熵的定义涉及到了事件发生的概率，假设信息熵是事件发生概率的函数 对于两个相互独立的事件 $X = A$ ，$Y = B$ 来说，其同时发生的概率为： P(X=A,Y=B)=P(X=A)\\cdot P(X=B)其同时发生的信息熵为： \\begin{align*} H(P(X=A,Y=B)) &= H(P(X=A)\\cdot P(X=B))\\\\ &= H(P(X=A))+H(P(X=B)) \\end{align*} 香农从数学上严格证明了满足上述条件的随机变量不确定性度量函数，具以下的唯一形式： H(X)=-C\\sum_{x}p(x)\\log p(x)其中，$C$ 为常数，当取 $C=1$ 时，即得到信息熵的公式 从信息熵的定义可以看出，信息熵是关于随机变量 $X$ 概率分布的函数，与 $X$ 的取值无关，因此，可将随机变量 $X$ 的信息熵记作 $H(p)$，即： H(p)=-\\sum_{x\\in X}p(x)\\log p(x)二进制信息熵当随机变量 $X$ 只取 $0$、$1$ 两个值时，$X$ 的分布为伯努利分布： \\left \\{\\begin{array}{rl} P(X=1) &=& p \\\\ P(X=0) &=& 1-p \\end{array} \\right.此时，信息熵为二进制信息熵（Binary Information Entropy），也被称为伯努利分布下的信息熵： \\begin{align*} H_b(p) &= -p\\log_2 p-(1-p)\\log_2(1-p) \\\\ &= p\\log_2\\frac{1}{p}+(1-p)\\log_2\\frac{1}{1-p} \\end{align*}二进制信息熵 $H_b(p)$ 随概率 $p$ 变化的曲线下图所示 由图像可知： 当 $p=0$ 或 $p=1$ 时，$H_b(p)=0$，随机变量没有不确定性 当 $p=0.5$ 时，$H(p)=1$，随机变量不确定性最大 联合熵对于二维离散随机变量 $(X,Y)$，其联合概率分布为： P(X=x,Y=y)=p(x,y)关于分量 $X$ 的边缘分布律为： P(X=x)=p(x)关于分量 $Y$ 的边缘分布律为： P(Y=y)=p(y)对于二维离散随机变量 $(X,Y)$，其联合熵（Joint Entropy）定义为： H(X,Y)=-\\sum_{x\\in X}\\sum_{y\\in Y}p(x,y)\\log p(x,y)同样，当联合熵中的概率由数据估计得到时，其被称为经验联合熵（Empirical Joint Entropy） 此外，联合熵具有以下两条性质： $H(X,X)=H(X)$ $H(X,Y)=H(Y,X)$ 条件熵条件熵（Conditional Entropy） $H(Y|X)$ 表示在已知随机变量 $X$ 的条件下，随机变量 $Y$ 的不确定性，其被定义为在给定条件 $X$ 的情况下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望： \\begin{align*} H(Y|X) &= \\sum_{x\\in X}p(x)H(Y|X=x) \\\\ &= -\\sum_{x\\in X} p(x) \\sum_{y\\in Y} p(y|x)\\log p(y|x) \\\\ &= -\\sum_{x\\in X}\\sum_{y\\in Y} p(x,y)\\log p(y|x) \\\\ &= -\\sum_{x\\in X}\\sum_{y\\in Y} p(x,y)\\log \\frac{p(x,y)}{p(x)} \\end{align*}同样，当条件熵中的概率由数据估计得到时，其被称为经验条件熵（Empirical Conditional Entropy） 此外，条件熵具有以下两条性质： $H(X|Y)\\neq H(Y|X)$ $H(X|Y)+H(Y)=H(Y|X)+H(X)=H(X,Y)$ 信息熵的链式法则与概率的链式法则 $P(X,Y)=P(X|Y)P(Y)=P(Y|X)P(X)$ 相似，信息熵同样存在链式法则 由于信息熵是 $\\log p$ 的期望，那么需要变相乘为相加，即有： H(X,Y) = H(X|Y)+H(Y)= H(Y|X)+H(X)【互信息】互信息互信息（Mutual Information）用于衡量随机变量 $X$、$Y$ 间的相互依赖程度，即在得知了 $X$ 的信息后，$Y$ 的信息的不确定性减少的程度 根据信息熵的链式法则，有： H(X,Y)=H(Y|X)+H(X)=H(X|Y)+H(Y)因此，有： H(X)-H(X|Y)=H(Y)-H(Y|X)这个差即为 $X$ 与 $Y$ 的互信息，记作 $I(X,Y)$，按照信息熵与联合熵的定义展开，有： \\begin{align*} I(X,Y) &= H(X)-H(X|Y) \\\\ &= H(X)+H(Y)-H(X,Y) \\\\ &= \\sum_{x\\in X}p(x) \\log\\frac{1}{p(x)} + \\sum_{y\\in Y} p(y)\\log\\frac{1}{p(y)}-\\sum_{x\\in X}\\sum_{y\\in Y}p(x,y)\\log \\frac{1}{p(x,y)} \\\\ &= \\sum_{x\\in X}\\sum_{y\\in Y} p(x,y)\\log\\frac{p(x,y)}{p(x)p(y)} \\end{align*}如下列 Venn 图所示，清晰地表示了信息熵 $P(X)$、$P(Y)$，联合熵 $P(X,Y)$，条件熵 $P(X|Y)$、$P(Y|X)$，互信息 $I(X,Y)$ 的关系 条件互信息条件互信息（Conditional Mutual Information）用于表示给定第三个变量 $Z$ 的情况下，两个随机变量 $X$、$Y$ 间互信息的期望值 其被定义为： \\begin{align*} I(X,Y|Z) &= \\sum_{z\\in Z} p(z) \\sum_{y\\in Y} \\sum_{x\\in X} p(x,y|z) \\log \\frac{p(x,y|z)}{p(x,z)p(y,z)} \\\\ &= \\sum_{z\\in Z} \\sum_{y\\in Y} \\sum_{x\\in X} p(x,y,z) \\log \\frac{p(z)p(x,y,z)}{p(x,z)p(y,z)} \\end{align*}如下列 Venn 图所示，清晰地表示了信息熵 $P(X)$、$P(Y)$、$P(Z)$，条件熵 $P(X|Y,Z)$、$P(Y|X,Z)$、$P(Z|X,Y)$，互信息 $I(X,Y,Z)$，条件互信息 $I(X,Y|Z)$、$I(X,Z|Y)$、$I(Y,Z|X)$ 的关系","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"信息论","slug":"mathematics/information-theory","permalink":"https://alex-mcavoy.github.io/categories/mathematics/information-theory/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"信息论","slug":"information-theory","permalink":"https://alex-mcavoy.github.io/tags/information-theory/"}],"author":"Alex_McAvoy"},{"title":"KD 树","slug":"machine-learning/26.KD树","date":"2019-07-11T07:10:00.000Z","updated":"2023-03-31T12:33:45.426Z","comments":true,"path":"artificial-intelligence/machine-learning/9b1193a0.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/9b1193a0.html","excerpt":"【概述】在实现 K 近邻时，主要考虑的是如何对训练数据进行 K 近邻搜索，最简单的实现方式是线性扫描（Linear Scan），此时要计算输入样本与每一个训练样本的距离，这在维度大的特征空间以及大容量的训练数据集中非常耗时 为提高 K 近邻搜索的效率，可以使用特殊的数据结构来存储训练数据，通过以空间换时间来快速查询样本的近邻","text":"【概述】在实现 K 近邻时，主要考虑的是如何对训练数据进行 K 近邻搜索，最简单的实现方式是线性扫描（Linear Scan），此时要计算输入样本与每一个训练样本的距离，这在维度大的特征空间以及大容量的训练数据集中非常耗时 为提高 K 近邻搜索的效率，可以使用特殊的数据结构来存储训练数据，通过以空间换时间来快速查询样本的近邻 KD 树（K-Dimensional Tree）利用树结构在 $k$ 维空间上为数据集建立索引，其建立思想如同分治法，即利用已有数据对 $k$ 维空间进行切分 具体来说，KD 树表示了对 $k$ 维空间的一个划分（Partition），构造 KD 树相当于不断利用垂直于坐标轴的超平面将 $k$ 维空间切分，从而构成一系列的 $k$ 维超矩形区域，这样一来，树上的每一个点都对应于一个 $k$ 维超矩形区域 同时，由于 KD 树是二叉树结构，其时间复杂度上是 $O(\\log n)$，相较于线性扫描的 $O(n)$ 的复杂度，有了极大的提高 此外，若在使用 sklearn 的 KNeighborsClassifier() 方法时，想利用 KD 树作为数据结构，在该方法参数中加入 algorithm=&#39;kd_tree&#39; 即可 1model = KNeighborsClassifier(n_neighbors=k, p=2, metric='minkowski', algorithm='kd_tree') 【KD 树的构造】基本思想构造 KD 树的基本思想是如下：先构造根结点，使根结点对应于 $k$ 维空间中包含所有样本的超矩形区域，之后对 $k$ 维空间进行递归切分，以生成子结点，每个子结点对应一个切分后的子超矩形区域，直到子区域内没有样本时终止切分，在迭代过程中，样本将被保存到相应的结点上 递归切分的方法是在超矩形区域上选择一个坐标轴，并在坐标轴上选择一个切分点，通过切分点来确定一个超平面，这个超平面通过选定的切分点，同时垂直于选定的坐标轴，此时，当前超矩形区域被切分为左右两个子超矩形区域 通常，依次选择坐标轴对空间进行切分，选择训练样本点在选定的坐标轴上的中位数作为切分点，此时得到的 KD 树，是一个平衡二叉树 算法流程对于给定的数据集 $T=\\{\\mathbf{x_1},\\mathbf{x_2},…,\\mathbf{x_n}\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$ 构造 KD 树的算法流程如下： Step 1：构造根结点，其对应于包含 $T$ 的样本输入 $\\mathbf{x_i}$ 的 $m$ 维空间的超矩形区域，并进行切分，切分由通过切分点且与坐标轴 $x^{(1)}$ 垂直的超平面实现 1）选择 $x^{(1)}$ 作为切分的坐标轴，以 $T$ 中所有实例的 $x^{(1)}$ 坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域 2）对于由根结点生成的深度为 $1$ 的左、右子结点：左子结点对应坐标 $x^{(1)}$ 小于切分点的子区域，右子结点对应坐标 $x^{(1)}$ 大于切分点的子区域 3）将落在切分超平面上的实例点，保存在根结点 Step 2：对于深度为 $j$ 的结点，进行迭代切分，切分由通过切分点且与坐标轴 $x^{(l)}$ 垂直的超平面实现 1）选择 $x^{(l)}$ 作为切分的坐标轴，$l=j\\:(mod\\:\\:k)+1$，以该结点的区域中的所有实例 $x^{(l)}$ 坐标的中位数为切分点，将该结点对应的超矩形区域切分为两个子区域 2）对于由该结点生成的深度为 $j+1$ 的左、右子结点：左子结点对应坐标 $x^{(l)}$ 小于切分点的子区域，右子结点对应坐标 $x^{(l)}$ 大于切分点的子区域 3）将落在切分超平面上的实例点，保存在该结点 Step 3：重复 Step 2，直到两个子区域没有实例存在时停止，此时即形成 KD 树的区域划分 实例给定一个输入 $\\mathbf{x}$ 为二维的数据集 $T=\\{(2,3),(5,4),(9,6),(4,7),(8,1),(7,2)\\}$ 首先构造根结点，选择 $x^{(1)}$ 轴，$6$ 个数据点的 $x^{(1)}$ 坐标的中位数为：$7$，此时以平面 $x^{(1)}=7$ 将空间划分为左、右两个子矩形 接着，左矩形以 $x^{(2)}=4$ 划分为两个子矩形，右矩形以 $x^{(2)}=6$ 划分为两个子矩形 之后，对划分出的 $4$ 个子矩形递归的进行划分，对于左上矩形，以 $x^{(1)}=4$ 划分为两个子矩形；对于左下矩形，以 $x^{(1)}=2$ 划分为两个子矩形；对于右下矩形，以 $x^{(1)}=8$ 划分为两个子矩形 此时，特征空间划分完毕，根据特征空间划分可生成如下图所示的 KD 树 【KD 树的搜索】基本思想对于指定目标点，在 KD 树上寻找该目标点的最近邻时，其基本思想是：找到包含目标点的叶结点，然后从该叶结点出发，依次退回到父结点，在退回的过程中，不断查找与目标点最近邻的结点，当确定不可能存在更近的结点时终止 在上述过程中，包含目标点的叶结点对应包含目标点的最小超矩形区域，故而以该叶结点的样本点作为当前最近点，同时，目标点的最近邻一定是以目标点为中心，并且通过当前最近点的超球体内部 在返回当前结点的父结点时，若父结点的另一子结点的超矩形区域与超球体相交，那么就在相交的区域内寻找与目标点更近的样本点，若存在更近的样本点，就将该结点作为新的当前最近点，之后转到更上一级的父结点，重复上述过程 在返回当前结点的父结点时，若父结点的另一子结点的超矩形区域与超球体不相交，或不存在比当前点更近的点，则停止搜索 这样搜索就被限制在空间的局部区域上，效率得到极大的提高 算法流程对于给定的数据集 $T=\\{\\mathbf{x_1},\\mathbf{x_2},…,\\mathbf{x_n}\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，在构造完 KD 树后，求目标点 $\\mathbf{x}$ 的最近邻的算法流程如下： Step 1：从 KD 树的根结点出发，按如下步骤递归地寻找包含目标点 $\\mathbf{x}$ 的叶结点 1）若目标点 $\\mathbf{x}$ 当前维的坐标小于切分点的坐标，移动到左子结点 2）若目标点 $\\mathbf{x}$ 当前维的坐标大于切分点的坐标，移动到右子结点 3）直到子结点为叶结点停止 Step 2：以 Step 1 中寻找到的叶结点为当前最近点 Step 3：按如下步骤递归地从叶结点向上回溯，对每个结点进行以下操作： 1）若该结点保存的样本点比当前最近点距离目标点更近，将该样本点作为当前最近点 2）当前最近点一定存在于该结点的某个子结点所对应的区域，检查该子结点的兄弟结点对应的区域是否有更近的点 a）该区域是否与以目标点为球心、以目标点与当前最近点的距离为半径的超球体相交 b）若相交，可能在该兄弟结点对应的区域内存在距目标点更近的点，移动到该兄弟结点中，接着向上递归 Step 4：当回溯到根结点时，搜索结束，最后的当前最近点，即为 $\\mathbf{x}$ 的最近邻点 实例以下例所示的 KD 树为例，假设求输入的目标点 $(2,4.5)$ 的最近邻 对于输入的目标点 $(2,4.5)$ 其落于叶结点 $(4,7)$ 上，将 $(4,7)$ 作为最近邻点，计算到该样本点的欧式距离，并将其作为最近距离，即： d_{min}=\\sqrt{(2-4)^2+(4.5-7)^2} \\approx 3.2在从叶结点向上回溯时，路径为：$(4,7)\\rightarrow(5,4)\\rightarrow(7,2)$ 输入样本点 $(2,4.5)$ 与 $(4,7)$ 的父结点 $(5,4)$ 的欧式距离为： d=\\sqrt{(2-5)^2+(4.5-4)^2} \\approx 3.04该距离小于 $d_{min}=3.2$，这就意味着叶结点 $(4,7)$ 作为最近邻点不成立，此时更新最近距离为 $d_{min}=3.04$，同时以 $(5,4)$ 作为最近邻点 之后，以输入样本点 $(2,4.5)$ 为圆心，以 $d_{min}=3.04$ 为半径做圆 圆跟 $(5,4)$ 所切分的两个子区域相交，因此需要检查 $(5,4)$ 的另外一个子树的叶结点 $(2,3)$ 输入样本点 $(2,4.5)$ 与叶结点 $(2,3)$ 的欧式距离为： d=\\sqrt{(2-2)^2+(4.5-3)^2} \\approx 1.5该距离小于 $d_{min}=3.04$，更新最近距离 $d_{min}=1.5$，并令 $(2,3)$ 为最近邻点 之后，回溯到根结点 $(7，2)$，由上图可以确认 $(7,2)$ 与切分的右子区域无关，回溯结束，$(2,3)$ 为最近邻点","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"K 近邻","slug":"machine-learning/25.K近邻","date":"2019-07-11T01:45:00.000Z","updated":"2023-03-31T12:43:15.092Z","comments":true,"path":"artificial-intelligence/machine-learning/4021c347.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/4021c347.html","excerpt":"【概述】K 近邻（K-Nearest Neighbor，kNN）是常用的监督学习方法之一，既可处理分类问题，也可处理回归问题 一般来说，当利用 KNN 处理分类任务时，通常使用投票法，即选择这 $k$ 个邻居中出现最多的类别标记作为预测结果；当利用 KNN 处理回归任务时，通常使用平均法，即将这 $k$ 个邻居的输出标记的平均值作为预测结果","text":"【概述】K 近邻（K-Nearest Neighbor，kNN）是常用的监督学习方法之一，既可处理分类问题，也可处理回归问题 一般来说，当利用 KNN 处理分类任务时，通常使用投票法，即选择这 $k$ 个邻居中出现最多的类别标记作为预测结果；当利用 KNN 处理回归任务时，通常使用平均法，即将这 $k$ 个邻居的输出标记的平均值作为预测结果 同时，KNN 是懒惰学习（Lazy Learning）的著名代表，在训练阶段仅仅将样本保存，训练开销时间为 0，待接收到测试样本后再进行处理；相应地，在训练阶段就对样本进行处理的学习方法，称为急切学习（Eager Learning） KNN 需要计算待测样本和训练集中所有样本的距离，时间复杂度为 $O(n)$，一般适用于样本数较少的数据集，当数据集很大时，不仅耗时，而且需要大量的存储空间，因此当数据量大时，一般将数据以树的形式呈现，以提高速度，常用的方法有：KD-Tree 与 Ball-Tree 其中，KD 树对于低维度（$D&lt;20$）的近邻搜索非常快，但当维数 $D$ 增长到很大时，效率会变低，这是维度灾难的一种体现，为解决 KD 树在高维上效率低下的问题，Ball 树应运而生 【算法流程】虽然 KNN 既可处理分类问题，也可处理回归问题，但一般将其用于处理分类问题 就分类效果来说，KNN 对于随机分布的数据集分类效果较差，对于类内间距小，类间间距大的数据集分类效果好，且对于边界不规则的数据效果好于线性分类器 此外，KNN 对于样本不均衡的数据效果不好，需要进行改进，一般改进的方法是对 $k$ 个近邻数据赋予权重，例如：距离测试样本越近，权重越大 KNN 工作机制十分简单：对于给定的测试样本，基于某种度量找出训练集中与该样本最靠近的 $k$ 个样本，然后基于这 $k$ 个邻居的信息进行预测，其算法流程如下： 对于给定的训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}= \\{c_1,c_2,…,c_K\\}$ 为实例的类别 当给定一个实例特征向量 $\\mathbf{x}$ 时，根据给定的距离度量，KNN 会在训练集 $T$ 中找出与 $\\mathbf{x}$ 最近邻的 $k$ 个点，涵盖这 $k$ 个点的 $\\mathbf{x}$ 的邻域记作 $N_k(\\mathbf{x})$ 在 $N_k(\\mathbf{x})$ 中根据分类决策规则（如投票法）决定 $\\mathbf{x}$ 的类别 $y$： y=\\arg \\max_{c_j} \\sum_{\\mathbf{x_i}\\in N_k(\\mathbf{x})}I(y_i=c_j),i=1,2,...,n,j=1,2,...,K【距离度量】在特征空间中，两个实例点的距离是这两个实例点的相似程度的反映 KNN 的特征空间一般是 $m$ 维实数向量空间 $\\mathbb{R}^{m}$，常选用闵氏距离作为相似度度量标准 设特征空间 $\\mathcal{X}$ 是 $m$ 维实数向量空间 $\\mathbb{R}^m$，$\\mathbf{x_i},\\mathbf{x_j}\\in \\mathcal{X}$，且 $\\mathbf{x_i}$ 和 $\\mathbf{x_j}$ 满足 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})^T$，$\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(m)})^T$ 则 $\\mathbb{x_i}$ 与 $\\mathbb{x_j}$ 的闵氏距离定义为： L_p(\\mathbb{x_i},\\mathbb{x_j})=\\bigl( \\sum_{l=1}^n |x_i^{(l)}-x_j^{(l)}|^p \\bigr)^{\\frac{1}{p}}关于闵氏距离的详细介绍：机器学习中的距离度量 【近邻数 k】近邻数 k，即在预测目标点时取 $k$ 个临近的点来预测，对于不同的样本，近邻数 $k$ 有着不同的取值，如何确定 $k$ 值获得最佳的结果是十分困难的 当 $k$ 的取值过小时，一旦有噪声的成分存在，将会对预测产生比较大影响，容易发生过拟合 当 $k$ 的取值过大时，就相当于用较大邻域中的训练实例进行预测，学习的近似误差会增大，这时与输入目标点较远实例也会对预测起作用，使预测发生错误 此外，对于 $k=1$ 的情况，称为最近邻算法，该算法将训练集中与输入实例 $x$ 最近邻点的类视为 $x$ 的类；而当 $k=n$，即取全部的实例时，无论输入的实例是什么，都将简单地预测其属于训练集中最多的类，此时模型过于简单，完全忽略了训练集中的信息，预测没有意义 同时，$k$ 的取值尽量要取奇数，以保证在计算结果最后会产生一个较多的类别，因为取偶数可能会产生相等的情况，不利于预测 在应用中，最常用的方法是从 $k=1$ 开始，使用检验集来估计分类器的误差率，然后不断重复该过程，每次令 $k$ 增加一个近邻，最后选取具有最小误差率的 $k$，一般来说，$k$ 的取值上限是 $\\sqrt n$ 【分类决策规则】在 KNN 中，分类决策规则往往是多数表决（Majority Voting Rule），又称投票法，其是由输入实例的 $k$ 个邻近的训练样本中的多数类决定输入实例的类 对于给定的训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，输入实例为 $\\mathbf{x}$，则 $\\mathbf{x}$ 的预测类别 $y$ 为： y=\\arg \\max_{c_j} \\sum_{\\mathbf{x_i}\\in N_k(\\mathbf{x})}I(y_i=c_j),i=1,2,...,n,j=1,2,...,K若分类的损失函数为 0-1 损失函数，分类函数为： f:\\mathbb{R}^K \\rightarrow \\{c_1,c_2,...,c_K\\}设正确分类的概率为： P(Y=f(X))则误分类的概率为： P(Y\\neq f(X))=1-P(Y=f(X))进一步，对于给定的输入实例 $\\mathbf{x}\\in\\mathcal{X}$，其最近邻的 $k$ 个训练样本点构成集合 $N_k(x)$，若涵盖 $N_k(\\mathbf{x})$ 的区域类别为 $c_j$，则正确分类率为： \\frac{1}{k}\\sum_{\\mathbf{x_i}\\in N_k(\\mathbf{x})}I(y_i= c_j)故误分类率为： \\frac{1}{k}\\sum_{\\mathbf{x_i}\\in N_k(\\mathbf{x})}I(y_i\\neq c_j)=1-\\frac{1}{k}\\sum_{\\mathbf{x_i}\\in N_k(\\mathbf{x})}I(y_i= c_j)要使误分类率即经验风险最小，就要使 $\\sum\\limits_{\\mathbf{x_i}\\in N_k(\\mathbf{x})}I(y_i= c_j)$ 最大 因此，可以认为，多数表决规则等价于经验风险最小化 【实例】假设在二维平面上，有四个点：$a_1(1,1)$、$a_2(1,2)$、$b_1(3,3)$、$b_2(3,4)$，其中，$a_1,a_2$ 属于 $A$ 类，$b1,b2$ 属于 $B$ 类 给出一个目标点 $c(2,1)$，现在想要知道对于 $c(2,1)$ 这个点来说，其属于 $A$ 类还是 $B$ 类 首先计算目标点 $c$ 到其他 $4$ 个点的距离，为方便计算，使用曼哈顿距离： $M(a_1,c) = |1-2|+|1-1| = 1$ $M(a_2,c) = |1-2|+|2-1| = 2$ $M(b_1,c) = |3-2|+|3-1| = 3$ $M(b_2,c) = |3-2|+|4-1| = 4$ 然后将计算出的距离集合按距离升序排序： 序号 点 类别 坐标 距离 $1$ $a_1$ $A$ $(1,1)$ $1$ $2$ $a_2$ $A$ $(1,2)$ $2$ $3$ $b_1$ $B$ $(3,3)$ $3$ $4$ $b_2$ $B$ $(3,4)$ $4$ 接着取距离列表排序后的前 $k$ 个数据，这里令 $k=3$ 序号 点 类别 坐标 距离 $1$ $a_1$ $A$ $(1,1)$ $1$ $2$ $a_2$ $A$ $(1,2)$ $2$ $3$ $b_1$ $B$ $(3,3)$ $3$ 最后，统计这 $k$ 个数据里，出现频次最多的类别。 在该样例中，根据上表可以看出，$A$ 出现了两次，$B$ 出现了一次，因此我们认为点 $c$ 属于 $A$ 类 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现 K 近邻 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train, X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(features, labels, k): # 建立 KNN 模型，采取 p=2 的闵氏距离，即标准欧式距离 model = KNeighborsClassifier(n_neighbors=k, p=2, metric='minkowski') # 训练 model.fit(features, labels) return model# 尝试不同的k值以达到最好的准确率def get_k(X_train, y_train, X_test, y_test): accuracy_list = [] for k in range(1, 10): model = train_model(X_train, y_train, k) accuracy = model.score(X_test, y_test) accuracy_list.append(accuracy) # 绘制k-accuracy折线图 plt.figure() plt.tick_params(direction='in') plt.grid(color='grey', linestyle=':', linewidth=1) plt.plot(range(1, 10), accuracy_list, color='green', marker='o') plt.xlabel('Value of K') plt.ylabel('Accuracy') plt.title('Testing the accuracy for different values of K') plt.show() # 寻找最大accuracy对应的k值 k = accuracy_list.index(max(accuracy_list)) + 1 return k# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 获取最大accuracy下的k值 k = get_k(X_train_std, y_train, X_test_std, y_test) print(\"k =\", k) # 模型训练 model = train_model(X_train_std, y_train, k) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"类别不平衡问题","slug":"machine-learning/24.类别不平衡问题","date":"2019-07-10T09:30:00.000Z","updated":"2023-03-31T12:28:11.479Z","comments":true,"path":"artificial-intelligence/machine-learning/bebe8788.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/bebe8788.html","excerpt":"【类别不平衡问题】对于分类学习方法，都有一个共同的假设，即：不同类别的训练样例数目相同 如果不同类别的训练样例数目稍有差别，通常对分类影响不大，但是若差别很大，则会对学习造成影响，测试结果非常差","text":"【类别不平衡问题】对于分类学习方法，都有一个共同的假设，即：不同类别的训练样例数目相同 如果不同类别的训练样例数目稍有差别，通常对分类影响不大，但是若差别很大，则会对学习造成影响，测试结果非常差 对于二分类问题，假设有 $998$ 个反例，$2$ 个正例，那么学习方法只需返回一个永远将新样本预测为反例的分类器，就能达到 $99.8\\%$ 的精度，显然，这样的分类器没有价值 对于多分类问题，在将其拆解为多个二分类任务时，当使用 OvR 或 MvM 策略后，产生的二分类任务就有可能出现类别不平衡（Class-imbalance），即分类任务中不同类别的训练样例数目差别很大 例如，在银行信用欺诈交易识别中，属于欺诈交易的应该是很少部分，绝大部分交易是正常的，这就是一个正常的类别不平衡问题 一般而言，如果类别不平衡比例超过 $4:1$，那么分类器会因为数据不平衡性而无法满足分类要求，因此在构建分类模型之前，需要对分类不平衡性问题进行处理 【再缩放策略】基本思想从线性分类器的角度进行讨论，当使用 $\\hat{y}=f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 对新样本进行拟合时，事实上是在用预测出的 $\\hat{y}$ 与一个阈值比较，一般来说，通常将阈值设为 $0.5$，即在 $\\hat{y}&gt;0.5$ 时判为正类，在 $\\hat{y}\\leq 0.5$ 时判为负类 $\\hat{y}$ 实际上反映了 $\\mathbf{x}$ 为正类的可能性，$1-\\hat{y}$ 反应了 $\\mathbf{x}$ 为负类的可能性，两者的比值 $\\frac{\\hat{y}}{1-\\hat{y}}$ 称为几率（Odds），其反应了 $\\mathbf{x}$ 为正类的相对可能性 当阈值设为 $0.5$ 时，恰好表明分类器认为 $\\mathbf{x}$ 为正类、负类的可能性相同，即分类器的决策规则为： 若\\:\\: \\frac{\\hat{y}}{1-\\hat{y}}>1,\\:\\: 则预测为正类当训练集中正类、反类数目不同时，用 $n^+$ 表示正类数目，$n^-$ 表示负类数目，则观测几率为 $\\frac{n^+}{n^-}$，假设训练集是真实样本总体的无偏估计，这时，观测几率就代表真实几率 因此，只要分类器的预测几率高于观测几率，就判为正类，即： 若 \\:\\: \\frac{\\hat{y}}{1-\\hat{y}}>\\frac{n^+}{n^-},\\:\\: 则预测为正类但分类器是基于 $\\frac{\\hat{y}}{1-\\hat{y}}&gt;1$ 进行决策的，因此需要对预测值进行调整，使其基于 $\\frac{\\hat{y}}{1-\\hat{y}}&gt;\\frac{n^+}{n^-}$ 执行 $\\frac{\\hat{y}}{1-\\hat{y}}&gt;1$，即再缩放（Rescaling）策略： \\frac{\\hat{y}'}{1-\\hat{y}'}=\\frac{\\hat{y}}{1-\\hat{y}}\\times \\frac{n^-}{n^+}简单来说，就是通过调整数据集中正类和负类的数目，从而对预测值进行缩放调整 再缩放策略虽然简单，但实际操作却没这么容易，因为在实际应用中，假设训练集是真实样本总体的无偏估计这个假设往往不成立，即不能有效地基于训练集观测几率来推断真实几率 策略的实现在实际应用中，有以下五种公认的方法去对数据集进行调整： 随机减少大类的样本数量 随机减少特定大类的样本数量 随机增大小类的样本数量 随机增大特定小类的样本数量 修改阈值，使阈值更符合实际情况 其中，通过实现第 1、2 种方法来使用再缩放策略的方法被称为欠采样，通过实现第 3、4 种方法来使用再缩放策略的方法被称为过采样，通过实现第 5 种方法来使用再缩放策略的方法被称为阈值移动 【欠采样】欠采样（Under-sampling）是指对大类的数据样本进行采样，从而减少该类数据样本的个数，使其与其他类的数目接近，然后再进行学习 目前，最常用的欠采样算法是 AdaBoost 迭代算法，其是为解决基于随机丢弃大类样本可能会丢失一些重要信息的问题 AdaBoost 迭代算法 是基于集成学习（Ensemble Learning）中简单集成（Easy Ensemble）的思想，其将大类随机分为若干个集合，每个集合分别与小类合并，得到多个新的训练子集，再利用每个训练子集分别训练 AdaBoost 弱分类器，最后集成所有的 AdaBoost 弱分类器，最终得到经过提升的的 AdaBoost 强分类器 这样对每个弱分类器来看，都进行了欠采样，在全局来看，没有丢失重要信息 【过采样】过采样（Over-sampling）是指增加小类数据样本的个数，使其与其他类的数目接近，然后再进行学习，其代表算法是 SMOTE 算法 要注意的是，过采样不能简单地对小类进行重复采样，这会导致出现过拟合 SMOTE 算法通过数据插值的思想来产生额外的小类样本数据，其基本思想是：对每个小类样本 $a_i$，从其最近的 $k$ 个邻居中随机选择一个样本 $b_i$，然后在 $a_i$ 与 $b_i$ 的连线上随机选择一点，作为新合成的小类样本 $c_i$ SMOTE 算法有效地防止了过拟合问题，但可能扩大噪声的影响范围，并加剧分类边界模糊化 【阈值移动】在分类问题中，阈值一般设为 $0.5$，当有可能出现类别不平衡问题时，可以根据实际情况对阈值进行移动，调整阈值，进而增加某一类的权重，以达到解决类别不平衡问题的目的，这就是阈值移动（Threshold Moving） 也就是说，阈值移动是直接基于原始训练集进行学习，在完成训练要进行预测时，将再缩放策略，即： \\frac{\\hat{y}'}{1-\\hat{y}'}=\\frac{\\hat{y}}{1-\\hat{y}}\\times \\frac{n^-}{n^+}嵌入到决策过程中，通过改变阈值来达到解决类别不平衡问题的目的","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"多分类问题的拆解策略","slug":"machine-learning/23.多分类问题的拆解策略","date":"2019-07-10T05:53:00.000Z","updated":"2023-03-31T12:33:48.647Z","comments":true,"path":"artificial-intelligence/machine-learning/325cb37d.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/325cb37d.html","excerpt":"【概述】当分类数据超过两类时，即为多分类问题 对于多分类问题，可以将其进行拆解，转换为若干个独立的二元分类问题，进而借助分类学习方法来解决多分类问题","text":"【概述】当分类数据超过两类时，即为多分类问题 对于多分类问题，可以将其进行拆解，转换为若干个独立的二元分类问题，进而借助分类学习方法来解决多分类问题 具体来说，先对问题进行进行拆分，然后为拆出的每个二分类任务训练一个分类器，在测试时，对这些分类器的预测结果进行集成，以获得最终的多分类结果 最常用的拆解策略有三种： 一对一（One vs One，OvO） 一对其余（One vs Rest，OvR） 多对多（Many vs Many，MvM） 【OvO】对于给定的训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}= \\{c_1,c_2,…,c_K\\}$ 为实例的类别 OvO 策略会将这 $K$ 个类别两两配对，产生 $C(K,2)=\\frac{K(K-1)}{2}$ 个二分类任务 之后，对划分好的 $C(K,2)$ 个任务分别使用分类器进行训练 在预测阶段，只需要将测试样本分别给在训练阶段训练好的 $C(K,2)$ 个分类器进行预测，再将这些预测结果进行投票统计，票数最多的即为最终的预测结果 例如，下图中的训练集可分为 $A$、$B$、$C$ 三个类别 采用 OvO 策略后，$3$ 个类别两两配对，产生 $C(3,2)=\\frac{3\\cdot 2}{2}=3$ 个二分类任务，相应地，利用这三种划分就能得到 $3$ 个分类器 在预测阶段，只需要将测试样本分别给在训练阶段训练好的 $3$ 个分类器进行预测，最后利用投票法，票数最多的即为预测结果 【OvR】对于给定的训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}= \\{c_1,c_2,…,c_K\\}$ 为实例的类别 OvR 策略每次将一个类的样例作为正类，其他的所有类的样例作为反类，如此划分为 $K$ 个类别，产生 $K$ 个二分类任务，之后，对这 $K$ 个类别分别进行训练，训练出 $K$ 个分类器 在测试时，若仅有一个分类器预测为正类，则对应的类别标记为最终的分类结果；若有多个分类器预测为正类，则考虑各分类器的预测置信度，选择置信度最大的类别标记为最终的分类结果 OvR 策略只需要训练 $K$ 个分类器，而 OvO 策略需要训练 $C(K,2)$ 个分类器，显然 OvO 策略的存储开销和时间开销要比 OvR 更大 但在实际使用时，OvO 策略并不需要像 OvR 策略一样使用全部样本进行训练，在类别很多时，使用 OvO 策略的时间开销反而要比 OvR 策略要小 例如，下图中的训练集可分为 $A$、$B$、$C$ 三个类别 采用 OvR 策略后，$3$ 个类别分别作为正类，相应地剩余的两类别作为反类，产生 $3$ 个二分类任务 相应地，利用这三种划分就能得到 $3$ 个分类器 在预测阶段，只需要将测试样本分别给在训练阶段训练好的 $3$ 个分类器进行预测，最后对这些结果选择概率最高的类别作为最终结果 【MvM】概述对于给定的训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i} =(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in\\mathcal{Y}= \\{c_1,c_2,…,c_K\\}$ 为实例的类别 MvM 策略每次将若干类的样例作为正类，其他的所有类的样例作为反类，显然 OvO 策略与 OvR 策略是 MvM 策略的特例 MvM 策略的正、反类构造必须要有特殊的设计，不能随意选取，最常用的构造技术为：纠错输出码（Error Correcting Output Codes，ECOC） ECOCECOC 是将编码思想引入到类别拆分中，并尽可能的在解码过程中具有容错性，其工作过程主要分两步： 编码：对 $K$ 个类别进行 $N$ 次划分，每次划分将一部分类别划分为正类，另一部分划分为反类，从而形成一个二分类训练集，这样一共产生 $N$ 个训练集，进而可训练出 $N$ 个分类器 解码：使用 $N$ 个分类器分别对测试样本进行预测，这些预测标记组成一个编码，将这个预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为预测结果 类别划分通过编码矩阵（Coding Matrix）指定，其有多种形式，最常见的是利用海明码来编码的二元码和三元码 如下图，二元码将类别分为正类（-1）和负类（+1），后者在二元码的基础上又加了停用类（0），即分类器 $f_i$ 不使用该类样本 在解码阶段，各分类器的预测结果联合起来形成了测试实例的编码，该编码与各类所对应的编码进行比较，将距离最小的编码所对应的类作为预测结果，例如，在上图中的二元码中，基于欧氏距离，预测结果将为 $C_3$ 在测试阶段，由于采取的是海明码，其对分类器的错误有一定的容忍和修正能力，在上图中，二元码中测试示例的正确编码是 $(-1,+1,+1,-1,+1)$，假设在预测时，分类器 $f_2$ 出错了，导致了出现错误编码 $(-1,-1,+1,-1,+1)$，但基于海明码与编码纠错理论，仍能产生正确的分类结果 $C_3$，这也是 ECOC 被称为纠错输出码的原因 一般来说，ECOC 编码越长，纠错能力越长，但编码越长意味着要训练分类器越多，计算、存储开销都会增大，同时，对于有限类别，可能的组合数目是有限的，码长在超过一定范围后，就失去了意义","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"对数线性回归与广义线性模型","slug":"machine-learning/22.对数线性回归与广义线性模型","date":"2019-07-06T11:32:00.000Z","updated":"2023-03-31T12:33:49.965Z","comments":true,"path":"artificial-intelligence/machine-learning/5206f73f.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/5206f73f.html","excerpt":"【对数线性回归】对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出为 $y_i$，多元线性回归学习到的模型为 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$，使得 $f(x_i;\\boldsymbol{\\theta})\\simeq y_i$ 假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 形式如下：","text":"【对数线性回归】对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出为 $y_i$，多元线性回归学习到的模型为 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$，使得 $f(x_i;\\boldsymbol{\\theta})\\simeq y_i$ 假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 形式如下： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}其中，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，即： \\boldsymbol{\\theta}=[\\theta^{(0)},\\theta^{(1)},...,\\theta^{(m)}]^T\\in \\mathbb{R}^{m+1}为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} x_i^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}将数据集 $D$ 写为 $(m+1)\\times n$ 的矩阵，即： X=\\begin{bmatrix} x_{1}^{(0)} & x_{2}^{(0)} & ... & x_{n}^{(0)} \\\\ x_{1}^{(1)} & x_{2}^{(1)} & ... & x_{n}^{(1)} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ x_{1}^{(m)} & x_{2}^{(m)} & ... & x_{n}^{(m)} \\end{bmatrix}同时，将预测值 $\\hat{y_i}$ 也写为矩阵形式，即预测输出变量 $\\hat{Y}$ 为 $n\\times 1$ 的列向量： \\hat{Y}=[\\hat{y_1},\\hat{y_2},...,\\hat{y_n}]^T \\in \\mathbb{R}^{n}那么，多元线性回归模型就可写为： \\hat{Y}=\\boldsymbol{\\theta}^TX当给定输入值后，如果希望预测值能够逼近真实值 $y_i$ 的衍生物，即输出是在指数尺度上变化时，就可将输出的对数作为线性模型逼近的目标，即： \\ln \\hat{Y}=\\boldsymbol{\\theta}^TX这就是对数线性回归（Log-linear Regression），实际上是试图让 $e^{\\boldsymbol{\\theta}^TX}$ 逼近真实输出 $\\hat{Y}$ 对数线性回归形式上虽然仍是线性回归，但其实质上是在求取输入空间到输出空间的非线性函数的映射 【广义线性模型】更一般地，考虑单调可微函数 $g(\\cdot)$，令： \\hat{Y}=g^{-1}(\\boldsymbol{\\theta}^TX)这样的模型称为广义线性模型（Generalized Linear Model，GLM），其中 $g(\\cdot)$ 称为联系函数（Link Function） 显然，线性回归、对数线性回归、Logistic 回归是 GLM 的联系函数 $g(\\cdot)$ 不同时的特例，可以总结为下表： 联系函数 输出变量类型 使用场景 线性回归 $g(z)=z$ 连续变量 身高、体重、房价等 对数线性回归 $g(z)=ln(z)$ 计数变量 销售数量、车祸数量等 二元 Logistic 回归 $g(z)=ln\\frac{P(z=1)}{1-P(z=1)}$ 二分类变量 购买行为、投票行为等 多元 Logistic 回归 $g(z)=ln\\frac{P(z=i)}{1-P(z=N)}$ 多分类变量 评分等级、多分类模型等","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"多元 Logistic 回归","slug":"machine-learning/21.多元Logistic回归","date":"2019-07-06T11:07:00.000Z","updated":"2023-03-31T12:43:11.170Z","comments":true,"path":"artificial-intelligence/machine-learning/c957033e.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/c957033e.html","excerpt":"Reference Multinomial logistic regression [机器学习算法系列（九）-多分类对数几率回归算法（Multinomial Logistic Regression） 机器学习小憩（二）：多分类Logistic回归的目标函数 逻辑回归算法原理及用于解决多分类问题 【概述】对数几率回归（Logistic regression）即 Logistic 回归，虽然名为回归，但其实际上是一种解决分类问题的分类学习方法，在现实中应用十分广泛，比如垃圾邮件识别，手写数字识别，人脸识别，语音识别等","text":"Reference Multinomial logistic regression [机器学习算法系列（九）-多分类对数几率回归算法（Multinomial Logistic Regression） 机器学习小憩（二）：多分类Logistic回归的目标函数 逻辑回归算法原理及用于解决多分类问题 【概述】对数几率回归（Logistic regression）即 Logistic 回归，虽然名为回归，但其实际上是一种解决分类问题的分类学习方法，在现实中应用十分广泛，比如垃圾邮件识别，手写数字识别，人脸识别，语音识别等 对于分类问题来说，如果利用线性回归来拟合，假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 的输出值会出现 $f(\\mathbf{x_i};\\boldsymbol{\\theta})&gt;1$ 或 $f(\\mathbf{x_i};\\boldsymbol{\\theta})&lt;0$ 的情况，无法对结果进行归纳，因此，有了 Logistic 回归 其利用一个单调可微的激活函数，将分类任务的真实标记 $y_i$ 与线性回归模型的预测值 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 联系起来，从而将数值结果转换为分类结果，简单来说，其是利用线性回归模型的预测结果去逼近真实标记的对数几率 关于激活函数的详细介绍，详见：常见的激活函数 Logistic 回归根据分类数据的类别，分为以下三种情况： 二元 Logistic 回归：分类数据为两类（例如：有/没有） 多元无序 Logistic 回归：分类数据超过两类，且类别间没有对比意义（例如：一线城市、二线城市、三线城市） 多元有序 Logistic 回归：分类数据超过两类，且类别间有对比意义（例如：喜欢、不喜欢、无所谓） 需要注意的是，这里的元，指的不是自变量的个数，而是因变量的取值范围 本文仅介绍多元 Logistic 回归，关于二元 Logistic 回归，详见：二元 Logistic 回归 【假设形式】假设函数对于给定的容量为 $n$ 的样本集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出 $y_i\\in \\{1,2,…,K\\}$，多元 Logistic 回归学习到的第 $k$ 类的模型为 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$，使得 $f(\\mathbf{x_i};\\boldsymbol{\\theta})\\simeq k$ 第 $k$ 类的假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta_k})$ 为： f(\\mathbf{x_i};\\boldsymbol{\\theta_k})=g(\\theta_k^{(0)} + \\theta_k^{(1)} x_i^{(1)} + \\theta_k^{(2)} x_i^{(2)} + ... + \\theta_k^{(m)} x_i^{(m)}),\\quad k=1,2...,K其中，$\\boldsymbol{\\theta}_k$ 为 $(m+1)\\times 1$ 的列向量，其是预测结果为 $k\\in \\{1,2,…,K\\}$ 时与假设函数相关的特征参数，即： \\boldsymbol{\\theta_k}=[\\theta_k^{(0)},\\theta_k^{(1)},...,\\theta_k^{(m)}]^T\\in \\mathbb{R}^{m+1},\\quad k=1,2...,K$g(z)$ 为激活函数，就是假说表示，对于不同的问题，根据实际情况来选择不同的激活函数 为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta_k})=g(\\theta_k^{(0)} x_i^{(0)} + \\theta_k^{(1)} x_i^{(1)} + \\theta_k^{(2)} x_i^{(2)} + ... + \\theta_k^{(m)} x_i^{(m)}),\\quad k=1,2...,K在多元 Logistic 回归中，采取 softmax 函数作为激活函数，其能够将多分类的输出值转换为范围在 $(0,1)$ 间的和为 $1$ 的概率分布 假设有 $K$ 种输出值，对于给定的 $K$ 维向量 $\\mathbf{z}$，针对其中的第 $i$ 个元素 $z^{(i)}$，有： \\text{softmax}(z^{(i)}) = \\frac{e^{z^{(i)}}}{\\sum\\limits_{k=1}^K e^{z^{(k)}}}对于多元 Logistic 回归，其有 $K$ 种分类，可以将每种分类的条件概率写成 Softmax 的形式， 于是，对于第 $k$ 类的假设函数可写作： f(\\mathbf{x_i};\\boldsymbol{\\theta_k})=\\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{\\sum\\limits_{j=1}^{K}e^{\\boldsymbol{\\theta_j}^T\\mathbf{x_i}}},\\quad k=1,2,...,K则多元 Logistic 回归整体的假设函数为： h(\\mathbf{x_i};\\boldsymbol{\\theta})=\\frac{1}{\\sum\\limits_{k=1}^{K}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\begin{bmatrix} e^{\\boldsymbol{\\theta_1}^T\\mathbf{x_i}} \\\\ e^{\\boldsymbol{\\theta_2}^T\\mathbf{x_i}} \\\\ ... \\\\ e^{\\boldsymbol{\\theta_K}^T\\mathbf{x_i}} \\end{bmatrix}对数几率形式与二元 Logistic 回归的对数几率形式相似，将 $f(\\mathbf{x_i};\\boldsymbol{\\theta_k})$ 视为后验概率估计 $P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta})$，即在给定概率参数为 $\\boldsymbol{\\theta}$ 时，对具有 $\\mathbf{x_i}$ 特征的条件下 $y_i=K$ 时的概率，即： \\hat{y_i} = P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})那么对于剩余的 $K-1$ 类，多元 Logistic 回归的对数几率可写为： \\begin{gather} \\ln \\frac{P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta_1})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})}=\\boldsymbol{\\theta_1}^T\\mathbf{x_i} \\notag \\\\ \\ln \\frac{P(y_i=2|\\mathbf{x_i};\\boldsymbol{\\theta_2})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})}=\\boldsymbol{\\theta_2}^T\\mathbf{x_i} \\notag \\\\ ... \\notag \\\\ \\ln \\frac{P(y_i=K-1|\\mathbf{x_i};\\boldsymbol{\\theta_2})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_{K}})}=\\boldsymbol{\\theta_{K-1}}^T\\mathbf{x_i} \\notag \\\\ \\end{gather}即： \\ln \\frac{P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_{K}})}=\\boldsymbol{\\theta_{k}}^T\\mathbf{x_i},\\quad k=1,2,...K-1后验概率形式对于对数几率 $\\ln \\frac{P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_{K}})}=\\boldsymbol{\\theta_{k}}^T\\mathbf{x_i}, k=1,2,…K-1$ 中的 $P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k})$，有： \\begin{gather} && \\ln \\frac{P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})} = \\boldsymbol{\\theta_k}^T\\mathbf{x_i} \\notag \\\\ &\\Rightarrow& \\frac{P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k})}{P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})} = e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}} \\notag \\\\ &\\Rightarrow& P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k}) = P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}} \\notag \\\\ \\end{gather}那么，对于 $P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})$，有： \\begin{align} P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K}) &= 1-\\sum_{k=1}^{K-1} P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k}) \\notag \\\\ &= 1-\\sum_{k=1}^{K-1} P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}\\notag \\end{align}化简，有： \\begin{gather} && P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K}) = 1-\\sum_{k=1}^{K-1} P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}\\notag \\\\ &\\Rightarrow& P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K}) = 1- P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K}) \\sum_{k=1}^{K-1} e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}} \\notag \\\\ &\\Rightarrow& ( 1 + \\sum_{k=1}^{K-1} e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}})P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})=1 \\notag \\\\ &\\Rightarrow& P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K}) = \\frac{1}{1 + \\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\notag \\end{gather}进而，对于 P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k}) = P(y_i=K|\\mathbf{x_i};\\boldsymbol{\\theta_K})e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}有： P(y_i=k|\\mathbf{x_i};\\boldsymbol{\\theta_k}) = \\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{1 + \\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}即对于假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta_k})$，有： \\left\\{\\begin{array}{rl} P(y_i=K|\\mathbf{x_i}) &=& \\frac{1}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\\\ P(y_i=k | \\mathbf{x_i}) &=& \\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}},\\quad k=1,2,...,K-1 \\end{array} \\right.引入指示函数 $\\mathbb{I}(\\cdot)$，从而将上面两个式子合写为一个，即： \\begin{align} P(y_i|\\mathbf{x_i};\\boldsymbol{\\theta}) &= \\sum_{k=1}^K \\mathbb{I}(y_i=k)P_k(\\mathbb{x_i};\\boldsymbol{\\theta_k})\\notag \\\\ &= \\sum_{k=1}^{K-1} \\mathbb{I}(y_i=k) \\Bigg( \\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\Bigg)+\\mathbb{I}(y_i=K)\\frac{1}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\notag \\end{align}【损失函数】与二元 Logistic 回归类似，对于得到的多元 Logistic 回归模型的后验概率形式： P(y_i|\\mathbf{x_i};\\boldsymbol{\\theta})=\\sum_{k=1}^{K-1} \\mathbb{I}(y_i=k) \\Big( \\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\Big)+\\mathbb{I}(y_i=K)\\frac{1}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}采用最大似然法（Maximum Likelihood Method）来估计 $\\boldsymbol{\\theta}$，即对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，可得到似然函数： \\begin{align} L(\\boldsymbol{\\theta}) &= \\prod_{i=1}^n P(y_i|\\mathbf{x_i};\\boldsymbol{\\theta}) \\notag \\\\ &= \\prod_{i=1}^n \\Bigg[\\sum_{k=1}^{K-1} \\mathbb{I}(y_i=k) \\Big( \\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\Big)+\\mathbb{I}(y_i=K)\\frac{1}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\Bigg] \\notag \\end{align}在 $\\boldsymbol{\\theta}$ 的所有可能取值中找一个使得似然函数取到最大值，这时求得的解就是最大似然估计，即： \\boldsymbol{\\theta}^*=\\arg \\min_{\\Theta}\\:L(\\boldsymbol{\\theta})由于带连乘运算的似然函数 $L(\\boldsymbol{\\theta})$ 不好优化，考虑到似然函数的取值范围为 $(0,1)$，那么对似然函数取自然对数不影响其单调性，，同时为将最大化问题转为最小化问题，再对取自然对数后的似然函数进行取反，这样就得到了多元 Logistic 回归的损失函数： \\begin{align} J(\\boldsymbol{\\theta}) &= -\\ln L(\\boldsymbol{\\theta}) \\notag \\\\ &= -\\sum_{i=1}^n \\ln \\Bigg[\\sum_{k=1}^{K-1} \\mathbb{I}(y_i=k) \\Big( \\frac{e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\Big)+\\mathbb{I}(y_i=K)\\frac{1}{1+\\sum\\limits_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}} \\Bigg] \\notag \\\\ &= -\\sum_{i=1}^n \\Bigg[ \\ln\\Big( \\sum_{k=1}^{K-1}\\mathbb{I}(y_i=k)e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}} + \\mathbb{I}(y_i=K) \\Big) - \\ln\\Big(1+\\sum_{k=1}^{K-1} e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}}\\Big) \\Bigg] \\notag \\\\ &= -\\sum_{i=1}^n \\Big[ \\sum_{k=1}^{K-1} \\mathbb{I}(y_i=k)\\boldsymbol{\\theta_k}^T\\mathbf{x_i}- \\ln\\Big( 1+\\sum_{k=1}^{K-1}e^{\\boldsymbol{\\theta_k}^T\\mathbf{x_i}} \\Big)\\Big] \\notag \\end{align}接下来要做的，就是要最小化代价函数，为训练集拟合出参数，即： \\boldsymbol{\\theta}^*=\\arg \\min_{\\Theta}\\:J(\\boldsymbol{\\theta})代价函数 $J(\\boldsymbol{\\theta})$ 是关于 $\\boldsymbol{\\theta}$ 的高阶可导连续凸函数，根据凸优化理论，利用梯度下降法或是牛顿迭代法均可取其最优解 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征来实现多元 Logistic 回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.linear_model import LogisticRegressionfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target #取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立Logistic回归模型 model = LogisticRegression(random_state=0) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵，三分类情况下，大小为 3*3 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # macro 分类报告 macro_class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\",\"类2\"]) # 微精确率 micro_p = precision_score(y_test,y_pred,average='micro') # 微召回率 micro_r = recall_score(y_test,y_pred,average='micro') # 微F1得分 micro_f1 = f1_score(y_test,y_pred,average='micro') indicators = &#123;\"cm2\":cm2,\"acc\":acc,\"acc_num\":acc_num,\"macro_class_report\":macro_class_report,\"micro_p\":micro_p,\"micro_r\":micro_r,\"micro_f1\":micro_f1&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 #第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 #第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange(x2_min, x2_max, resolution)) # reolution为网格剖分粒度 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) # 对组合的特征进行预测，ravel为数组展平 Z = Z.reshape(xx1.shape) # Z是列向量 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.xlim(xx1.min(), xx1.max()) #对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) #对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show() if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) macro_class_report = indicators[\"macro_class_report\"] print(\"macro 分类报告：\\n\", macro_class_report) micro_p = indicators[\"micro_p\"] print(\"微精确率：\", micro_p) micro_r = indicators[\"micro_r\"] print(\"微召回率：\", micro_r) micro_f1 = indicators[\"micro_f1\"] print(\"微F1得分：\", micro_f1) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(105, 150))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"二元 Logistic 回归","slug":"machine-learning/20.二元Logistic回归","date":"2019-07-05T11:37:00.000Z","updated":"2023-03-31T13:28:26.136Z","comments":true,"path":"artificial-intelligence/machine-learning/129a3efa.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/129a3efa.html","excerpt":"Reference Logistic regression 周志华机器学习（西瓜书）学习笔记（持续更新） 西瓜书学习笔记(3)—线性模型 最大似然估计 机器学习算法系列（七）-对数几率回归算法（一）（Logistic Regression Algorithm） 【概述】对数几率回归（Logistic regression）即 Logistic 回归，虽然名为回归，但其实际上是一种解决分类问题的分类学习方法，在现实中应用十分广泛，比如垃圾邮件识别，手写数字识别，人脸识别，语音识别等","text":"Reference Logistic regression 周志华机器学习（西瓜书）学习笔记（持续更新） 西瓜书学习笔记(3)—线性模型 最大似然估计 机器学习算法系列（七）-对数几率回归算法（一）（Logistic Regression Algorithm） 【概述】对数几率回归（Logistic regression）即 Logistic 回归，虽然名为回归，但其实际上是一种解决分类问题的分类学习方法，在现实中应用十分广泛，比如垃圾邮件识别，手写数字识别，人脸识别，语音识别等 对于分类问题来说，如果利用线性回归来拟合，假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 的输出值会出现 $f(\\mathbf{x_i};\\boldsymbol{\\theta})&gt;1$ 或 $f(\\mathbf{x_i};\\boldsymbol{\\theta})&lt;0$ 的情况，无法对结果进行归纳，因此，有了 Logistic 回归 其利用一个单调可微的激活函数，将分类任务的真实标记 $y_i$ 与线性回归模型的预测值 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 联系起来，从而将数值结果转换为分类结果，简单来说，其是利用线性回归模型的预测结果去逼近真实标记的对数几率 关于激活函数的详细介绍，详见：常见的激活函数 Logistic 回归根据分类数据的类别，分为以下三种情况： 二元 Logistic 回归：分类数据为两类（例如：有/没有） 多元无序 Logistic 回归：分类数据超过两类，且类别间没有对比意义（例如：一线城市、二线城市、三线城市） 多元有序 Logistic 回归：分类数据超过两类，且类别间有对比意义（例如：喜欢、不喜欢、无所谓） 需要注意的是，这里的元，指的不是自变量的个数，而是因变量的取值范围 本文仅介绍二元 Logistic 回归，关于多元 Logistic 回归，详见：多元 Logistic 回归 【假设形式】假设函数对于给定的容量为 $n$ 的样本集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出为 $y_i\\in \\{0,1\\}$，二元 Logistic 回归学习到的模型为 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$，使得 $f(\\mathbf{x_i};\\boldsymbol{\\theta})\\simeq y_i$ 假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=g(\\theta^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)})其中，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，即： \\boldsymbol{\\theta}=[\\theta^{(0)},\\theta^{(1)},...,\\theta^{(m)}]^T\\in \\mathbb{R}^{m+1}$g(z)$ 为激活函数，就是假说表示，对于不同的问题，根据实际情况来选择不同的激活函数 为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=g(\\theta^{(0)} x_i^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)})在二元 Logistic 回归中，采用 sigmoid 函数 $\\sigma(z)=\\frac{1}{1+e^{-z}}$ 作为激活函数，其图像如下： 不难看出，sigmoid 函数左侧无限接近于 $0$，右侧无限接近于 $1$，具有很好的对称性，值域 $y \\in (0,1)$，正好符合对二分类问题模型的要求 于是，假设函数可以写作： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\frac{1}{1+e^{-\\boldsymbol{\\theta}^T\\mathbf{x_i}}}对数几率形式对于假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\frac{1}{1+e^{-\\boldsymbol{\\theta}^T\\mathbf{x_i}}}$，将假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 的值 $\\hat{y_i}$ 记为样本 $\\mathbf{x_i}$ 为正例的可能性，则 $1-\\hat{y_i}$ 是其为反例的可能性，则两者的比值，称为几率（Odds），其反映了 $\\mathbf{x_i}$ 作为正例的相对可能性： \\frac{\\hat{y_i}}{1-\\hat{y_i}}当假设输出标记 $\\hat{y_i}$ 是在指数尺度上变化时，可对几率取对数，称为对数几率（Log Odds），即： logit(p)=\\ln \\frac{\\hat{y_i}}{1-\\hat{y_i}}将对数几率作为模型逼近的目标，并将假设函数带入，即二元 Logistic 回归模型的对数几率形式： \\ln \\frac{\\hat{y_i}}{1-\\hat{y_i}}=\\boldsymbol{\\theta}^T\\mathbf{x_i}若将 $\\hat{y_i}$ 视为后验概率估计 $P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})$，即在给定概率参数为 $\\boldsymbol{\\theta}$ 时，对具有 $\\mathbf{x_i}$ 特征的条件下 $y_i=1$ 时的概率，即： \\hat{y_i} = P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})那么对于二分类问题，由于输出值非 $0$ 即 $1$，故而可计算出 $y_i=0$ 的概率，即： \\begin{align} P(y_i=0 | \\mathbf{x_i};\\boldsymbol{\\theta}) &= 1- P(y_i=1 | \\mathbf{x_i};\\boldsymbol{\\theta}) \\notag \\\\ &= 1 - \\hat{y_i} \\notag \\end{align}那么对数几率可写为： \\ln \\frac{P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})}{P(y_i=0|\\mathbf{x_i};\\boldsymbol{\\theta})}=\\boldsymbol{\\theta}^T\\mathbf{x_i}后验概率形式对于对数几率 $\\ln \\frac{P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})}{P(y_i=0|\\mathbf{x_i};\\boldsymbol{\\theta})}=\\boldsymbol{\\theta}^T\\mathbf{x_i}$ 中的 $P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})$ 有： \\begin{gather} && \\ln \\frac{P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})}{P(y_i=0|\\mathbf{x_i};\\boldsymbol{\\theta})}=\\boldsymbol{\\theta}^T\\mathbf{x_i} \\notag \\\\ &\\Rightarrow& \\frac{P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})}{P(y_i=0|\\mathbf{x_i};\\boldsymbol{\\theta})} = e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}} \\notag \\\\ &\\Rightarrow& \\frac{P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})}{1-P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})} = e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}\\notag \\\\ &\\Rightarrow& P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})= e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}-P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta}) e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}} \\notag \\\\ &\\Rightarrow& P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})(1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}})= e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}} \\notag \\\\ &\\Rightarrow& P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta})=\\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\notag \\end{gather}进而可得： \\begin{align} P(y_i=0 | \\mathbf{x_i};\\boldsymbol{\\theta}) &= 1- P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta}) \\notag \\\\ &=1- \\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\notag \\\\ &= \\frac{1}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\notag \\end{align}即： \\left\\{\\begin{array}{rl} P(y_i=1|\\mathbf{x_i};\\boldsymbol{\\theta}) &=& \\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\\\ P(y_i=0 |\\mathbf{x_i};\\boldsymbol{\\theta}) &=& \\frac{1}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\end{array} \\right.由于 $y_i$ 只能取 $0$ 或 $1$，那么可以将上面两个式子合写为一个，即二元 Logistic 回归模型的后验概率形式： P(y_i|\\mathbf{x_i};\\boldsymbol{\\theta})=\\Big(\\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\Big)^{y_i} \\Big( \\frac{1}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\Big)^{1-y_i}【损失函数】引入在多元线性回归模型中，当批量使用梯度下降法求解时，损失函数为： J(\\boldsymbol{\\theta})=\\frac{1}{2n}\\sum_{i=1}^n (f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i)^2在二元 Logistic 回归中，将假设函数 $\\hat{y_i}=\\frac{1}{1+e^{-\\boldsymbol{\\theta}^T\\mathbf{x_i}}}$ 带入上述的代价函数里，并画出代价函数的图像，会发现可能是一个类似下图的非凸函数，即有许多局部最优值，如果将梯度下降法用在这样一个函数上，无法保证其能收敛到全局最小值 因此，为了保证使用梯度下降法使得代价函数收敛到全局最小值，代价函数需要是一个凸函数，那么就要另找一个不同的代价函数 损失函数对于得到的二元 Logistic 回归模型的后验概率形式： P(y_i|\\mathbf{x_i};\\boldsymbol{\\theta})=\\Big(\\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\Big)^{y_i} \\Big( \\frac{1}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\Big)^{1-y_i}采用最大似然法（Maximum Likelihood Method）来估计 $\\boldsymbol{\\theta}$，即对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，可得到似然函数： \\begin{align} L(\\boldsymbol{\\theta}) &= \\prod_{i=1}^n P(y_i|\\mathbf{x_i};\\boldsymbol{\\theta}) \\notag \\\\ &= \\prod_{i=1}^n \\Big(\\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\Big)^{y_i} \\Big( \\frac{1}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}} \\Big)^{1-y_i} \\notag \\end{align}在 $\\boldsymbol{\\theta}$ 的所有可能取值中找一个使得似然函数取到最大值，这时求得的解就是最大似然估计，即： \\boldsymbol{\\theta}^*=\\arg \\max_{\\Theta}\\:L(\\boldsymbol{\\theta})由于带连乘运算的似然函数 $L(\\boldsymbol{\\theta})$ 不好优化，考虑到似然函数的取值范围为 $(0,1)$，那么对似然函数取自然对数不影响其单调性，同时为将最大化问题转为最小化问题，再对取自然对数后的似然函数进行取反，这样就得到了二元 Logistic 回归的损失函数： \\begin{align} J(\\boldsymbol{\\theta}) &= -\\ln L(\\boldsymbol{\\theta}) \\notag \\\\ &= -\\sum_{i=1}^n \\Big[ y_i \\ln \\big(\\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\big)+ (1-y_i) \\ln \\big( \\frac{1}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\big) \\Big] \\notag \\\\ &= -\\sum_{i=1}^n \\Big[ y_i \\ln \\big(\\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\big)+ (1-y_i) \\ln \\big(1- \\frac{e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}{1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}}\\big) \\Big] \\notag \\\\ &= -\\sum_{i=1}^n \\big[ y_i \\ln \\hat{y_i} + (1-y_i) \\ln (1-\\hat{y_i}) \\big] \\notag \\end{align}此时的损失函数 $J(\\boldsymbol{\\theta})=-\\sum\\limits_{i=1}^n \\big[ y_i \\ln \\hat{y_i} + (1-y_i) \\ln (1-\\hat{y_i}) \\big] $，就是整个训练集的损失函数 下面继续对损失函数 $J(\\boldsymbol{\\theta})$ 进行化简，考虑使用对数几率 $\\ln \\frac{\\hat{y_i}}{1-\\hat{y_i}}=\\boldsymbol{\\theta}^T\\mathbf{x_i}$ 进行表示，则有： \\begin{align} J(\\boldsymbol{\\theta}) &=-\\sum_{i=1}^n \\Big[ y_i\\ln \\hat{y_i} + (1-y_i) \\ln(1-\\hat{y_i}) \\Big]\\notag \\\\ &= -\\sum_{i=1}^n \\Big[ y_i\\ln\\hat{y_i}+\\ln(1-\\hat{y_i})-y_i\\ln(1-\\hat{y_i}) \\Big]\\notag \\\\ &= -\\sum_{i=1}^n \\Big[ y_i\\ln\\frac{\\hat{y_i}}{1-\\hat{y_i}}+\\ln(1-\\hat{y_i})-0 \\Big]\\notag \\\\ &= -\\sum_{i=1}^n \\Big[ y_i\\ln\\frac{\\hat{y_i}}{1-\\hat{y_i}}-(\\ln1-\\ln(1-\\hat{y_i})) \\Big]\\notag \\\\ &= -\\sum_{i=1}^n \\Big[ y_i\\ln\\frac{\\hat{y_i}}{1-\\hat{y_i}}-\\ln\\frac{1}{1-\\hat{y_i}} \\Big]\\notag \\\\ &= \\sum_{i=1}^n \\Big[ -y_i\\ln\\frac{\\hat{y_i}}{1-\\hat{y_i}}+\\ln\\frac{1}{1-\\hat{y_i}}\\Big] \\notag \\\\ &= \\sum_{i=1}^n \\Big[ -y_i\\ln\\frac{\\hat{y_i}}{1-\\hat{y_i}}+\\ln(1+\\frac{\\hat{y_i}}{1-\\hat{y_i}})\\Big] \\notag \\\\ &= \\sum_{i=1}^n \\Big[ -y_i\\boldsymbol{\\theta}^T\\mathbf{x_i}+\\ln(1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}) \\Big] \\notag \\end{align}即： J(\\boldsymbol{\\theta})= \\sum_{i=1}^n \\Big[ -y_i\\boldsymbol{\\theta}^T\\mathbf{x_i}+\\ln(1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}) \\Big]接下来要做的，就是要最小化代价函数，为训练集拟合出参数，即： \\boldsymbol{\\theta}^*=\\arg \\min_{\\Theta}\\:J(\\boldsymbol{\\theta})【批量梯度下降法求解】使用批量梯度下降法来最小化代价函数： J(\\boldsymbol{\\theta})= \\sum_{i=1}^n \\Big[ -y_i\\boldsymbol{\\theta}^T\\mathbf{x_i}+\\ln(1+e^{\\boldsymbol{\\theta}^T\\mathbf{x_i}}) \\Big]即将下列公式重复直到收敛为止： \\theta^{(j)} = \\theta^{(j)} - \\alpha \\frac{1}{n} \\Big[\\sum_{i=1}^n \\big(\\hat{y_i}-y_i\\big) \\Big] \\cdot x_i^{(j)}关于批量梯度下降法的具体介绍，详见：梯度下降法 【决策边界】决策边界（Decision Boundary）是分类问题中假设函数的一个属性，其决定于 $\\boldsymbol{\\theta}$ 参数，一旦通过训练集拟合出了 $\\boldsymbol{\\theta}$ 参数，就确定了决策边界 首先来看假设函数： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\frac{1}{1+e^{-\\boldsymbol{\\theta}^T\\mathbf{x_i}}}接着给出 sigmoid 函数的图像，来看一下假设函数何时会预测 $y=0$，何时又会预测 $y=1$ 根据 sigmoid 函数图像的对称性，可以认为，只要假设函数输出 $y=1$ 的概率大于或等于 $0.5$，那么意味着 $y=1$，相反地，只要假设函数输出 $y=0$ 的概率小于 $0.5$，那么意味着 $y=0$，即： \\left\\{\\begin{matrix} y=1, & \\hat{y_i}\\geq 0.5 \\\\y=0, & \\hat{y_i}< 0.5 \\end{matrix}\\right.也就是说，只要 $\\boldsymbol{\\theta}^T\\mathbf{x_i} \\geq 0$，那么 $\\hat{y_i} \\geq 0.5$，就预测 $y=1$，同理，只要 $\\boldsymbol{\\theta}^T\\mathbf{x_i} &lt; 0$，那么 $\\hat{y_i} &lt; 0.5$，就预测 $y=0$ 而决策边界，是一条直线，其将预测值为 $1$ 和 $0$ 的两个区域分隔开来，这一条线对应的就是 $\\hat{y_i}=0.5$，即 $\\boldsymbol{\\theta}^T\\mathbf{x_i}=0$ 时所对应的线 如下图，假设有一个存在两个特征的模型：$\\hat{y_i}=g(\\theta_0+\\theta_1x_1+\\theta_2x_2)$ 通过训练集拟合出的 $\\boldsymbol{\\theta}=[-3,1,1]^T$，则： 当 $\\boldsymbol{\\theta}^T\\mathbf{x_i} \\geq 0$，即：$-3+x_1+x_2 \\geq 0$ 时，模型预测 $y=1$ 当 $\\boldsymbol{\\theta}^T\\mathbf{x_i} &lt; 0$，即：$-3+x_1+x_2 &lt; 0$ 时，模型预测 $y=0$ 此时，$x_1+x_2=3$ 就是该模型的决策边界 【sklearn 实现】以 sklearn 中的鸢尾花数据集为例，选取其后两个特征实现二元 Logistic 回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.linear_model import LogisticRegressionfrom sklearn.metrics import confusion_matrix,accuracy_score,classification_report,precision_score,recall_score,f1_score,roc_auc_scorefrom matplotlib.colors import ListedColormap# 特征提取def deal_data(): iris = load_iris() # sklearn的鸢尾花数据集 # iris分为三类，前50行一类，51-100行一类，101-150行一类 X = iris.data[:100, [2, 3]] # 选用后两个特征作为样本特征 y = iris.target[:100] # 取species列，类别 return X,y# 数据归一化def standard_scaler(X_train,X_test): sc = StandardScaler() # 初始化一个sc对象去对数据集作变换 scaler = sc.fit(X_train) # 归一化，存有计算出的均值和方差 X_train_std = scaler.transform(X_train) # 利用 scaler 进行标准化 X_test_std = scaler.transform(X_test) # 利用 scaler 进行标准化 return X_train_std, X_test_std# 模型训练def train_model(X_train_std, y_train): # 建立Logistic回归模型 model = LogisticRegression(random_state=0) # 训练 model.fit(X_train_std, y_train) return model# 模型评估def estimate_model(y_pred, y_test, model): # 混淆矩阵 cm2 = confusion_matrix(y_test,y_pred) # 准确率 acc = accuracy_score(y_test,y_pred) # 正确分类的样本数 acc_num = accuracy_score(y_test,y_pred,normalize=False) # 分类报告 class_report = classification_report(y_test, y_pred,target_names=[\"类0\",\"类1\"]) # 精确率 p = precision_score(y_test,y_pred) # 召回率 r = recall_score(y_test,y_pred) # F1得分 f1 = f1_score(y_test,y_pred) # ROC-AUC auc = roc_auc_score(y_test,y_pred) indicators = &#123;\"cm2\": cm2, \"acc\": acc, \"acc_num\": acc_num, \"class_report\": class_report, \"p\": p, \"r\": r, \"f1\": f1, \"auc\": auc&#125; return indicators# 可视化def visualization(X, y, classifier, test_id=None, resolution=0.02): # 创建 color map markers = ('s', 'x', 'o', '^', 'v') colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan') cmap = ListedColormap(colors[:len(np.unique(y))]) # 绘制决策边界 x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1 # 第一个特征取值范围作为横轴 x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1 # 第二个特征取值范围作为纵轴 xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution), np.arange( x2_min, x2_max, resolution)) # reolution为网格剖分粒度 # 对组合的特征进行预测，ravel为数组展平 Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T) Z = Z.reshape(xx1.shape) # Z是列向量 # x和y为两个等长一维数组，z为二维数组，指定每一对xy所对应的z值 plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap) plt.xlim(xx1.min(), xx1.max()) # 对等高线间的区域进行填充 plt.ylim(xx2.min(), xx2.max()) # 对等高线间的区域进行填充 # 全数据集，不同类别样本点的特征作为坐标(x,y)，用不同颜色画散点图 for idx, cl in enumerate(np.unique(y)): plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8, c=cmap(idx), marker=markers[idx], label=cl) # # 高亮测试集 if test_id: X_test, y_test = X[test_id, :], y[test_id] # c设置颜色，测试集不同类别的实例点画图不区别颜色 plt.scatter(x=X_test[:, 0], y=X_test[:, 1], alpha=1.0, c='gray', marker='^', linewidths=1, s=55, label='test set') plt.xlabel('petal length [standardized]') plt.ylabel('petal width [standardized]') plt.legend(loc='upper left') plt.tight_layout() plt.show()if __name__ == \"__main__\": # 特征提取 X, y = deal_data() # 简单交叉验证 X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.3, random_state=0) # 数据标准化 X_train_std, X_test_std = standard_scaler(X_train, X_test) # 模型训练 model = train_model(X_train_std, y_train) # 预测结果 y_pred = model.predict(X_test_std) print(\"y test:\", y_test) # 测试集y值 print(\"y pred:\", y_pred) # 预测y值 # 模型评估 indicators = estimate_model(y_pred, y_test, model) cm2 = indicators[\"cm2\"] print(\"混淆矩阵：\\n\", cm2) acc = indicators[\"acc\"] print(\"准确率：\", acc) acc_num = indicators[\"acc_num\"] print(\"正确分类的样本数：\", acc_num) class_report = indicators[\"class_report\"] print(\"分类报告：\\n\", class_report) p = indicators[\"p\"] print(\"精确率：\", p) r = indicators[\"r\"] print(\"召回率：\", r) f1 = indicators[\"f1\"] print(\"F1得分：\", f1) auc = indicators[\"auc\"] print(\"AUC：\", auc) # 可视化 X_combined_std = np.vstack((X_train_std, X_test_std)) y_combined = np.hstack((y_train, y_test)) # classifier为分类器，test_id为测试集序号 visualization(X_combined_std, y_combined, classifier=model, test_id=range(70, 100))","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"常见的激活函数","slug":"machine-learning/19.常见的激活函数","date":"2019-07-05T05:24:00.000Z","updated":"2023-03-31T12:33:55.649Z","comments":true,"path":"artificial-intelligence/machine-learning/dae268f.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/dae268f.html","excerpt":"【概述】激活函数（Activation Function），是用于将权值结果转换为分类结果的一类函数，目前常用激活函数的地方有两个： 逻辑回归（Logistic Regression） 神经网络（Neural Network）","text":"【概述】激活函数（Activation Function），是用于将权值结果转换为分类结果的一类函数，目前常用激活函数的地方有两个： 逻辑回归（Logistic Regression） 神经网络（Neural Network） 在这两种应用中，激活函数都是用于计算一个线性函数，通过计算每个类别可能性的概率，将其权值结果转为分类结果 激活函数的灵感来自于生物神经网络，被认为是神经元对输入的激活程度 最理想的一种形式是单位阶跃函数，其类似一个开关，要么是 $0$，要么是 $1$，即： \\epsilon(t)=\\left\\{\\begin{matrix}1 & t\\geq 0 \\\\ 0 & t","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"最小角回归法","slug":"numerical-analysis/09.最小角回归法","date":"2019-07-03T11:23:00.000Z","updated":"2023-03-31T13:27:04.862Z","comments":true,"path":"mathematics/numerical-analysis/613660fc.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/613660fc.html","excerpt":"Reference 最小角回归详解 最小角回归（Least Angle Regression） 机器学习方法：回归（三）：最小角回归Least Angle Regression（LARS），forward stagewise selection 最小角回归算法（LARS） 对LARS(Least Angle Regression)的简单理解 Least-angle regression 【概述】最小角回归法（Least Angle Regression，LAR），是一种针对于线性回归问题，快速进行特征选择和回归系数计算的迭代算法，其被广泛推广用于求解线性回归以及 Lasso 回归问题","text":"Reference 最小角回归详解 最小角回归（Least Angle Regression） 机器学习方法：回归（三）：最小角回归Least Angle Regression（LARS），forward stagewise selection 最小角回归算法（LARS） 对LARS(Least Angle Regression)的简单理解 Least-angle regression 【概述】最小角回归法（Least Angle Regression，LAR），是一种针对于线性回归问题，快速进行特征选择和回归系数计算的迭代算法，其被广泛推广用于求解线性回归以及 Lasso 回归问题 其核心思想是：将回归目标向量依次分解为若干组特征向量的线性组合，最终使得与所有特征均线性无关的残差向量最小 可见，最小角回归法的关键在于选择正确的特征向量分解顺序和分解系数 为更好地介绍最小角回归法，首先介绍相关的前向选择算法（Forward Selection Algorithm）与前向逐步算法（Forward Stagewise Algorithm） 【残差向量】对于忽略偏置项的回归问题： y=\\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)} + ... + \\theta^{(m)} x^{(m)}$x^{(1)},x^{(2)},…,x^{(m)}$ 为特征向量，$\\theta^{(1)},…,\\theta^{(m)}$ 为预求的回归系数 定义残差向量 $y_i$ 为进行第 $i$ 次特征向量线性组合后，与目标向量 $y$ 的向量差 那么，初始残差向量有： y_0=y对于忽略偏置项的回归问题 $y= \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)}$，特征向量与初始残差向量如下图 【前向选择算法】前向选择算法（Forward Selection Algorithm）是一种贪婪地对目标向量进行特征分解的算法，常用于回归模型的自变量选择，其是一种迭代算法，每次将候选的自变量逐个引入回归方程中，逐个选择自变量 对于回归问题 $y=\\theta^{(0)} + \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)} + … + \\theta^{(m)} x^{(m)}$，其初始残差向量为： y_0=y在第一轮中，会选择一个与 $y_0$ 余弦相似度最高的特征向量 $x^{(M_0)}$，并将 $y_0$ 在该特征向量的方向上进行投影，以得到第二轮的残差向量 $y_1=y_0-\\theta^{(M_0)}x^{(M_0)}$ 之后，进行迭代，对于第 $k$ 轮迭代来说，会在该轮迭代前未被选用过的特征向量中，选择一个与当前残差向量 $y_{k-1}$ 余弦相似度最高的特征向量 $x^{(M_k)}$，然后在该特征向量的方向上进行投影，最后令该轮的残差向量 $y_{k-1}$ 减去该轮的投影向量 $x_{M_k}=\\theta^{(M_k)}x^{(M_k)}$，以得到该轮的目标残差向量 $y_k$，即： y_k=y_{k-1}-\\theta^{(M_k)}x^{(M_k)},\\quad k=1,2,...直到无多余特征向量，或无目标残差向量，或残差向量足够小时，终止迭代 对于忽略偏置项的回归问题 $y= \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)}$，前向选择算法迭代过程如下图 前向选择算法简单粗暴，各特征向量最多使用一次，每轮的目标残差方向均与上一轮采用的特征向量方向正交，但由于其忽略了各特征向量间可能存在的线性关系，仅作盲目的依次投影，因此计算较为粗糙，只能给出局部近似解 【前向逐步算法】前向逐步算法（Forward Stagewise Algorithm）与前向选择算法的基本思想一致，但其没有盲目的进行投影，而是采用了小步试错的方法，以保证每一步分解的合理性 对于回归问题 $y=\\theta^{(0)} + \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)} + … + \\theta^{(m)} x^{(m)}$，其初始残差向量为： y_0=y在第 $k$ 轮迭代中，其选择一个与本轮目标残差向量 $y_{k-1}$ 余弦相似度最高的特征向量 $x^{(M_k)}$，然后在该方向上移动一小步 $\\epsilon x^{(M_k)}$，从而得到下一轮的目标残差向量 $y_{k}$，即： y_{k}=y_{k-1}-\\epsilon x^{(M_k)},\\quad k=1,2,...直到无目标残差向量，或残差向量足够小时，终止迭代 对于忽略偏置项的回归问题 $y= \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)}$，前向逐步算法迭代过程如下图 前向逐步算法中，每轮的候选特征向量均为全部的特征向量，因此每个特征向量可能会被多次使用，同时，当 $\\epsilon$ 足够小时，可以得到一个较为精确的解，但此时计算量很大 【最小角回归法】对于前向选择算法来说，其相较于前向逐步算法速度快，但准确性不高；对于前向逐步算法来说，其相较于前向选择算法准确性高，但速度不快 最小角回归法（Least Angle Regression，LAR）就是前向选择算法的快速性与前向逐步算法的准确性的折中 对于回归问题 $y=\\theta^{(0)} + \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)} + … + \\theta^{(m)} x^{(m)}$，其初始残差向量为： y_0=y在第一轮中，会选择一个与 $y_0$ 余弦相似度最高的特征向量 $x^{(M_0)}$，并在特征向量 $x^{(M_0)}$ 的方向上移动某个步长 $\\omega^{(0)}$，得到此时的目标残差向量 $y_1=y_0-\\omega^{(0)}x^{(M_0)}$，要求 $y_1$ 与特征向量 $x^{(M_0)}$ 和余弦相似度第二高的特征向量 $x^{(M_0’)}$ 的相关性相等，即令 $y_1$ 等于 $x^{(M_0)}$ 和 $x^{(M_0’)}$ 的角平分向量 之后，进行迭代，对于第 $k$ 轮迭代来说，会在该轮迭代前未被选用过的特征向量中，选择一个与当前残差向量 $y_{k-1}$ 余弦相似度最高的特征向量 $x^{(M_k)}$，并在上一轮的角平分向量的方向即当前残差向量 $y_{k-1}$ 上移动某个步长 $\\omega^{(k)}$，得到该轮的目标残差向量 $y_k=y_{k-1}-\\omega^{(k)}x^{(M_k)}$，要求 $y_k$ 与之前被选用过的特征向量的相关性相等，即令 $y_k$ 等于之前被选用过的特征向量的角平分向量 直到无多余特征向量，或无目标残差向量，或残差向量足够小时，终止迭代 对于忽略偏置项的回归问题 $y= \\theta^{(1)} x^{(1)} + \\theta^{(2)} x^{(2)}$，最小角回归算法迭代过程如下图 在最小角回归算法中，各特征向量最多使用一次，其通过准确得到每步最优的分解长度以保证计算的准确性和速度 此外，其具有以下特点： 特别适合特征维度 $m$ 远高于样本数 $n$ 的情况 最坏计算复杂度和最小二乘法相同，但平均计算速度与前向选择算法一样 可以产生分段线性结果的完整路径，在模型的交叉验证中极为有用 迭代方向是基于目标残差方向，很容易受到噪声的影响","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"坐标下降法","slug":"convex-optimization/09.坐标下降法","date":"2019-07-03T04:46:00.000Z","updated":"2023-03-09T14:32:56.084Z","comments":true,"path":"mathematics/convex-optimization/4e3d286.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/convex-optimization/4e3d286.html","excerpt":"Reference 【机器学习】坐标下降法（Coordinate descent） 优化算法——坐标下降法(Coordinate Descent) 坐标下降法 Coordinate descent 【概述】坐标下降法（Coordinate Descent）是一种非梯度优化算法，常用于不可微的凸函数优化问题中","text":"Reference 【机器学习】坐标下降法（Coordinate descent） 优化算法——坐标下降法(Coordinate Descent) 坐标下降法 Coordinate descent 【概述】坐标下降法（Coordinate Descent）是一种非梯度优化算法，常用于不可微的凸函数优化问题中 与梯度下降法利用目标函数的导数来确定搜索方向不同，坐标轴下降法是每次沿着单个维度方向进行搜索，当得到一个当前维度最小值之后再循环使用不同的维度方向，最终收敛得到最优解 对于每次进行的最小值的搜索，其实就是把其他的变量看作常量，然后目标凸函数 $f(\\cdot)$ 就看作是关于当前搜索变量的函数，在该函数上进行线性搜索，每次迭代时某个维度的搜索会使用上一维度搜索的结果 例如，对于函数 $f(x,y)=xe^{-(x^2+y^2)}$，当对其进行坐标下降的搜索结果如下图所示 图中的红色小点就是搜索过程，可以看到红点是交替分布的，这印证了坐标下降法分别在不同维度上进行交替搜索的过程 坐标下降法与梯度下降法的不同之处在于，坐标下降法不需要计算目标函数的梯度，每次迭代只用在单一维度上进行线性搜索，但是坐标下降法只适用于光滑函数，如果是非光滑函数可能会陷入非驻点从而无法更新 【基本思想】对于无约束极小化问题： \\mathbf{x}^*=\\arg \\min_{\\mathcal{X}} f(\\mathbf{x})其中，$f(\\cdot)$ 为目标优化凸函数，$\\mathbf{x}=(x^{(1)},x^{(2)},…,x^{(n)})^T\\in \\mathbb{R}^n$，$x^{(i)}$ 为向量 $\\mathbf{x}$ 的第 $i$ 个分量 坐标下降法的基本过程如下： 首先，选取 $x^{(2)},x^{(3)},…,x^{(n)}$ 的初值 然后，进行迭代，在每轮迭代中进行如下操作 固定 $x^{(2)},x^{(3)},…,x^{(n)}$，将 $x^{(1)}$ 作为自变量，进行线性搜索，得到： (x^{(1)}) ^*= \\arg \\min_{x^{(1)}} f(x^{(1)},x^{(2)},...,x^{(n)})将得到的 $(x^{(1)})^*$ 代入凸函数，同时固定 $x^{(3)},x^{(4)},…,x^{(n)}$，搜索得到： (x^{(2)}) ^*= \\arg \\min_{x^{(2)}} f((x^{(1)})^*,x^{(2)},...,x^{(n)})将得到的 $(x^{(1)})^*,(x^{(2)})^*$ 代入凸函数，同时固定 $x^{(4)},x^{(5)},…,x^{(n)}$，搜索得到： (x^{(3)}) ^*= \\arg \\min_{x^{(3)}} f((x^{(1)})^*,(x^{(2)})^*,...,x^{(n)})以此类推，最终得到本轮迭代后的一组值： (x^{(1)})^*,(x^{(2)})^*,...,(x^{(n)})^*若结果收敛或满足迭代终止条件，则达到最优值，否则进行下一轮迭代 其迭代过程可以表示为： \\begin{align*} x_k^{(1)} &= \\arg \\min\\limits_{x^{(1)}} f(x^{(1)},x_{k-1}^{(2)},x_{k-1}^{(3)},...,x_{k-1}^{(n)}) \\\\ x_k^{(2)} &= \\arg \\min\\limits_{x^{(2)}} f(x_k^{(1)},x^{(2)},x_{k-1}^{(3)},...,x_{k-1}^{(n)}) \\\\ x_k^{(3)} &= \\arg \\min\\limits_{x^{(3)}} f(x_k^{(1)},x_k^{(2)},x^{(3)},...,x_{k-1}^{(n)}) \\\\ &... \\\\ x_k^{(n)} &= \\arg \\min\\limits_{x^{(n)}} f(x_k^{(1)},x_k^{(2)},x_k^{(3)},...,x^{(n)}) \\\\ \\end{align*}其中，$x_k^{(i)}$ 代表第 $k$ 次迭代时的第 $i$ 个系数 以二维空间为例，设损失函数 $J(x,y)$ 为凸函数，在初始点固定 $x_0$，使得 $J(x_0,y)$ 达到最小的 $y_1$，然后固定 $y_1$，使得 $J(x,y_1)$ 达到最小的 $x_2$，如此迭代下去，由于 $J(x,y)$ 为凸函数，所以一定可以找到使得 $J(x,y)$ 达到最小的点 $(x_k,y_k)$ 【全局最小值】可微凸函数假设坐标下降法收敛后的坐标点为 $\\mathbf{x}$，函数上的任意一点为 $\\mathbf{y}$，根据多元函数的二阶泰勒展开，有： f(\\mathbf{y})=f(\\mathbf{x})+\\triangledown f(\\mathbf{x})^T(\\mathbf{y}-\\mathbf{x})+\\frac{1}{2}(\\mathbf{y}-\\mathbf{x})^T\\triangledown^2 f(\\mathbf{x})(\\mathbf{y}-\\mathbf{x})+o^2(\\mathbf{y-x})对于可微的凸函数，坐标下降法的收敛处各坐标方向的偏导必为 $0$，即：$\\triangledown f(\\mathbf{x})=0$ 否则函数沿着坐标轴方向必存在函数值进一步下降的空间，这与坐标下降法的迭代终止条件相违背 此外，可微凸函数的海森矩阵为正定矩阵，即：$\\triangledown^2 f(\\mathbf{x})=0$ 故而可得： \\begin{align*} f(\\mathbf{y}) &= f(\\mathbf{x})+\\triangledown f(\\mathbf{x})^T(\\mathbf{y}-\\mathbf{x})+\\frac{1}{2}(\\mathbf{y}-\\mathbf{x})^T\\triangledown^2 f(\\mathbf{x})(\\mathbf{y}-\\mathbf{x})+o^2(\\mathbf{y-x}) \\\\ &= f(\\mathbf{x})+o^2(\\mathbf{y-x}) \\\\ &\\geq f(\\mathbf{x}) \\end{align*}因此，对于可微凸函数，坐标下降法的任意局部最优解即为全局最优解 不可微凸函数对于不可微凸函数，很容易举出坐标下降法不适用的例子 如下等高线图，蓝色点处为全局最小值点，若以红色点 A 为初始点进行坐标下降法，由于沿着平面内两根轴都无法进一步下降，所以最终值仍为红色点 A ，此时坐标下降法失效 联合函数凸函数假设目标函数为可微凸函数 $f(\\mathbf{x})$ 和不可微凸函数 $h(\\mathbf{x})$ 的和，且 $h(\\mathbf{x})$ 可写为各坐标轴方向的和： f(\\mathbf{x})=g(\\mathbf{x})+\\sum_i h(x_i)假设坐标下降法收敛后的坐标点为 $\\mathbf{x}$，函数上的任意一点为 $\\mathbf{y}$，则有： \\begin{align*} f(\\mathbf{y})-f(\\mathbf{x}) &= g(\\mathbf{y})-g(\\mathbf{x})+\\sum_i\\big[ h(y_i)-h(x_i) \\big] \\\\ &\\geq \\triangledown g(\\mathbf{x})^T(\\mathbf{y}-\\mathbf{x}) + \\sum_i \\big[ h(y_i)-h(x_i) \\big] \\\\ &= \\sum_i \\big[ \\triangledown_i g(\\mathbf{x})(y_i-x_i) +h(y_i)-h(x_i) \\big] \\\\ &\\geq 0 \\end{align*}因此，对于可微凸函数和不可微凸函数的联合函数，坐标下降法的最终结果即为全局最小值点","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"凸优化","slug":"mathematics/convex-optimization","permalink":"https://alex-mcavoy.github.io/categories/mathematics/convex-optimization/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"凸优化","slug":"convex-optimization","permalink":"https://alex-mcavoy.github.io/tags/convex-optimization/"}],"author":"Alex_McAvoy"},{"title":"弹性网络回归","slug":"machine-learning/18.弹性网络回归","date":"2019-07-02T15:44:00.000Z","updated":"2023-04-06T06:44:06.529Z","comments":true,"path":"artificial-intelligence/machine-learning/49b5f2a0.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/49b5f2a0.html","excerpt":"Reference 弹性网络回归算法（Elastic Net Regression Algorithm） 机器学习算法系列（六）- 弹性网络回归算法（Elastic Net Regression Algorithm） Elastic net regularization 【概述】在 Lasso 回归与 Ridge 回归 中，介绍了 Lasso 回归与岭回归两种正则化的方法","text":"Reference 弹性网络回归算法（Elastic Net Regression Algorithm） 机器学习算法系列（六）- 弹性网络回归算法（Elastic Net Regression Algorithm） Elastic net regularization 【概述】在 Lasso 回归与 Ridge 回归 中，介绍了 Lasso 回归与岭回归两种正则化的方法 当多个特征存在相关时，Lasso 回归可能只会随机选择其中一个，岭回归则会选择所有的特征 如果将这两种正则化的方法结合起来，就能够集合两种方法的优势，这种正则化后的算法就被称为弹性网络回归（Elastic Net Regression） 【假设形式】弹性网络回归算法的损失函数结合了 Lasso 回归和岭回归的正则化方法，通过两个参数 $\\lambda$ 和 $\\rho$ 来控制惩罚项的大小 \\begin{align*} J(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda\\rho||\\boldsymbol{\\theta}||_1 + \\frac{\\lambda(1-\\rho)}{2} ||\\boldsymbol{\\theta}||_2^2 \\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda\\rho\\sum_{j=0}^m |\\theta^{(j)}| + \\frac{\\lambda(1-\\rho)}{2} \\sum_{j=0}^{m}(\\theta^{(j)})^2 \\end{align*}其最优化目标同样是求损失函数 $J(\\boldsymbol{\\theta})$ 最小时 $\\boldsymbol{\\theta}$ 的大小，即： \\boldsymbol{\\theta}^* = \\arg \\min_{\\boldsymbol{\\theta}} \\Big( \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda\\rho\\sum_{j=0}^m |\\theta^{(j)}| + \\frac{\\lambda(1-\\rho)}{2} \\sum_{j=0}^{m}(\\theta^{(j)})^2 \\Big)可以看到，当 $\\rho=0$ 时，其损失函数就等同于岭回归的代价函数，当 $\\rho=1$ 时，其代价函数就等同于 Lasso 回归的损失函数 如下图所示，展示了 Lasso 回归与弹性网络回归对比，虚线表示 Lasso 回归的十个特征，实线表示弹性网络回归的十个特征，每一个颜色表示一个自变量的权重系数，可以看到，相对 Lasso 回归来说，弹性网络回归保留了 Lasso 回归的特征选择的性质，又兼顾了岭回归的稳定性 与 Lasso 回归相似，弹性网络回归中，损失函数中有绝对值存在，不是处处可导的，无法通过直接求导的方式来直接得到 $\\boldsymbol{\\theta}$ 的解析解，通常使用坐标下降法（Coordinate Descent）来求解 $\\boldsymbol{\\theta}$ 的最优解 关于坐标下降法的详细介绍，见：坐标下降法 【skleran 实现】以 sklearn 中的波士顿房价数据集为例，实现 Lasso 回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import ElasticNetfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立弹性网络回归模型，l1_ratio即损失函数中的ρ，l1_ratio=1时，为Lasso回归 model = ElasticNet(l1_ratio=0.7) # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3,random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"Lasso 回归与 Ridge 回归","slug":"machine-learning/17.Lasso回归与Ridge回归","date":"2019-07-02T05:28:00.000Z","updated":"2023-04-06T06:43:44.468Z","comments":true,"path":"artificial-intelligence/machine-learning/113e5e58.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/113e5e58.html","excerpt":"Reference Lasso回归 Lasso—原理及最优解 机器学习算法系列（五）- Lasso回归算法（Lasso Regression Algorithm） 岭回归 岭回归详解 从零开始 从理论到实践 Tikhonov regularization 吉洪诺夫正则化（L2正则化） 机器学习算法系列（四）- 岭回归算法（Ridge Regression Algorithm） Lasso (statistics)) Tikhonov regularization 【概述】在 机器学习的模型选择 中，简单介绍过过拟合现象和正则化","text":"Reference Lasso回归 Lasso—原理及最优解 机器学习算法系列（五）- Lasso回归算法（Lasso Regression Algorithm） 岭回归 岭回归详解 从零开始 从理论到实践 Tikhonov regularization 吉洪诺夫正则化（L2正则化） 机器学习算法系列（四）- 岭回归算法（Ridge Regression Algorithm） Lasso (statistics)) Tikhonov regularization 【概述】在 机器学习的模型选择 中，简单介绍过过拟合现象和正则化 对于线性回归来说，其损失函数的解析解为： \\boldsymbol{\\theta}=(XX^T)^{-1}XY当 $XX^T$ 不是满秩矩阵时，没有逆矩阵，此时会出现过拟合现象，其本质就是自变量 $x^{(j)}$ 之间存在多重共线性（Multicollinearity），即自变量 $x^{(j)}$ 间存在相关关系 对于线性回归中的多重共线性问题，其中一个解决方法就是剔除掉共线的自变量，可以通过计算方差膨胀因子（Variance inflation factor，VIF）来量化自变量之间的相关关系，方差扩大因子越大说明自变量的共线性越严重 另一种解决方法是通过对损失函数正则化来解决，使用 L1 范数正则化的回归模型一般称为 Lasso 回归，使用 L2 范数正则化的回归模型一般称为 Ridge 回归 本文仅介绍 Lasso 回归与 Ridge 回归，关于多重共线性与方差膨胀因子，详见：多重共线性与方差膨胀因子 【正则化】对于给定的容量为 $n$ 的样本集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})^T\\in \\mathbb{R}^m$，输出为 $y_i$ 用假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 来表示对第 $i$ 组数据的预测结果： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}其中，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，即： \\boldsymbol{\\theta}=[\\theta^{(0)},\\theta^{(1)},...,\\theta^{(m)}]^T\\in \\mathbb{R}^{m+1}现在，希望求出相应的 $\\{\\theta^{(i)}\\}^{m+1}_{i=0}$ 来使得 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 能够尽量的拟合好样本集 $D$ 为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} x_i^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}选用残差平方和 RSS 作为损失函数，则有： \\begin{align} J_0(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n (f(\\mathbf{x_i})-y_i)^2 \\notag \\\\ &= \\sum_{i=1}^n(\\sum_{j=0}^{m+1}\\theta_jx_{i}^{(j)}-y_i)^2 \\notag \\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 \\notag \\end{align}对于原始的损失函数 $J_0(\\boldsymbol{\\theta})$，在加入正则化项 $R(\\boldsymbol{\\theta})$ 后，新的损失函数为： J(\\boldsymbol{\\theta}) = J_0(\\boldsymbol{\\theta})+\\lambda R(\\boldsymbol{\\theta}),\\quad \\lambda\\geq 0其中，$R(\\boldsymbol{\\theta})$ 是正则化项，$\\lambda\\geq0$ 为正则化参数，用于控制两者之间的平衡关系 如果 $\\lambda$ 设置的过小，那么 $\\boldsymbol{\\theta}$ 参数的惩罚程度为起到应有的效果，仍会出现过拟合问题 如果 $\\lambda$ 设置的过大，那么 $\\boldsymbol{\\theta}$ 参数的惩罚程度太大，所有的 $\\boldsymbol{\\theta}$ 参数几乎全部等于 $0$，这就使得把假设函数的除去 $\\theta^{(0)}$ 的项全都忽略掉了，相当于直接用 $f(x)=\\theta^{(0)}$ 来拟合数据，这就出现了欠拟合问题 因此，为了让正则化起到应用的效果，应当根据实际情况去选择一个合适的正则化参数 $\\lambda$ 【Lasso 回归】一种对损失函数正则化的方式是将正则化项 $R(\\boldsymbol{\\theta})$ 取全部权重向量 $\\boldsymbol{\\theta}$ 的 L1 范数 $||\\boldsymbol{\\theta}||_1$，这个过程被称为 L1 正则化，经过这种损失函数正则化后的线性回归，被称为 Lasso 回归，其完整名称是最小绝对值收敛和选择算子（Least Absolute Shrinkage and Selection Operator）回归 \\begin{align*} J(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda ||\\boldsymbol{\\theta}||_1\\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda\\sum_{j=0}^m |\\theta^{(j)}| \\end{align*}此时最优化目标是求损失函数 $J(\\boldsymbol{\\theta})$ 最小时 $\\boldsymbol{\\theta}$ 的大小，即： \\boldsymbol{\\theta}^* = \\arg \\min_{\\boldsymbol{\\theta}} \\Big( \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda\\sum_{j=0}^m |\\theta^{(j)}| \\Big)由于加入了 L1 范数，存在绝对值，因此损失函数 $J(\\boldsymbol{\\theta})$ 并不是处处可导的，无法通过直接求导的方式来直接得到 $\\boldsymbol{\\theta}$ 的解析解，通常使用坐标下降法（Coordinate Descent）或最小角回归法（Least Angle Regression，LARS），来求 $\\boldsymbol{\\theta}$ 的最优解 如图所示，展示了采用最小角回归法时惩罚系数 $\\lambda$ 对各个自变量的权重系数的影响，图中横轴为惩罚系数 $\\lambda$，纵轴为权重系数，每一个颜色表示一个自变量的权重系数 可以看到当 $\\lambda$ 逐渐增大时（向左），某些特征的权重系数会快速变成零，通过这个性质说明 Lasso 回归可以用来进行特征选择，即通过控制 $\\lambda$ 的大小来选择关键特征 关于坐标下降法的详细介绍，见：坐标下降法 关于最小角回归法，详见：最小角回归法 【Ridge 回归】最优化过程除上述的 L1 正则化外，另一种对损失函数正则化的方式是将正则化项 $R(\\boldsymbol{\\theta})$ 取全部权重向量 $\\boldsymbol{\\theta}$ 的 L2 范数 $||\\boldsymbol{\\theta}||_2$ 的平方，这种方式被吉洪诺夫正则化（Tikhonov Regularization），又称为 L2 正则化，经过这种损失函数正则化后的线性回归，被称为 Ridge 回归，即岭回归 \\begin{align*} J(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda ||\\boldsymbol{\\theta}||_2^2, \\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda \\sum_{j=0}^{m}(\\theta^{(j)})^2 \\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda \\boldsymbol{\\theta}^T\\boldsymbol{\\theta} \\\\ \\end{align*}此时最优化目标是求损失函数 $J(\\boldsymbol{\\theta})$ 最小时 $\\boldsymbol{\\theta}$ 的大小，即： \\boldsymbol{\\theta}^* = \\arg \\min_{\\boldsymbol{\\theta}} \\Big( \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda \\boldsymbol{\\theta}^T\\boldsymbol{\\theta} \\Big)对于损失函数 $J(\\boldsymbol{\\theta})$ 可以通过求导来直接得到 $\\boldsymbol{\\theta}$ 的解析解，即： \\boldsymbol{\\theta}=(XX^T+\\lambda I)^{-1} XY可以看到岭回归的损失函数的解析解，相较于线性回归来说多了一个可以人为控制的对角矩阵 $I$，这时可以通过调整不同的 $\\lambda$ 来使得矩阵 $XX^T+\\lambda I$ 整体可逆 如图所示，展示了惩罚系数 $\\lambda$ 对各个自变量的权重系数的影响，图中横轴为惩罚系数 $\\lambda$，纵轴为权重系数，每一个颜色表示一个自变量的权重系数 可以看到当 $\\lambda$ 越大时（向左），惩罚项的影响越来越大，逐渐占据主导地位，会使得每个自变量的权重系数趋近于零；当 $\\lambda$ 越小时（向右），惩罚项的影响越来越小，会导致每个自变量的权重系数震荡的幅度变大 推导过程将数据集 $D$ 写为 $(m+1)\\times n$ 的矩阵，即： X=\\begin{bmatrix} x_{1}^{(0)} & x_{2}^{(0)} & ... & x_{n}^{(0)} \\\\ x_{1}^{(1)} & x_{2}^{(1)} & ... & x_{n}^{(1)} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ x_{1}^{(m)} & x_{2}^{(m)} & ... & x_{n}^{(m)} \\end{bmatrix}同时，将样本中的 $y_i$ 也写为矩阵形式，即输出变量 $Y$ 为 $n\\times 1$ 的列向量： Y=[y_1,y_2,...,y_n]^T \\in \\mathbb{R}^{n}那么损失函数 $J(\\boldsymbol{\\theta})$ 可写为： \\begin{align*} J(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 + \\lambda \\boldsymbol{\\theta}^T\\boldsymbol{\\theta} \\\\ &= \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} -\\boldsymbol{\\theta}^TXY -Y^TX^T\\boldsymbol{\\theta} +Y^TY + \\lambda \\boldsymbol{\\theta}^T\\boldsymbol{\\theta} \\\\ &= \\boldsymbol{\\theta}^T(XX^T+\\lambda I)\\boldsymbol{\\theta} -\\boldsymbol{\\theta}^TXY -Y^TX^T\\boldsymbol{\\theta} +Y^TY \\end{align*}要令目标函数最小，显然要令 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=0$ 对于 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})$，有： \\begin{align*} \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J(\\boldsymbol{\\theta}) &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\Big ( \\boldsymbol{\\theta}^T(XX^T+\\lambda I)\\boldsymbol{\\theta} -\\boldsymbol{\\theta}^TXY -Y^TX^T\\boldsymbol{\\theta} +Y^TY \\Big) \\\\ &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^T(XX^T+\\lambda I)\\boldsymbol{\\theta} - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TX^T\\boldsymbol{\\theta} + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY \\end{align*}对于上式的第一部分，由于 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，$XX^T+\\lambda I$ 为 $(m+1)\\times (m+1)$ 的矩阵，故 $\\theta^T(XX^T+\\lambda I)\\boldsymbol{\\theta}$ 为标量，求导为分母布局下的标量/向量的形式，故有： \\begin{align} \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\theta^T(XX^T+\\lambda I)\\boldsymbol{\\theta} &= \\big[(XX^T+\\lambda I)+(XX^T+\\lambda I)^T\\big] \\boldsymbol{\\theta} \\notag \\\\ &= \\big[ (XX^T+\\lambda I)+(XX^T+\\lambda I) \\big] \\boldsymbol{\\theta} \\notag \\\\ &= 2(XX^T+\\lambda I) \\boldsymbol{\\theta} \\notag \\end{align}对于剩余的三部分（证明详见：最小二乘法），有： - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TX^T\\boldsymbol{\\theta} + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY = -2XY因此，对于 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})$，有： \\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=2(XX^T+\\lambda I) \\boldsymbol{\\theta} - 2XY令 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=0$，则有： \\begin{gather} && 2(XX^T+\\lambda I) \\boldsymbol{\\theta} -2XY = 0 \\notag \\\\ &\\Rightarrow& (XX^T+\\lambda I) \\boldsymbol{\\theta}=XY \\notag \\\\ &\\Rightarrow& (XX^T+\\lambda I)^{-1} (XX^T+\\lambda I)\\boldsymbol{\\theta} = (XX^T+\\lambda I)^{-1} XY \\notag \\\\ &\\Rightarrow& \\boldsymbol{\\theta}=(XX^T+\\lambda I)^{-1} XY \\notag \\end{gather}【sklearn 实现】Lasso 回归以 sklearn 中的波士顿房价数据集为例，实现 Lasso 回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import Lassofrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立Lasso回归模型 model = Lasso() # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3,random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model) Ridge 回归以 sklearn 中的波士顿房价数据集为例，实现 Ridge 回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import Ridgefrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立Ridge回归模型 model = Ridge() # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3,random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"多重共线性与方差膨胀因子","slug":"machine-learning/16.多重共线性与方差膨胀因子","date":"2019-07-02T03:21:00.000Z","updated":"2023-03-31T12:43:03.784Z","comments":true,"path":"artificial-intelligence/machine-learning/aa85fef4.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/aa85fef4.html","excerpt":"Reference 一看就懂的多重共线性 如何理解方差膨胀因子（Variance Inflation Factor，VIF）？ 使用方差膨胀因子(Variance Inflation Factor)来特征选择 Multicollinearity Variance inflation factor 【概述】在 机器学习的模型选择 中，简单介绍过过拟合现象和正则化","text":"Reference 一看就懂的多重共线性 如何理解方差膨胀因子（Variance Inflation Factor，VIF）？ 使用方差膨胀因子(Variance Inflation Factor)来特征选择 Multicollinearity Variance inflation factor 【概述】在 机器学习的模型选择 中，简单介绍过过拟合现象和正则化 对于线性回归来说，其代价函数的解析解为： \\boldsymbol{\\theta}=(XX^T)^{-1}XY当 $XX^T$ 不是满秩矩阵时，没有逆矩阵，此时会出现过拟合现象，其本质就是自变量 $x^{(j)}$ 之间存在多重共线性（Multicollinearity），即自变量 $x^{(j)}$ 间存在相关关系 对于线性回归中的多重共线性问题，其中一个解决方法就是剔除掉共线的自变量，可以通过计算方差膨胀因子（Variance inflation factor，VIF）来量化自变量之间的相关关系，方差扩大因子越大说明自变量的共线性越严重 另一种解决方法是通过对代价函数正则化来解决，使用 L1 范数正则化的回归模型一般称为 Lasso 回归，使用 L2 范数正则化的回归模型一般称为 Ridge 回归 本文仅介绍多重共线性与方差膨胀因子，关于 Lasso 回归与 Ridge 回归，详见：Lasso 回归与 Ridge 回归 【多重共线性】多重共线性（Multicollinearity）是指线性回归中，变量之间由于存在精确相关关系或高度相关关系而使回归估计不准确 假设多元线性回归 $y_i=\\theta^{(1)}x_i^{(1)}+\\theta^{(2)}x_i^{(2)}$，其中 $\\theta^{(1)}=2,\\theta^{(2)}=3$ 如果 $x^{(1)}$ 与 $x^{(2)}$ 之间存在明确的相关关系，则称两者存在精确相关关系： \\left\\{\\begin{array}{rl} y_i &=& 2x_i^{(1)}+3x_i^{(2)} \\\\ x_i^{(2)} &=& 2x_i^{(1)} \\end{array} \\right.如果 $x_i^{(1)}$ 与 $x_i^{(2)}$ 之间存在近似的相关关系，则称两者存在高度相关关系： \\left\\{\\begin{array}{rl} y_i &=& 2x_i^{(1)}+3x_i^{(2)} \\\\ x_i^{(2)} &\\approx& 2x_i^{(1)} \\end{array} \\right.以上述的精确相关关系为例，由于 $x_i^{(2)} = 2x_i^{(1)}$ 可以将 $y_i = 2x_i^{(1)}+3x_i^{(2)}$ 改写为不同的形式，这样就会导致 $\\theta^{(1)},\\theta^{(2)}$ 存在无数中解，使得最后的回归估计不准确 \\left\\{\\begin{array}{rl} y_i &=& 2x_i^{(1)}+3x_i^{(2)} &\\Rightarrow \\theta^{(1)}=2,\\theta^{(2)}=3 \\\\ y_i &=& 6x_i^{(1)}+x_i^{(2)} &\\Rightarrow \\theta^{(1)}=6,\\theta^{(2)}=1 \\\\ y_i &=& 8x_i^{(1)} &\\Rightarrow \\theta^{(1)}=8,\\theta^{(2)}=0 \\\\ y_i &=& 4x_i^{(2)} &\\Rightarrow \\theta^{(1)}=0,\\theta^{(2)}=4 \\\\ &&... \\end{array} \\right.根据线性回归的解析解 $\\boldsymbol{\\theta}=(XX^T)^{-1}XY$，可以通过下述公式来求解其中的逆矩阵 (XX^T)^{-1}=\\frac{(X^TX)^*}{|X^TX|}可以看到，逆矩阵可逆的条件是其行列式 $|XX^T|$ 不能为 $0$ 如果存在多重共线性，会使得矩阵的行列式 $|XX^T|$ 为 $0$，导致 $XX^T$ 不可逆，使得最后的回归估计不准确 如下示例，可以看到 $x_i^{(2)}$ 与 $x_i^{(3)}$ 之间存在精确相关关系 \\begin{align*} x_1 \\quad\\: x_2\\:\\:\\:\\quad x_3 \\quad\\:\\:\\: x_4\\:\\: \\\\ X = \\begin{bmatrix} 1\\quad & 1\\quad & 1\\quad & 1 \\\\ 1\\quad & 2\\quad & 3\\quad & 4 \\\\ 2\\quad & 4\\quad & 6\\quad & 8 \\\\ \\end{bmatrix} \\end{align*}此时，$XX^T$ 经过初等变换后，其行列式为 $0$，$XX^T$ 不可逆，使得最后的回归估计不准确 XX^T = \\begin{bmatrix} 4 & 10 & 20 \\\\ 10 & 30 & 60 \\\\ 20 & 60 & 120 \\\\ \\end{bmatrix} \\stackrel{初等变换}{\\longrightarrow} \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 2 \\\\ 0 & 0 & 0 \\\\ \\end{bmatrix}相似地，如果存在高度相关关系，那么会使得 $XX^T$ 的行列式近似为 $0$，此时得到的 $\\boldsymbol{\\theta}$ 的偏差很大，回归不准确 【方差膨胀因子】方差膨胀因子（Variance inflation factor，VIF）是用来量化自变量之间的相关关系的一种指标，VIF 越大说明自变量的多重共线性越严重 VIF 的一般标准如下： 0 &lt; VIF &lt; 5：无共线性 5 &lt; VIF &lt; 10：弱多重共线性 10 &lt; VIF &lt; 100：中多重共线性 VIF &gt; 100：强共线性 对于线性回归问题，可以计算每个自变量 $x^{(j)}$ 的 VIF，之后去掉 VIF 较大的自变量，或将相关的变量组合为一个单一的变量 对于多元线性回归的第 $j$ 个自变量 $x^{(j)}$，其 VIF 的计算公式为： VIF_j = \\frac{1}{1-R^2_j}其中，$R^2_j$ 是可决系数 相较于 Pearson 相关系数来说，VIF 除了可以量化多重共线性外，还可以看到多个变量间的复相关性 关于 Pearson 相关系数与可决系数详见：回归问题的评价指标（二）","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"多元线性回归","slug":"machine-learning/15.多元线性回归","date":"2019-06-26T06:44:00.000Z","updated":"2023-04-06T06:42:31.292Z","comments":true,"path":"artificial-intelligence/machine-learning/554feae6.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/554feae6.html","excerpt":"【假设形式】在回归分析中，如果有两个及以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归（Multivariate Linear Regression） 其假设形式如下：","text":"【假设形式】在回归分析中，如果有两个及以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归（Multivariate Linear Regression） 其假设形式如下： 对于给定的容量为 $n$ 的训练集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$，输出为 $y_i$，多元线性回归学习到的模型为 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$，使得 $f(\\mathbf{x_i};\\boldsymbol{\\theta})\\simeq y_i$ 用假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 来表示对第 $i$ 组数据的预测结果： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}其中，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，即： \\boldsymbol{\\theta}=[\\theta^{(0)},\\theta^{(1)},...,\\theta^{(m)}]^T\\in \\mathbb{R}^{m+1}为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} x_i^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}与一元线性回归模型相同，需要一个损失函数损失函数 $J(\\boldsymbol{\\theta})$ 来作为衡量预测结果的指标，对于损失函数最小化时的 $\\boldsymbol{\\theta}$，通常使用最小二乘法或以梯度下降法为代表的迭代法来求解 无论使用何种方法，最终的目标，都是要令这个损失函数的值最小化，即 \\boldsymbol{\\theta}^* = \\arg \\min \\limits_{\\boldsymbol{\\theta}} \\:J(\\boldsymbol{\\theta})【梯度下降法求解】对于给定的容量为 $n$ 的样本集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})\\in \\mathbb{R}^m$ 设习得的模型的假设函数为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}其中，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，即： \\boldsymbol{\\theta}=[\\theta^{(0)},\\theta^{(1)},...,\\theta^{(m)}]^T\\in \\mathbb{R}^{m+1}为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} x_i^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}设损失函数为： J(\\boldsymbol{\\theta})=\\frac{1}{2}\\big[f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big]^2之所以要乘以 $\\frac{1}{2}$，是因为在求导后会带来 $\\times 2$，不利于表达与计算，当乘以 $\\frac{1}{2}$ 后，求导带来的 $\\times 2$ 就与 $\\frac{1}{2}$ 抵消，从而简化计算 目标是通过最小化代价函数 $J(\\boldsymbol{\\theta})$ 来在参数空间 $\\Theta$ 中找到合适的 $\\boldsymbol{\\theta}$ 参数，即： \\boldsymbol{\\theta}^*=\\arg \\min_{\\Theta}\\:J(\\boldsymbol{\\theta})在最小化代价函数 $J(\\boldsymbol{\\theta})$ 时，其核心是损失函数对应的梯度函数，即将下列公式重复直到收敛为止： \\boldsymbol{\\theta_{k+1}} = \\boldsymbol{\\theta_k} - \\alpha \\frac{\\partial}{\\partial \\boldsymbol{\\theta_k}}J(\\boldsymbol{\\theta_k})根据链式法则：若 $z=f[g(x)]$，则 $z’=f[g(x)]’+g(x)’$ 则对于偏导数项 $\\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J( \\boldsymbol{\\theta})$ 有： \\begin{align} \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J( \\boldsymbol{\\theta}) &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\frac{1}{2}\\big[f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big]^2 \\notag \\\\ &= \\frac{1}{2} \\cdot \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\Big[\\big(f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big)^2\\Big] \\cdot \\Big[ \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta}) - y_i\\big)\\Big] \\notag \\\\ &= \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big) \\cdot \\Big[ \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta}) - y_i\\big)\\Big] \\notag \\\\ &= \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big) \\cdot \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\bigg( \\sum_{j=0}^m \\theta^{(j)} x_i^{(j)} - y_i \\bigg) \\notag \\\\ &= \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big) \\cdot \\bigg[ \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\sum_{j=0}^m \\theta^{(j)} x_i^{(j)} - 0 \\bigg] \\notag \\\\ &= \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big) \\cdot \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\big(\\theta^{(0)}x_i^{(0)}+\\theta^{(1)}x_i^{(1)}+...+\\theta^{(m)}x_i^{(m)}\\big) \\notag \\end{align}对于求和函数展开的部分，当对其中第 $j$ 项求导时，其余各项实际上就是一个常数，它们在求导这一刻是固定不变的，因此有： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} f(\\mathbf{x_i};\\boldsymbol{\\theta}) = 0+...+ \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\theta^{(j)}x_i^{(j)}+...+0对于得到的乘积函数 $\\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\theta^{(j)}x_i^{(j)}$，有： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\theta^{(j)}x_i^{(j)}= x_i^{(j)}将得到的结果组合回去，即有： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} J(\\boldsymbol{\\theta})= \\big[f(\\mathbf{x_i};\\boldsymbol{\\theta}) -y_i\\big] \\cdot x_i^{(j)}故而，只需将下列公式重复至收敛即可： \\boldsymbol{\\theta_{k+1}} = \\boldsymbol{\\theta_k} - \\alpha \\big[f(\\mathbf{x_i};\\boldsymbol{\\theta}) -y_i \\big] \\cdot x_i^{(j)},j = 0,1,...,m其中，$x_i^{(0)}=1$ 关于梯度下降法的具体介绍，详见：梯度下降法 【最小二乘法求解】将数据集 $D$ 写为 $(m+1)\\times n$ 的矩阵，即： X=\\begin{bmatrix} x_{1}^{(0)} & x_{2}^{(0)} & ... & x_{n}^{(0)} \\\\ x_{1}^{(1)} & x_{2}^{(1)} & ... & x_{n}^{(1)} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ x_{1}^{(m)} & x_{2}^{(m)} & ... & x_{n}^{(m)} \\end{bmatrix}同时，将样本中的 $y_i$ 也写为矩阵形式，即输出变量 $Y$ 为 $n\\times 1$ 的列向量： Y=[y_1,y_2,...,y_n]^T \\in \\mathbb{R}^{n}选用残差平方和 RSS 作为损失函数，则有： \\begin{align} J(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n (f(\\mathbf{x_i})-y_i)^2 \\notag \\\\ &= \\sum_{i=1}^n(\\sum_{j=0}^{m+1}\\theta^{(j)}x_{i}^{(j)}-y_i)^2 \\notag \\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 \\notag \\\\ &= (X^T\\boldsymbol{\\theta}-Y)^T(X^T\\boldsymbol{\\theta}-Y) \\notag \\\\ &= (\\boldsymbol{\\theta}^TX -Y^T)(X^T\\boldsymbol{\\theta}-Y) \\notag \\\\ &= \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} -\\boldsymbol{\\theta}^TXY -Y^TX^T\\boldsymbol{\\theta} +Y^TY \\notag \\end{align}要令目标函数最小，显然要令 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=0$ 首先求 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})$，有： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=2XX^T \\boldsymbol{\\theta} -2XY解得： \\boldsymbol{\\theta}=(XX^T)^{-1}XY其中，$XX^T$ 为满秩矩阵，$(XX^T)^{-1}$ 为对应的逆矩阵 因此，只要根据样本给出的输入 $X$ 与输出 $Y$，若 $(XX^T)^{-1}$ 存在，即可计算出 $\\boldsymbol{\\theta}$ 的解析解 关于最小二乘法的具体介绍，详见：最小二乘法 【sklearn 实现】以 sklearn 中的波士顿房价数据集为例，实现多元线性回归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, :-1], data[:, -1]# 模型训练def train_model(features, labels): # 建立线性回归模型 model = LinearRegression() # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3,random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 y_pred = model.predict(x_test) # predict()输入输出均为二维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"一元线性回归","slug":"machine-learning/14.一元线性回归","date":"2019-06-26T05:18:00.000Z","updated":"2023-04-06T06:41:36.299Z","comments":true,"path":"artificial-intelligence/machine-learning/1bfe723c.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/1bfe723c.html","excerpt":"【假设形式】在回归分析中，只有一个自变量和因变量，且因变量和自变量之间是线性关系，一般称为一元线性回归（Unary Linear Regression） 通过线性回归算法，会得到很多的线性回归模型，但是不同的模型对于数据的拟合（描述能力）是不一样的，我们的目的是找到一个能够最精确描述数据之间关系的线性回归模型","text":"【假设形式】在回归分析中，只有一个自变量和因变量，且因变量和自变量之间是线性关系，一般称为一元线性回归（Unary Linear Regression） 通过线性回归算法，会得到很多的线性回归模型，但是不同的模型对于数据的拟合（描述能力）是不一样的，我们的目的是找到一个能够最精确描述数据之间关系的线性回归模型 其假设形式如下： 对于给定的容量为 $n$ 的样本集 $D=\\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\\}$，第 $i$ 组样本中的输入为 $x_i$，输出为 $y_i$ 假设一元线性回归学习到的模型是 $f(x_i;\\theta_0,\\theta_1)=\\theta_0+\\theta_1 x_i$，使得 $f(x_i;\\theta_0,\\theta_1)\\simeq y_i$ 若要使预测更为精确，那么预测就要以现有的数据为根基，尽量的贴合现有数据，使得预测值与真实值的差距尽量小 这就需要一个损失函数 $J(\\theta_0,\\theta_1)$ 来作为衡量预测结果的指标，对于损失函数最小化时的 $\\theta_0$ 与 $\\theta_1$，通常使用最小二乘法或以梯度下降法为代表的迭代法来求解 无论使用何种方法，最终的目标，都是要令这个损失函数的值最小化，即 (\\theta_0^*,\\theta_1^*) = \\arg \\min \\limits_{(\\theta_0,\\theta_1)} \\:J(\\theta_0,\\theta_1)【梯度下降法求解】对于给定的容量为 $n$ 的样本集 $D=\\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\\}$，第 $i$ 组样本中的输入为 $x_i$，输出为 $y_i$ 设习得的模型的假设函数为： f(x_i;\\theta_0,\\theta_1)=\\theta_0+\\theta_1 x_i令损失函数为： J(\\theta_0,\\theta_1) = \\frac{1}{2n} \\sum\\limits_{i=1}^{n} (f(x_i;\\theta_0,\\theta_1) - y_i )^2之所以要乘以 $\\frac{1}{2}$，是因为在求导后会带来 $\\times 2$，不利于表达与计算，当乘以 $\\frac{1}{2}$ 后，求导带来的 $\\times 2$ 就与 $\\frac{1}{2}$ 抵消，从而简化计算 目标是通过最小化代价函数 $J(\\theta_0,\\theta_1)$ 来在参数空间 $\\Theta$ 中找到合适的 $\\theta_0,\\theta_1$ 参数，即： (\\theta_0^*,\\theta_1^*) = \\arg \\min \\limits_{(\\theta_0,\\theta_1)} \\:J(\\theta_0,\\theta_1)在最小化代价函数 $J(\\theta_0,\\theta_1)$ 时，其核心是损失函数对应的梯度函数，使用梯度下降法，即将下列公式重复直到收敛为止： \\boldsymbol{\\theta_{k+1}} = \\boldsymbol{\\theta_k} - \\alpha \\frac{\\partial}{\\partial \\boldsymbol{\\theta_k}}J(\\boldsymbol{\\theta_k})即： \\left\\{\\begin{array}{rl} \\theta_0 & = & \\theta_0 - \\alpha \\sum\\limits_{i=1}^n (f(x_i;\\theta_0,\\theta_1) - y_i) \\\\ \\theta_1 & = & \\theta_1 - \\alpha \\sum\\limits_{i=1}^n (f(x_i;\\theta_0,\\theta_1) - y_i)\\cdot x_i \\end{array} \\right.关于批量梯度下降法的具体介绍，详见：梯度下降法 【最小二乘法求解】当使用最小二乘法来求解时，一般选用残差平方和 RSS 作为损失函数，即： \\begin{align} J(\\theta_0,\\theta_1) & = \\sum_{i=1}^n(f(x_i;\\theta_0,\\theta_1)-y_i)^2 \\notag \\\\ & = \\sum_{i=1}^n( \\theta_0 + \\theta_1 x_i-y_i)^2 \\notag \\end{align}目标是通过最小化代价函数 $J(\\theta_0,\\theta_1)$ 来在参数空间 $\\Theta$ 中找到合适的 $\\theta_0,\\theta_1$ 参数，即： (\\theta_0^*,\\theta_1^*) = \\arg \\min \\limits_{(\\theta_0,\\theta_1)} \\:J(\\theta_0,\\theta_1)在最小化代价函数 $J(\\theta_0,\\theta_1)$ 时，其核心是损失函数对应的梯度函数，分别对 $J(\\theta_0,\\theta_1)$ 分别对 $\\theta_0$、$\\theta_1$ 进行求导，有： \\left\\{\\begin{array}{rl} \\frac{\\partial J(\\theta_0,\\theta_1)}{\\partial \\theta_0} &=& 2\\sum\\limits_{i=1}^n(\\theta_0+\\theta_1 x_i-y_i) \\\\ \\frac{\\partial J(\\theta_0,\\theta_1)}{\\partial \\theta_1} &=& 2\\sum\\limits_{i=1}^n(\\theta_0+\\theta_1 x_i-y_i)x_i \\end{array} \\right.取 $\\overline{x}=\\frac{1}{n}\\sum_\\limits{i=1}^nx_i$，$\\overline{y}=\\frac{1}{n}\\sum_\\limits{i=1}^ny_i$ 令 $\\frac{\\partial J(\\theta_0,\\theta_1)}{\\partial \\theta_0}=0$，$\\frac{\\partial J(\\theta_0,\\theta_1)}{\\partial \\theta_1}=0$，联立后可解得 $\\theta_0$ 和 $\\theta_1$ 的解析解（Analytical Solution）： \\left\\{\\begin{array}{rl} \\theta_0 &=& \\overline{y}- \\overline{x}\\cdot \\frac{\\sum\\limits_{i=1}^n(x_i-\\overline{x})(y_i-\\overline{y})}{\\sum\\limits_{i=1}^n(x-\\overline{x})^2} \\\\ \\theta_1 &=& \\frac{\\sum\\limits_{i=1}^n(x_i-\\overline{x})(y_i-\\overline{y})}{\\sum\\limits_{i=1}^n(x-\\overline{x})^2} \\end{array} \\right.关于普通最小二乘法的具体介绍，详见：最小二乘法 【sklearn 实现】以 sklearn 中的波士顿房价数据集为例，选取该数据集中的 CRIM 特征作为自变量，选用普通最小二乘法实现一元线性回归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import mean_absolute_errorfrom sklearn.metrics import r2_score# 特征提取def deal_data(): boston = load_boston() # sklearn的波士顿房价数据集 df = pd.DataFrame(boston.data, columns=boston.feature_names) df['result'] = boston.target data = np.array(df) return data[:, 0], data[:, -1]# 模型训练def train_model(features, labels): # 由一维变为二维 features = features.reshape(-1,1) labels = labels.reshape(-1,1) # 建立线性回归模型 model = LinearRegression() # 训练 model.fit(features, labels) return model# 模型评估def estimate_model(y_true, y_pred): MSE = mean_squared_error(y_true, y_pred) RMSE = np.sqrt(MSE) MAE = mean_absolute_error(y_true, y_pred) R2 = r2_score(y_true, y_pred) indicators = &#123;\"MSE\": MSE, \"RMSE\":RMSE, \"MAE\":MAE, \"R2\":R2&#125; return indicators# 可视化def visualization(y_true, y_pred, model): # 绘图 plt.plot(range(y_true.shape[0]), y_true, \"b-\") plt.plot(range(y_true.shape[0]), y_pred, \"r-.\") plt.legend([\"original value\", \"predicted value\"]) plt.xlabel(\"samples\", fontsize=\"15\") plt.ylabel(\"y\", fontsize=\"15\") plt.show()if __name__ == \"__main__\": # 特征提取 x, y = deal_data() # 简单交叉验证 x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=0) # 模型训练 model = train_model(x_train, y_train) # 预测结果 x_test = x_test.reshape(-1,1) # 由一维变为二维 y_pred = model.predict(x_test) # predict()输入输出均为二维 y_pred = y_pred.flatten() # 由二维变为一维 print(\"y test:\", y_test[:10]) # 测试集y值 print(\"y pred:\", y_pred[:10]) # 预测y值 # 模型评估 indicators = estimate_model(y_test, y_pred) print(\"MSE:\", indicators[\"MSE\"]) print(\"RMSE:\", indicators[\"RMSE\"]) print(\"MAE:\", indicators[\"MAE\"]) print(\"R2:\", indicators[\"R2\"]) # 可视化 visualization(y_test, y_pred, model)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"最小二乘法","slug":"numerical-analysis/08.最小二乘法","date":"2019-06-24T03:58:00.000Z","updated":"2023-03-31T13:19:54.662Z","comments":true,"path":"mathematics/numerical-analysis/6b330b18.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/6b330b18.html","excerpt":"Reference 如何理解最小二乘法？ 最小二乘法（least sqaure method） Ordinary Least Square(OLS) 普通最小二乘 普通最小二乘法的推导证明 最小二乘法和梯度下降法的区别？ 非线性拟合怎么转化为线性拟合？ 【引入】假设使用五把尺子，分别测量一个线段的长度，测量的结果如下：","text":"Reference 如何理解最小二乘法？ 最小二乘法（least sqaure method） Ordinary Least Square(OLS) 普通最小二乘 普通最小二乘法的推导证明 最小二乘法和梯度下降法的区别？ 非线性拟合怎么转化为线性拟合？ 【引入】假设使用五把尺子，分别测量一个线段的长度，测量的结果如下： 尺子颜色 长度 红 $10.2$ 蓝 $10.3$ 橙 $9.8$ 黄 $9.9$ 绿 $9.8$ 使用不同的尺子测量，由于材质、精度等因素，会有误差出现，这种情况下，日常一般简单的取平均值作为线段的长度，即： \\overline{x} = \\frac{10.2+10.3+9.8+9.9+9.8}{5}=10下面，换一种思路来思考这个问题 首先，将测量得到的值绘制在笛卡尔坐标系中，分别记作 $y_i$，同时将要猜测的线段长度的真实值用平行于横轴的虚线来表示，记作 $y$ 将每个点 $y_i$ 向猜测值 $y$ 作垂线，每个垂线的长度就是 $|y-y_i|$，可以理解为测量值与真实值的误差 由于误差 $|y-y_i|$ 是长度，需要取绝对值，为后续计算方便，直接使用平方来代替误差，即： |y-y_i|\\rightarrow (y-y_i)^2那么，总的误差的平方即为残差平方和（Residual Sum of Squares，RSS）： RSS = \\sum_i(y-y_i)^2关于 RSS 的详细介绍，见：回归问题的评价指标（二） 另一方面，由于猜测值 $y$ 是猜测的，其是不断变换的，那么，$RSS$ 也就不断在变换 勒让德基于误差围绕真值上下波动，提出了最小二乘法（Least Sqaure Method），即让 $RSS$ 最小的 $y$ 就是真实值 $y^*$ y^*=\\arg \\min \\sum_i (y-y_i)^2【概述】最小二乘法（Least Sqaure Method）是回归分析中的标准方法，该方法用于近似超定系统（Overdetermined System）答案，即一组包含未知数的方程组中，如果方程的数量大于未知数的数量，则系统就是一个超定系统，超定系统是无解的，只能求近似解，是一种解析解法 如下图，二维屏幕中有许多点，假设想用一条直线来拟合数据，即期望找到一条直线能最好地穿过这些数据点 在图中，一个点即可构造一个方程，而显然有直线的斜率和截距两个未知数，因此这就是一个超定系统，是无法找到一条完美的直线，使得点均在直线上，因此，我们只能期望找到一条最好的适配直线（Best Fitting Line）来拟合这些数据 在机器学习中，目前应用的最广泛的普通最小二乘法（Ordinary Least Squares，OLS），常通过 OLS 来得到一个使目标函数最小化时的拟合函数的模型，一般形式为： 目标函数=\\sum(观测值-理论值)^2其中，观测值就是给定的多组样本，理论值就是假设的拟合函数，目标函数即损失函数 任务就是得到使目标函数最小化时的拟合函数 【普通最小二乘法】假设形式对于给定的容量为 $n$ 的样本集 $D=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_n},y_n)\\}$，第 $i$ 组样本中的输入 $\\mathbf{x_i}$ 具有 $m$ 个特征值，即：$\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(m)})^T\\in \\mathbb{R}^m$，输出为 $y_i$ 用假设函数 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 来表示对第 $i$ 组数据的预测结果： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}其中，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，即： \\boldsymbol{\\theta}=[\\theta^{(0)},\\theta^{(1)},...,\\theta^{(m)}]^T\\in \\mathbb{R}^{m+1}现在，希望求出相应的 $\\{\\theta^{(i)}\\}^{m+1}_{i=0}$ 来使得 $f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 能够尽量地拟合样本集 $D$ 为了表述方便，对假设函数进行简化，定义一个额外的第 $0$ 个特征量，这个特征量对所有样本的取值全部为 $1$，这使得特征量从过去的 $m$ 个变为 $m+1$ 个，即设：$x_i^{(0)}=1$ 那么假设函数就可以写为： f(\\mathbf{x_i};\\boldsymbol{\\theta})=\\theta^{(0)} x_i^{(0)} + \\theta^{(1)} x_i^{(1)} + \\theta^{(2)} x_i^{(2)} + ... + \\theta^{(m)} x_i^{(m)}将数据集 $D$ 写为 $(m+1)\\times n$ 的矩阵，即： X=\\begin{bmatrix} x_{1}^{(0)} & x_{2}^{(0)} & ... & x_{n}^{(0)} \\\\ x_{1}^{(1)} & x_{2}^{(1)} & ... & x_{n}^{(1)} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ x_{1}^{(m)} & x_{2}^{(m)} & ... & x_{n}^{(m)} \\end{bmatrix}同时，将样本中的 $y_i$ 也写为矩阵形式，即输出变量 $Y$ 为 $n\\times 1$ 的列向量： Y=[y_1,y_2,...,y_n]^T \\in \\mathbb{R}^{n}选用残差平方和 RSS 作为损失函数，则有： \\begin{align} J(\\boldsymbol{\\theta}) &= \\sum_{i=1}^n (f(\\mathbf{x_i})-y_i)^2 \\notag \\\\ &= \\sum_{i=1}^n(\\sum_{j=0}^{m+1}\\theta_jx_{i}^{(j)}-y_i)^2 \\notag \\\\ &= \\sum_{i=1}^n(\\boldsymbol{\\theta}^T\\mathbf{x_i}-y_i)^2 \\notag \\\\ &= (X^T\\boldsymbol{\\theta}-Y)^T(X^T\\boldsymbol{\\theta}-Y) \\notag \\\\ &= (\\boldsymbol{\\theta}^TX -Y^T)(X^T\\boldsymbol{\\theta}-Y) \\notag \\\\ &= \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} -\\boldsymbol{\\theta}^TXY -Y^TX^T\\boldsymbol{\\theta} +Y^TY \\notag \\end{align} 最优化过程要令目标函数最小，显然要令 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=0$ 对于 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})$，有： \\begin{align} \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J(\\boldsymbol{\\theta}) &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}(\\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} -\\boldsymbol{\\theta}^TXY -Y^TX^T\\boldsymbol{\\theta} +Y^TY) \\notag \\\\ &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TX^T\\boldsymbol{\\theta} + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY \\notag \\\\ &= 2XX^T \\boldsymbol{\\theta} -2XY \\notag \\end{align}关于详细证明，见：推导过程 之后，令 $\\frac{\\partial}{\\partial\\boldsymbol{\\theta}}J(\\boldsymbol{\\theta})=0$，则有： \\begin{gather} && 2XX^T \\boldsymbol{\\theta} -2XY = 0 \\notag \\\\ &\\Rightarrow& XX^T\\boldsymbol{\\theta}=XY \\notag \\\\ &\\Rightarrow& (XX^T)^{-1} XX^T\\boldsymbol{\\theta} = (XX^T)^{-1} XY \\notag \\\\ &\\Rightarrow& \\boldsymbol{\\theta}=(XX^T)^{-1} XY \\notag \\end{gather}其中，$XX^T$ 为满秩矩阵，$(XX^T)^{-1}$ 为对应的逆矩阵 因此，只要根据样本给出的输入 $X$ 与输出 $Y$，若 $(XX^T)^{-1}$ 存在，即可计算出 $\\boldsymbol{\\theta}$ 的最优解： \\boldsymbol{\\theta}=(XX^T)^{-1}XY 推导过程首先给出需要用到的矩阵求导公式： 对于 $n\\times 1$ 的列向量 $\\mathbf{x}$，与 $n\\times 1$ 的列向量 $\\mathbf{y}$，分母 $\\mathbf{x}^T\\mathbf{y}=\\mathbf{y}^T\\mathbf{x}$ 为标量，分子 $\\mathbf{x}$ 为向量，求导为分母布局下的标量/向量的形式时，有： \\frac{\\partial (\\mathbf{x}^T \\mathbf{y})}{\\partial \\mathbf{x}} = \\frac{\\partial (\\mathbf{y}^T \\mathbf{x})}{\\partial \\mathbf{x}} = \\mathbf{y}对于 $n\\times 1$ 的列向量 $\\mathbf{x}$，与 $n\\times n$ 的矩阵 $A$，分母 $\\mathbf{x}^TA\\mathbf{x}$ 为标量，分子 $\\mathbf{x}$ 为向量，求导为分母布局下的标量/向量的形式时，有： \\frac{\\partial (\\mathbf{x}^T A \\mathbf{x})}{\\partial \\mathbf{x}} = (A+A^T)\\mathbf{x} 对于下列公式，进行推导： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J(\\boldsymbol{\\theta}) = \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TX^T\\boldsymbol{\\theta} + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY式中，输入 $X$ 为 $(m+1)\\times n$ 的矩阵，输出 $Y$ 为 $n\\times 1$ 的列向量，特征参数 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量 对于上式的第三项： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} Y^TX^T\\boldsymbol{\\theta}由于 $Y^TX^T\\boldsymbol{\\theta}$ 是一个标量，故有： Y^TX^T\\boldsymbol{\\theta} = (\\boldsymbol{\\theta}^TXY )^T=\\boldsymbol{\\theta}^TXY则： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} Y^TX^T\\boldsymbol{\\theta} = \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}\\boldsymbol{\\theta}^TXY因此，可得： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J(\\boldsymbol{\\theta}) = \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} - 2\\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} Y^TY对于上式的第一项： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\theta^TXX^T\\boldsymbol{\\theta}由于 $\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，$XX^T$ 为 $(m+1)\\times (m+1)$ 的矩阵，故 $\\theta^TXX^T\\boldsymbol{\\theta}$ 为标量，求导为分母布局下的标量/向量的形式，故有： \\begin{align} \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\theta^TXX^T\\boldsymbol{\\theta} &= (XX^T+(XX^T)^T) \\boldsymbol{\\theta} \\notag \\\\ &= (XX^T+XX^T) \\boldsymbol{\\theta} \\notag \\\\ &= 2XX^T \\boldsymbol{\\theta} \\notag \\end{align}对于第二项： 2\\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY$\\boldsymbol{\\theta}$ 为 $(m+1)\\times 1$ 的列向量，$X^TY$ 为 $(m+1)\\times 1$ 的矩阵，故 $\\boldsymbol{\\theta}^TXY$ 为标量，求导为分母布局下的标量/向量的形式，故有： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY = XY对于第三项： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY显然有： \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY=0综上，可得： \\begin{align} \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}J(\\boldsymbol{\\theta}) &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY - \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TX^T\\boldsymbol{\\theta} + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}}Y^TY \\notag \\\\ &= \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXX^T\\boldsymbol{\\theta} - 2\\frac{\\partial}{\\partial \\boldsymbol{\\theta}} \\boldsymbol{\\theta}^TXY + \\frac{\\partial}{\\partial \\boldsymbol{\\theta}} Y^TY \\notag \\\\ &= 2XX^T \\boldsymbol{\\theta} -2XY+0 \\notag \\\\ &= 2XX^T \\boldsymbol{\\theta} -2XY \\notag \\end{align}点击返回 【局限性与适用场景】最小二乘法与梯度下降法、拟牛顿法这样的迭代法相比，似乎方便很多，但其仍有局限性 首先，最小二乘法需要计算 $XX^T$ 的逆矩阵 $(XX^T)^{-1}$，有可能这个逆矩阵不存在，这样就无法使用最小二乘法了，此时以梯度下降法为代表的迭代法仍可以使用。当然，可以通过对样本数据进行整理，去掉冗余特征，让 $XX^T$ 的行列式 $|XX^T|\\neq 0$，然后继续采用最小二乘法 其次，当样本特征 $m$ 非常大时，$XX^T$ 是一个 $(m+1)\\times(m+1)$ 的特征矩阵，对其求逆是一个十分耗时的工作，甚至不可行，此时以梯度下降法为代表的迭代法仍可以使用。一般来说，如果没有分布式大数据计算资源，超过 $10000$ 个特征就不建议使用最小二乘法了，如果一定要采用，可以使用 PCA 等降维的方法，降低特征维度后再使用最小二乘法 最后，如果拟合函数不是线性的，那么此时也无法使用最小二乘法，此时以梯度下降法为代表的迭代法仍可以使用。如果一定要采用最小二乘法，一般是利用线性微分方程来表示这个非线性的拟合函数，然后拟合线性微分方程的系数，再计算出对应的非线性函数的参数 下面给出梯度下降法与最小二乘法的对比： 梯度下降法 最小二乘法 学习率 需要选择 不需要选择 计算方式 多次迭代 解析解法，一次运算得出 算法复杂度 $O(km^2)$ $O(m^3)$ 适用情形 无论当特征数量 $m$ 多大均可 需计算矩阵的逆，特征数量 $m$ 较大时运算代价大一般 $n&lt;10000$ 时选用 适用算法 适用非线性、线性模型 只能用于线性模型","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"L-BFGS 算法","slug":"numerical-analysis/07.L-BFGS算法","date":"2019-06-22T11:01:00.000Z","updated":"2023-03-31T13:18:30.514Z","comments":true,"path":"mathematics/numerical-analysis/1b992508.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/1b992508.html","excerpt":"Reference 牛顿法与拟牛顿法学习笔记（五）L-BFGS 算法 Limited-memory BFGS 一文读懂L-BFGS算法 L-BFGS算法介绍 【技术分享】L-BFGS算法 【概述】在 Sherman-Morrison 公式下的 BFGS 算法中，需要用到一个 $N\\times N$ 的矩阵 $G_k$，当 $N$ 很大时，存储这个矩阵将十分消耗计算机的资源","text":"Reference 牛顿法与拟牛顿法学习笔记（五）L-BFGS 算法 Limited-memory BFGS 一文读懂L-BFGS算法 L-BFGS算法介绍 【技术分享】L-BFGS算法 【概述】在 Sherman-Morrison 公式下的 BFGS 算法中，需要用到一个 $N\\times N$ 的矩阵 $G_k$，当 $N$ 很大时，存储这个矩阵将十分消耗计算机的资源 以 $N=100,000$ 为例，其所需要消耗的内存空间如下： \\frac{N\\:阶矩阵字节数\\quad\\quad}{1GB\\:的字节数\\quad\\quad}=\\frac{10^5 \\cdot 10^5 \\cdot 8}{2^{10} \\cdot 2^{10} \\cdot 2^{10}}=74.5\\:GB这对一般的服务器是难以承受的，虽然考虑到矩阵 $G_k$ 是对称阵，使用对称存储的方法内存可以降低一半，但是 $10W$ 规模的数据在机器学习问题中只能算是中小规模 为减少 BFGS 算法迭代过程中的内存开销，有了 L-BFGS 算法（Limited-memory BFGS），其对矩阵 $G_k$ 进行了近似，不再存储完整的矩阵 $G_k$，而是存储计算过程中的向量序列 $\\{\\boldsymbol{\\delta_i}\\}$ 和 $\\{\\mathbf{y_i}\\}$，在需要矩阵 $G_k$ 时，利用这两个向量序列计算来代替 同时，向量序列 $\\{\\boldsymbol{\\delta_i}\\}$ 和 $\\{\\mathbf{y_i}\\}$，也并非每次都存储，而是根据用户机器的内存每次各自存储最新的 $m$ 个，每次计算 $G_k$ 时，都利用这最新的 $m$ 个向量序列进行计算，这样存储就由原来的 $O(N^2)$ 降低到了 $O(mN)$ 【算法原理】L-BFGS 算法的出发点是 BFGS 算法中的迭代式： G_{k+1} = (I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})G_k(I-\\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}记：$\\rho_k=\\frac{1}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}$，$V_k=I-\\rho_k\\mathbf{y_k}\\boldsymbol{\\delta_k}^T$，则上式可写为： G_{k+1}=V_k^TG_kV_k+\\rho_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T若给定初始矩阵 $G_0=I$，则依次可得： \\begin{align} G_1 &= V_0^TG_0V_0+\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^T \\notag \\\\ G_2 &= V_1^TG_1V_1+\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T \\notag \\\\ &= V_1^T(V_0^TG_0V_0+\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^T)V_1+\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T \\notag \\\\ &= V_1^TV_0^TG_0V_0V_1+V_1^T\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^TV_1+\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T \\notag \\\\ G_3 &= V_2^TG_2V_2+\\rho_2\\boldsymbol{\\delta_2}\\boldsymbol{\\delta_2}^T \\notag \\\\ &= V_2^T(V_1^TV_0^TG_0V_0V_1+V_1^T\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^TV_1+\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T)V_2+\\rho_2\\boldsymbol{\\delta_2}\\boldsymbol{\\delta_2}^T \\notag \\\\ &= V_2^TV_1^TV_0^TG_0V_0V_1V_2+V_2^TV_1^T\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^TV_1V_2 + V_2^T\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^TV_2 \\notag \\\\ &\\quad + \\rho_2\\boldsymbol{\\delta_2}\\boldsymbol{\\delta_2}^T \\notag \\\\ ... & \\notag \\end{align}由此，可进行递推，有： \\begin{align} G_{k+1} &= \\quad (V_k^TV_{k-1}^T...V_1^TV_0^T) G_0 (V_0V_1...V_{k-1}V_k) \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T...V_2^TV_1^T)(\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^T)(V_1V_2...V_{k-1}V_k) \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T...V_3^TV_2^T)(\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T)(V_2V_3...V_{k-1}V_k) \\notag \\\\ &\\quad + \\dots \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T)(\\rho_{k-2}\\boldsymbol{\\delta_{k-2}}\\boldsymbol{\\delta_{k-2}}^T)(V_{k-1}V_k) \\notag \\\\ &\\quad + V_k^T(\\rho_{k-1}\\boldsymbol{\\delta_{k-1}}\\boldsymbol{\\delta_{k-1}}^T)V_k \\notag \\\\ &\\quad + \\rho_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T \\notag \\end{align}可见，计算 $G_{k+1}$ 需要用到向量序列 $\\{(\\boldsymbol{\\delta_i},\\mathbf{y_i})\\}_{i=0}^k$，若从 $\\boldsymbol{\\delta_0},\\mathbf{y_0}$ 开始连续地存储 $m$ 组的话，只能依次计算到 $G_m$ 也就是说，如果想要求 $G_{m+1},G_{m+2},…$ 的话，就要考虑丢弃一些最早生成的向量 举例来说，如果要计算 $G_{m+1}$，就保存 $\\{(\\boldsymbol{\\delta_i},\\mathbf{y_i})\\}_{i=1}^{m}$，丢弃 $\\{(\\boldsymbol{\\delta_0},\\mathbf{y_0})\\}$，如果要计算 $G_{m+2}$，就保存 $\\{(\\boldsymbol{\\delta_i},\\mathbf{y_i})\\}_{i=2}^{m+1}$，丢弃 $\\{(\\boldsymbol{\\delta_i},\\mathbf{y_i})\\}_{i=0}^{1}$ 在舍弃一些向量后，就只能近似计算了，当 $k+1&gt;m$ 时，按照上述的 $G_{k+1}$ 可以构造近似计算公式，即： \\begin{align} G_{k+1} &\\approx \\quad (V_k^TV_{k-1}^T...V_{k-m+2}^TV_{k-m+1}^T) G_0 (V_{k-m+1}V_{k-m+2}...V_{k-1}V_k) \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T...V_{k-m+3}^TV_{k-m+2}^T)(\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^T)(V_{k-m+2}V_{k-m+3}...V_{k-1}V_k) \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T...V_{k-m+4}^TV_{k-m+3}^T)(\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T)(V_{k-m+3}V_{k-m+4}...V_{k-1}V_k) \\notag \\\\ &\\quad + \\dots \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T)(\\rho_{k-2}\\boldsymbol{\\delta_{k-2}}\\boldsymbol{\\delta_{k-2}}^T)(V_{k-1}V_k) \\notag \\\\ &\\quad + V_k^T(\\rho_{k-1}\\boldsymbol{\\delta_{k-1}}\\boldsymbol{\\delta_{k-1}}^T)V_k \\notag \\\\ &\\quad + \\rho_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T \\notag \\end{align}若引入 $\\hat{m}=\\min\\{k,m-1\\}$ 则可以将上述的递推式与近似式进行合并，即： \\begin{align} G_{k+1} &= \\quad (V_k^TV_{k-1}^T...V_{k-\\hat{m}+1}^TV_{k-\\hat{m}}^T) G_0 (V_{k-\\hat{m}}V_{k-\\hat{m}+1}...V_{k-1}V_k) \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T...V_{k-\\hat{m}+2}^TV_{k-\\hat{m}+1}^T)(\\rho_0\\boldsymbol{\\delta_0}\\boldsymbol{\\delta_0}^T)(V_{k-\\hat{m}+1}V_{k-m+2}...V_{k-1}V_k) \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T...V_{k-\\hat{m}+3}^TV_{k-\\hat{m}+2}^T)(\\rho_1\\boldsymbol{\\delta_1}\\boldsymbol{\\delta_1}^T)(V_{k-\\hat{m}+2}V_{k-\\hat{m}+3}...V_{k-1}V_k) \\notag \\\\ &\\quad + \\dots \\notag \\\\ &\\quad + (V_k^TV_{k-1}^T)(\\rho_{k-2}\\boldsymbol{\\delta_{k-2}}\\boldsymbol{\\delta_{k-2}}^T)(V_{k-1}V_k) \\notag \\\\ &\\quad + V_k^T(\\rho_{k-1}\\boldsymbol{\\delta_{k-1}}\\boldsymbol{\\delta_{k-1}}^T)V_k \\notag \\\\ &\\quad + \\rho_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T \\notag \\end{align}事实上，根据 BFGS 算法流程可知，$G_k$ 的作用仅用于计算 $G_k\\mathbf{g_k}$ 来获取搜索方向，因此，若能根据上式设计出一种能够快速计算 $G_k\\mathbf{g_k}$ 的算法即可 【算法流程】快速计算 $G_k\\mathbf{g_k}$ 的算法流程如下： Step 1：初始化 \\mathbf{s}=\\left\\{\\begin{array}{rl} 0 ,& k\\leq m \\\\ k-m,& k>m \\end{array} \\right. ,\\quad L=\\left\\{\\begin{array}{rl} k ,& k\\leq m \\\\ m,& k>m \\end{array} \\right. ,\\quad \\mathbf{q_L}=\\mathbf{g_k}Step 2：后向循环 \\begin{align} FOR \\quad i&=L-1,L-2,...,1,0 \\quad \\{ & \\notag \\\\ j &=i+\\mathbf{s}; &&& \\notag \\\\ \\alpha_i &=\\rho_j\\boldsymbol{\\delta_j}^T\\mathbf{q_{i+1}}; && \\notag \\\\ \\mathbf{q_i} &=\\mathbf{q_{i+1}}-\\alpha_i\\mathbf{y_j}; \\notag \\\\ \\}\\quad\\quad\\quad \\notag \\end{align}Step 3：前向循环 \\begin{align} \\mathbf{r_0}=G_0\\mathbf{q_0} \\notag \\\\ FOR \\quad i&=0,1,...,L-2,L-1 \\quad \\{ & \\notag \\\\ j &=i+\\mathbf{s}; &&& \\notag \\\\ \\beta_j &=\\rho_j\\mathbf{y_j}^T\\mathbf{r_{i+1}}; && \\notag \\\\ \\mathbf{r_{i+1}} &=\\mathbf{r_i}+(\\alpha_i - \\beta_i) \\boldsymbol{\\delta_j}; \\notag \\\\ \\}\\quad\\quad\\quad\\quad \\notag \\end{align}最后求出的 $\\mathbf{r_L}$ 即为 $H_k\\mathbf{g_k}$ 的值","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"Broyden 族","slug":"numerical-analysis/06.Broyden族","date":"2019-06-22T07:23:00.000Z","updated":"2023-03-31T13:21:15.619Z","comments":true,"path":"mathematics/numerical-analysis/19c28982.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/19c28982.html","excerpt":"Reference 最优化方法复习笔记（四）拟牛顿法与SR1,DFP,BFGS三种拟牛顿算法的推导与代码实现 Broyden类算法 【DFP 与 BFGS 的关系】对于 DFP 算法来说，其迭代式为：","text":"Reference 最优化方法复习笔记（四）拟牛顿法与SR1,DFP,BFGS三种拟牛顿算法的推导与代码实现 Broyden类算法 【DFP 与 BFGS 的关系】对于 DFP 算法来说，其迭代式为： D_{k+1}=D_k+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}}-\\frac{D_k\\mathbf{y_k}\\mathbf{y_k}^TD_k}{\\mathbf{y_k}^TD_k\\mathbf{y_k}},\\quad k=0,1,2,...利用在 BFGS 算法 中提到的 Sherman-Morrison-Woodbury 公式，对其两边进行求逆（证明过程与 BFGS 中相似），可得： D_{k+1}^{-1} = D_k^{-1}-\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big)\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T} {\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} - \\frac{D_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} - \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^TD_k^{-1}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}对于 BFGS 算法来说，其迭代格式为： B_{k+1}=B_k+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}},\\quad k=0,1,2,...在 BFGS 算法 中，详细证明了使用 Sherman-Morrison-Woodbury 公式后得到的蕴含 $B_{k+1}^{-1}$ 与 $B_k^{-1}$ 的关系式的 BFCS 算法的迭代式，即： B_{k+1}^{-1} = B_k^{-1}-\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big)\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T} {\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} - \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^TB_k^{-1}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}在 拟牛顿迭代法 中，介绍了拟牛顿条件，其对牛顿法迭代过程中的海森矩阵 $H_{k+1}$ 进行约束，规定用 $B$ 表示对海森矩阵 $H$ 本身的近似，用 $D$ 表示对海森矩阵的逆 $H^{-1}$ 的近似，即： B\\approx H,\\quad D\\approx H^{-1}因此，有： B^{-1}=D此时再看 DFP 和 BFGS 迭代式与其求逆后的迭代式，可以发现，双方高度对称，只需令 $\\boldsymbol{\\delta_k}\\leftrightarrow \\mathbf{y_k}$，$B_k\\leftrightarrow D_k$，即可在 DFP 和 BFGS 之间相互转换 因此，DFP 与 BFGS 互为对偶 【Broyden 族】既然 DFP 与 BFGS 互为对偶，那么在具体应用中，选择哪一个会更好？ 一个基本的思路是通过若干组实验来测试哪个算法在模型训练过程中更优，或对其进行收敛验证，但这无疑会耗费大量的时间 为此，Broyden 提出了一种较为简易的思路，即将 DFP 的迭代式与 BFGS 的迭代式进行正加权组合 将由 DFP 算法的迭代式得到的 $D_{k+1}$ 记作 $G^{DFP}_{k+1}$，即： G^{DFP}_{k+1}=D_{k+1}=D_k+\\frac{\\mathbf{\\delta_k}\\mathbf{\\delta_k}^T}{\\mathbf{\\delta_k}^T\\mathbf{y_k}}-\\frac{D_k\\mathbf{y_k}\\mathbf{y_k}^TD_k}{\\mathbf{y_k}^TD_k\\mathbf{y_k}},\\quad k=0,1,2,...再将使用 Sherman-Morrison 公式后的 BFGS 算法的迭代式得到的 $G_{k+1}$ 记作 $G^{BFGS}_{k+1}$，即： G^{BFGS}_{k+1}=G_{k+1} = (I-\\frac{\\mathbf{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}})G_k(I-\\frac{\\mathbf{y_k}\\mathbf{\\delta_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}})+\\frac{\\mathbf{\\delta_k}\\mathbf{\\delta_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}}由于 $G^{DFP}_{k+1}$ 与 $G^{BFGS}_{k+1}$ 均满足拟牛顿条件，那么它们的线性组合也满足拟牛顿条件，且是正定的，故有： G^{\\phi}_{k+1}=\\phi_{k} G^{DFP}_{k+1}+(1-\\phi_k)G^{BFGS}_{k+1},\\quad 0\\leq\\phi\\leq 1当 $\\phi_k=0$ 时，$G_{k+1}^{\\phi}$ 为 BFGS 校正，$\\phi_k=1$ 时，$G_{k+1}^{\\phi}$ 为 DFP 校正 随着 $\\phi_k$ 遍历 $[0,1]$ 的值，就可以得到一系列的 $G_{k+1}^{\\phi}$，这一系列的 $G_{k+1}^{\\phi}$ 的集合被称为 Broyden 族","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"BFGS 算法","slug":"numerical-analysis/05.BFGS算法","date":"2019-06-21T05:11:00.000Z","updated":"2023-03-31T13:20:57.459Z","comments":true,"path":"mathematics/numerical-analysis/dec32020.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/dec32020.html","excerpt":"Reference Broyden–Fletcher–Goldfarb–Shanno algorithm Sherman–Morrison formula Woodbury matrix identitty 牛顿法与拟牛顿法学习笔记（四）BFGS 算法 Broyden类算法：BFGS算法的迭代公式推导（应用两次Sherman-Morrison公式） Sherman-Morrison公式在BFGS算法的应用 BFGS算法中Sherman-Morrison-Woodbury公式的使用 【概述】BFCS 算法是建立在阻尼牛顿法之上的，其以发明者 Broyden、Fletcher、Goldfarb、Shanno 四人姓名的首字母命名的，与 DFP 算法相比，其性能更佳，目前已成为求解无约束非线性优化问题的常用方法","text":"Reference Broyden–Fletcher–Goldfarb–Shanno algorithm Sherman–Morrison formula Woodbury matrix identitty 牛顿法与拟牛顿法学习笔记（四）BFGS 算法 Broyden类算法：BFGS算法的迭代公式推导（应用两次Sherman-Morrison公式） Sherman-Morrison公式在BFGS算法的应用 BFGS算法中Sherman-Morrison-Woodbury公式的使用 【概述】BFCS 算法是建立在阻尼牛顿法之上的，其以发明者 Broyden、Fletcher、Goldfarb、Shanno 四人姓名的首字母命名的，与 DFP 算法相比，其性能更佳，目前已成为求解无约束非线性优化问题的常用方法 对于阻尼牛顿法的搜索方向 $\\mathbf{d_k}=-H_k^{-1}\\cdot \\mathbf{g_k}$，根据拟牛顿条件，BFCS 选用近似矩阵 $B_k$ 作为海森矩阵 $H_k$ 的近似，其迭代格式为： B_{k+1}=B_k+\\triangle B_k,\\quad k=0,1,2,...其中，$B_0$ 取单位矩阵 $I$，因此，算法的关键就是每一次迭代的校正矩阵 $\\triangle B_k$ 如何构造 关于拟牛顿条件详见：拟牛顿迭代法 【BFCS 算法】算法原理假设校正矩阵 $\\triangle B_k$ 与拟牛顿条件 $\\mathbf{y_k} = B_{k+1}\\boldsymbol{\\delta_k}$、近似矩阵 $B_k$ 有关 采用待定系数法，设 $\\alpha$、$\\beta$ 为待定系数，向量 $\\boldsymbol{\\mu},\\boldsymbol{\\nu} \\in \\mathbb{R}^n$ 为待定列向量，则校正矩阵 $\\triangle B_k$ 可待定为： \\triangle B_k=\\alpha\\boldsymbol{\\mu}\\boldsymbol{\\mu}^T+\\beta\\boldsymbol{\\nu}\\boldsymbol{\\nu}^T从形式上看，这种待定公式保证了校正矩阵 $\\triangle B_k$ 的对称性 结合拟牛顿条件 $\\mathbf{y_k} = B_{k+1}\\boldsymbol{\\delta_k}$，将 $\\triangle B_k$ 的待定式带入迭代式，有： \\begin{align*} \\mathbf{y_k} &= (B_k+\\triangle B_k)\\boldsymbol{\\delta_k}\\\\ &= B_k\\boldsymbol{\\delta_k}+\\alpha\\boldsymbol{\\mu}\\boldsymbol{\\mu}^T\\boldsymbol{\\delta_k}+\\beta\\boldsymbol{\\nu}\\boldsymbol{\\nu}^T\\boldsymbol{\\delta_k} \\notag \\\\ &= B_k\\boldsymbol{\\delta_k}+\\boldsymbol{\\mu}(\\alpha\\boldsymbol{\\mu}^T\\boldsymbol{\\delta_k})+\\boldsymbol{\\nu}(\\beta\\boldsymbol{\\nu}^T\\boldsymbol{\\delta_k}) \\notag \\\\ &= B_k\\boldsymbol{\\delta_k}+(\\alpha\\boldsymbol{\\mu}^T\\boldsymbol{\\delta_k})\\boldsymbol{\\mu}+(\\beta\\boldsymbol{\\nu}^T\\boldsymbol{\\delta_k})\\boldsymbol{\\nu} \\notag \\end{align*}可以发现，括号中的 $\\alpha\\boldsymbol{\\mu}^T\\boldsymbol{\\delta_k}$ 与 $\\beta\\boldsymbol{\\nu}^T\\boldsymbol{\\delta_k}$ 是两个数，取最简单的情况，进行如下赋值： \\left\\{\\begin{array}{rl} \\alpha\\boldsymbol{\\mu}^T\\boldsymbol{\\delta_k} &=& 1 \\\\ \\beta\\boldsymbol{\\nu}^T\\boldsymbol{\\delta_k} &=& -1 \\end{array} \\right.并将其带回 $\\mathbf{y_k}$ 中，有： \\mathbf{y_k}-B_k\\boldsymbol{\\delta_k}=\\boldsymbol{\\mu}-\\boldsymbol{\\nu}为使上式成立，直接取最简单情况 $\\boldsymbol{\\mu}=\\boldsymbol{\\delta_k}$，$\\boldsymbol{\\nu}=B_k\\boldsymbol{\\delta_k}$，此时，对于待定系数 $\\alpha$、$\\beta$ 有： \\left\\{\\begin{array}{rl} \\alpha &=& \\frac{1}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\\\ \\beta &=& -\\frac{1}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}} \\end{array} \\right.这时，校正矩阵 $\\triangle B_k$ 已构造出来，即： \\triangle B_k=\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}}-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k^T}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}}由于近似矩阵 $D_k$ 为近似成海森矩阵 $H_k$ 的正定矩阵，故有： B_k^T=B_k因此，BFCS 最终的迭代式为： B_{k+1}=B_k+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}},\\quad k=0,1,2,...可以发现，对于 BFGS 与 DFP 相比，除了将近似矩阵 $D$ 换为 $B$ 外，其他地方只是将 $\\boldsymbol{\\delta_k}$ 替换为 $\\mathbf{y_k}$，将 $\\mathbf{y_k}$ 替换为 $\\boldsymbol{\\delta_k}$ 算法流程BFGS 算法的算法流程如下： 给定初值 $\\mathbf{x_0}$ 和精度阈值 $\\varepsilon$，并令 $B_0=I$，$k=0$ 计算梯度向量 $\\mathbf{g_k}$，与搜索方向 $\\mathbf{d_k}=-B_k^{-1}\\cdot \\mathbf{g_k}$ 利用 $\\lambda_k=\\arg \\min\\limits_{\\lambda\\in \\mathbb{R}} f(\\mathbf{x_k}+\\lambda \\mathbf{d_k})$ 得到步长 $\\lambda_k$，并令 $\\boldsymbol{\\delta_k}=\\lambda\\mathbf{d_k}$，$\\mathbf{x_{k+1}}=\\mathbf{x_k} + \\mathbf{\\delta_k}$ 若 $\\mathbf{x_{k+1}}$ 的梯度向量 $\\mathbf{g_{k+1}}$ 的 L1 范数 $||\\mathbf{g_{k+1}}||$ 满足 $||\\mathbf{g_{k+1}}||&lt;\\varepsilon$，则停止迭代，得近似解 $\\mathbb{x}^*=\\mathbf{x_{k+1}}$，否则转至步骤 5 计算两次迭代的梯度差 $\\mathbf{y_k}=\\mathbf{g_{k+1}}-\\mathbf{g_k}$ 计算第 $k+1$ 次的近似矩阵 $B_{k+1}=B_k+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}}$ 令 $k=k+1$，转至步骤 2 【谢尔曼-莫里森公式下的 BFGS 算法】算法原理对于阻尼牛顿法来说，其搜索方向为： \\mathbf{d_k}=-H_k^{-1}\\cdot \\mathbf{g_k}BFGS 算法选择使用近似矩阵 $B_k$ 来作为海森矩阵 $H_k$ 的近似，因此，这不可避免的需要在计算出 $B_k$ 后再求 $B_k^{-1}$，通常情况下，对于 $B_k^{-1}$ 的计算，都是通过解线性方程组 $B_k\\mathbf{d_k}=-\\mathbf{g_k}$ 进行的，这无疑影响了算法的运行速度 为此，在 BFGS 算法的基础上，使用谢尔曼-莫里森公式（Sherman-Morrison Formula），将 BFGS 的迭代式进行改进，直接给出 $B_{k+1}^{-1}$ 与 $B_k^{-1}$ 的关系式，即： B_{k+1}^{-1} = (I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})B_k^{-1}(I-\\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}从而对 BFGS 算法进一步优化，使得整个算法不再需要解线性方程组，仅使用矩阵-向量运算即可完成 为算法流程的清晰性，不再出现矩阵求逆符号，统一将 $B_k^{-1}$ 换为 $G_k$，并称 $G_k$ 为特殊 BFGS 矩阵，即： G_{k+1} =(I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})G_k(I-\\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}算法流程此时 BFGS 算法流程如下： 给定初值 $\\mathbf{x_0}$ 和精度阈值 $\\varepsilon$，并令 $G_0=I$，$k=0$ 计算梯度向量 $\\mathbf{g_k}$，与搜索方向 $\\mathbf{d_k}=-G_k\\cdot \\mathbf{g_k}$ 利用 $\\lambda_k=\\arg \\min\\limits_{\\lambda\\in \\mathbb{R}} f(\\mathbf{x_k}+\\lambda \\mathbf{d_k})$ 得到步长 $\\lambda_k$，并令 $\\boldsymbol{\\delta_k}=\\lambda\\mathbf{d_k}$，$\\mathbf{x_{k+1}}:=\\mathbf{x_k} + \\boldsymbol{\\delta_k}$ 若 $\\mathbf{x_{k+1}}$ 的梯度向量 $\\mathbf{g_{k+1}}$ 的 L1 范数 $||\\mathbf{g_{k+1}}||$ 满足 $||\\mathbf{g_{k+1}}||&lt;\\varepsilon$，则停止迭代，否则转至步骤 5 计算两次迭代的梯度差 $\\mathbf{y_k}=\\mathbf{g_{k+1}}-\\mathbf{g_k}$ 计算第 $k+1$ 次的近似矩阵 $G_{k+1} = (I-\\frac{\\mathbf{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}})G_k(I-\\frac{\\mathbf{y_k}\\mathbf{\\delta_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}})+\\frac{\\mathbf{\\delta_k}\\mathbf{\\delta_k}^T}{\\mathbf{y_k}^T\\mathbf{\\delta_k}}$ 令 $k=k+1$，转至步骤 2 算法推导谢尔曼-莫里森公式谢尔曼-莫里森公式（Sherman-Morrison Formula）是以 Sherman 和 Morrison 命名，在线性代数中，是求解逆矩阵的一种方法，其内容如下： 设 $A\\in \\mathbb{R}^{n\\times n}$ 是非奇异方阵，$\\boldsymbol{\\mu},\\boldsymbol{\\nu} \\in \\mathbb{R}^{n}$，则 $(A+\\boldsymbol{\\mu}\\boldsymbol{\\nu}^T)$ 可逆，当且仅当 $1+\\boldsymbol{\\nu}^TA\\boldsymbol{\\mu}\\neq0$，其逆矩阵为： (A+\\boldsymbol{\\mu}\\boldsymbol{\\nu}^T)^{-1}=A^{-1}-\\frac{A^{-1}\\boldsymbol{\\mu}\\boldsymbol{\\nu}^TA^{-1}}{1+\\boldsymbol{\\nu}^TA^{-1}\\boldsymbol{\\mu}} 通过使用两次 Sherman-Morrison 公式，可以在 BFGS 算法迭代式的基础上得到蕴含 $B_{k+1}^{-1}$ 与 $B_k^{-1}$ 的关系式的 BFCS 算法的迭代式，证明如下： 已知 BFGS 算法迭代式为： B_{k+1}=B_k+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}},\\quad k=0,1,2,...其中，近似矩阵 $B_k\\in \\mathbb{R}^{n\\times n}$ 是可逆的实对称矩阵，梯度差 $\\mathbf{y_k}=\\mathbf{g_{k+1}}-\\mathbf{g_k}\\in \\mathbb{R}^n$，$\\mathbf{x}$ 的增量 $\\boldsymbol{\\delta_k}=\\mathbf{x_{k+1}}-\\mathbf{x_k} \\in \\mathbb{R}^n$ 对于 $-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}}$，有： -\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}} =\\frac{1}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}}(B_k\\boldsymbol{\\delta_k})(B_k\\boldsymbol{\\delta_k})^T其中，$\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}$ 为二次型形式的标量，$B_k\\boldsymbol{\\delta_k}\\in \\mathbb{R}^n$ 记 $A=B_{k}+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}$，那么有： B_{k+1}^{-1}=A+\\frac{1}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}}(B_k\\boldsymbol{\\delta_k})(B_k\\boldsymbol{\\delta_k})^T根据 Sherman-Morrison 公式，有： \\begin{align} B_{k+1}^{-1} &= \\Big(A+\\frac{1}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}}(B_k\\boldsymbol{\\delta_k})(B_k\\boldsymbol{\\delta_k})^T \\Big)^{-1} \\notag \\\\ &= A^{-1} - \\frac{A^{-1} \\Big( -\\frac{1}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}} (B_k\\boldsymbol{\\delta_k}) (B_k\\boldsymbol{\\delta_k})^T \\Big) A^{-1}}{1+ \\Big(-\\frac{1}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}} (B_k\\boldsymbol{\\delta_k})^T A^{-1} (B_k\\boldsymbol{\\delta_k})\\Big)} \\notag \\\\ &= A^{-1}+A^{-1}\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k} - \\boldsymbol{\\delta_k}^TB_kA^{-1}B_k\\boldsymbol{\\delta_k}}A^{-1} \\notag \\end{align}对于 $A=B_{k}+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}$，分母 $\\mathbf{y_k}^T\\boldsymbol{\\delta_k}$ 为标量，再次利用 Sherman-Morrison 公式，有： \\begin{align} A^{-1} &= \\Big( B_k+\\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big)^{-1} \\notag \\\\ &= B_k^{-1}-\\frac{B_k^{-1} \\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} B_k^{-1}}{1+ \\frac{1}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}} \\notag \\\\ &= B_k^{-1}-\\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}+\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}} \\notag \\end{align}其中，分母 $\\mathbf{y_k}^T\\boldsymbol{\\delta_k}$ 是内积形式的标量，$\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}$ 是二次型形式的标量，记： Q=\\mathbf{y_k}^T\\boldsymbol{\\delta_k}+\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}则有： A^{-1}=B_k^{-1}-\\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q}对于 $B_{k+1}^{-1}= A^{-1}+A^{-1}\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k} - \\boldsymbol{\\delta_k}^TB_kA^{-1}B_k\\boldsymbol{\\delta_k}}A^{-1} $，先对后半部分进行化简，有： \\begin{align} 原式 &= A^{-1}\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k} - \\boldsymbol{\\delta_k}^TB_k \\Big(B_k^{-1} -\\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q}\\Big) B_k\\boldsymbol{\\delta_k}}A^{-1} \\notag \\\\ &= A^{-1} \\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k} - \\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}+ \\frac{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}{Q}} A^{-1} \\notag \\\\ &= \\frac{Q}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big( B_k^{-1}-\\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q} \\Big) B_k \\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T B_k A^{-1} \\notag \\\\ &= \\frac{Q}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big( \\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB -\\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^T \\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{Q} \\Big) A^{-1} \\notag \\\\ &\\xlongequal[m=\\mathbf{y_k}^T\\boldsymbol{\\delta_k}]{m=\\boldsymbol{\\delta_k}^T\\mathbf{y_k}} \\frac{Q}{m^2} \\Big( \\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T - \\frac{m\\boldsymbol{\\delta_k}\\mathbf{y_k}^TB_k^{-1}}{Q} - \\frac{B_k^{-1}m\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{Q} + \\frac{B_k^{-1}m^2\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q^2} \\Big) \\notag \\\\ &= \\frac{Q\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m^2} - \\frac{B_k^{-1}\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q} \\notag \\end{align}此时，有： B_{k+1}^{-1} = A^{-1} + \\frac{Q\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m^2} - \\frac{B_k^{-1}\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q}再次将 $A^{-1}=B_k^{-1}-\\frac{B_k^{-1}\\mathbf{y_k}\\mathbf{y_k}^TB_k^{-1}}{Q}$ 代入，化简可得： \\begin{align} B_{k+1}^{-1} &= B_{k}^{-1} + \\frac{Q\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m^2} - \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^TB_k^{-1}}{m} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} \\notag \\\\ &= \\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m}\\Big)B_k^{-1} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{(\\mathbf{y_k}^T\\boldsymbol{\\delta_k}+\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k})\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m^2} \\notag \\\\ &= \\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m}\\Big)B_k^{-1} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m^2} \\notag \\end{align}对于最后一项的分子 $\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T$，由于 $\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}$ 是二次型形式的标量，因此有： \\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T = \\boldsymbol{\\delta_k}\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T故有： \\begin{align} B_{k+1}^{-1} &= \\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m}\\Big)B_k^{-1} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m} \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} \\notag \\\\ &= \\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m}\\Big)B_k^{-1} - \\Big( I- \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m} \\Big) B_k^{-1}\\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} + \\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m} \\notag \\\\ &= \\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{m}\\Big)B_k^{-1}\\Big( I- \\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{m} \\Big) +\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{m} \\notag \\end{align}将 $m=\\mathbf{y_k}^T\\boldsymbol{\\delta_k}$ 带回，有： B_{k+1}^{-1}=\\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\Big) B_k^{-1} \\Big( I- \\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big) +\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}再记 $G_k=B_k^{-1}$，则有： G_{k+1}=\\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\Big) B_k^{-1} \\Big( I- \\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big) +\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}证明完毕 伍德伯里矩阵恒等式伍德伯里矩阵恒等式（Woodbury Matrix Identity）是 Woodbury 在 Sherman-Morrison 公式的基础上进行的一般化推广，推广后的 Sherman-Morrison 公式一般称为 Sherman-Morrison-Woodbury 公式，其内容如下： 设 $A\\in \\mathbb{R}^{n\\times n}$ 是非奇异方阵，$U,V \\in \\mathbb{R}^{n\\times p}$，其中 $1\\leq p \\leq n$，则矩阵 $A+UV^T$ 可逆，当且仅当矩阵 $I+V^TA^{-1}U$ 可逆，且有： (A+UV^T)^{-1}=A^{-1}-A^{-1}U(I+V^TA^{-1}U)^{-1}V^TA^{-1} 对于 BFCS 算法，通过使用两次 Sherman-Morrison 公式，可以在 BFGS 算法迭代式的基础上得到蕴含 $B_{k+1}^{-1}$ 与 $B_k^{-1}$ 的关系式的 BFCS 算法的迭代式 当使用 Sherman-Morrison-Woodbury 公式时，则仅需使用一次即可得到蕴含 $B_{k+1}^{-1}$ 与 $B_k^{-1}$ 的关系式的 BFCS 算法的迭代式，证明如下： 已知 BFGS 算法迭代式为： B_{k+1} = B_k + \\frac{\\mathbf{y_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}-\\frac{B_k\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^TB_k}{\\boldsymbol{\\delta_k}^TB_k\\boldsymbol{\\delta_k}},\\quad k=0,1,2,...其中，近似矩阵 $B_k\\in \\mathbb{R}^{n\\times n}$ 是可逆的实对称矩阵，梯度差 $\\mathbf{y_k}=\\mathbf{g_{k+1}}-\\mathbf{g_k}\\in \\mathbb{R}^n$，$\\mathbf{x}$ 的增量 $\\boldsymbol{\\delta_k}=\\mathbf{x_{k+1}}-\\mathbf{x_k} \\in \\mathbb{R}^n$ 将后两项写成矩阵相乘的形式，有： B_{k+1} = B_k + \\begin{bmatrix} -\\frac{B_k\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}} \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{\\delta_k}^T B_k \\\\ \\mathbf{y_k}^T \\end{bmatrix}记 $U=\\begin{bmatrix}-\\frac{B_k\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} &amp; \\frac{\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}\\end{bmatrix}$，$V=\\begin{bmatrix}B_k\\boldsymbol{\\delta_k} &amp;\\mathbf{y_k}^T\\end{bmatrix}$，则有： B_{k+1}=B_k+UV^T根据 Sherman-Morrison-Woodbury 公式，可得： B_{k+1}^{-1} = B_k^{-1} - B_k^{-1}U (I+V^TB_k^{-1}U)^{-1} V^TB_k^{-1}对于 $I+V^TB_k^{-1}U$，有： \\begin{align} I+V^TB_k^{-1}U &= I + \\begin{bmatrix} \\boldsymbol{\\delta_k}^T B_k \\\\ \\mathbf{y_k}^T \\end{bmatrix} B_k^{-1} \\begin{bmatrix} -\\frac{B_k\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}} \\end{bmatrix} \\notag \\\\ &= I + \\begin{bmatrix} \\boldsymbol{\\delta_k}^T \\\\ \\mathbf{y_k}^T B_k^{-1} \\end{bmatrix} \\begin{bmatrix} -\\frac{B_k\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}} \\end{bmatrix} \\notag \\\\ &= I + \\begin{bmatrix} -1 & 1 \\\\ -\\frac{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}} \\end{bmatrix}\\notag \\\\ &= \\begin{bmatrix} 0 & 1 \\\\ -\\frac{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1 \\end{bmatrix} \\notag \\end{align}对于二阶矩阵来说，若 $\\begin{bmatrix}a&amp;b\\\\c&amp;d\\end{bmatrix}$ 可逆，那么有： \\begin{bmatrix}a&b\\\\c&d\\end{bmatrix} = \\frac{1}{ad-bc} \\begin{bmatrix}d&-b\\\\-c&a\\end{bmatrix}于是，对于 $I+V^TB_k^{-1}U$ 来说，就有： \\begin{align} (I+V^TB_k^{-1}U)^{-1} &=\\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\begin{bmatrix} \\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big) & -1\\\\ \\frac{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & 0 \\end{bmatrix} \\notag \\\\ &= \\begin{bmatrix} \\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big) & -\\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\\\ 1 & 0 \\end{bmatrix} \\notag \\end{align}那么，对于 $B_k^{-1}U (I+V^TB_k^{-1}U)^{-1} V^TB_k^{-1}$，有： \\begin{align} 原式 &= B_k^{-1} \\begin{bmatrix}-\\frac{B_k\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}\\end{bmatrix} \\begin{bmatrix} \\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big) & -\\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{\\delta_k}^T B_k \\\\ \\mathbf{y_k}^T \\end{bmatrix} B_k^{-1} \\notag \\\\ &= \\begin{bmatrix}-\\frac{\\boldsymbol{\\delta_k}}{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}} & \\frac{B_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}} \\end{bmatrix} \\begin{bmatrix} \\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big) & -\\frac{\\boldsymbol{\\delta_k}^T B_k \\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{\\delta_k}^T \\\\ \\mathbf{y_k}^TB_k^{-1} \\end{bmatrix} \\notag \\\\ &= \\begin{bmatrix} -\\frac{\\boldsymbol{\\delta_k}\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big)}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}+\\frac{B_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}} & \\frac{\\boldsymbol{\\delta_k}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{\\delta_k}^T \\\\ \\mathbf{y_k}^TB_k^{-1} \\end{bmatrix} \\notag \\\\ &= \\frac{\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big)\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T} {\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} + \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} + \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^TB_k^{-1}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\notag \\end{align}综上，对于原式 $B_{k+1}^{-1} = B_k^{-1} - B_k^{-1}U (I+V^TB_k^{-1}U)^{-1} V^TB_k^{-1}$，有： \\begin{align} B_{k+1}^{-1} &= B_k^{-1}-\\Big(\\frac{\\mathbf{y_k}^TB_k^{-1}\\mathbf{y_k}}{\\mathbf{y_k}^T \\boldsymbol{\\delta_k}}+1\\Big)\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T} {\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} - \\frac{B_k^{-1}\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} - \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^TB_k^{-1}}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\notag \\\\ &= \\Big( I - \\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big) B_k^{-1} \\Big( I - \\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big) + \\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\notag \\end{align}再记 $G_k=B_k^{-1}$，则有： G_{k+1}=\\Big( I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}\\Big) B_k^{-1} \\Big( I- \\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}} \\Big) +\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}证明完毕","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"DFP 算法","slug":"numerical-analysis/04.DFP算法","date":"2019-06-20T07:31:00.000Z","updated":"2023-03-31T13:20:53.403Z","comments":true,"path":"mathematics/numerical-analysis/45eb9a09.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/45eb9a09.html","excerpt":"Reference 牛顿法与拟牛顿法学习笔记（三）DFP 算法 优化算法——拟牛顿法之DFP算法 Davidon–Fletcher–Powell formula【概述】 DFP 算法是建立在阻尼牛顿法之上的，由 Davidon 提出，后经 Fletcher 和 Powell 加以发展和完善，因此以三人的姓名的首字母命名，是最早的拟牛顿法 对于阻尼牛顿法的搜索方向 $\\mathbf{d_k}=-H_k^{-1}\\cdot \\mathbf{g_k}$，根据拟牛顿条件，DFP 选用 $D_k$ 作为 $H_k^{-1}$ 的近似，其迭代格式为：","text":"Reference 牛顿法与拟牛顿法学习笔记（三）DFP 算法 优化算法——拟牛顿法之DFP算法 Davidon–Fletcher–Powell formula【概述】 DFP 算法是建立在阻尼牛顿法之上的，由 Davidon 提出，后经 Fletcher 和 Powell 加以发展和完善，因此以三人的姓名的首字母命名，是最早的拟牛顿法 对于阻尼牛顿法的搜索方向 $\\mathbf{d_k}=-H_k^{-1}\\cdot \\mathbf{g_k}$，根据拟牛顿条件，DFP 选用 $D_k$ 作为 $H_k^{-1}$ 的近似，其迭代格式为： D_{k+1}=D_k+\\triangle D_k,\\quad k=0,1,2,...其中，$D_0$ 取单位矩阵 $I$，因此，算法的关键就是每一次迭代的校正矩阵 $\\triangle D_k$ 如何构造 关于拟牛顿条件详见：拟牛顿迭代法 【算法原理】假设校正矩阵 $\\triangle D_k$ 与拟牛顿条件 $\\boldsymbol{\\delta_k}=D_{k+1}\\mathbf{y_k}$、近似矩阵 $D_k$ 有关 采用待定系数法，设 $\\alpha$、$\\beta$ 为待定系数，向量 $\\boldsymbol{\\mu},\\boldsymbol{\\nu} \\in \\mathbb{R}^n$ 为待定列向量，则校正矩阵 $\\triangle D_k$ 可待定为： \\triangle D_k=\\alpha\\boldsymbol{\\mu}\\boldsymbol{\\mu}^T+\\beta\\boldsymbol{\\nu}\\boldsymbol{\\nu}^T从形式上看，这种待定公式保证了校正矩阵 $\\triangle D_k$ 的对称性 结合拟牛顿条件 $\\boldsymbol{\\delta_k}=D_{k+1}\\mathbf{y_k}$，将 $\\triangle D_k$ 的待定式带入迭代式，有： \\begin{align} \\boldsymbol{\\delta_k} &= D_{k+1}\\mathbf{y_k} \\notag \\\\ &= (D_k+\\triangle D_k)\\mathbf{y_k} \\notag \\\\ &= D_k\\mathbf{y_k}+\\alpha\\boldsymbol{\\mu}\\boldsymbol{\\mu}^T\\mathbf{y_k}+\\beta\\boldsymbol{\\nu}\\boldsymbol{\\nu}^T\\mathbf{y_k} \\notag \\\\ &= D_k\\mathbf{y_k}+\\boldsymbol{\\mu}(\\alpha\\boldsymbol{\\mu}^T\\mathbf{y_k})+\\boldsymbol{\\nu}(\\beta\\boldsymbol{\\nu}^T\\mathbf{y_k}) \\notag \\\\ &=D_k\\mathbf{y_k}+(\\alpha\\boldsymbol{\\mu}^T\\mathbf{y_k})\\boldsymbol{\\mu}+(\\beta\\boldsymbol{\\nu}^T\\mathbf{y_k})\\boldsymbol{\\nu} \\notag \\end{align}可以发现，括号中的 $\\alpha\\boldsymbol{\\mu}^T\\mathbf{y_k}$ 与 $\\beta\\boldsymbol{\\nu}^T\\mathbf{y_k}$ 是两个数，取最简单的情况，进行如下赋值： \\left\\{\\begin{array}{rl} \\alpha\\boldsymbol{\\mu}^T\\mathbf{y_k} &=& 1 \\\\ \\beta\\boldsymbol{\\nu}^T\\mathbf{y_k} &=& -1 \\end{array} \\right.带回 $\\boldsymbol{\\delta_k}$ 中，有： \\mathbf{\\delta_k}-D_k\\mathbf{y_k}=\\boldsymbol{\\mu}-\\boldsymbol{\\nu}为使上式成立，直接取最简单情况 $\\boldsymbol{\\mu}=\\boldsymbol{\\delta_k}$，$\\boldsymbol{\\nu}=D_k\\mathbf{y_k}$，此时，对于待定系数 $\\alpha$、$\\beta$，有： \\left\\{\\begin{array}{rl} \\alpha &=& \\frac{1}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}} \\\\ \\beta &=& -\\frac{1}{\\mathbf{y_k}^TD_k\\mathbf{y_k}} \\end{array} \\right.这时，校正矩阵 $\\triangle D_k$ 已构造出来，即： \\triangle D_k=\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}}-\\frac{D_k\\mathbf{y_k}\\mathbf{y_k}^TD_k^T}{\\mathbf{y_k}^TD_k\\mathbf{y_k}}由于近似矩阵 $D_k$ 为近似成海森矩阵逆矩阵 $H_k^{-1}$ 的正定矩阵，故有： D_k^T=D_k因此，DFP 最终的迭代式为： D_{k+1}=D_k+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}}-\\frac{D_k\\mathbf{y_k}\\mathbf{y_k}^TD_k}{\\mathbf{y_k}^TD_k\\mathbf{y_k}},\\quad k=0,1,2,...【算法流程】DFP 算法的算法流程如下： 给定初值 $\\mathbf{x_0}$ 和精度阈值 $\\varepsilon$，并令 $D_0=I$，$k=0$ 计算梯度向量 $\\mathbf{g_k}$，与搜索方向 $\\mathbf{d_k}=-D_k\\cdot \\mathbf{g_k}$ 利用 $\\lambda_k=\\arg \\min\\limits_{\\lambda\\in \\mathbb{R}} f(\\mathbf{x_k}+\\lambda \\mathbf{d_k})$ 得到步长 $\\lambda_k$，并令 $\\boldsymbol{\\delta_k}=\\lambda\\mathbf{d_k}$，$\\mathbf{x_{k+1}}=\\mathbf{x_k} + \\boldsymbol{\\delta_k}$ 若 $\\mathbf{x_{k+1}}$ 的梯度向量 $\\mathbf{g_{k+1}}$ 的 L1 范数 $||\\mathbf{g_{k+1}}||$ 满足 $||\\mathbf{g_{k+1}}||&lt;\\varepsilon$，则停止迭代，得近似解 $\\mathbb{x}^*=\\mathbf{x_{k+1}}$，否则转至步骤 5 计算两次迭代的梯度差 $\\mathbf{y_k}=\\mathbf{g_{k+1}}-\\mathbf{g_k}$ 计算第 $k+1$ 次的近似矩阵 $D_{k+1}=D_k+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}}-\\frac{D_k\\mathbf{y_k}\\mathbf{y_k}^TD_k}{\\mathbf{y_k}^TD_k\\mathbf{y_k}}$ 令 $k=k+1$，转至步骤 2","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"拟牛顿迭代法","slug":"numerical-analysis/03.拟牛顿迭代法","date":"2019-06-20T04:47:00.000Z","updated":"2023-03-31T13:21:51.569Z","comments":true,"path":"mathematics/numerical-analysis/374099fe.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/374099fe.html","excerpt":"Reference 牛顿法与拟牛顿法 梯度下降法、牛顿法和拟牛顿法 牛顿法与拟牛顿法学习笔记（二）拟牛顿条件 拟牛顿法 【概述】在 牛顿迭代法 中，介绍了海森矩阵（Hessian Matrix），以及原始牛顿迭代法、阻尼牛顿迭代法","text":"Reference 牛顿法与拟牛顿法 梯度下降法、牛顿法和拟牛顿法 牛顿法与拟牛顿法学习笔记（二）拟牛顿条件 拟牛顿法 【概述】在 牛顿迭代法 中，介绍了海森矩阵（Hessian Matrix），以及原始牛顿迭代法、阻尼牛顿迭代法 牛顿迭代法虽然收敛速度快，但在计算过程中需要计算目标函数 $f(\\mathbf{x})$ 的梯度 $\\triangledown f$ 和二阶偏导数 $\\triangledown^2f $，以及海森矩阵的逆矩阵 $H^{-1}$，计算量大，且有时海森矩阵无法保持正定，使得牛顿迭代法失效 为克服上述的这两个问题，于是提出了拟牛顿法（Quasi Newton Method） 拟牛顿法又称拟牛顿迭代法，其基本思想是：不用二阶偏导数而构造出近似海森矩阵的正定对称矩阵，在拟牛顿的条件下优化目标函数，从而简化计算过程 使用不同的构造构造方法，就产生了不同拟牛顿法，常见的有：DFP 算法、BFGS 算法、L-BFGS 算法等 【拟牛顿条件】拟牛顿条件（Quasi Newton Condition）为拟牛顿法提供理论指导，指出了用来近似海森矩阵 $H$ 的矩阵应满足的条件 对于无约束极小化问题： \\mathbf{x}^*=\\arg \\min_{\\mathcal{X}} f(\\mathbf{x})其中，$\\mathbf{x}=(x^{(1)},x^{(2)},…,x^{(n)})^T\\in \\mathbb{R}^n$，$x^{(i)}$ 为向量 $\\mathbf{x}$ 的第 $i$ 个分量 设经过了 $k+1$ 次迭代后，得到 $\\mathbf{x_{k+1}}$，此时将目标函数 $f(\\mathbf{x})$ 在 $\\mathbf{x_{k+1}}$ 附近利用多元函数的泰勒展开式作二阶展开，有： f(\\mathbf{x}) = f(\\mathbf{x_{k+1}})+\\triangledown f(\\mathbf{x_{k+1}})(\\mathbf{x}-\\mathbf{x_{k+1}})+\\frac{1}{2}(x-\\mathbf{x_{k+1}})^T\\triangledown^2 f(\\mathbf{x_{k+1}})(\\mathbf{x}-\\mathbf{x_{k+1}}) + o(\\mathbf{x}^2)在两边同时作用一个梯度算子 $\\triangledown$，有： \\begin{align} \\triangledown f(\\mathbf{x}) &= \\triangledown f(\\mathbf{x_{k+1}})+\\triangledown^2f(\\mathbf{x_{k+1}})(\\mathbf{x}-\\mathbf{x_{k+1}}) + o(\\mathbf{x}^2) \\notag \\\\ &= \\mathbf{g_{k+1}}+H_{k+1}(\\mathbf{x}-\\mathbf{x_{k+1}}) + o(\\mathbf{x}^2) \\notag \\end{align}其中，$\\mathbf{g_{k+1}}$ 为梯度向量，$H_{k+1}$ 为海森矩阵 取 $\\mathbf{x}=\\mathbf{x_k}$，则 $\\triangledown f(\\mathbf{x})=\\mathbf{g_k}$，故有： \\mathbf{g_k}\\approx\\mathbf{g_{k+1}}+H_{k+1}(\\mathbf{x_k}-\\mathbf{x_{k+1}})移项得： \\mathbf{g_{k+1}}-\\mathbf{g_k}\\approx H_{k+1}(\\mathbf{x_{k+1}}-\\mathbf{x_k})记第 $k$ 次迭代与第 $k+1$ 次迭代的梯度差为 $\\mathbf{y_k}=\\mathbf{g_{k+1}}-\\mathbf{g_k}$，$\\mathbf{x}$ 的增量为$\\boldsymbol{\\delta_k}=\\mathbf{x_{k+1}}-\\mathbf{x_k}$，则有： \\mathbf{y_k} \\approx H_{k+1}\\boldsymbol{\\delta_k}或： \\boldsymbol{\\delta_k} \\approx H_{k+1}^{-1}\\mathbf{y_k}这就是拟牛顿条件，其对牛顿法迭代过程中的海森矩阵 $H_{k+1}$ 进行约束 令 $B$ 表示对海森矩阵 $H$ 本身的近似，用 $D$ 表示对海森矩阵的逆 $H^{-1}$ 的近似，即： B\\approx H,\\quad D\\approx H^{-1}此时，对 $H_{k+1}$ 做近似有 $B_{k+1}$，对 $H_{k+1}^{-1}$ 做近似有 $D_{k+1}$，故拟牛顿条件可写为： \\mathbf{y_k} = B_{k+1}\\boldsymbol{\\delta_k}或 \\boldsymbol{\\delta_k}=D_{k+1}\\mathbf{y_k}【拟牛顿法】在拟牛顿法中，通常选择 $D_{k}$ 作为 $H_{k}^{-1}$ 的近似（DFP 算法），或选择 $B_{k}$ 作为 $H_{k}$ 的近似（BFGS 算法），使其满足拟牛顿条件 从而令搜索方向由 $\\mathbf{d_k}=-H_k^{-1}\\cdot \\mathbf{g_k}$ 近似为 $\\mathbf{d_k}=-D_k\\cdot \\mathbf{g_k}$ 或 $\\mathbf{d_k}=-B_k^{-1}\\cdot \\mathbf{g_k}$ 拟牛顿法具体的算法如下表 方法 迭代式 具体介绍 DFP 算法 $D_{k+1}=D_k+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\boldsymbol{\\delta_k}^T\\mathbf{y_k}}-\\frac{D_k\\mathbf{y_k}\\mathbf{y_k}^TD_k}{\\mathbf{y_k}^TD_k\\mathbf{y_k}}$ DFP 算法 BFGS 算法 $G_{k+1} =(I-\\frac{\\boldsymbol{\\delta_k}\\mathbf{y_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})G_k(I-\\frac{\\mathbf{y_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}})+\\frac{\\boldsymbol{\\delta_k}\\boldsymbol{\\delta_k}^T}{\\mathbf{y_k}^T\\boldsymbol{\\delta_k}}$ BFGS 算法 Broyden 族 $G^{\\phi}_{k+1}=\\phi_{k} G^{DFP}_{k+1}+(1-\\phi_k)G^{BFGS}_{k+1},\\quad 0\\leq\\phi\\leq 1$ Broyden 族 L-BFGS 算法 $-$ L-BFGS 算法","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"牛顿迭代法","slug":"numerical-analysis/02.牛顿迭代法","date":"2019-06-19T01:21:00.000Z","updated":"2023-03-31T13:20:47.759Z","comments":true,"path":"mathematics/numerical-analysis/9550a8b2.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/9550a8b2.html","excerpt":"Reference 多元变量函数，泰勒如何展开？（泰勒展开） 多元函数判断是否为函数值下降方向的直观理解 牛顿法与拟牛顿法学习笔记（一）牛顿法 机器学习笔记-牛顿法 机器学习笔记-牛顿法搜索方向的相关证明 【最优化】无约束优化方法-牛顿法 【最优化】无约束优化方法-阻尼牛顿法 梯度下降法、牛顿法和拟牛顿法 牛顿法与拟牛顿法 【概述】牛顿法（Newton Method）又称牛顿迭代法，其是梯度下降法的进一步发展，是求解非线性优化问题的常用方法","text":"Reference 多元变量函数，泰勒如何展开？（泰勒展开） 多元函数判断是否为函数值下降方向的直观理解 牛顿法与拟牛顿法学习笔记（一）牛顿法 机器学习笔记-牛顿法 机器学习笔记-牛顿法搜索方向的相关证明 【最优化】无约束优化方法-牛顿法 【最优化】无约束优化方法-阻尼牛顿法 梯度下降法、牛顿法和拟牛顿法 牛顿法与拟牛顿法 【概述】牛顿法（Newton Method）又称牛顿迭代法，其是梯度下降法的进一步发展，是求解非线性优化问题的常用方法 梯度下降法利用目标函数的一阶偏导数信息，以负梯度方向作为搜索方向，仅考虑了目标函数在迭代点的局部性质，得到的仅是局部最优解（关于梯度下降法，详见：梯度下降法） 牛顿迭代法在梯度下降法的基础上，进一步利用了目标函数的二阶偏导数，这样就考虑了梯度变化的趋势，能够更加全面地确定合适的搜索方向以加快收敛，其具二阶收敛快速的特点 但牛顿迭代法对目标函数有着较为严格的要求，即函数必须具有连续的一、二阶偏导数，海森矩阵（Hessian Matrix）必须正定，此外，其每一步除了计算梯度外，还需要计算目标函数的海森矩阵与其逆矩阵，计算复杂、存储量大，以维数 $N$ 的平方比增加 牛顿迭代法是二阶收敛，梯度下降法是一阶收敛，因此牛顿迭代法要比梯度下降法更快 如下图，红色路径代表牛顿迭代法，绿色路径代表梯度下降法 【牛顿迭代法的基本原理】牛顿迭代法的原理，是使用函数 $f(x)$ 的泰勒级数，来寻找方程 $f(x)=0$ 根的个数 将 $f(x)$ 在 $x_0$ 处展开成泰勒级数，有： f(x)=f(x_0)+f'(x_0)(x-x_0)+\\frac{f''(x_0)}{2!}(x-x_0)^2+...+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+...取其线性部分的前两项，作为 $f(x)$ 的近似，即用 $f(x_0)+f’(x_0）(x-x_0)=0$ 的解来近似 $f(x)=0$ 的解 取 $x=x_1$，有： x_1=x_0-\\frac{f(x_0)}{f'(x_0)}由于对 $f(x)$ 的近似只是一阶展开，因此 $x_1$ 并非 $f(x)=0$ 的解，只能说 $f(x_1)$ 比 $f(x_0)$ 更加接近于 $0$ 因此，考虑迭代求解： x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}由于最开始是选用 $f(x_0)+f’(x_0)(x-x_0)=0$ 来进行近似，其本质是过点 $(x_0,f(x_0))$ 做曲线 $y=f(x)$ 的切线 $L:y=f(x_0)+f’(x_0)(x-x_0)$，近似解 $x_1=x_0-\\frac{f(x_0)}{f’(x_0)}$ 为 $L$ 与 $x$ 轴交点的横坐标 将上述过程进行推广，可以发现牛顿迭代法实质就是在曲线 $y=f(x)$ 上不断绘制点 $x_i$ 处的切线，来逼近 $f(x)$ 的解 迭代过程可参考下图 【海森矩阵与牛顿方向】对于无约束极小化问题： \\mathbf{x}^*=\\arg \\min_{\\mathcal{X}} f(\\mathbf{x})其中，$\\mathbf{x}=(x^{(1)},x^{(2)},…,x^{(n)})^T\\in \\mathbb{R}^n$，$x^{(i)}$ 为向量 $\\mathbf{x}$ 的第 $i$ 个分量 首先考虑 $n=1$ 的简单情形，此时 $\\mathbf{x}=x$ 设 $x_k$ 为当前的极小点估计值，使用牛顿迭代法进行求解，即在当前极小点估计值 $x_k$ 的附近对 $f(x)$ 做二阶泰勒展开，进而找到极小点的下一个估计值，有： \\varphi(x)=f(x_k)+f'(x_k)(x-x_k)+\\frac{1}{2}f''(x_k)(x-x_k)^2+o^2(x)由于求的是最值，根据极值必要条件，$\\varphi(x)$ 应满足： \\varphi'(x)=0即： f'(x_k)(x-x_k)+\\frac{1}{2}f''(x_k)(x-x_k)^2=0进而有： x=x_k-\\frac{f'(x_k)}{f''(x_k)}于是，若给定初始值 $x_k$，则可构造如下的迭代格式： x_{k+1}=x_k-\\frac{f'(x_k)}{f''(x_k)},\\quad k=0,1,...产生序列 $\\{x_k\\}$ 来逼近 $f(x)$ 的极小点 对于 $n&gt;1$ 的情景，设 $\\mathbf{x_k}$ 为当前的极小点估计值，此时利用多元函数的二阶泰勒展开式，有： \\varphi(\\mathbf{x})=f(\\mathbf{x_k})+\\triangledown f(\\mathbf{x_k})^T(\\mathbf{x}-\\mathbf{x_k})+\\frac{1}{2}(\\mathbf{x}-\\mathbf{x_k})^T\\triangledown^2 f(\\mathbf{x_k})(\\mathbf{x}-\\mathbf{x_k})+o^2(\\mathbf{x})其中，$\\triangledown f$ 为 $f$ 的梯度向量，$\\triangledown^2f$ 为 $f$ 的二阶偏导数构成的方阵，描述了函数的局部曲率，被称为海森矩阵（Hessian matrix） \\triangledown f =\\begin{bmatrix} \\frac{\\partial f}{\\partial x^{(1)}} \\\\ \\frac{\\partial f}{\\partial x^{(2)}} \\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial x^{(n)}} \\end{bmatrix},\\quad \\triangledown^2 f=\\begin{bmatrix} \\frac{\\partial f^2}{\\partial (x^{(1)})^2} &\\frac{\\partial f^2}{\\partial x^{(1)}\\partial x^{(2)}} &... & \\frac{\\partial f^2}{\\partial x^{(1)} \\partial x^{(n)}} \\\\ \\frac{\\partial f^2}{\\partial x^{(2)} \\partial x^{(1)}} &\\frac{\\partial f^2}{\\partial (x^{(2)})^2} &... & \\frac{\\partial f^2}{\\partial x^{(2)} \\partial x^{(n)}} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial f^2}{\\partial x^{(n)} \\partial x^{(1)}} &\\frac{\\partial f^2}{\\partial x^{(n)} \\partial x^{(2)}} &... & \\frac{\\partial f^2}{\\partial (x^{(n)})^2} \\end{bmatrix}$\\triangledown f$ 与 $\\triangledown^2f$ 中的元素均为关于 $\\mathbf{x}$ 的函数，将 $\\triangledown f(\\mathbf{x_k})$ 和 $\\triangledown^2 f(\\mathbf{x_k})$ 简记为 $\\boldsymbol{g_k}$ 和 $H_k$，表示 $\\mathbf{x}$ 取当前极小点估计值 $\\mathbf{x_k}$ 后得到的梯度向量和海森矩阵 同样的，根据极值必要条件，$\\varphi(\\mathbf{x})$ 应满足： \\triangledown \\varphi(\\mathbf{x})=0即： \\boldsymbol{g_k}+H_k(\\mathbf{x}-\\mathbf{x_k})=0若海森矩阵 $H_k$ 为非奇异矩阵（矩阵可逆），则有： \\mathbf{x}=\\mathbf{x_k}-H_{k}^{-1}\\cdot \\boldsymbol{g_k}由此，若给定初值 $x_0$，则可构造如下的迭代格式： \\mathbf{x_{k+1}}=\\mathbf{x_k}-H_k^{-1}\\cdot \\boldsymbol{g_k},\\quad k=0,1,...记： \\boldsymbol{d_k}=-H_k^{-1}\\cdot \\boldsymbol{g_k}$\\boldsymbol{d_k}$ 即为迭代过程中的迭代方向，被称为牛顿方向（Newton Direction），其是指向二次函数最优点的迭代方向，这个方向可正可负 【原始牛顿法】原始牛顿迭代法即最原始的牛顿法（Newton Method），即在每次迭代时，迭代方向取牛顿方向 $\\boldsymbol{d_k}$，每次迭代令 $\\mathbf{x_{k+1}}=\\mathbf{x_k}+\\boldsymbol{d_k}$ 即可 下面给出原始牛顿法的完整算法描述： 给定初值 $\\mathbf{x_0}$ 和精度阈值 $\\varepsilon$，并令 $k=0$ 计算凸函数 $f(\\mathbf{x})$ 的梯度向量 $\\boldsymbol{g_k}$ 和海森矩阵 $H_k$ 若梯度向量的 L1 范数 $||\\boldsymbol{g_k}||$ 满足 $||\\boldsymbol{g_k}||&lt;\\varepsilon$，则停止迭代，否则执行步骤 4 根据牛顿方向 $\\boldsymbol{d_k}=-H_k^{-1}\\cdot \\boldsymbol{g_k}$，计算新的迭代点 $\\mathbf{x_{k+1}}=\\mathbf{x_k}+\\boldsymbol{d_k}$ 令 $k=k+1$，转至步骤 2 如下图所示，实线是目标函数 $f(x)$，虚线是 $f(x)$ 在点 $x$ 处的二阶泰勒展开 由于牛顿方向 $\\boldsymbol{d_k}$ 可正可负，那么就需要知道在满足什么条件下牛顿法的迭代方向是下降的 首先给出下降方向（Descent Direction）的定义： 设 $f:\\mathbb{R}^n\\rightarrow \\mathbb{R}^1$ 在点 $x$ 处可微，若存在 $\\mathbf{p} \\in \\mathbb{R}^n$，使得： \\triangledown f(x)^T \\mathbf{p}0可以发现，这恰好是海森矩阵正定的条件 也就是说，如果想要牛顿方向朝函数值下降的方向移动，就需要当前点的海森矩阵是正定的，而这个要求是极强的 因此，当目标函数是二次正定函数时，由于二阶泰勒展开函数与原目标函数不是近似，而是完全相同的二次式，此时海森矩阵 $H_k$ 退化为一个常数矩阵，从任意一初始点出发，利用迭代式 $\\mathbf{x_{k+1}}=\\mathbf{x_k}-H_k^{-1}\\cdot \\boldsymbol{g_k}$ 只需迭代一次即可达到 $f(x)$ 的极小值点 $x^*$ 而当目标函数非二次函数，若函数的二次性态较强，或迭代点已进入到最优点的较小邻域，则其收敛速度同样很快；反之，则可能会出现函数值可能会上升的情况，即 $f(\\mathbf{x_{k+1}})&gt;f(\\mathbf{x_k})$，在严重的情况下，甚至会导致迭代点列 $\\{\\mathbf{x_k}\\}$ 的发散，以至于计算失败，这表明原始牛顿法不能保证迭代方向一定沿函数值下降方向 【阻尼牛顿法】为解决原始牛顿法不能保证迭代方向一定沿函数值下降方向的问题，出现了阻尼牛顿法（Damped Newton’s Method） 在梯度下降法中，介绍了学习率 $\\alpha$，即迭代步长，但在原始牛顿迭代法中，没有迭代步长这个概念，或者说在确定迭代方向后，迭代步长恒为 $1$ 阻尼牛顿法是确定迭代方向后，继续在该方向进行一维搜索（Line Search），寻找在该迭代方向上最优的迭代步长 $\\lambda$ 阻尼牛顿法的牛顿方向与原始牛顿法一致，仍为 $\\boldsymbol{d_k}=-H_k^{-1}\\cdot \\boldsymbol{g_k}$，寻找的迭代步长为： \\lambda_k=\\arg \\min_{\\lambda\\in \\mathbb{R}} f(\\mathbf{x_k}+\\lambda \\boldsymbol{d_k})在引入步长因子 $\\lambda_k$ 后，迭代式就变为： \\mathbf{x_{k+1}}=\\mathbf{x_k} - \\lambda_k H_k^{-1}\\cdot \\boldsymbol{g_k},\\quad k=0,1,...下面给出阻尼牛顿法的完整算法描述： 给定初值 $x_0$ 和精度阈值 $\\varepsilon$，并令 $k=0$ 计算凸函数 $f(\\mathbf{x})$ 的梯度向量 $\\boldsymbol{g_k}$ 和海森矩阵 $H_k$ 若梯度向量的 L1 范数 $||\\boldsymbol{g_k}||$ 满足 $||\\boldsymbol{g_k}||&lt;\\varepsilon$，则停止迭代，否则确定搜索方向 $\\boldsymbol{d_k}=-H_k^{-1}\\cdot \\boldsymbol{g_k}$ 利用 $\\lambda_k=\\arg \\min\\limits_{\\lambda\\in \\mathbb{R}} f(\\mathbf{x_k}+\\lambda \\boldsymbol{d_k})$ 得到迭代步长 $\\lambda_k$ 令 $\\mathbf{x_{k+1}}=\\mathbf{x_k}- \\lambda_k \\boldsymbol{d_k}$ 令 $k=k+1$，转至步骤 2 需要注意的是，无论是原始牛顿法还是阻尼牛顿法，均涉及到 $H_k^{-1}$ 的计算，在实际应用中，为追求效率，通常不直接对 $H_k$ 求逆，而是将其转换为求解线性方程组 $H_k \\boldsymbol{d_k} = -\\boldsymbol{g_k}$，此时可根据海森矩阵的性态来选择合适的迭代法，例如：预条件共轭梯度法（PCG）、代数多重网格法（AMG）等","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"梯度下降法","slug":"numerical-analysis/01.梯度下降法","date":"2019-06-17T03:12:00.000Z","updated":"2023-03-31T13:19:55.605Z","comments":true,"path":"mathematics/numerical-analysis/14625c0.html","link":"","permalink":"https://alex-mcavoy.github.io/mathematics/numerical-analysis/14625c0.html","excerpt":"Reference 梯度下降法 —— 经典的优化方法 梯度下降算法（Gradient Descent)的原理和实现步骤 详解梯度下降法（干货篇） 什么是梯度下降 梯度下降算法原理讲解——机器学习 随机梯度下降（stochastic gradient descent，SGD） 梯度下降法(Gradient Descent)优化函数的详解（3）小批量随机梯度下降法（mini-batch SGD ） 【概述】梯度下降法（Gradient Descent）不是一个机器学习算法，而是一种基于搜索的最优化方法，其目的是通过迭代来最小化一个效用函数，是求解无约束优化问题最简单、最经典的方法之一","text":"Reference 梯度下降法 —— 经典的优化方法 梯度下降算法（Gradient Descent)的原理和实现步骤 详解梯度下降法（干货篇） 什么是梯度下降 梯度下降算法原理讲解——机器学习 随机梯度下降（stochastic gradient descent，SGD） 梯度下降法(Gradient Descent)优化函数的详解（3）小批量随机梯度下降法（mini-batch SGD ） 【概述】梯度下降法（Gradient Descent）不是一个机器学习算法，而是一种基于搜索的最优化方法，其目的是通过迭代来最小化一个效用函数，是求解无约束优化问题最简单、最经典的方法之一 梯度下降法就好比一个蒙着眼睛的人下山，每次在负梯度最大的方向，向前走一步，走出一步后，比较前后的的落差，若落差小于一定阈值，则认为到达山谷，若落差大于阈值，则继续向前走，直到到达山谷 在机器学习中，绝大多数的机器学习模型都会有一个损失函数，用来衡量机器学习模型的精确度，一般来说，损失函数的值越小，模型的精确度就越高，如果要提高机器学习模型的精确度，就要尽可能的降低损失函数的值，而梯度下降法，就是用来优化损失函数的值的 关于损失函数，详见：机器学习三要素 常见的梯度下降法有：批量梯度下降（Batch Gradient Descent，BGD）、随机梯度下降（Stochastic Gradient Descent，SGD）、小批量梯度下降（Mini-Batch Gradient Descent，MBGD），其中小批量梯度下降法常用于深度学习中进行模型的训练 【梯度】梯度，实际上就是多变量微分的一般化： 单变量函数：梯度就是函数的微分，代表着函数在某个给定点的切线的斜率 多变量函数：梯度是一个向量，梯度的方向指出了函数在给定点上升最快的方向 而这就说明了梯度向量法为何需要求梯度，即梯度的反方向就是函数在给定点下降最快的方向，只要沿着这个方向一直走，就能走到最低点或局部最低点 举例来说，对于函数：J(x,y,z) = 15x + y - 3z，其梯度为： \\bigtriangledown J(x,y,z) = \\left \\langle \\frac{\\partial J}{\\partial x}, \\frac{\\partial J}{\\partial y}, \\frac{\\partial J}{\\partial z} \\right \\rangle = \\left \\langle 15,1,-3 \\right \\rangle【梯度下降法的一般形式】首先给出梯度下降法的一般形式： \\boldsymbol{\\theta_{k+1}}=\\boldsymbol{\\theta_k} - \\alpha \\bigtriangledown J(\\boldsymbol{\\theta})该公式的含义为：对于当前点 $\\boldsymbol{\\theta_k}$，要从这个点走向关于 $\\boldsymbol{\\theta}$ 的函数 $J(\\boldsymbol{\\theta})$ 的最小值点，前进的方向是函数 $J(\\boldsymbol{\\theta})$ 的梯度的反方向，行走一段距离的步长为 $\\alpha$，到达的点即为 $\\boldsymbol{\\theta_k}$ 步长 $\\alpha$ 在机器学习中又被称为学习率（Learning Rate），意味着可以通过控制 $\\alpha$ 来控制每一步走的距离 $\\alpha$ 的设置不能太小，太小会导致收敛慢，也不能设置太大，太大会导致错过最优解，通常来说，需要从小到大，分别测试，来选出一个最优解 当我们到达最优点或局部最优点时，其梯度为 $0$，此时无论步长 $\\alpha$ 为多大，都不会再进行更新 【常见的梯度下降法】随机梯度下降法 SGD在上文中所举的例子即随机梯度下降（Stochastic Gradient Descent，SGD），其每次迭代更新时只用到了一个样本来调整 其一般形式为： \\begin{align} for & \\quad i=1,...,n: \\notag \\\\ &Repeat\\:until\\:convergence: \\notag \\\\ &\\quad \\boldsymbol{\\theta_{k+1}} = \\boldsymbol{\\theta_k} - \\alpha \\big[f(\\mathbf{x_i};\\boldsymbol{\\theta}) -y_i \\big] \\cdot x_i^{(j)},j = 0,1,...,m \\notag \\end{align}SGD 从概率意义上来说，单个样本的梯度是对整个数据集合梯度的无偏估计，但是由于存在着一定的不确定性，即下降路径容易受到训练数据自身噪音的影响，因此在每次迭代更新时并不一定是向最优方向进行的 同时，学习率 $\\alpha$ 不能设置过大，不然容易在最优解附近出现震荡，始终无法解决最优解，但从另一个角度来看，这种在最优解附近出现震荡的路径，在损失的优化路线在损失函数局部极小值较多时，能够有效避免模型陷入局部最优解 虽然 SGD 不是每次迭代得到的损失函数都向着全局最优方向，但是整体方向是向全局最优解前进的，最终的结果往往是在全局最优解附近，这种方法相比于 BGD 来说，收敛的更快，虽然不是全局最优，但很多时候是可以接受的 批量梯度下降法 BGD批量梯度下降（Batch Gradient Descent，BGD）认为，对于 $\\boldsymbol{\\theta}$ 的更新，数据集中的所有样本的损失函数都有贡献，因此，BGD 是计算数据集中所有样本的损失函数的总和后再进行更新 其一般形式为： \\begin{align} &Repeat\\:until\\:convergence: \\notag \\\\ &\\quad \\boldsymbol{\\theta_{k+1}} = \\boldsymbol{\\theta_k} - \\alpha \\frac{1}{n} \\Big[\\sum_{i=1}^n \\big(f(\\mathbf{x_i};\\boldsymbol{\\theta})-y_i\\big) \\Big] \\cdot x_i^{(j)},j = 0,1,...,m \\notag \\end{align}BGD 每迭代更新一次参数，都要使用到数据集中的所有样本，其下降方向是最优方向，学习率 $\\alpha$ 可以设置的比 SGD 大，但计算量大、速度慢，且不支持在线学习 小批量梯度下降法 MBGD小批量梯度下降（Mini-Batch Gradient Descent，MBGD）是为克服 SGD、BGD 两种方法的缺点而出现的，其采用了一种折中手段 MBGD 将数据分为若干批次，按批次更新参数，每一批次中的一组数据共同决定了本次梯度的方向，这样下降起来就不容易跑偏，减少了随机性，同时因为每一批的样本数相较整个数据集来说少了很多，计算量也不是很大，在数据量较大的项目中，可以明显地减少梯度计算的时间 其一般形式为： \\begin{align} for & \\quad i=1,...,n: \\notag \\\\ &Repeat\\:until\\:convergence: \\notag \\\\ &\\quad \\boldsymbol{\\theta_{k+1}} = \\boldsymbol{\\theta_k} - \\alpha \\frac{1}{b} \\Big[\\sum_{k=i}^{i+b-1} \\big(f(\\mathbf{x_k};\\boldsymbol{\\theta})-y_k\\big) \\Big] \\cdot x_k^{(j)},,j = 0,1,...,m \\notag \\\\ &\\quad i=i+b \\notag \\end{align}其中，$b$ 为批大小（Batch Size），即选取的样本数量，一般根据数据集的数据量的实际情况进行选取","categories":[{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/categories/mathematics/"},{"name":"数值分析","slug":"mathematics/numerical-analysis","permalink":"https://alex-mcavoy.github.io/categories/mathematics/numerical-analysis/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"},{"name":"数学","slug":"mathematics","permalink":"https://alex-mcavoy.github.io/tags/mathematics/"},{"name":"数值分析","slug":"numerical-analysis","permalink":"https://alex-mcavoy.github.io/tags/numerical-analysis/"}],"author":"Alex_McAvoy"},{"title":"机器学习中的距离度量","slug":"machine-learning/13.机器学习中的距离度量","date":"2019-06-15T15:37:00.000Z","updated":"2023-03-31T12:34:02.788Z","comments":true,"path":"artificial-intelligence/machine-learning/c13ce69f.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/c13ce69f.html","excerpt":"Reference 距离计算方法总结 几种距离度量方法比较 欧几里得距离、曼哈顿距离和切比雪夫距离 向量相似度匹配之“闵可夫斯基距离” 标准化欧式距离 马氏距离 马氏距离和欧式距离详解 【概述】在机器学习中的分类、聚类问题中，常常需要估算不同样本之间的相似性度量（Similarity Measurement），这时会计算样本间的距离（Distance）来作为度量的标准","text":"Reference 距离计算方法总结 几种距离度量方法比较 欧几里得距离、曼哈顿距离和切比雪夫距离 向量相似度匹配之“闵可夫斯基距离” 标准化欧式距离 马氏距离 马氏距离和欧式距离详解 【概述】在机器学习中的分类、聚类问题中，常常需要估算不同样本之间的相似性度量（Similarity Measurement），这时会计算样本间的距离（Distance）来作为度量的标准 在实际应用中，采用不同的计算距离的方法，关系到处理问题结果的正确与否 【欧氏距离】欧氏距离（Euclidean Distance）是最基础的一种距离，源自欧氏空间中两点间的距离公式 欧氏距离能够体现个体数值特征的绝对差异，所以更多的用于需要从维度的数值大小中体现差异的分析，例如：使用用户行为指标分析用户价值的相似度或差异 当数据集有很多特征，且任意一对个体之间的欧氏距离都相等，那么就无法通过欧氏距离进行比较 二维平面上，$A(x_1,y_1)$ 和 $B(x_2,y_2)$ 两点间的欧氏距离为： E(A,B) = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}三维空间中，$A(x_1,y_1,z_1)$ 和 $B(x_2,y_2,z_2)$ 两点间的欧氏距离为： E(A,B)= \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}对于 $n$ 维实数向量空间 $\\mathbb{R}^n$，其中的任意两个向量 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T\\in \\mathbb{R}^n$， $\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T\\in \\mathbb{R}^n$，它们的欧氏距离为： \\begin{align} E(\\mathbf{x_i},\\mathbf{x_j}) &= \\sqrt{\\sum_{l=1}^n(x_i^{(l)}-x_j^{(l)})^2} \\notag \\\\ &= \\sqrt{(x_i-x_j)(x_i-x_j)^T} \\notag \\end{align}【曼哈顿距离】曼哈顿距离（Manhattan distance），又称曼氏距离，想象在高楼林立的曼哈顿街道上，从一个十字路口开车到另一个十字路口，除非穿越大楼，否则驾驶距离就是这个“曼哈顿距离”，即两个点在标准坐标系上的绝对轴距总和 曼哈顿距离在某些情况下具有极高的稳定性，但是如果数据集中某些特征值很大，用曼哈顿距离的话，这些特征会掩盖其他特征间的邻近关系 二维平面上，$A(x_1,y_1)$ 和 $B(x_2,y_2)$ 两点间的曼哈顿距离为： M(A,B)=|x_1-x_2| + |y_1-y_2|三维空间中，$A(x_1,y_1,z_1)$ 和 $B(x_2,y_2,z_2)$ 两点间的曼哈顿距离为： M(A,B)= |x_1-x_2| + |y_1-y_2| + |z_1-z_2|对于 $n$ 维实数向量空间 $\\mathbb{R}^n$，其中的任意两个向量 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T\\in \\mathbb{R}^n$， $\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T\\in \\mathbb{R}^n$，它们的曼哈顿距离为： E(\\mathbf{x_i},\\mathbf{x_j}) = \\sum_{l=1}^n|x_i^{(l)}-x_j^{(l)}|【切比雪夫距离】定义切比雪夫距离（Chebyshev distance）是向量空间中的一种度量，二个点之间的距离定义为其各坐标数值差的最大值 在国际象棋中，国王从 $A(x_1,y_1)$ 走到 $B(x_2,y_2)$ 最少需要的步数就是切比雪夫距离，即： C(A,B)=\\max (|x_1-x_2|,|y_1-y_2|)对于 $n$ 维实数向量空间 $\\mathbb{R}^n$，其中的任意两个向量 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T\\in \\mathbb{R}^n$， $\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T\\in \\mathbb{R}^n$，它们的欧氏距离为： \\begin{align} E(\\mathbf{x_i},\\mathbf{x_j}) &= \\max\\{ |x_i^{(1)}-x_j^{(1)}|,|x_i^{(2)}-x_j^{(2)}|,...,|x_i^{(n)}-x_j^{(n)}| \\} \\notag \\\\ &= \\max_l\\{|x_i^{(l)}-x_j^{(l)}|\\} \\notag \\\\ &= \\lim_{i\\rightarrow +\\infty} \\sum_{l=1}^n|x_i^{(l)}-x_j^{(l)})|^{\\frac{1}{i}} \\notag \\end{align}注：最后一步由放缩法和夹逼法则推导得来 与曼哈顿距离的转化切比雪夫距离与曼哈顿距离可以互相转化 考虑最简单的情况，在二维坐标系中，设原点为 $(0,0)$ 若用曼哈顿距离表示，与原点距离为 $1$ 的点会构成一个边长为 $\\sqrt 2$ 的正方形 若用切比雪夫距离表示，与原点距离为 $1$ 的点会构成一个边长为 $2$ 的正方形 仔细对比可以发现，这两种距离可以通过某种变换相互转化，即： 将一个点 $(x,y)$ 变为 $(x+y,x-y)$ 后，原坐标系曼哈顿距离 = 新坐标系切比雪夫距离 将一个点 $(x,y)$ 变为 $(\\frac{x+y}{2},\\frac{x-y}{2})$ 后，原坐标系切比雪夫距离 = 新坐标系曼哈顿距离 【闵科夫斯基距离】闵科夫斯基距离（Minkowski Distance），又称闵氏距离或 $L_p$ 距离，其实际上并不是一种距离，而是一组距离的定义 对于 $n$ 维实数向量空间 $\\mathbb{R}^n$，其中的任意两个向量 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T\\in \\mathbb{R}^n$， $\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T\\in \\mathbb{R}^n$，它们的闵氏距离为： L_p(\\mathbf{x_i},\\mathbf{x_j})=\\bigl( \\sum_{l=1}^n |x_i^{(l)}-x_j^{(l)}|^p \\bigr)^{\\frac{1}{p}},\\quad p\\geq1 当 $p=1$ 时，$L_1(\\mathbf{x_i},\\mathbf{x_j})$ 是曼哈顿距离 当 $p=2$ 时，$L_2(\\mathbf{x_i},\\mathbf{x_j})$ 是欧氏距离 当 $p\\rightarrow \\infty$ 时，$L_{\\infty}(\\mathbf{x_i},\\mathbf{x_j})$ 是切比雪夫距离 下图给出了二维空间 $p$ 取不同值时，与原点的距离 $L_p=1$ 的点的图形 根据可变参数 $p$ 的不同，闵氏距离可表示为一类的距离，其包括了曼哈顿距离、欧氏距离、切比雪夫距离，但无论是曼哈顿距离、欧氏距离、切比雪夫距离，都存在明显的缺点 举例来说，对于二维样本（身高，体重），假设有：A(170,50)、B(180,50)、C(170,60)，此时的 A 与 B 闵氏距离等于 A 与 C 的闵氏距离，但身高的 10cm 并不等价于体重的 10kg 也就是说，其将各分量的量纲当做相同来看待，且没有考虑到各个分量的分布可能是不同的 【标准化欧氏距离】标准化欧式距离（Standardized Euclidean distance），是针对欧氏距离的缺点而作的一种改进方案 考虑到数据各维分量的尺度是不同的，那么就先将各分量都进行标准化，使得各维度的数据分别满足标准正态分布 假设样本集 $X$ 的均值为 $m$，标准差为 $s$，那么 $X$ 的标准化变量 $X’$ 表示为： X'=\\frac{X_i-m}{s}对于 $n$ 维实数向量空间 $\\mathbb{R}^{n}$，其中的任意两个向量 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T\\in \\mathbb{R}^n$， $\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T\\in \\mathbb{R}^n$ 的标准化欧氏距离为： SE(\\mathbf{x_i}',\\mathbf{x_j}')= \\sqrt{\\sum_{l=1}^n(\\frac{x_i^{(l)}-x_j^{(l)}}{s_l})^2}如果将方差的倒数看成是一个权重，这个公式可以看成是一种加权欧氏距离（Weighted Euclidean distance） 在实际应用中，对长方体区域进行聚类的时，按照普通的距离聚类大多是圆形的区域，无法满足要求，这时候要采用标准的欧式距离 举例来说，当对于长宽比为 $2:1$ 的矩形进行聚类时，采用标准欧拉距离有： s=\\sqrt{(\\frac{x_2-x_1}{2})^2+(\\frac{y_2-y_1}{1})^2}【马氏距离】引入下图有两个正态分布总体，他们的均值分别是 $a$、$b$，但方差不同，现在有一点 $A$，则 $A$ 点离哪个总体更近一些？或者说 $A$ 有更大的概率属于谁？ 若以欧式距离来计算，那么显然 A 属于 b，但以马氏距离来看，A 离左边的 a 更近一些。 马氏距离能够表示点与一个分布之间的距离，它是一种有效的计算两个未知样本集的相似度的方法。 定义马氏距离（Mahalanobis Distance）是一种基于样本分布的一种距离，其量纲无关，能排除变量之间的相关性的干扰 就其物理意义而言，马氏距离是在规范化的主成分空间中的欧式距离。规范化的主成分空间是指利用主成分分析对一些数据进行主成分分解，再对所有主成分分解轴归一化，形成新的坐标轴，由这些坐标轴张成的空间就是规范化的主成分空间 马氏距离的计算是建立在总体样本的基础上，如果拿同样的两个样本，放在两个不同的总体中，最后计算出的两个样本间的马氏距离通常是不同的，除非这两个总体的协方差矩阵正好相同 假设有 $M$ 个样本 $X_1,X_2,…,X_m$，他们的协方差矩阵记为 $S$，均值记为向量 $\\boldsymbol{\\mu}$，则其中样本向量 $X$ 到 $\\mu$ 的马氏距离为： D(X)=\\sqrt{(X-\\boldsymbol{\\mu})^TS^{-1}(X-\\boldsymbol{\\mu})}若协方差矩阵是单位矩阵，即各样本向量之间独立同分布，则 $X_i$ 与 $X_j$ 的马氏距离等于他们间的欧氏距离，即： D(X_i,X_j)=\\sqrt{(X_i-X_j)^T(X_i-X_j)}在计算马氏距离时，要求总体样本数大于样本维度数，否则得到的总体样本协方差矩阵逆矩阵不存在。而总体样本数小于样本维度时，用欧式距离计算即可 【余弦距离】几何中，余弦距离（Cosine Distance）可用来衡量两个向量方向的差异，在机器学习中，借用这一概念来衡量样本向量间的差异 二维平面上，$A(x_1,y_1)$、$B(x_2,y_2)$ 两向量间的余弦距离为： \\begin{align*}cos\\theta &= \\frac{A \\cdot B}{|A| |B|} \\\\ &= \\frac{x_1x_2+y_1y_2}{\\sqrt{x_1^2+y_1^2}\\sqrt{x_2^2+y_2^2}} \\end{align*}对于 $n$ 维实数向量空间 $\\mathbb{R}^n$，其中的任意两个向量 $\\mathbf{x_i}=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T\\in \\mathbb{R}^n$， $\\mathbf{x_j}=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T\\in \\mathbb{R}^n$ 的余弦距离为： \\begin{align*}cos\\theta &= \\frac{\\mathbf{x_i} \\cdot \\mathbf{x_j}}{|\\mathbf{x_i}| |\\mathbf{x_j}|} \\\\ &= \\frac{\\sum\\limits_{l=1}^nx_i^{(l)}x_j^{(l)}}{\\sqrt{\\sum\\limits_{l=1}^nx_i^{(l)}}\\sqrt{\\sum\\limits_{l=1}^n x_j^{(l)}}} \\end{align*}夹角余弦的取值范围为 $[-1,1]$，余弦越大表示两个向量的夹角越小，余弦越小表示两向量的夹角越大，当两个向量的方向相同时，余弦取最大值 $1$；当两个向量方向完全相反时，余弦取最小值 $-1$ 【汉明距离】汉明距离（Hamming distance）是一个概念，它定义为两个数字对应二进制位不同的位置的数目，其在信息论、密码学等领域都有应用。 例如：1011101 与 1001001 之间的汉明距离是 2 【杰卡德距离】定义在给出杰卡德距离的定义前，先引入杰卡德相似系数（Jaccard Similarity Coefficient） 杰卡德相似系数是衡量两个集合的相似度的一种指标，其定义为两个集合 $A$ 和 $B$ 的交集元素在 $A$、$B$ 的并集中所占的比例，一般用 $J(A,B)$ 来表示 $A$、$B$ 两个集合的杰卡德相似系数 即： J(A,B)=\\frac{|A \\cap B|}{|A \\cup B|}而杰卡德距离（Jaccard Distance）与杰卡德相似系数相反，其用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度即： J_{\\delta}(A,B)=1-J(A,B)=\\frac{|A \\cup B|-|A \\cap B|}{|A \\cup B|}应用在实际应用中，一般将杰卡德相似系数用于衡量样本的相似度 假设样本 $A$ 与样本 $B$ 是两个 $n$ 维向量，且所有维度的取值都是 $0$ 或 $1$，例如：$A(0,1,1,1)$ 和 $B(1,0,1,1)$ 将每个样本看成是一个集合，$1$ 表示集合包含该元素，$0$ 表示集合不包含该元素 定义： $p$ ：样本 $A$ 与 $B$ 都是 $1$ 的维度的个数 $s$ ：样本 $A$ 与 $B$ 都是 $0$ 的维度的个数 $q$ ：样本 $A$ 是 $1$，样本 $B$ 是 $0$ 的维度的个数 $r$：样本 $A$ 是 $0$，样本 $B$ 是 $1$ 的维度的个数 那么样本 $A$ 与 $B$ 的杰卡德相似系数可以表示为： J=\\frac{p}{p+q+r}这里的 $p+q+r$ 可理解为 $A$ 与 $B$ 的并集的元素个数，而 $p$ 可理解为 $A$ 与 $B$ 的交集的元素个数 而样本 $A$ 与 $B$ 的杰卡德距离表示为： J_{\\delta}=\\frac{q+r}{p+q+r}","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"分类问题的评价指标（四）","slug":"machine-learning/12.分类问题的评价指标（四）","date":"2019-06-15T08:52:00.000Z","updated":"2023-03-31T12:42:58.419Z","comments":true,"path":"artificial-intelligence/machine-learning/40b9080e.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/40b9080e.html","excerpt":"【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上 对于分类问题来说，其根据所分类别的个数，可分为二分类问题、多分类问题","text":"【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上 对于分类问题来说，其根据所分类别的个数，可分为二分类问题、多分类问题 在二分类问题中，使用的评价指标有：误差率（Error Rate）、准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1 score）、$F_\\beta$ 分数（$F_\\beta$ score）、PR 曲线、ROC 曲线、AUC、代价敏感错误率（Cost-sensitive Error Rate）、代价曲线（Cost Curve）等 在多分类问题中，使用的评价指标有： 宏精确率（macro-P）、宏召回率（macro-R）、宏 F1（macro-F1） 、微精确率（micro-P）、微召回率（micro-R）、微F1（micro-F1）等 本文将详细介绍多分类问题中的评价指标 【混淆矩阵】在 分类问题的评价指标（一） 中介绍了混淆矩阵，对于多分类问题，每两两类别组都会对应一个混淆矩阵，此时，$n$ 个类别即有 $\\frac{n(n-1)}{2}$ 个混淆矩阵 如下图所示，总共有 $1$、$2$、$3$、$4$ 四种类别，则共有 $6$ 个混淆矩阵 此外，还可以将 $n$ 个类别对应的 $\\frac{n(n-1)}{2}$ 个混淆矩阵写为一个 $n\\times n$ 的矩阵 【宏精确率、宏召回率、宏 F1 分数】最直接的评估方法是在各混淆矩阵上分别计算出精确率与召回率，记为：$(P_1,R_1),(P_2,R_2),…,(P_n,R_n)$，之后再计算平均值，这样就得到了宏精确率（macro-P）和宏召回率（macro-R），即： \\begin{gather} P_{macro} = \\frac{1}{n} \\sum_{i=1}^n P_i \\notag \\\\ R_{macro} = \\frac{1}{n} \\sum_{i=1}^n R_i \\notag \\end{gather}进一步，利用 macro-P 和 macro-R，带入 F1 分数的公式中，即可得到宏 F1 得分（macro-F1），即： \\frac{2}{F1_{macro}}=\\frac{1}{P_{macro}}+\\frac{1}{R_{macro}}化简即得： F1_{macro}=\\frac{2\\cdot P_{macro}\\cdot R_{macro}}{P_{macro}+R_{macro}}【微精确率、微召回率、微 F1 分数】除上述的将各混淆矩阵的精确率、召回率分别计算后求平均外，还可先将各混淆矩阵的对应元素进行平均，得到 TP、FP、TN、FN 的平均值，再基于平均值计算微精确率（micro-P）、微召回率（micro-R） 将 TP、FP、TN、FN 的平均值记为：$\\overline{TP}$、$\\overline{FP}$、$\\overline{TN}$、$\\overline{FN}$ 则微精确率和微召回率为： \\begin{gather} P_{micro} = \\frac{\\overline{TP}}{\\overline{TP}+\\overline{FP}} \\notag \\\\ R_{micro} = \\frac{\\overline{TP}}{\\overline{TP}+\\overline{FN}} \\notag \\end{gather}进一步，利用 micro-P 和 micro-R，带入 F1 分数的公式中，即可得到微 F1 得分（micro-F1），即： \\frac{2}{F1_{micro}}=\\frac{1}{P_{micro}}+\\frac{1}{R_{micro}}化简即得： F1_{micro}=\\frac{2\\cdot P_{micro}\\cdot R_{micro}}{P_{micro}+R_{micro}}","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"分类问题的评价指标（三）","slug":"machine-learning/11.分类问题的评价指标（三）","date":"2019-06-13T03:15:00.000Z","updated":"2023-03-31T12:42:57.551Z","comments":true,"path":"artificial-intelligence/machine-learning/f794116b.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/f794116b.html","excerpt":"Reference Explicitly Representing Expected Cost Cost curves: An improved method for visualizingclassifier performance 机器学习模型性能评估二：代价曲线与性能评估方法总结 模型评估与选择（后篇）-代价曲线 西瓜书《机器学习》阅读笔记4——Chapter2_代价曲线 【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上","text":"Reference Explicitly Representing Expected Cost Cost curves: An improved method for visualizingclassifier performance 机器学习模型性能评估二：代价曲线与性能评估方法总结 模型评估与选择（后篇）-代价曲线 西瓜书《机器学习》阅读笔记4——Chapter2_代价曲线 【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上 对于分类问题来说，其根据所分类别的个数，可分为二分类问题、多分类问题 在二分类问题中，使用的评价指标有：误差率（Error Rate）、准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1 score）、$F_\\beta$ 分数（$F_\\beta$ score）、PR 曲线、ROC 曲线、AUC、代价敏感错误率（Cost-sensitive Error Rate）、代价曲线（Cost Curve）等 在多分类问题中，使用的评价指标有： 宏精确率（macro-P）、宏召回率（macro-R）、宏 F1（macro-F1） 、微精确率（micro-P）、微召回率（micro-R）、微F1（micro-F1）等 本文将详细介绍代价敏感错误率（Cost-sensitive Error Rate）、代价曲线（Cost Curve） 【误分类代价与代价矩阵】在 分类问题的评价指标（二） 中，简单提及了误分类代价 $C(-|+)$ 与 $C(+|-)$ ，下面将详细进行介绍 现实情况中，不同的错误造成的后果不同，为权衡不同错误造成的不同损失，为错误赋予非均等代价（Unequal Cost） 对于二分类问题，设定一个代价矩阵（Cost Matrix），用误分类代价 $C(j|i)$ 代表第 $i$ 类样本预测为第 $j$ 类样本的代价，且 $C(i|i)=0$，此处的代价是指的比值，即 5：1 与 50：10 的效果相当 若将第 $0$ 类判别为第 $1$ 类所造成的损失更大，则 $C(1|0)&gt;C(0|1)$，损失程度相差越大，$C(1|0)$ 与 $C(0|1)$ 差别越大 如下图，设第 $0$ 类为负类，第 $1$ 类为正类，则 $cost_{01}$ 是负类样本被预测为正类样本的代价，$cost_{10}$ 是正类样本为预测为负类样本的代价 【代价敏感错误率】在均等代价下，错误率大多都是直接计算错误次数，并没有考虑不同错误造成不同的后果，在非均等代价下，我们希望的不再是最小化错误次数，而是最小化总体代价（Total Cost） 对于样本容量为 $n$ 的测试集 $T$，若将第 $1$ 类作为正类，第 $0$ 类作为负类，令 $T^+$ 表示测试集的正类集，$T^-$ 表示测试集的负类集，对于学习到的模型为 $Y=f(X;\\boldsymbol{\\theta})$，代价敏感错误率（Cost-sensitive Error Rate）定义为： E_T(f;cost) = \\frac{1}{n} \\bigl[ \\sum_{x_i\\in T^+} I(f(\\mathbf{x_i};\\boldsymbol{\\theta})\\neq y_i) \\cdot C(0|1) + \\sum_{x_i\\in T^-} I(f(\\mathbf{x_i};\\boldsymbol{\\theta})\\neq y_i) \\cdot C(1|0)\\bigr]此外，如果令 $C(j|i)$ 中 $i$、$j$ 的取值不仅限于 $0$、$1$，则可定义出多分类问题的代价敏感性能度量标准 【代价曲线】ROC 曲线无法直接反应期望总体代价，为解决该问题，引入了代价曲线（Cost Curve） 均等代价下的代价曲线在均等代价下，即 $C(-|+)=C(+|-)$ 时，此时期望代价就是错误率，且运行条件（Operating Condition）就是数据集中正类所占的比例 $p(+)$ 关于运行条件（Operating Condition）详见：分类问题的评价指标（二） 我们希望用实际使用时的性能来评估分类器，但实际数据集中的正类所占比例 $p(+)$ 是未知的，因此应该得到所有可能的 $p(+)$ 值上的性能来对分类器进行评估 此时，绘制一个二维坐标系统，的 $x$ 轴是 $p(+)$，$y$ 轴是错误率，当 $x=0$ 时，意味着数据集中全是反例，一个分类器在该数据集上的整体错误率就等于将所有正例预测为反例的概率，即 FNR；当 $x=1$ 时，意味着数据集中全是正例，一个分类器在该数据集上的整体错误率就等于将反例预测为正例的概率，即 FPR 这样一来，在 ROC 空间中的一个分类器所对应的点，在该二维坐标系统中就成了一条线段，这个二维坐标系统中的所有线段所围成的下包络线，就是在误分类代价等价下的代价曲线 非均等代价下的代价曲线下面从均等代价向非均等代价推广 在非均等代价下，即 $C(-|+)\\neq C(+|-)$ 时，考虑所有可能的运行条件（Operating Condition），即考虑所有的 （类别分布，误分类代价）对，此时，一个分类器的期望代价为： E(Cost)=FNR*p(+)*C(-|+)+FPR*p(-)*C(+|-)最大期望代价是在所有的样本都被错误分类，即 $FNR=FPR=1$ 时，此时有： \\max E(Cost)=p(+)*C(-|+)+p(-)*C(+|-)通过期望代价对最大期望代价进行归一化，有： E_{Norm}(Cost) =\\frac{FNR*p(+)*C(-|+)+FPR*p(-)*C(+|-)}{p(+)*C(-|+)+p(-)*C(+|-)}此时，归一化后的最大期望代价 $E_{Norm}(Cost)$，即非均等代价下的代价曲线的纵轴，其取值范围是 $[0,1]$ 回过头来看 ROC 空间中的一个点 $(TPR,FPR)$，由于 $TPR=1-FNR$ 那么，由于在均等代价下，ROC 空间与 CC 空间中的直线是一一对应的，可以视为不严格的对偶（Dual），那么在从均等代价向非均等代价推广过程中也应当极力保障这个性质，这样可以对模型的分析、评价带来极大的便捷 为了配合纵轴的归一化思路，只有对横轴进行同样的操作才可确保直线，即在数据集中正类所占的比例 $p(+)$ 的基础上引入包含误分类代价的信息，有： p(+)*C(-|+)之后再进行归一化： PC(+) =\\frac{p(+)*C(-|+)}{p(+)*C(-|+)+p(-)*C(+|-)}此时，归一化后的引入误分类代价信息的在数据集中正类所占的比例 $PC(+)$，即非均等代价下的代价曲线的横轴，其取值范围是 $[0,1]$ 类似的，还可定义 $PC(-)$，即： PC(-) =\\frac{p(-)*C(+|-)}{p(+)*C(-|+)+p(-)*C(+|-)}由于 $p(+)=1-p(-)$，易得： PC(-)=1-PC(+)将上式带入归一化后的最大期望代价 $E_{Norm}(Cost)$，有： E_{Norm}(Cost)=FNR*PC(+)+FPR*(1-PC(+))将 $PC(+)\\in[0,1]$ 整体看作自变量，至此，就得到了非等价代价下的代价曲线的线性参数方程，其绘制出的图形是一条左端点位于点 $(0,FPR)$，右端点位于点 $(1,FNR)$ 的线段 在非均等代价的 CC 空间中所有线段围成下包络线就是非均等代价的代价曲线 ROC 曲线与代价曲线的转换ROC 曲线，它可视化的是 $FPR$（横轴） 和 $TPR$（纵轴）的关系，代价曲线则可视化了正例先验概率 $PC(+)$ 和最小代价期望 $E_{Norm}(Cost)$ 的关系 而 ROC 空间中的一个点是与 CC 空间中的一条线段存在着不严格的对偶关系，也就是说，ROC 曲线与代价曲线是可以互相转换的：一旦获得了 ROC 曲线的所有信息，就可以逐点画出另个坐标系里对应的线段；反之，如果有一条代价曲线，就可以通过画切线，看切线左右的截距来得到 $FPR$ 和 $FNR$，而 $TPR=1-FNR$，进而即可绘制出 ROC 曲线 包络线下的面积在 CC 空间中，任一直线的绘制均与代价无关，那么所有直线拟合出的下包络线即代价曲线，也与代价无关 简单来说，对于分类器，给定一个阈值，相应地统计出一个 $(FPR,FNR)$ 组合，再根据该组合绘制出一条直线，全程没有用到代价 对于已知的 $(FPR,FNR)$ 组合，其在 CC 空间中绘制出的单根线段与横轴间的梯形面积，即模型对于某一阈值的期望总体代价（期望总体错误率） 在代价曲线中，横轴是正例先验概率，即一个关于正例概率 $p$ 的函数，那么，利用积分的方法，即可求出这个梯形面积： \\int_{p\\in[0,1]} err(p)\\: dp = \\int_{p\\in[0,1]} FNR*p+FPR*(1-p)\\:dp既然当给出一个 $(FPR,FNR)$ 组合时，任一直线的绘制与代价无关，那么所有直线拟出的下包络线即代价曲线，也与代价无关 同样，当给定一个正例概率 $p$ 的函数时，代价曲线下的面积即模型对于所有阈值的期望总体代价（期望总体错误率），也可通过积分的方式求出： \\int_{p\\in[0,1]} err(p)\\: dp = \\int_{p\\in[0,1]} \\inf_{(FNR,FPR)\\in\\Omega} FNR*p+FPR*(1-p) \\:dp其中，$\\Omega$ 是一个模型对应的所有 $(FNR,FPR)$ 的集合，即 CC 空间中所有线段的端点，寻找下确界 $\\inf$ 的操作则对应了寻找下包络线","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"分类问题的评价指标（二）","slug":"machine-learning/10.分类问题的评价指标（二）","date":"2019-06-12T08:53:00.000Z","updated":"2023-03-31T12:42:56.477Z","comments":true,"path":"artificial-intelligence/machine-learning/ba8ab239.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/ba8ab239.html","excerpt":"Reference ROC曲线和AUC值 机器学习之分类性能度量指标 : ROC曲线、AUC值、正确率、召回率 模型评估与选择（中篇）-ROC曲线与AUC曲线 西瓜书《机器学习》阅读笔记3——Chapter2_ROC曲线 【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上","text":"Reference ROC曲线和AUC值 机器学习之分类性能度量指标 : ROC曲线、AUC值、正确率、召回率 模型评估与选择（中篇）-ROC曲线与AUC曲线 西瓜书《机器学习》阅读笔记3——Chapter2_ROC曲线 【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上 对于分类问题来说，其根据所分类别的个数，可分为二分类问题、多分类问题 在二分类问题中，使用的评价指标有：误差率（Error Rate）、准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1 score）、$F_\\beta$ 分数（$F_\\beta$ score）、PR 曲线、ROC 曲线、AUC、代价敏感错误率（Cost-sensitive Error Rate）、代价曲线（Cost Curve）等 在多分类问题中，使用的评价指标有： 宏精确率（macro-P）、宏召回率（macro-R）、宏 F1（macro-F1） 、微精确率（micro-P）、微召回率（micro-R）、微F1（micro-F1）等 本文将详细介绍 ROC 曲线、AUC 【ROC 曲线】在根据预测结果对样例进行排序时，排序本身的质量好坏，体现了综合考虑模型在不同任务下的泛化性能的好坏，ROC 正是从这个角度出发来研究模型的泛化性能 ROC 全称是受试者工作特征（Receiver Operating Characteristic），与 P-R 曲线相似，根据模型的预测结果对样例进行排序，按顺序逐个将样本作为正类进行预测，每次计算真正类率（True Positive Rate，TPR）、假正类率（False Positive Rate，FPR），并将他们作为纵轴、横轴来绘制曲线 关于 TPR 与 FPR，详见：分类问题的评价指标（一） 如下图，将 TPR 作为纵轴，FPR 作为横轴，即可绘制出 ROC 曲线 对于样本数据，使用分类器对其进行分类，分类器会给出每个数据为正例的概率，由此可以来设定一个阈值，当某个样本数据被判断为正例的概率大于这个阈值时，即认为该样本为正例，小于则为负例，然后通过计算就可以得到一个 (TPR , FPR) 坐标对，即图像上的一个点，之后通过不断调整这个阈值，就得到若干个点，从而画出一条近似 ROC 曲线，再用线性插值补全间断处 当阈值越大时，就会使越多的样本被分为负例，会使得正例样本被分为负例，从而导致 TPR 下降，同时，负例样本更不会被分为正例，FPR 也会下降，但是影响要比 TPR 小，因此随着阈值的增大，$\\frac{FPR}{TPR}$ 呈上升趋势 当阈值越小时，就会使越多的样本被分为正例，会使得负例样本被分为正例，从而导致 TPR 上升，同时，正例样本会被分为正例，FPR 也会上升，但影响要比 TPR 大，因此，随着阈值的减小，$\\frac{FPR}{TPR}$ 呈下降趋势 举例来说，在医疗诊断中，判断有病的样本，那么将有病的样本找出是主要任务，也就是要求真正类率越高 TPR 越好，而将没病的样本误诊为有病的，也就是要求假正类率 FPR 越低越好，不难发现，TPR 与 FPR 这两个指标是相互制约的 一般来说，分类器会对一批数据的每个样本给出一个是正例的概率，如下图所示，共 $20$ 个样本，class 为实际标签，score 为分类器判断样本为正例的概率 对给出的 score 进行排序，然后依次使用 score 作为阈值，这样就得到了 $20$ 组 (TPR , FPR) 坐标对，绘制出的 ROC 曲线如下 【AUC】与 P-R 曲线类似，在进行模型比较时，如果一个模型的 ROC 曲线被另一个模型的 ROC 曲线完全包住，则可断言后者的性能优于前者，若两模型的 ROC 曲线发生交叉，则难以断言两者的优劣 如果一定要对两交叉的 ROC 曲线对应的模型进行比较，则对两 ROC 曲线下的面积进行比较 AUC（Area Under ROC Curve）被定义为 ROC 曲线下的面积，显然这个面积小于 $1$，又因为 ROC 曲线一般都处于 TPR = FPR 这条直线的上方，因此 AUC 一般都在 $0.5$ 到 $1$ 之间 假设分类器的输出是样本属于正类的置信度 score，那么 AUC 的物理意义就是：任取一对正例、负例样本，正样本的 score 大于负样本的 score 的概率 从图像来看，横轴是假正类率 FPR，即所有实际为负类但被判为正类的概率；纵轴是真正类率 TPR，即所有实际为正类也被判正类的概率 当 TPR = FPR 时，即上图中的虚线，此时无论真实类别为正类还是为负类的样本，分类器将其预测为正类的概率相等，即分类器对于样本毫无区分能力，与掷骰子没有任何区别 而分类器希望达到的效果是：对于真实类别为正类，分类器预测为正类的概率，要大于真实类别为负类，分类器预测为正类的概率，即：TPR &gt; FPR，也就是上图中的实线曲线 在最理想的情况下，没有真实类别为正类，但被错分为负类的样本，即 TPR = 1；也没有真实类别为负类，但被错分为正类的样本，即 FPR = 0，此时，AUC = 1 由此，可以总结出从 AUC 判断分类器优劣的标准： AUC = 1：完美分类器，最理想的情况，实际不存在 0.5 &lt; AUC &lt; 1：优于随机猜测，妥善设定阈值的情况下，模型具备预测价值 AUC = 0.5：与随机猜测一样，模型不具备预测价值 AUC &lt; 0.5：不如随机猜测，但只要总是反预测的话，就优于随机猜测 形式化来看，AUC 考虑的是样本预测的排序质量，因此其与排序误差有着紧密的联系 对于样本容量为 $n$ 的测试集 $T$ 来说，假设有 $n^+$ 个正例和 $n^-$ 个负例，令 $T^+$ 为正类集合，$T^-$ 为负类集合，那么 ROC 曲线上方的面积即排序损失 $\\ell_{rank}$，其被定义为： \\ell_{rank} = \\frac{1}{n^+n^-}\\sum_{x^+\\in T^+} \\sum_{x^-\\in T^-} \\bigl[ I\\bigl(f(x^+)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"分类问题的评价指标（一）","slug":"machine-learning/09.分类问题的评价指标（一）","date":"2019-06-12T06:47:00.000Z","updated":"2023-03-31T12:37:12.020Z","comments":true,"path":"artificial-intelligence/machine-learning/82ea5b3f.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/82ea5b3f.html","excerpt":"【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上 对于分类问题来说，其根据所分类别的个数，可分为二分类问题、多分类问题","text":"【概述】评价指标可以说明模型的性能，辨别模型的结果，在建立一个模型后，计算指标，从指标获取反馈，再继续改进模型，直到达到理想的效果，因此，在预测之前检查模型的评估指标至关重要，不应在建立一个模型后，就直接将模型应用到看不见的数据上 对于分类问题来说，其根据所分类别的个数，可分为二分类问题、多分类问题 在二分类问题中，使用的评价指标有：误差率（Error Rate）、准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1 score）、$F_\\beta$ 分数（$F_\\beta$ score）、PR 曲线、ROC 曲线、AUC、代价敏感错误率（Cost-sensitive Error Rate）、代价曲线（Cost Curve）等 在多分类问题中，使用的评价指标有： 宏精确率（macro-P）、宏召回率（macro-R）、宏 F1（macro-F1） 、微精确率（micro-P）、微召回率（micro-R）、微F1（micro-F1）等 本文将详细介绍误差率（Error Rate）、准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1 分数（F1 score）、$F_\\beta$ 分数（$F_\\beta$ score）、PR 曲线 【误差率与准确率】错误率与准确率是分类问题中最常用的两种性能度量，既适用于二分类问题，又适用于多分类问题 误差率（Error Rate）是分类错误的样本数占据总样本的比例，即如果在 $m$ 个样本中有 $a$ 个样本分类错误，则误差率为： E=\\frac{a}{m}相应地，将分类正确的样本数占据总样本的比例称为准确率（Accuracy） 对于给定测试集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_N},y_N)\\}$，学习到的模型为 $Y=f(X;\\boldsymbol{\\theta})$ 误差率（Error Rate）为： E_T(f)=\\frac{1}{N}\\sum_{i=1}^{N} \\mathbb{I}(y_i\\neq f(\\mathbf{x_i};\\boldsymbol{\\theta}))准确率（Accuracy）为： ACC_T(f)=\\frac{1}{N}\\sum_{i=1}^{N} \\mathbb{I}(y_i= f(\\mathbf{x_i};\\boldsymbol{\\theta}))其中，$\\mathbb{I}(\\cdot)$ 为指示函数，即满足函数中的条件时，值为 $1$，不满足时为 $0$ 显然有： E_T(f)=1-ACC_T(f)虽然准确率能够判断总的预测正确率，但是在样本不均衡的情况下（例如有 $90$ 个样本 $10$ 个负样本），准确率高并没有任何意义，此时准确率就会失效，无法作为一个较好的指标来衡量结果 【混淆矩阵】对于二分类问题，通常以关注的类为正类，其他类为负类，这样将样例根据其真实类别与预测类别的组合划分为真正类（True Positive，TP）、假正类（False Positive，FP）、真负类（True Negative，TN）、假负类（False Negative，FN）四种情形，显然有： TP+FP+TN+FN=样例总数相应地，分类结果的混淆矩阵（Confusion Matrix）如下 由此，可定义出如下四个概念： 真正类率（True Positive Rate，TPR）：在所有实际为正类的样本中，被正确预测为正类的比例 TPR=\\frac{TP}{TP+FN}真负类率（True Negative Rate，TNR）：在所有实际为负类的样本中，被正确预测为负类的比例 FNR = \\frac{TN}{FP+TN}假正类率（False Positive Rate，FPR）：在所有实际为负类的样本中，被错误预测为正类的比例 FPR=\\frac{FP}{FP+TN}假负类率（False Negative Rate，FNR）：在所有实际为正类的样本中，被错误预测为负类的比例 FNR = \\frac{FN}{TP+FN}【精确率与召回率】精确率（Precision）是针对预测结果而言的，表示预测为正类中有多少是真正的正类，也就是说预测的有多少预测对了，其定义为： P=\\frac{TP}{TP+FP}召回率（Recall）是针对原来样本而言的，表示样本中的正类有多少被正确预测了，也就是说样本里的正类有多少被找出来了，其定义为： R=\\frac{TP}{TP+FN}可以发现，精确率与召回率是一对矛盾的度量，一般来说，当精确率高时，召回率偏低；当召回率高时，精确率偏低 【P-R 曲线】在大多数情形下，根据预测结果对样例进行排序，排在前面的是模型认为最可能是正类的样本，排在最后的是模型认为最不可能是正类的样本 按上述的顺序，逐个将样本作为正类进行预测，每次可以计算出当前的精确率和召回率，之后，以精确率为纵轴，召回率为横轴绘制二维函数图，即可得到精确率-召回率曲线（Precision Recall Curve），即 P-R 曲线 举例来说，对于逻辑回归问题，其输出值处于 $0$ 到 $1$ 之间，如果想判断一个西瓜的好坏，就必须要定一个阈值，例如大于 $0.5$ 时为好西瓜，小于 $0.5$ 时为坏西瓜，此时即可得到相应的精确率与召回率，但这个阈值是我们随意定义的，不能确定其是否真的符合我们的要求，因此为了寻找一个合适的阈值，就要遍历 $0$ 到 $1$ 之间的所有阈值，每个阈值都对应一组精确率和召回率，进而即可得到一组 P-R 曲线 P-R 曲线直观地显示出了模型在样本总体上的精确率、召回率，在进行比较时，如果一个模型的 P-R 曲线被另一个模型的 P-R 曲线完全包住，则可断言后者的性能优于前者；如果两个模型的 P-R 曲线发生交叉，则一般难以断言两者优劣，只能在具体的精确率、召回率下进行比较 如下图所示，曲线 A 完全包住曲线 C，可以断言模型 A 要优于模型 C；而曲线 A 与曲线 B 发生了交叉，两者难以比较 但有时，仍希望将两个发生交叉的曲线所分别对应的模型进行比较，此时一般比较两者曲线下面积的大小，其在一定程度上表征了模型在精确率和召回率上取得了双高的比例 但由于面积并不好进行估算，为此设计了平衡点（Break-Even Point，BEP），来综合考虑精确率与召回率，其是 精确率 = 召回率 时的取值 在上图中，基于 BEP 的比较，可以断定，模型 A 优于模型 B、模型 C，模型 B 优于模型 C 【F1 分数】BEP 是 精确率 = 召回率 时的取值，过于简单粗暴了一些，于是定义了一个新的指标：F1分数（F1-Score），其同时考虑精确率和召回率，让两者同时达到最高，取得平衡 F1 分数被定义为精确率和召回率的调和均值（Harmonic Mean）： \\frac{2}{F_1}=\\frac{1}{P}+\\frac{1}{R}即： \\begin{align*} F_1 &= \\frac{2 \\cdot P \\cdot R}{P+R}\\\\ &= \\frac{2 \\cdot TP}{2\\cdot TP+FP+FN} \\notag \\\\ \\end{align*}【$F_\\beta$ 分数】在实际应用中，对于不同的情景对精确率和召回率的要求不同，例如：在推荐系统中，更希望推荐内容是用户感兴趣的，此时精确率更为重要；在逃犯信息检索系统中，更希望能够少漏掉逃犯，此时召回率更为重要 为此，有了 F1 分数的一般形式 $F_{\\beta}$ 分数，其能表达出对精确率、召回率的不同偏好，其被定义为精确率、召回率的加权调和均值（Weighted Harmonic Mean）： \\frac{1}{F_\\beta}=\\frac{1}{1+\\beta^2}(\\frac{1}{P}+\\frac{\\beta^2}{R}),\\quad \\beta>0即： F_\\beta=\\frac{(1+\\beta^2) \\cdot P \\cdot R}{(\\beta^2 \\cdot P)+R},\\quad \\beta>0其中，$\\beta$ 度量了召回率对精确率的相对重要性 当 $\\beta=1$ 时：退化为 F1 分数 当 $\\beta&lt;1$ 时：精确率有更大的影响 当 $\\beta&gt;1$ 时：召回率有更大的影响","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"回归问题的评价指标（二）","slug":"machine-learning/08.回归问题的评价指标（二）","date":"2019-06-11T06:59:00.000Z","updated":"2023-03-31T12:42:54.439Z","comments":true,"path":"artificial-intelligence/machine-learning/2559e399.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/2559e399.html","excerpt":"Reference 回归评价指标MSE、RMSE、MAE、R-Squared R方的理解与用法 Wikipedia entry on the Coefficient of determination 统计学——线性回归决定系数R2 mse、rmse、mae、r2指标的总结以及局限性 可决系数 【概述】在 回归问题的评价指标（一） 中，介绍了回归问题考虑经验风险 $R_{emp}(f)$ 时的评价指标 MSE、RMSE、MAE","text":"Reference 回归评价指标MSE、RMSE、MAE、R-Squared R方的理解与用法 Wikipedia entry on the Coefficient of determination 统计学——线性回归决定系数R2 mse、rmse、mae、r2指标的总结以及局限性 可决系数 【概述】在 回归问题的评价指标（一） 中，介绍了回归问题考虑经验风险 $R_{emp}(f)$ 时的评价指标 MSE、RMSE、MAE 但除这三个外，在回归问题中，进行拟合时，常采用相关系数（Correlation Coefficient）来研究变量间线性相关程度的量，在统计学中，三大相关系数是：皮尔森相关系数（Pearson Correlation Coefficient）、斯皮尔曼相关系数（Spearman Correlation Coefficient）和肯德尔相关系数.（Kendall Correlation Coefficient） 在机器学习中，常采用可决系数（Coefficient of Determination）来估量回归方程拟合 $y$ 对 $x$ 的协变关系效果的量数 本文仅介绍皮尔森相关系数（Pearson Correlation Coefficient）与可决系数（Coefficient of Determination） 【皮尔逊相关系数 PCCs】皮尔逊相关系数（Pearson Correlation Coefficient，PCCs）是衡量随机变量 X 与 Y 的相关程度的一种指标，其取值范围为 $[-1,1]$，相关系数的绝对值越大，则表明 $X$ 与 $Y$ 相关度越高 当 $X$ 与 $Y$ 线性正相关时，相关系数取值为 $1$；当 $X$ 与 $Y$ 线性负相关时，相关系数取值为 $-1$ 对于两个随机变量 $X$、$Y$，他们的皮尔逊相关系数定义为 $X$ 与 $Y$ 间的协方差 $cov(X,Y)$ 和标准差 $\\sigma_X,\\sigma_Y$ 的商，即： \\begin{align*}\\rho_{X,Y} &= \\frac{cov(X,Y)}{\\sigma_X\\sigma _Y} \\notag \\\\ &= \\frac{E[(X-\\mu_X)(Y-\\mu_Y)]}{\\sigma_X\\sigma_Y} \\notag \\\\ &= \\frac{E(XY)-E(X)E(Y)}{\\sqrt{E(X^2)-E^2(X)}\\sqrt{E(Y^2)-E^2(Y)}} \\notag \\end{align*}【可决系数 $R^2$】总离差、可解释离差、不可解释离差统计学中，一个特定数值对其平均值的偏离，被称为离差（Deviation） 在回归问题下，因变量 $y$ 的离差 $y-\\overline{y}$ 被称为总离差（Total Dispersion），其可看作是由两部分合成的：一部分是因变量 $y$ 的回归拟合值 $\\hat{y}$ 对均值 $\\overline{y}$ 的离差 $ \\hat{y}-\\overline{y}$，另一部分是因变量 $y$ 对回归拟合值 $\\hat{y}$ 的离差 $y-\\hat{y}$ 当 $x=\\overline{x}$ 时，有 $\\hat{y}-\\overline{y} = 0$，可以发现，自变量 $x$ 的取值越偏离 $\\overline{x}$，第一部分的离差就越大，即存在如下的函数关系： \\hat{y}-\\overline{y}=a+b(x-\\overline{x})可以发现，第一部分的离差 $ \\hat{y}-\\overline{y}$ 完全是由因变量 $y$ 倚自变量 $x$ 的回归关系决定的，被称为可解释离差（Explained Deviation） 而第二部分的离差 $y-\\hat{y}$ 是呈随机变化的，与回归关系无关，被称为不可解释离差（Unexplained Deviation） 那么，总离差、可解释离差、不可解释离差三者的关系如下： y-\\overline{y}=(\\hat{y}-\\overline{y}) - (y-\\hat{y})总平方和、回归平方和、残差平方和一个变量的各数值对其平均值的偏离，被称为变异（Variation），通常用离差平方和（Sum of Squares of Deviations）来描述变异程度 对于样本数量为 $N$ 的测试集，总离差的平方和被称为总平方和（Sum of Squares for Total，SST），即： SST=\\sum_{i=1}^N (y_i-\\overline{y})^2可解释离差的平方和被称为回归平方和（Sum of Squares for Regression，SSR），又称解释平方和（ Explained Sum of Squares，ESS），即： SSR=\\sum_{i=1}^N(\\hat{y_i}-\\overline{y})^2不可解释离差的平方和被称为残差平方和（Sum of Squares for Error，SSE）或（Residual Sum of Squares，RSS），即： SSE=\\sum_{i=1}^N(y_i-\\hat{y_i})^2易得： SST=SSR+SSE样本可决系数对于 $SST=SSR+SSE$，将两边同时都除以 $SST$，可得： \\frac{\\sum\\limits_{i=1}^N(\\hat{y_i}-\\overline{y})^2}{\\sum\\limits_{i=1}^N(y_i-\\overline{y})^2} + \\frac{\\sum\\limits_{i=1}^N(y_i-\\hat{y_i})^2}{\\sum\\limits_{i=1}^N(y_i-\\overline{y})^2} = 1这样就把在绝对数意义上对总离差的分割，改换成在相对数意义上对总离差的分割 其中，$\\frac{\\sum\\limits_{i=1}^N(\\hat{y_i}-\\overline{y})^2}{\\sum\\limits_{i=1}^N(y_i-\\overline{y_i})^2} $ 表示的是回归关系已经解释的 $y_i$ 值变异在其总变异中所占的比率，$\\frac{\\sum\\limits_{i=1}^N(y_i-\\hat{y_i})^2}{\\sum\\limits_{i=1}^N(y_i-\\overline{y})^2}$ 表示的是回归关系不能解释的 $y_i$ 值变异在总变异中所占的比率 前者正是要寻求的用于估量回归方程拟合 $y$ 对 $x$ 的协变关系效果的量数，称为可决系数（Coefficient of Determination），其是由样本数据产生的，也被称为样本可决系数，用 $R^2$ 表示，即： R^2 = 1 - \\frac{\\sum\\limits_{i=1}^N(y_i-\\hat{y_i})^2}{\\sum\\limits_{i=1}^N(y_i-\\overline{y})^2}$R^2$ 的含义是预测值 $\\hat{y_i}$ 解释了真实值 $y_i$ 变量的方差的多大比例，衡量的是预测值 $\\hat{y_i}$ 对于真实值 $y_i$ 的拟合程度 简单来说，假定 $y_i$ 的方差为 $1$ 个单位，那么 $R^2$ 表示使用该模型后，$y_i$ 的残差的方差减少了多少，假设 $R^2=0.8$，那么使用该模型后，残差的方差为真实值 $y_i$ 方差的 $20\\%$ $R^2=1$：是最理想的情况，此时所有预测值 $\\hat{y_i}$ 等于真实值 $y_i$ $R^2=0$：最可能的情况是所有预测值 $\\hat{y_i}$ 等于平均值 $\\overline{y}$ $R^2&lt;0$：模型的预测能力差，说明学习到的模型还不如基准模型，可能是数据中不存在线性关系 需要注意的是 $R^2$ 的最小值没有下限，因为预测可能出现任意程度的差，因此 $R^2$ 的取值范围是 $(-\\infty,1]$ 总体可决系数总体可决系数是在总体中关于 $Y$ 总变异中总体回归方程 $\\hat{Y}=\\alpha + \\beta{X}$ 已解释的变异所占比重的描述量数，其表示为： \\rho^2=1-\\frac{\\sigma^2_{y\\cdot x}}{\\sigma^2_{y}}其中，$\\sigma^2_{y\\cdot x}$ 是围绕总体回归直线的方差，$\\sigma^2_{y}$ 是围绕总体平均数的方差 $\\rho^2$ 作为总体参数，通常视为未知的，需要用样本统计量去估计，将 $\\sigma^2_{y\\cdot x}$ 与 $\\sigma^2_{y}$ 的无偏估计量分别代入上式，即可得 $\\rho^2$ 的估计量的公式 \\begin{align} R_c^2 &= 1 - \\frac{S^2_{y\\cdot x}}{S^2_{y}} \\notag \\\\ &= 1 - \\frac{\\frac{1}{n-2}\\sum\\limits_{i=1}^N(y_i-\\hat{y_i})^2 }{\\frac{1}{n-1}\\sum\\limits_{i=1}^N(y_i-\\overline{y})^2} \\notag \\end{align}不难发现 $R^2$ 与 $R_c^2$ 的形式略有不同，前者采用的是平方和比率的形式，而后者采用的是均方和比率的形式 $R^2_c$ 被称为经调整样本拟合系数（Adjusted Coefficient of Determination），常用于对总体可决系数进行点估计，其平抑了方程中自变量数目的对解释作用的夸大 需要注意的是，在多元回归分析中，因为对同一样本 $m$ 个自变量的回归方程总比 $m-1$ 个自变量的回归方程求得已解释变差小，$R^2_c$ 在 $m$ 个自变量的方程中已解释离差除以 $(n-m-1)$，而在 $(m-1)$ 个自变量的方程中则除以 $(n-m-2)$","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"回归问题的评价指标（一）","slug":"machine-learning/07.回归问题的评价指标（一）","date":"2019-06-10T15:27:00.000Z","updated":"2023-03-31T12:42:53.382Z","comments":true,"path":"artificial-intelligence/machine-learning/3b881afd.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/3b881afd.html","excerpt":"【概述】在 机器学习三要素 中介绍过损失函数（Loss Function）、期望风险（Expected Risk）、经验风险（Empirical Risk） 损失函数是定义在单个样本上的，计算的是一个样本的误差，即：","text":"【概述】在 机器学习三要素 中介绍过损失函数（Loss Function）、期望风险（Expected Risk）、经验风险（Empirical Risk） 损失函数是定义在单个样本上的，计算的是一个样本的误差，即： L(Y,f(X;\\boldsymbol{\\theta}))期望风险是理论上模型 $f(X;\\boldsymbol{\\theta})$ 关于联合分布 $P(X,Y)$ 的平均意义下的损失，即： R_{exp}(f) = E_p\\big[L(Y,f(X;\\boldsymbol{\\theta}))\\big]=\\int_{\\mathcal{X}\\times\\mathcal{Y}}L(Y,f(X;\\boldsymbol{\\theta}))P(X,Y)dXdY经验风险（Empirical Risk）是关于测试集的平均损失，即： R_{emp}(f)=\\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))考虑到辛钦大数定律，当测试集的样本容量 $N$ 趋于无穷时，训练集的损失函数的平均损失依概率收敛到真实分布的期望风险，因此可用经验风险来估计期望风险 而机器学习的最终目的是采用结构风险最小化策略，对目标函数（Object Function）进行优化，即： \\min_{f\\in \\mathcal{F}}\\quad \\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))+\\lambda J(f)那么在回归问题中，进行模型评估时，除考虑正则化项 $\\lambda J(f)$ 外，还需考虑经验风险 $R_{emp}(f)$ 一般来说，常见的评估指标有：均方误差（Mean Square Error，MSE）、均方根误差（Root Mean Square Error，RMSE）、平均绝对误差（Mean Absolute Error，MAE） 【均方误差 MSE】均方误差（Mean Square Error，MSE）是预测值 $\\hat{y_i}$ 与真实值 $y_i$ 差值的平方和的平均数 对于回归问题，假设测试集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_N},y_N)\\}$ ，对于给定的输入 $\\mathbf{x_i}$，由决策函数 $f(X;\\boldsymbol{\\theta})$ 给出预测值 $\\hat{y}=f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 当采用平方损失函数时： L(Y,f(X;\\boldsymbol{\\theta}))=(Y-f(X;\\boldsymbol{\\theta}))^2那么在进行模型评估时，此时经验风险 $R_{emp}(f)$ 被称为 MSE，即： \\begin{align} MSE &= \\frac{1}{N}\\sum_{i=1}^N L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta})) \\notag \\\\ &= \\frac{1}{N}\\sum_{i=1}^N (y_i-\\hat{y_i})^2 \\notag \\end{align}MSE 对应了欧氏距离（Euclidean Distance），常用于线性回归分析中，即基于 MSE 最小化来进行模型求解，试图寻找一条直线，使得所有样本到直线上的欧氏距离最小 关于欧式距离的具体介绍详见：机器学习中的相似性度量 【均方根误差 RMSE】均方根误差（Root Mean Square Error，RMSE）是 MSE 的平方根，也用于衡量真实值 $y_i$ 与预测值 $\\hat{y_i}$ 间的偏差 RMSE=\\sqrt{\\frac{1}{N}\\sum_{i=1}^N (y_i-\\hat{y_i})^2}RMSE 实质与 MSE 相同，只是用于数据更好的描述 举例来说，当做房价预测时，每平方以万元为单位，那么预测结果也是万元，若采用 MSE 作为模型的评估标准，单位就是千万级别的，不太好描述模型效果，而采用 RMSE 作为评估标准，误差的结果就与数据是同一个级别的 【平均绝对误差 MAE】平均绝对误差（Mean Absolute Error，MAE）是真实值 $y_i$ 与预测值 $\\hat{y_i}$ 差值的绝对值的平均数 对于回归问题，假设测试集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_N},y_N)\\}$ ，对于给定的输入 $\\mathbf{x_i}$，由决策函数 $f(X;\\boldsymbol{\\theta})$ 给出预测值 $\\hat{y}=f(\\mathbf{x_i};\\boldsymbol{\\theta})$ 当采用绝对值损失函数时： L(Y,f(X;\\boldsymbol{\\theta}))=|Y-f(X;\\boldsymbol{\\theta})|那么在进行模型评估时，经验风险 $R_{emp}(f)$ 被称为 MAE，即： \\begin{align} MAE &= \\frac{1}{N}\\sum_{i=1}^N L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta})) \\notag \\\\ &= \\frac{1}{N}\\sum_{i=1}^N |y_i-\\hat{y_i}| \\notag \\end{align}MAE 是绝对误差的平均值，能够更好地反映预测值误差的实际情况","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"机器学习的模型选择","slug":"machine-learning/06.机器学习的模型选择","date":"2019-06-09T14:54:00.000Z","updated":"2023-04-08T13:33:02.030Z","comments":true,"path":"artificial-intelligence/machine-learning/d9259ca2.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/d9259ca2.html","excerpt":"【欠拟合与过拟合】当假设空间中含有不同复杂度的模型时，就面临模型选择问题，即假设假设空间中存在符合问题的真模型，那么选择的模型应该逼近该真模型，从而提高预测能力 如果模型复杂度低，在训练集中无法获得足够低的误差，使得模型在训练集上就表现的很差，无法学习到数据背后的规律，这种现象称为欠拟合（Under-fitting）","text":"【欠拟合与过拟合】当假设空间中含有不同复杂度的模型时，就面临模型选择问题，即假设假设空间中存在符合问题的真模型，那么选择的模型应该逼近该真模型，从而提高预测能力 如果模型复杂度低，在训练集中无法获得足够低的误差，使得模型在训练集上就表现的很差，无法学习到数据背后的规律，这种现象称为欠拟合（Under-fitting） 欠拟合一般会出现于训练刚开始的时候，随着训练次数的增加，欠拟合的现象基本会消失，无需考虑，但如果训练完毕后仍存在欠拟合问题的话，可以在模型中增加特征以解决欠拟合 但如果一味的提高训练集的预测能力，不断地增加模型特征，则会出现过拟合（Over-fitting）现象，即训练误差和测试误差间的差距过大，模型对已知数据的预测表现很好，但对未知数据的预测表现很差的现象 除了增加模型特征使得模型过于复杂导致出现过拟合外，如果训练集样本单一，或者训练数据中噪声干扰过大，仍会出现过拟合现象 如下图，为回归问题中的三种拟合状态 如下图，为分类问题中的三种拟合状态 当模型的复杂度增大时，训练误差会逐渐减小并趋近于 $0$，而测试误差即泛化误差会先减小达到最小值后又增大，因此当选择的模型复杂度过大时，过拟合现象就会发生 一般而言，解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力 常见的处理方法有：删除冗余特征、正则化（L1/L2 正则化）、交叉验证、随机失活（Dropout）、提前终止（Early Stopping）等 【正则化】正则化（Regularizatoin）是机器学习的回归问题中最常用的模型选择方法之一，用于选择经验风险与模型复杂度同时较小的模型，其是结构风险最小化策略的实现，即在经验风险的基础上加了一个正则化项（Regularizer），此时损失函数的一般形式如下： \\min_{f\\in\\mathcal{F}} \\quad \\frac{1}{N}\\sum_{i=1}^N L(y_i,f(x_i;\\boldsymbol{\\theta}))+\\lambda J(f),\\quad \\lambda\\geq 0其中，第一项是经验风险，第二项是正则化项，$\\lambda\\geq0$ 是用于调整两者之间关系的系数 正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大，在实际应用中，常根据实际模型的情况取模型参数向量的范数（Norm），即利用 L1 范数或 L2 范数作为正则项，进行 L1 正则化或 L2 正则化，从而避免过拟合问题 使用 L1 正则化的回归模型一般称为 Lasso 回归，使用 L2 正则化的回归模型一般称为 Ridge 回归（岭回归） 关于 Lasso 回归与 Ridge 回归见：Lasso 回归与 Ridge 回归 【交叉验证】概述如果给定的样本数据充足，最简单的模型选择方法是随机将数据集分为训练集、验证集、测试集三部分，训练集用于训练模型，验证集用于模型选择，测试集用于对学习方法进行评估 其中，训练集用于训练模型，验证集用于模型选择，即衡量同一个模型的不同参数的表现，以挑选一个模型的中最优的参数，测试集用于对学习方法进行评估，即用来比较不同的模型进而选择最优模型 由于数据充足，验证集中有足够多的数据，因此在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型即可 但在实际应用中，数据可能并不充足，此时可以采用交叉验证（Cross Validation）的方法，将给定数据进行切分，分为训练集、测试集，重复地使用数据来进行训练、选择、测试 简单交叉验证简单交叉验证首先随机将数据分为训练集、测试集两部分，一般来说，常取 70% 的数据作为训练集，30% 的数据作为测试集 之后用训练集在不同参数个数的条件下训练模型，以得到不同的模型 最后在测试集上对各个模型计算测试误差，选出测试误差最小的模型 S 折交叉验证S 折交叉验证（S-fold Cross Validation）是最常用的交叉验证方法，其首先随机将数据分为 $S$ 个互不相交的大小相同的子集，目前一般取 $S=10$，即 10 折交叉验证 之后利用 $S-1$ 个子集的数据训练模型，并利用剩余的 $1$ 个子集测试模型，将训练、测试过程对可能的 $S$ 种选择重复进行 最后选出 $S$ 次评测中平均测试误差最小的模型 留一交叉验证留一交叉验证（Leave-one-out Cross Validation）是 S 折交叉验证的特殊情形，即对于样本容量为 $N$ 的数据集，取 $S=N$ 的情形 该方法往往在数据极度缺乏的情况下使用 【自助法】对于一个模型来说，我们希望其能够采用数据集 $D$ 中的全部数据进行训练，但在交叉验证中，无论采用哪种方法，都会保留部分样本进行测试，这使得实际评估的模型使用的训练集要比数据集 $D$ 要小，这就导致会引入一些由于训练样本规模不同造成的估计偏差 为解决上述问题，将推论统计学中的自助采样法（Bootstrap Sampling）引入，从样本统计量来推算总体统计量，这就是自助法（Bootstrapping） 对于给定的包含 $n$ 个样本的初始数据集 $D$，每次随机从 $D$ 中选择一个样本，将其拷贝放入采样数据集 $D’$，放入拷贝的原因是令该样本在下次采样时仍有可能被选择到 将上述过程重复执行 $n$ 次，即得到包含 $n$ 个样本的采样数据集 $D’$，显然，$D$ 中的某些样本会在 $D’$ 中多次出现，某些样本一次也不出现 在 $n$ 次采样中，每个样本被采样的概率是 $\\frac{1}{n}$，那么始终不被采样的概率为： (1-\\frac{1}{n})^n取极限有： \\begin{align*} \\lim_{n\\rightarrow\\infty} (1-\\frac{1}{n})^n &= \\lim_{n\\rightarrow\\infty} e^{n\\ln (1-\\frac{1}{n})} \\\\ &= e^{n\\cdot (-\\frac{1}{n})} \\\\ &= e^{-1} \\\\ &\\approx 0.368 \\end{align*}即通过自助采样，初始数据集 $D$ 中约有 $36.8\\%$ 的样本未出现在采样数据集 $D’$ 中 由此，可将 $D’$ 作为训练集，将 $D\\backslash D’$ 作为测试集，即实际评估的模型与期望评估的模型都使用 $n$ 个训练样本，但仍有约 $\\frac{1}{3}$ 没有在训练集中出现的数据可以作为测试集 自助法常用于数据量较小，难以划分训练集和测试集的数据集，但自助法产生的数据集改变了初始数据集的分布，会引入估计偏差 【随机失活】随机失活（Dropout）是在训练神经网络时的一种技巧，相当于在隐藏单元中增加了噪声 其在训练过程中，每次按一定的概率随机地删除一部分隐藏单元，删除概率一般设为 50% 所谓的删除，并非真正意义上的删除，而是将该部分的神经元的激活函数的输出设为 $0$，让这些神经元不参与计算 由于在训练过程中会产生不同的训练模型，而不同的训练模型也会产生不同的的计算结果，随着训练的不断进行，计算结果会在一个范围内波动，但是均值却不会有很大变化，因此可以把最终的训练结果看作是不同模型的平均输出 Dropout 消除、减弱了神经元节点间的联合，降低了网络对单个神经元的依赖，从而增强了泛化能力，进而防止了过拟合现象的出现 【提前终止】提前终止（Early Stoping）是一种使用截断迭代次数以防止过拟合的方法，常用于学习过程中存在迭代的学习方法 简单来说，提前终止是在模型对训练数据集迭代收敛前，通过停止迭代来防止过拟合 但提前终止没有采取不同的方式来解决优化损失函数和过拟合这两个问题，使用同一种方法同时解决两个问题 ，结果就是要考虑的东西变得更复杂","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"机器学习的模型评估","slug":"machine-learning/05.机器学习的模型评估","date":"2019-06-07T03:15:00.000Z","updated":"2023-03-31T12:42:50.571Z","comments":true,"path":"artificial-intelligence/machine-learning/97708f21.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/97708f21.html","excerpt":"Reference 统计学习方法（一）：泛化误差上界 关于Hoeffding不等式及泛化误差上界 偏差方差分解 偏置方差分解Bias-variance Decomposition 机器学习中的方差和偏差 【训练误差与测试误差】在 机器学习三要素 中，介绍了损失函数，而对于任何一个模型来说，具体采用的损失函数，未必是评估模型时所用的损失函数","text":"Reference 统计学习方法（一）：泛化误差上界 关于Hoeffding不等式及泛化误差上界 偏差方差分解 偏置方差分解Bias-variance Decomposition 机器学习中的方差和偏差 【训练误差与测试误差】在 机器学习三要素 中，介绍了损失函数，而对于任何一个模型来说，具体采用的损失函数，未必是评估模型时所用的损失函数 当损失函数给定时，基于损失函数的训练误差（Training Error）和测试误差（Test Error）就成为了评估标准 所谓误差，是指学习器的实际预测输出与样本的真实输出间的差值，训练误差常用于判定给定的问题是否为一个容易学习的问题，测试误差则反映了学习方法对未知的测试集的预测能力 假设学习到的模型是 $Y=f(X;\\boldsymbol{\\theta})$，训练误差是与模型相关的含有 $N$ 个样本的训练集的平均损失，即： R_{emp}(f)=\\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))测试误差是与模型相关的含有 $N’$ 个样本的测试集的平均损失，即： e_{test}=\\frac{1}{N'}\\sum_{i=1}^{N'} L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))由于模型是针对一个问题设计的，这个问题会有一个数据总体，包含了所有可能的情况，模型都是先在训练集上进行训练，再在测试集上进行测试，但总体数据量往往很大，不可能用到所有的数据，一般都是在总体中进行抽样 也就是说，模型在训练数据上进行训练，得到的误差为训练误差；在测试数据上进行测试，得到的误差即测试误差 【泛化能力】学习方法的泛化能力（Generalization Ability）是指由该学习方法学习到的模型对未知数据的预测能力 泛化误差我们真正想要的是模型在总体上的误差，即模型在未知记录上的期望误差，也即泛化误差 在实际应用中，如果在样本集划分时，得到的训练集与测试集数据没有交集，可以将测试误差近似等同于泛化误差 具体来说，泛化误差是学习到的模型的期望风险，其反映了理论上的学习方法的泛化能力 假设学习到的模型为 $Y=f(X;\\boldsymbol{\\theta})$，用这个模型对未知数据预测的泛化误差为： R_{exp}(f)=E_P\\big[L(Y,f(X;\\boldsymbol{\\theta})\\big]=\\int_{\\mathcal{X}\\times\\mathcal{Y}}L(Y,f(X;\\boldsymbol{\\theta}))P(X,Y)dXdY简单来说，训练误差即经验风险 $R_{emp}(f)$，测试误差可近似等同于泛化误差，泛化误差即期望风险 $R_{exp}(f)$ 泛化误差上界由于实际应用中使用的测试误差与泛化误差之间存在一定的误差，因此对于学习方法的泛化能力分析是通过研究泛化误差的概率上界进行的，即泛化误差上界（Generalization Error Bound），两种学习方法的优劣，通常通过他们的泛化误差上界来进行比较 泛化误差上界具有以下性质： 样本容量的函数：当样本容量增加时，泛化误差上界趋于 $0$ 假设空间容量的函数：容量越大模型越难以学习，泛化误差上界就越大 二分类问题的泛化误差上界以简单的二分类问题为例，已知训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_N},y_N)\\}$ 是由联合分布概率 $P(X,Y)$ 独立同分布产生的，且 $X\\in \\mathbb{R}^n$，$Y\\in\\{-1,+1\\}$，假设空间为 $d$ 个函数 $f$ 的有限集合 $\\mathcal{F}=\\{f_1,f_2,…,f_d\\}$，采用的损失函数为 0-1 损失函数，其取值为 $\\{0,1\\}$ 关于 $f$ 的训练误差，即经验风险 $R_{emp}(f)$ 为： R_{emp}(f) = \\frac{1}{N} \\sum\\limits_{i=1}^N L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta}))关于 $f$ 的泛化误差，即期望风险 $R_{exp}(f)$ 为： R_{exp}(f)=E\\big[L(Y,f(X;\\boldsymbol{\\theta}))\\big] 那么，对任意 $f\\in\\mathcal{F}$，至少以 $1-\\delta$ 的概率，使得下式成立： R_{exp}(f)\\leq R_{emp}(f)+\\varepsilon(d,N,\\delta)不等式右端的 $R_{emp}(f)+\\varepsilon(d,N,\\delta)$ 即为泛化误差上界 其中，$\\varepsilon(d,N,\\delta)$ 为样本数量 $N$ 的单调递减函数，即： \\varepsilon(d,N,\\delta)=\\sqrt{\\frac{1}{2N}(log\\:d+log\\:\\frac{1}{\\delta})}当 $N$ 趋于无穷时其趋于 $0$，同时也是 $\\sqrt{log\\:d}$ 阶的函数，假设空间 $\\mathcal{F}$ 包含的函数越多，其值越大 假设找到了经验风险最小化的函数： f_N=arg\\:\\min_{f\\in\\mathcal{F}}R_{emp}(f)那么根据上述不等式，只要加上 $\\varepsilon(d,N,\\delta)$ 项，即可控制住测试集上的期望风险 $R_{exp}(f)$ 换句话来说，随着样本数量 $N$ 的增大，训练误差和泛化误差会越来越接近 关于该部分的详细证明见：证明1 【偏差-方差分解】方差、噪声、偏差偏差（bias）是独立于训练样本的误差，度量了模型的期望预测与真实结果的偏差程度，刻画了模型本身拟合行为的准确性与质量，偏差越高，拟合程度越差 噪声（noise）是当前任务上任何模型能达到的期望泛化误差下界，是任何方法都无法克服的误差，刻画了学习问题本身的难度 方差（variance）度量了面对同样规模的不同训练集时，样本变动导致的模型的学习性能的变化，是相关于观测样本的误差，刻画了一个学习算法在数据扰动时的精确性、特定性，方差越大，越不稳定 以最简单的一元线性回归问题为例 对于在训练数据集 $T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$ 上习得的模型 $f_T$，当给定测试样本 $(x,y)$ 时，$x$ 为测试样本的输入，$y$ 为测试样本的输出，记 $\\hat{y}$ 为实际测试时得到的输出，$f_T(x;\\theta)$ 为对测试样本的输入 $x$ 的预测输出 采用平方损失函数： L(Y,f(X;\\theta))=(Y-f(X;\\theta))^2则学习算法的泛化误差为： \\begin{align} R_{exp}(f) &= E_P\\big[ L(Y,f(X;\\theta)) \\big] \\notag \\\\ &= E_P\\big[(y-\\hat{y})^2\\big] \\notag \\\\ &= E_P\\big[(y-f_T(x;\\theta))^2\\big] \\notag \\end{align}针对与数据集 $T$ 具有相同样本数的不同数据集所训练的模型 $f$ 对测试样本 $x$ 的预测值的期望，即平均预测值（average predicted）为： \\overline{f}_T(x;\\theta)=E_P\\big[f_T(x;\\theta)\\big]依据离散型方差计算公式： D(X)=E\\big[(X-E(X))^2\\big]此时，使用样本数相同的不同训练集产生的方差（variance）为： D(x)=E_P\\big[(f(x;\\theta)-\\overline{f}(x;\\theta))^2\\big]由于样本可能出现标记错误等情况，此时模型 $f_T$ 预测到的数据 $\\hat{y}$ 可能与数据集中的样本输出 $y$ 不相符，两者间的差异即噪声（noise），即： \\varepsilon^2=E_P\\big[(\\hat{y}-y)^2\\big]而对于期望预测 $\\overline{f}(x;\\theta)$ 与预测输出 $y$ 的误差，称之为偏差（bias），为方便起见，直接取偏差的平方，即： bias^2(x)=(\\overline{f}(x;\\theta)-\\hat{y})^2偏差-方差分解偏差-方差分解（Bias-Variance Decomposition）是机器学习用于解释学习算法的泛化能力的分析技术，对于给定学习目标和训练集，其可以将一种学习算法的泛化误差分解为噪声（noise）、偏差（bias）和方差（variance） 为便于讨论，假定噪声期望为 $0$，即：$E_P(y-\\hat{y})=0$ 接上例，对学习算法的泛化误差 $R_{exp}(f)$ 进行分解： \\begin{align} R_{exp}(f) &= E_P \\big[ (y-f_T(x;\\theta))^2 \\big] \\notag \\\\ &= bias^2(x) + \\varepsilon^2 + D(x) \\notag \\end{align}关于该部分的详细证明见：证明2 偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性、学习任务本身的难度所共同决定的 偏差-方差窘境对于给定的学习任务，若为了得到泛化性能好的模型，需要使偏差较小，以充分拟合数据，同时要使方差较小，使得数据扰动产生的影响小，但偏差与方差在一定程度上是有冲突的，即偏差-方差窘境（bias-variance dilemma） 如下图，在模型训练不足时，拟合能力不够强，训练数据的扰动不足以使得学习器产生显著的变化，此时偏差主导泛化误差，即欠拟合现象；当随着训练程度加深，模型的拟合能力增强，训练数据的扰动慢慢使得方差主导泛化误差；当训练充足时，模型的拟合能力非常强，数据轻微变化都能导致模型发生变化，如果过分学习训练数据的特点，则会发生过拟合现象 随着模型复杂度的提升，偏差逐渐减小，方差逐渐增大，最佳的模型复杂度是在泛化误差 $R_{exp}(f)$ 最小的时候，此时该点导数为 $0$ 由于 $R_{exp}(f)= bias^2(x)+\\varepsilon^2+D(x)$，因此，在拐点处有： \\frac{d\\:bias}{d\\:complexity}=\\frac{d\\:D}{d\\:complexity}其中，$complexity$ 代表模型复杂度 若模型复杂度大于平衡点，则模型的方差会偏高，模型倾向于过拟合；若模型复杂度小于平衡点，则模型的偏差会偏高，模型倾向于欠拟合 【附：证明】 证明1 霍夫丁不等式（Hoeffding’s inequality）给出了随机变量的均值与期望值的偏差的概率上限： 设 $\\overline{X}=\\frac{1}{N}\\sum\\limits_{i=1}^nX_i$ 是独立随机变量 $X_1,X_2,…,X_n$ 的经验均值，$X_i\\in[a_i,b_i]$，则对任意的 $t&gt;0$，以下两不等式成立： \\left\\{\\begin{array}{rl} P(\\overline{X}-E({\\overline{X}}) \\geq t) & \\leq & exp \\biggl(\\frac{-2N^2t^2}{\\sum\\limits_{i=1}^N(b_i-a_i)^2} \\biggr ) \\\\P(E(\\overline{X})-{\\overline{X}} \\geq t) & \\leq & exp \\biggl(\\frac{-2N^2t^2}{\\sum\\limits_{i=1}^N(b_i-a_i)^2} \\biggr ) \\end{array} \\right. 已知训练数据集 $T=\\{(\\mathbf{x_1},y_1),(\\mathbf{x_2},y_2),…,(\\mathbf{x_N},y_N)\\}$ 是由联合分布概率 $P(X,Y)$ 独立同分布产生的，且 $X\\in \\mathbb{R}^n$，$Y\\in\\{-1,+1\\}$，假设空间为 $d$ 个函数 $f$ 的有限集合 $\\mathcal{F}=\\{f_1,f_2,…,f_d\\}$，采用的损失函数 $L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta}))$ 为 0-1 损失函数，其取值为 $\\{0,1\\}$ 损失函数的均值为： \\overline{X} = \\frac{1}{N} \\sum\\limits_{i=1}^N L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta}))损失函数的期望为： \\begin{align} E(\\overline{X}) &= E\\bigg[\\frac{1}{N} \\sum\\limits_{i=1}^N L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta}))\\bigg] \\notag \\\\ &= \\frac{1}{N} \\sum\\limits_{i=1}^N E\\bigg[L(y_i,f(\\mathbf{x_i};\\boldsymbol{\\theta}))\\bigg] \\notag \\\\ &= E\\big[L(Y,f(X;\\boldsymbol{\\theta}))\\big]\\notag \\end{align}易知： \\left\\{\\begin{array}{rl} \\overline{X} &=& R_{emp}(f) \\\\ E(\\overline{X}) &=& R_{exp}(f) \\end{array} \\right.根据霍夫丁不等式： P(E({\\overline{X}})-\\overline{X} \\geq t) \\leq \\exp \\bigl(\\frac{-2N^2t^2}{\\sum\\limits_{i=1}^N(b_i-a_i)^2} \\bigr )将 $\\overline{X}=R_{emp}(f)$，$E(\\overline{X})=R_{exp}(f)$ 代入，并取 $t=\\varepsilon &gt;0$ 同时，由于是二分类问题，故有 $a_i,b_i\\in\\{0,1\\}$，也就是说，对于 $a_i$ 与 $b_i$，当其中一个取值为 $1$ 时，另一个取值一定为 $0$ 故有： P(R_{exp}(f)-R_{emp}(f) \\geq \\varepsilon) \\leq \\exp(\\frac{-2N^2\\varepsilon^2}{\\sum\\limits_{i=1}^N 1}),\\quad \\varepsilon>0也就是说，对于假设空间 $\\mathcal{F}$，其中的任意一个函数 $f$ 作为模型时，其泛化误差的概率上限满足以下的不等式： P(R_{exp}(f)-R_{emp}(f) \\geq \\varepsilon) \\leq exp(-2N\\varepsilon^2),\\quad \\varepsilon>0而假设空间 $\\mathcal{F}$ 是一个有限集合，如果要求 $\\mathcal{F}$ 中存在某个函数 $f$ 作为模型时，根据概率的加和规则，其泛化误差的概率上限满足以下不等式： \\begin{align} P(\\exists f \\in \\mathcal{F}: R_{exp}(f)-R_{emp}(f)\\geq \\varepsilon) & = P(\\cup_{f\\in\\mathcal{F}}\\{R_{exp}(f)-R_{emp}(f)\\geq \\varepsilon \\}) \\notag \\\\ & \\leq \\sum_{f\\in\\mathcal{F}}P(R_{exp}(f)-R_{emp}(f) \\geq \\varepsilon) \\notag \\\\ & \\leq d\\cdot exp(-2N\\varepsilon^2) \\notag \\end{align}其中，$d$ 为假设空间 $\\mathcal{F}$ 中函数 $f$ 的个数 相应地，对任意 $f\\in \\mathcal{F}$，有： P(R_{exp}(f)-R_{emp}(f)","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"机器学习中常见的损失函数","slug":"machine-learning/04.机器学习中常见的损失函数","date":"2019-06-06T14:02:00.000Z","updated":"2023-04-03T13:33:35.269Z","comments":true,"path":"artificial-intelligence/machine-learning/4a4b5c97.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/4a4b5c97.html","excerpt":"【0-1 损失函数】0-1 损失函数（0-1 Loss Function）常用于分类问题，当真实值 $y$ 与预测值 $f(\\mathbf{x};\\boldsymbol{\\theta})$ 不相等为 $1$，否则为 $0$，其标准形式如下： L(y,f(\\mathbf{x};\\boldsymbol{\\theta})) = \\left\\{\\begin{array} {rl}1 & y \\neq f(\\mathbf{x};\\boldsymbol{\\theta}) \\\\0 & y = f(\\mathbf{x};\\boldsymbol{\\theta}) \\end{array} \\right.由于相等条件过于严格，因此可以放宽条件，设置一个阈值 $T$，即满足 $|y-f(\\mathbf{x};\\boldsymbol{\\theta})|&lt;T$ 时认为相等，否则认为不相等","text":"【0-1 损失函数】0-1 损失函数（0-1 Loss Function）常用于分类问题，当真实值 $y$ 与预测值 $f(\\mathbf{x};\\boldsymbol{\\theta})$ 不相等为 $1$，否则为 $0$，其标准形式如下： L(y,f(\\mathbf{x};\\boldsymbol{\\theta})) = \\left\\{\\begin{array} {rl}1 & y \\neq f(\\mathbf{x};\\boldsymbol{\\theta}) \\\\0 & y = f(\\mathbf{x};\\boldsymbol{\\theta}) \\end{array} \\right.由于相等条件过于严格，因此可以放宽条件，设置一个阈值 $T$，即满足 $|y-f(\\mathbf{x};\\boldsymbol{\\theta})|&lt;T$ 时认为相等，否则认为不相等 L(y,f(\\mathbf{x};\\boldsymbol{\\theta})) = \\left\\{\\begin{array} {rl}1, & |y - f(\\mathbf{x};\\boldsymbol{\\theta})|\\geq T \\\\0, & |y - f(\\mathbf{x};\\boldsymbol{\\theta})|","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"AOE网与关键路径","slug":"graph/05.aoe-critical-path/1.AOE网与关键路径","date":"2019-06-06T04:33:37.000Z","updated":"2021-09-12T13:56:46.549Z","comments":true,"path":"oi-acm/graph/aoe-critical-path/115b39e5.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/aoe-critical-path/115b39e5.html","excerpt":"【AOE 网】日常生活中，一项大的工程可以看作是由若干个子工程组成的集合，这些子工程之间必定存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始 用结点表示活动，用弧表示活动间优先关系，形成的无权 DAG 图，被称为顶点活动网络","text":"【AOE 网】日常生活中，一项大的工程可以看作是由若干个子工程组成的集合，这些子工程之间必定存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始 用结点表示活动，用弧表示活动间优先关系，形成的无权 DAG 图，被称为顶点活动网络 而用结点表示事件，用弧表示活动，用边权表示活动持续时间的有权 DAG 图，被称为边活动网络（Activity On Edge Network，AOE 网） 与 AOV 网相同，AOE 网同样存在如下基本概念： 活动：子工程组成的集合，每个子工程即为一个活动 前驱活动：有向边起点的活动称为终点的前驱活动，只有当一个活动的前驱全部都完成后，这个活动才能进行 后继活动：有向边终点的活动称为起点的后继活动 源点：工程开始的结点，入度为 $0$ 汇点：工程结束的结点，出度为 $0$ 【关键路径】AOE 网，主要用于工程管理，在 AOE 网中，有些活动是可以并行进行的，这就导致从源点到汇点的有向路径有多条，且这些路径长度不同 完成不同路径上的活动所需时间不同，只有所有路径上的活动都已完成，整个工程才算结束 关键路径被定义为从源点到汇点的具最大路径长度的路径，该路径上的活动被称为关键活动 关键活动决定了整个工程的工期，因此可以通过加快关键活动来缩短工程的工期，但不能任意缩短关键活动，当缩短到一定程度，会使得关键活动变为非关键活动 而 AOE 网中的关键活动不唯一，对于有几条关键路径的网，只提高一条关键路径上的关键活动并不能缩短整个工程的工期，只有加快包括在所有关键路径上的关键活动，才能缩短工期 此外，完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销总和，这是因为关键活动若不按期完成，则整个工程的完成时间就会被延长 因此，只要找到关键路径，就能得到工程的最短完成时间 【关键路径寻找参量】事件 $v_k$ 的最早发生时间 $ve(k)$ $ve(k)$ 是从源点 $v_1$ 开始到结点 $v_k$ 的最大路径长度，其是在保证工程顺利完成的基础上，事件最早的开始时间，其决定了所有从 $v_k$ 开始的活动能够开工的最早时间，因此称为最早发生时间 求解 $ve(k)$ 可以从源点 $ve(1)=0$ 开始 按照拓扑排序的规则，每输出一个入度为 $0$ 的顶点 $v_j$，计算它所有直接后继顶点 $v_k$ 的最早发生时间，即有： ve[k]=max(ve[k],ve[j]+dis[j][k])事件 $v_k$ 的最晚发生时间 $vl(k)$$vl(k)$ 是在保证工程顺利完成的基础上，事件 $v_k$ 最迟的开始时间，因此被称为最晚发生时间 求解 $vl(k)$ 可以从汇点 $vl(n)=ve(n)$ 开始 按照逆拓扑排序的规则，每输出一个出度为 $0$ 的顶点 $v_j$，计算它所有直接前驱顶点 $v_k$ 的最晚发生时间，即有： vl[k]=min(vl[k],vl[j]-dis[k][j])活动 $a_i$ 的最早开始时间 $ee(i)$$ee(i)$ 是在保证工程顺利完成的基础上，活动 $a_i$ 最早的必须开始时间，因此被称为最早开始时间 根据 AOE 网的性质，只有事件 $v_k$ 发生后，活动 $a_i$ 才能开始，那么若活动 $a_i$ 由 $&lt; v_k, v_j &gt;$ 表示，活动 $a_i$ 的最早开始时间等于事件 $v_k$ 的最早发生时间，即： ee[i]=ve[k]活动 $a_i$ 的最晚开始时间 $el(i)$$el(i)$ 是在保证工程顺利完成的基础上，活动 $a_i$ 最迟的必须开始时间，因此被称为最晚开始时间 若活动 $a_i$ 由弧 $&lt; v_k, v_j &gt;$ 表示，则 $a_i$ 的最晚开始时间要保证事件 $v_j$ 的最迟发生时间不拖后，即： el[i]=vl[j]-dis[k][j]活动 $a_i$ 的松弛时间 $d(i)$$d(i)$ 是指活动完成的时间余量，即在不增加完成整个工程所需时间的情况下，活动 $a_i$ 可以拖延的时间，其值为 $a_i$ 的最晚开始时间 $el(i)$ 与最早开始时间 $ee(i)$ 的差值，即： d(i)=el(i)-ee(i)若一个活动松弛时间为 $0$，那么说明该活动必须按期完成，否则会影响整个工程的进度 也就是说，若满足 $el(i)-ee(i)=0$，即满足 $el(i)=ee(i)$ 时，活动 $a_i$ 是关键活动 【关键路径的求解】关键路径的求解算法如下： 1）求结点的最早发生时间 $ve(i)$ 从源点出发，令 $ve(1)=0$，按拓扑序列，求解每个顶点 $i$ 的最早发生时间 $ve(i)$，即： ve[i]=max(ve[i],ve[j]+dis[j][i])2）求结点的最晚发生时间 $vl(i)$ 从汇点出发，令 $vl(n)=ve(n)$，按逆拓扑序列，求解每个顶点 $i$ 的最晚发生时间 $vl(i)$，即： vl[i]=min(vl[i],vl[j]-dis[i][j])3）求弧的最早开始时间 $ee(i)$ 根据各顶点 $i$ 的最早发生时间 $ve(i)$ 求所有弧 $&lt; v_k, v_j &gt;$ 的最早开始时间 $ee(i)$，即： ee[i]=ve[k]4）求弧的最晚开始时间 $el(i)$ 根据各顶点 $i$ 的最晚发生时间 $vl(i)$ 求所有弧 $&lt; v_k, v_j &gt;$ 的最晚开始时间 $el(i)$，即： el[i]=vl[j]-dis[k][j]4）求弧的松弛时间 $d(i)$ 计算所有弧的松弛时间 $d(i)$，找出所有 $d(i)=0$ 的弧，其构成一条关键路径，即： d(i)=el(i)-ee(i)=0【实例】 在上图所示的 AOE 网中，从源点事件 $1$ 和汇点事件 $6$，进行拓扑排序，可以得到一个拓扑序列为 $132456$，由此，事件最早发生时间 $ve(i)$ 与事件最晚发生时间 $vl(i)$ 如下表： 事件 $i$ $1$ $3$ $2$ $4$ $5$ $6$ $ve(i)$ $0$ $8$ $12$ $19$ $18$ $27$ $vl(i)$ $0$ $8$ $12$ $21$ $18$ $27$ 进一步，由于活动 $i$ 是由弧 $&lt; v_k, v_j &gt;$ 表示，那么，活动 $a$ 到活动 $h$ 的最早开始时间 $ee(i)$ 与最晚开始时间 $el(i)$ 如下表： 活动 $i$ $a$ $b$ $c$ $d$ $e$ $f$ $g$ $h$ 对应弧 $&lt; v_k, v_j &gt;$ $&lt; 1,2 &gt;$ $&lt; 3,2 &gt;$ $&lt; 1,3 &gt;$ $&lt; 2,4 &gt;$ $&lt; 2,5 &gt;$ $&lt; 3,5 &gt;$ $&lt; 4,6 &gt;$ $&lt; 5,6 &gt;$ $ve(v_k)$ $0$ $8$ $0$ $12$ $12$ $8$ $19$ $18$ $vl(v_j)$ $12$ $12$ $8$ $19$ $18$ $18$ $27$ $27$ 弧长 $3$ $4$ $8$ $7$ $6$ $10$ $6$ $9$ $ee(i)$ $0$ $8$ $0$ $12$ $12$ $8$ $19$ $18$ $el(i)$ $12-3=9$ $12-4=8$ $8-8=0$ $21-7=14$ $18-6=12$ $18-10=8$ $27-6=21$ $27-9=18$ 故活动的松弛时间 $d(i)$ 如下表： 活动 $i$ $a$ $b$ $c$ $d$ $e$ $f$ $g$ $h$ $ee(i)$ $0$ $8$ $0$ $12$ $12$ $8$ $19$ $18$ $el(i)$ $9$ $8$ $0$ $14$ $12$ $8$ $21$ $18$ $d(i)$ $9$ $0$ $0$ $2$ $0$ $0$ $2$ $0$ 可知，活动 $b$、$c$、$e$、$f$、$h$ 为关键活动，他们构成的路径 $cbeh$、$cbfh$ 为两条关键路径 在这两条关键路径中，活动 $c$、$b$、$h$ 在所有的关键路径中，因此，加快这三个活动的进度，能够缩短工期 【实现】输出关键路径根据关键路径的定义，依次求出 $ve$、$vl$、$ee$、$el$，然后比较 $ee$、$el$ 进行输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109int n,m;int G[N][N]; //邻接矩阵bool vis[N]; //访问数组int in[N]; //入度int ve[N]; //事件vk的最早发生时间int vl[N]; //事件vk的最晚发生时间int ee[N]; //活动ai的最早开始时间int el[N]; //活动ai的最晚开始时间int Stack[N]; //栈struct Edge &#123; int x, y; int dis; Edge() &#123;&#125; Edge (int x, int y, int dis): x(x), y(y), dis(dis)&#123;&#125;&#125; edge[N];void getVe() &#123; //求ve int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; //从源点开始，求每个结点i的ve int k = -1; for (int j = 1; j &lt;= n; j++) &#123; //按拓扑序列寻找入度为0的点 if (in[j] == 0) &#123; //入度为0，进栈 Stack[++cnt] = j; k=j; in[j]=-1; break; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; //计算ve if(G[k][j] != INF) &#123; ve[j] = max(ve[j], ve[k] + G[k][j]); in[j]--; &#125; &#125; &#125;&#125;void getVl() &#123; //求vl memset(vl, INF, sizeof(vl)); vl[Stack[n]] = ve[Stack[n]]; for (int i = n; i &gt;= 1; i--) &#123; //从汇点开始，求每个结点i的vl for (int j = 1; j &lt;= n; j++) //计算vl if (G[Stack[i]][j] != INF) vl[Stack[i]] = min(vl[j] - G[Stack[i]][j] , vl[Stack[i]]); &#125;&#125;void getEe() &#123; //求ee for (int i=1; i&lt;=m; i++) ee[i] = ve[edge[i].x];&#125;void getEl() &#123; //求el for (int i = 1; i &lt;= m; i++) el[i] = vl[edge[i].y] - edge[i].dis;&#125; void printEdge() &#123; //以边输出 for (int i = 1; i &lt;= m; i++) if (ee[i] == el[i]) //松弛时间为0的关键活动 printf(\"&lt;%d,%d&gt;:%d\\n\", edge[i].x, edge[i].y, edge[i].dis);&#125;void printNode()&#123; //以点输出 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= m; i++) &#123; if (ee[i] == el[i]) &#123; //松弛时间为0的关键活动 int x = edge[i].x; int y = edge[i].y; if (!vis[x]) &#123; Q.push(x); vis[x] = true; &#125; if (!vis[y]) &#123; Q.push(y); vis[y] = true; &#125; &#125; &#125; while (!Q.empty()) &#123; int temp = Q.top(); Q.pop(); printf(\"v%d \", temp); &#125;&#125;int main() &#123; memset(G,INF,sizeof(G)); scanf(\"%d%d\",&amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int x, y, dis; scanf(\"%d%d%d\",&amp;x, &amp;y, &amp;dis); edge[i].x = x; edge[i].y = y; edge[i].dis = dis; G[x][y] = dis; in[y]++; &#125; getVe(); getVl(); getEe(); getEl(); printf(\"以边输出：\\n\"); printEdge(); printf(\"以点输出：\\n\"); printNode(); return 0;&#125; 求关键路径长度由于关键路径是具有最大路径长度的路径，因此直接求有向图的最长路即为关键路径的长度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Node &#123; int to, dis; Node()&#123;&#125; Node(int to, int dis): to(to), dis(dis)&#123;&#125;&#125;;int n, m;int in[N];vector&lt;Node&gt; G[N];int dis[N];void getPath() &#123; queue&lt;int&gt; Q; for (int i = 0; i &lt; n; i++) &#123; if (in[i] == 0) &#123; Q.push(i); dis[i]++; &#125; &#125; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for(int i = 0; i &lt; G[x].size(); i++) &#123; int y = G[x][i].to; int diss = G[x][i].dis; dis[y] = max(dis[y], dis[x] + diss); if (--in[y] == 0) Q.push(y); &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y, dis; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;dis); G[x].push_back(Node(y, dis)); in[y]++; &#125; getPath(); int res = -INF; for(int i = 0; i &lt; n; i++) res = max(res, dis[i]); printf(\"%d\\n\",res); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"AOE网与关键路径","slug":"oi-acm/graph/aoe-critical-path","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/aoe-critical-path/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"AOE网与关键路径","slug":"aoe-critical-path","permalink":"https://alex-mcavoy.github.io/tags/aoe-critical-path/"}],"author":"Alex_McAvoy"},{"title":"机器学习三要素","slug":"machine-learning/03.机器学习三要素","date":"2019-06-05T06:27:00.000Z","updated":"2023-03-31T12:42:48.417Z","comments":true,"path":"artificial-intelligence/machine-learning/d6bfa51b.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/d6bfa51b.html","excerpt":"【概述】在 机器学习概述 中，对机器学习进行了简单的介绍，即机器学习是由模型、策略、算法构成的，可以表示为：方法 = 模型 + 策略 + 算法","text":"【概述】在 机器学习概述 中，对机器学习进行了简单的介绍，即机器学习是由模型、策略、算法构成的，可以表示为：方法 = 模型 + 策略 + 算法 对于监督学习来说，处理的是标注数据，数据类型是已知的，知道输出是什么样的，因此，相应的模型、策略、算法是比较具体的 对于非监督学习来说，处理的是未标注数据，希望能找到隐含在数据内部的结构信息，此时，相应的模型、策略、算法就不那么具体了 【监督学习】模型在监督学习过程中，模型就是要学习的决策函数或条件概率分布，模型的假设空间中的模型有无穷多个，包含所有可能的决策函数或条件概率分布，一般用 $\\mathcal{F}$ 来表示假设空间 决策函数若假设空间 $\\mathcal{F}$ 为决策函数的集合，$X$ 和 $Y$ 是定义在输入空间 $\\mathcal{X}$ 和输出空间 $\\mathcal{Y}$ 上的变量，则： \\mathcal{F}=\\{f\\:|\\:Y=f(X)\\}而 $\\mathcal{F}$ 是由取值于 $n$ 维欧式空间 $\\mathbb{R}^n$ 的参数向量 $\\boldsymbol{\\theta}$ 决定的函数族，即： \\mathcal{F}= \\{f\\:|\\:Y=f(X;\\boldsymbol{\\theta}),\\boldsymbol{\\theta}\\in \\mathbb{R}^n\\}对于参数向量 $\\boldsymbol{\\theta}$ 取值的 $n$ 维欧式空间 $\\mathbb{R}^n$，即：$\\Theta=\\{\\boldsymbol{\\theta}|\\boldsymbol{\\theta}\\in \\mathbb{R}^n\\}，$通常称为参数空间 条件概率若假设空间 $\\mathcal{F}$ 为条件概率的集合，$X$ 和 $Y$ 是定义在输入空间 $\\mathcal{X}$ 和输出空间 $\\mathcal{Y}$ 上的随机变量，则： \\mathcal{F}=\\{P\\:|\\:P(Y|X)\\}而 $\\mathcal{F}$ 是由取值于 $n$ 维欧式空间 $\\mathbb{R}^n$ 的参数向量 $\\boldsymbol{\\theta}$ 决定的条件概率分布族，即： \\mathcal{F}= \\{P\\:|\\:P_{\\boldsymbol{\\theta}}(Y|X),\\boldsymbol{\\theta}\\in \\mathbb{R}^n\\}对于参数向量 $\\boldsymbol{\\theta}$ 取值的 $n$ 维欧式空间 $\\mathbb{R}^n$，即：$\\Theta=\\{\\boldsymbol{\\theta}|\\boldsymbol{\\theta}\\in \\mathbb{R}^n\\}$，通常称为参数空间 策略在有了模型的假设空间后，接着要考虑的问题是按照什么样的准则去学习或选择最优模型 损失函数监督学习问题是在假设空间 $\\mathcal{F}$ 中选取模型 $f$ 作为决策函数，对于给定的输入 $X$，由决策函数 $f(X;\\boldsymbol{\\theta})$ 给出相应的输出 $Y$ 一个好的模型 $f(X;\\boldsymbol{\\theta})$ 应该在所有的 $(\\mathbf{x},\\mathbf{y})$ 的可能取值上都与真实映射函数 $y=g(x)$ 一致，但由于输出的预测值 $f(X;\\boldsymbol{\\theta})$ 与真实值 $Y$ 可能存在误差，因此需要用一个函数来度量模型预测和真实标签间的差异，这个函数被称为损失函数（Loss Function）或代价函数（Cost Function），其是真实值 $Y$ 与预测值 $f(X;\\boldsymbol{\\theta})$ 的非负实值函数，记作：$L(Y,f(X;\\boldsymbol{\\theta}))$ 简单来说，损失函数度量了模型一次预测的好坏，损失函数值越小，模型就越好，不同模型采用的损失函数一般不同，常见的损失函数详见：机器学习中常见的损失函数 期望风险机器学习的目标是选择期望风险最小的模型，即使用期望风险来度量平均意义下模型预测的好坏 模型的输入、输出 $(X,Y)$ 是随机变量，遵循联合分布律 $P(X,Y)$，那么损失函数 $L(Y,f(X;\\boldsymbol{\\theta}))$ 的期望为： R_{exp}(f) = E_p\\big[L(Y,f(X;\\boldsymbol{\\theta}))\\big]=\\int_{\\mathcal{X}\\times\\mathcal{Y}}L(Y,f(\\mathbf{x};\\boldsymbol{\\theta}))P(X,Y)dXdY这是理论上模型 $f(X;\\boldsymbol{\\theta})$ 关于联合分布 $P(X,Y)$ 的平均意义下的损失，称为期望风险（Expected Risk），又称期望损失（Expected Loss） 事实上，如果知道真实分布 $P(X,Y)$，那就可以从真实分布直接求出条件概率分布 $P(Y|X)$，这样就不需要学习了 但由于真实分布 $P(X,Y)$ 是未知的，期望风险 $R_{exp}(f)$ 无法直接计算，因此监督学习成了一个病态问题（Ill-formed Problem），即一方面要根据期望风险来度量模型从而求得最优模型，另一方面又不知道真实分布 经验风险将机器学习问题转换为一个优化问题的最简单的方法是通过最小化测试集上的期望风险，这意味着需要用测试集上的经验分布 $\\hat{P}(X,Y)$ 替代真实分布 $P(X,Y)$ 将给定训练集模型 $f(X;\\boldsymbol{\\theta})$ 关于测试集的平均损失称为经验风险（Empirical Risk）或经验损失（Empirical Loss），即： R_{emp}(f)=\\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))考虑到辛钦大数定律，对于一个样本容量为 $N$ 的测试集 $T=\\{(\\mathbf{x_1},\\mathbf{y_1}),(\\mathbf{x_2},\\mathbf{y_2}),…,(\\mathbf{x_N},\\mathbf{y_N})\\}$，当 $N$ 趋于无穷时，测试集的损失函数的平均损失依概率收敛到真实分布的期望风险 因此，可以用经验风险 $R_{emp}(f)$ 来估计期望风险 $R_{exp}(f)$，即： R_{emp}(f)=\\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta})) \\longrightarrow R_{exp}(f) = E_p\\big[L(Y,f(X;\\boldsymbol{\\theta}))\\big],\\quad N\\rightarrow \\infty也就是说，经验风险是测试集中 $N$ 个独立随机变量 $(\\mathbf{x_i},\\mathbf{y_i})$ 的损失函数 $L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))$ 的均值，期望风险可以看作是经验风险的期望值 但由于训练样本数目有限，效果常常不理想，这就需要对经验风险进行一定的矫正，即风险最小化 关于依概率收敛： 设 $X_1,X_2,…,X_n$ 是相互独立的随机变量序列，$X$ 是一个随机变量，若对任意的 $\\varepsilon &gt; 0$，使得下式成立，则称随机变量序列 $X_1,X_2,…,X_n$ 依概率收敛到 $X$ \\lim_{n\\rightarrow \\infty} P \\Big\\{ \\bigg| \\sum_{i=1}^n X_i - \\mu \\bigg| \\geq \\varepsilon \\Big\\} =0关于辛钦大数定律： 设 $X_1,X_2,…,X_n$ 是相互独立的随机变量序列，服从相同分布，且具有有限的数学期望 $\\mu$，则对于任意的 $\\varepsilon &gt; 0$，有： \\lim_{n\\rightarrow \\infty} P \\Big\\{ \\bigg| \\frac{1}{n} \\sum_{i=1}^n X_i - \\mu \\bigg| < \\varepsilon \\Big\\} =1辛钦大数定律从理论上指出：用算术平均值来近似实际真值是合理的，在数理统计中，这一定律使得用算术平均值来估计数学期望有了理论依据 经验风险最小化策略在假设空间 $\\mathcal{F}$、损失函数 $L(Y,f(X;\\boldsymbol{\\theta}))$、训练数据集 $T$ 确定的情况下，经验风险 $R_{emp}(f)$ 就可以确定 经验风险最小化（Empirical Risk Minimization，ERM）策略认为，经验风险最小的模型即最优模型 根据这一策略，按照经验风险最小化求最优模型，就是求解经验风险最优化问题，即： \\min_{f\\in \\mathcal{F}}\\quad \\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))在样本容量 $N$ 足够大时，该种方法能够保证很好的学习效果，但通常情况下，无法获取无限的训练样本，且训练样本往往是真实数据的一个很小的子集或包含一定噪声的数据，无法很好地反映全部数据的真实分布，这就容易导致模型在测试集的错误率很低，但在未知数据上的错误率很高，即所谓的过拟合（Over-fitting）现象 结构风险为防止过拟合现象，又引入了结构风险（Structural Risk），其是在经验风险 $R_{emp}(f)$ 的基础上加上表示模型复杂度的正则化项（Regularizer），即： R_{str}(f)=\\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))+\\lambda J(f)其中， $\\lambda \\geq 0$ 是系数，$J(f)$ 是定义在假设空间 $\\mathcal{F}$ 上的泛函数，表示模型的复杂度，模型 $f$ 越复杂， $J(f)$ 就越大，模型 $f$ 越简单，$J(f)$ 就越小，常用的有 L1 范数、L2 范数 在上面这个式子中，复杂度 $J(f)$ 可以理解为对复杂模型的惩罚，系数 $\\lambda$ 用来控制正则化强度，以此权衡经验风险和模型复杂度 结构风险最小化策略结构风险最小化（Structural Risk Minimization，SRM）策略等价于正则化（Regularization），其认为结构风险最小的模型是最优模型，因此求解最优模型，就是求解结构风险最优化问题，即： \\min_{f\\in \\mathcal{F}}\\quad \\frac{1}{N}\\sum_{i=1}^N L(\\mathbf{y_i},f(\\mathbf{x_i};\\boldsymbol{\\theta}))+\\lambda J(f)此时，结构风险 $R_{str}(f)$ 就是最优化的目标函数，监督学习的优化问题就转换为了结构风险的优化问题 算法统计学习基于训练集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的算法求解最优模型，而最后一步的算法，就是指学习模型的具体计算方法 在引入经验风险最小化和结构风险最小化后，监督学习问题就变成了最优化问题，此时经验风险函数或结构风险函数就是最优化的目标函数 此时算法就称为了求解最优化问题的算法，如果优化问题存在解析解，那么通过严格的公式即可求得，但大多数情况下解析解不存在，此时就要用数值计算的方法（如梯度下降法），来求解近似解 【非监督学习】对于非监督学习来说，处理的是未标注数据，我们希望能找到隐含在数据内部的结构信息，此时，相应的模型、策略、算法就不那么具体了，简单来说，无监督学习的三要素如下： 模型：函数 $Z=g(X;\\boldsymbol{\\theta})$，条件概率分布 $P_{\\theta}(Z|X)$ 或 $P_{\\boldsymbol{\\theta}}(X|Z)$ 策略：优化目标函数 算法：通常为迭代算法","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"机器学习的分类","slug":"machine-learning/02.机器学习的分类","date":"2019-06-03T13:49:00.000Z","updated":"2023-03-31T12:32:59.530Z","comments":true,"path":"artificial-intelligence/machine-learning/5b4cd4f9.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/5b4cd4f9.html","excerpt":"【监督学习】定义监督学习（Supervised Learning）的任务是学习一个模型，使得模型能够对任意给定的输入，对其相应的输出做出一个好的预测，简单来说，就是利用训练数据集学习一个模型，再用模型对测试样本集进行预测","text":"【监督学习】定义监督学习（Supervised Learning）的任务是学习一个模型，使得模型能够对任意给定的输入，对其相应的输出做出一个好的预测，简单来说，就是利用训练数据集学习一个模型，再用模型对测试样本集进行预测 监督学习是从已标注好数据输入输出对应关系的标注数据中进行学习，本质是学习从输入到输出的映射的统计规律 基本概念1.输入与输出空间 在监督学习中，输入、输出变量/向量用大写字母表示，习惯上输入变量/向量写为 $X$，输出变量/向量写为 $Y$；输入、输出变量的取值用小写字母表示，习惯上输入变量的取值写为 $x$，输出变量的取值写为 $y$；输入、输出向量的取值用加粗的小写字母表示，习惯上输入向量的取值写为 $\\mathbf{x}$，输出向量的取值写为 $\\mathbf{y}$ 输入与输出的所有可能取值的集合分别称为输入空间、输出空间，分别用 $\\mathcal{X}$、$\\mathcal{Y}$ 表示，他们可以是有限元素的集合，也可以是整个欧式空间 $\\mathbb{R}^n$，即现实空间规则的抽象与推广（从 $n\\leq 3$ 到有限 $n$ 维空间） 2.假设空间 监督学习的目标就是从假设空间中找到最优的参数组合，具体来说，就是学习一个用模型来表示的从输入到输出的映射，模型属于从输入空间到输出空间的映射的集合，这个集合就是假设空间 也就是说，监督学习想学习一种映射 $\\hat{\\mathbf{y}}=f(\\mathbf{x};\\boldsymbol{\\theta})$，$\\boldsymbol{\\theta}$ 为映射 $f$ 的参数向量，那么所有可能的参数向量组成假设空间，要从假设空间中找到最优的 $\\boldsymbol{\\theta}$ 使得 $f(\\mathbf{x};\\boldsymbol{\\theta})$ 尽可能逼近真实值 $\\mathbf{y}$ 3.特征空间 每个具体的输入是一个实例，由特征向量来表示，所有特征向量存在的空间称为特征空间，输入空间与特征空间大多时候为同一个空间，当不为同一个空间时，会将实例从输入空间映射到特征空间 对于输入实例 $\\mathbf{x}$ 的特征向量，记作： \\mathbf{x}=(x^{(1)},x^{(2)},...,x^{(n)})^T \\in \\mathbb{R}^n其中，$x^{(i)}$ 表示 $\\mathbf{x}$ 的第 $i$ 个特征 同时，用 $\\mathbf{x_i}$ 表示多个输入向量中的第 $i$ 个向量，则 $\\mathbf{x_i}$ 的表示为： \\mathbf{x_i}=(x^{(1)}_i,x^{(2)}_i,...,x^{(n)}_i)4.样本 监督学习从训练数据集中学习模型，对测试数据进行预测，训练数据由输入与输出对组成，对于样本容量为 $N$ 的训练集，表示为： T=\\{(\\mathbf{x_1},\\mathbf{y_1}),(\\mathbf{x_2},\\mathbf{y_2}),...,(\\mathbf{x_N},\\mathbf{y_N})\\}其中，每一个输入输出对 $(\\mathbf{x_i},\\mathbf{y_i})$ 称为一个样本 模型形式针对具体的学习方法，监督学习可以是概率模型也可以是非概率模型，分别由条件概率分布 $P_{\\boldsymbol{\\theta}}(Y|X)$ 或决策函数 $Y=f(X;\\boldsymbol{\\theta})$ 来表示 在对训练集训练完成得到模型后，根据训练的模型，对具体的输入进行相应的输出预测时，输出写作 $\\hat{P}_{\\boldsymbol{\\theta}}(\\mathbf{y}|\\mathbf{x})$ 或 $y=\\hat{f}(\\mathbf{x};\\boldsymbol{\\theta})$ 生成模型与判别模型监督学习方法可以分为生成方法、判别方法，相应地，学习到的模型分别被称为生成模型、判别模型 1.生成模型 生成方法通过学习联合概率分布 $P(X,Y)$，然后求出条件概率分布 $P(Y|X)$ 作为预测模型，即： P(Y|X)=\\frac{P(X,Y)}{P(X)}生成模型表示了给定输入 $X$ 产生输出 $Y$ 的生成关系，其可以还原出联合概率分布 $P(X,Y)$，且收敛速度更快 2.判别模型 判别方法通过直接学习决策函数 $f(X;\\boldsymbol{\\theta})$ 或条件概率分布 $P(Y|X)$ 作为预测模型 判别模型关心的是给定输入的 $X$，应该预测什么样的输出 $Y$，其直接面对预测，学习的准确率会更高，同时由于是直接学习 $f(X;\\boldsymbol{\\theta})$ 或 $P(Y|X)$，可以对数据进行各种程度上的抽象、定义特征并使用特征，从而简化学习问题 预测任务回归问题输入、输出变量均为连续变量，回归模型用于预测输入变量和输出变量间的关系，表示从输入变量到输出变量间的映射函数 回归问题的学习等价于函数拟合，即选择一条函数曲线，使其能够很好地拟合已知数据，且能很好地对未知数据进行预测 回归问题按照输入变量的个数，分为一元回归、多元回归；按照输入变量和输出变量间的关系，分为线性回归、非线性回归 常用的学习方法有：一元线性回归、多元线性回归、多项式回归、k 近邻、决策树等 分类问题当输出变量 $Y$ 取有限个离散变量时，预测问题即变为分类问题，此时，输入变量 $X$ 可以是离散的，也可以是连续的 监督学习会从数据中学习一个分类模型或分类决策函数，即分类器（Classifier），分类器将会对于新的输入进行预测，确定输入所属的类别 常用的学习方法有：感知机、k 近邻、朴素贝叶斯、决策树、Logistic 回归与最大熵模型、支持向量机、提升方法等 标注问题标注问题可以认为是分类问题的推广，输入是一观测序列，输出是一个标记序列或状态序列，其目的是学习一个模型，使其能够对观测序列给出标记序列作为预测 简单来说，分类问题的输出是一个值，而标注问题输出是一个向量，向量的每个值属于一种标记类型 标注问题在信息抽取、自然语言处理领域等领域广泛应用，常用的学习方法有：隐马尔可夫模型、条件随机场等，其评价标准与评价分类模型的指标相同 【非监督学习】定义非监督学习（Unsupervised Learning）是直接从自然数据（无标注数据）中学习预测模型，其没有给定标记过的训练范例，即事先不知道输入数据对应的输出结果是什么，其本质是学习数据中的统计规律、潜在结构 非监督学习所用的数据没有属性或标签这一概念，对于每一个输入实例，给定的输出是对输入的结果分析，可由输入的类别、转换、概率来表示，相应地，可以实现数据的聚类、降维、密度估计 基本概念1.输入与输出空间 在非监督学习中，输入、输出变量/向量用大写字母表示，习惯上输入变量/向量写为 $X$，输出变量/向量写为 $Z$；输入、输出变量的取值用小写字母表示，习惯上输入变量的取值写为 $x$，输出变量的取值写为 $z$；输入、输出向量的取值用加粗的小写字母表示，习惯上输入向量的取值写为 $\\mathbf{x}$，输出向量的取值写为 $\\mathbf{z}$ 输入与输出的所有可能取值的集合分别称为输入空间、输出空间，分别用 $\\mathcal{X}$、$\\mathcal{Z}$ 表示，他们可以是有限元素的集合，也可以是整个欧式空间 $\\mathbb{R}^n$，即现实空间规则的抽象与推广（从 $n\\leq 3$ 到有限 $n$ 维空间） 2.假设空间 在非监督学习中，包含所有可能的模型的集合称为假设空间 非监督学习的目标是从假设空间中选出给定评价标准下的最优模型 3.样本 非监督学习通常使用大量的无标注数据进行训练，每个样本是一个实例 对于样本容量为 $N$ 的训练集，表示为： U=\\{\\mathbf{x_1},\\mathbf{x_2},...,\\mathbf{x_N}\\}模型形式针对具体的学习方法，非监督学习可以是概率模型也可以是非概率模型，分别由条件概率分布 $P_{\\boldsymbol{\\theta}}(Z|X)$、$P_{\\boldsymbol{\\theta}}(X|Z)$ 或决策函数 $Z=g(X;\\boldsymbol{\\theta})$ 来表示 对于具体的输入来说，分析时使用学习得到的具体模型写作：$\\hat{P}_{\\boldsymbol{\\theta}}(\\mathbf{z}|\\mathbf{x})$、$\\hat{P}_{\\boldsymbol{\\theta}}(\\mathbf{x}|\\mathbf{z})$ 或 $\\mathbf{z}=\\hat{g}(\\mathbf{x};\\boldsymbol{\\theta})$ 预测任务聚类问题聚类，是发现数据集 $X$ 中的纵向结构，即将数据按照相似度聚类成不同的分组 假设输入空间 $X$，输出空间为类别集合 $Z=\\{1,2,…,k\\}$，对于输入空间 $X$ 中的某一输入 $\\mathbf{x_{N+1}}$，由模型 $\\hat{P}_{\\boldsymbol{\\theta}}(Z|X)$ 或 $Z=\\hat{g}(X;\\boldsymbol{\\theta})$ 给出相应的输出 $\\mathbf{z_{N+1}}$ 当聚类问题为硬聚类，即一个样本只能属于一个类时，模型采用 $Z=\\hat{g}(X;\\boldsymbol{\\theta})$；当聚类问题为软聚类，即一个样本可以属于多个类时，模型采用 $\\hat{P}_{\\boldsymbol{\\theta}}(Z|X)$ 降维问题降维，是发现数据集 $X$ 中的横向结构，即数据可能会出现维度灾难的问题，需要在保留数据结构和有用性的同时对数据进行压缩 假设输入空间 $X$，输出空间为 $Z$，$\\mathbf{x}\\in X$ 是样本的高维向量，$\\mathbf{z}\\in Z$ 是样本的低维向量，对于给定的输入 $\\mathbf{x_{N+1}}$，由模型 $Z=\\hat{g}(X;\\boldsymbol{\\theta})$ 给出相应的输出 $\\mathbf{z_{N+1}}$，其中 $g$ 可是线性函数，也可是非线性函数 概率估计问题概率估计，是指对于给出的无标注数据，寻找分布规律并估计服从这种分布的正确性概率是多少，简单来说，是假设训练数据由一个概率模型生成，通过训练数据来学习这个模型的结构与参数 通常由条件分布 $P_{\\Theta}(X|Z)$ 来表示概率估计，对于输入数据 $x\\in X$，其可以是连续变量，也可以是离散变量；对于输出数据 $z\\in Z$，当模型为隐式结构时，$z$ 为离散变量，当模型为混合模型时，$z$ 表示成分的个数，当模型为概率图模型时，$z$ 表示图的结构 根据贝叶斯公式，软聚类也可看作概率估计问题，即： P(Z|X)=\\frac{P(Z)P(X|Z)}{P(X)} \\propto P(Z)P(X|Z)其中，$P(Z)$ 为先验概率，且服从均匀分布，因此只需计算出条件概率 $P_{\\boldsymbol{\\theta}}(X|Z)$ 即可进行软聚类 【强化学习】强化学习（Reinforcement Learning）是指智能系统在与环境的连续互动中，学习最优行为策略的机器学习问题 智能系统与环境的互动基于马尔科夫决策过程（Markov Decision Processes, MDPs），观测到的是与环境互动得到的数据序列，其本质是学习最优的按时序排列的各种决策，即序贯决策 简单来说，就是一个智能体（Agent）通过采取行动（Action），来改变自己的状态（State），以获得奖励（Reward），并与环境（Environment）发生交互的循环过程 智能系统与环境的互动如下图所示，在每一步 $t$，智能系统从环境中观测一个状态 $s_t$ 与一个奖励 $r_t$，采取一个动作 $a_t$，环境根据智能系统选择的动作 $a_t$，决定下一步 $t+1$ 的状态 $s_{t+1}$ 和奖励 $r_{t+1}$ 在强化学习过程中，系统不断的试错，以达到学习最优策略的目的，整个智能系统的目标不是短期奖励最大化，而是长期累积奖励的最大化 【半监督学习与主动学习】半监督学习（Semi-supervised Learning）是指同时利用标注数据和未标注数据学习预测模型的机器学习问题 由于标注数据的构建需要人工干预，成本较高，而未标注数据的收集不需太多成本，因此用少量标注数据、大量未标注数据进行学习，以较低的成本达到较好的学习效果 主动学习（Active Learning）是指机器不断主动给出实例让用户进行标注，然后用标注数据学习预测模型的机器学习问题 一般的监督学习所使用的标注数据往往是随机得到的，可以看作是被动学习，主动学习的目标是找出对学习最有利的实例让用户进行标注，即通过较小的标注代价，达到较好的学习效果","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"机器学习概述","slug":"machine-learning/01.机器学习概述","date":"2019-06-03T05:16:00.000Z","updated":"2023-03-31T12:42:44.628Z","comments":true,"path":"artificial-intelligence/machine-learning/3d0bbe69.html","link":"","permalink":"https://alex-mcavoy.github.io/artificial-intelligence/machine-learning/3d0bbe69.html","excerpt":"【概述】当提及机器学习时，一般指的是统计机器学习（Statistical Machine Learning），其也被称为统计学习（Statistical Learning），即利用数据来构建统计模型，并运用模型对数据进行预测和分析的学科 【形式化】","text":"【概述】当提及机器学习时，一般指的是统计机器学习（Statistical Machine Learning），其也被称为统计学习（Statistical Learning），即利用数据来构建统计模型，并运用模型对数据进行预测和分析的学科 【形式化】统计学习方法包括：模型的假设空间、模型的选择准则、求解最优模型的算法，这三者被称为统计学习三要素，即：模型（Model）、策略（Strategy）、算法（Algorithms） 简单来说，在确定模型的假设空间后，需要依照一定的标准在假设空间中选取一个最优模型，依照的标准即模型的选择准则，而选取最优模型的需要通过一定的算法来求解出，这个算法即求解最优模型的算法 基于上述的三要素，统计学习的实现步骤如下： 获取一个有限的训练数据集 确定模型（确定模型的假设空间） 确定策略（确定模型的选择准则） 实现算法（设计选择最优模型的算法） 通过学习方法（即第 2、3、4 步）来选择一个最优模型 通过第 5 步得出的最优模型，对新的数据集进行预测、分析 如下图，假设训练集中有 $N$ 个数据，学习系统包含第 2、3、4 步过程的实现，模型为第 5 步得出的最优模型，即预测系统 将训练集输入到学习系统中，通过学习系统不断地学习，得到了一个最优模型（预测系统），当输入一个新的实例 $\\mathbf{x_{N+1}}$ 时，通过预测系统即可得到输出 $\\mathbf{y_{N+1}}$，即对于新数据的预测和分析 【分类】机器学习可以按照任务、模型、处理过程等进行分类 若按任务分类，可分为：监督学习、无监督学习、半监督学习、强化学习，具体介绍见：机器学习的分类 需要说明的是，深度学习是根据模型的结构上的差异化形成的机器学习的一个分支，而其它四类是连接主义学习的四大类别，深度学习跟四类都是有都分重叠关系 若按模型分类，可分为： 概率模型与非概率模型 概率模型：用条件概率分布表达的模型，例如：决策树、朴素贝叶斯等 非概率模型：用函数表达的模型，例如：感知机、支持向量机、神经网络等 线性模型与非线性模型 线性模型：模型函数是线性的，例如：线性回归模型、Logistics 回归模型等 非线性模型：模型函数是非线性的，例如：神经网络等 参数化模型与非参数化模型 参数化模型：模型参数维度是固定的，例如：感知机、朴素贝叶斯等 非参数化模型：模型参数维度是不固定的，例如：决策树、k 近邻等 若按处理过程分类，可分为： 在线学习：每次接受一个输入，然后进行预测，在每次接受样本预测后，不断地去修正、优化模型 批量学习：每次接受所有输入，学习后即进行预测","categories":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/"},{"name":"机器学习","slug":"artificial-intelligence/machine-learning","permalink":"https://alex-mcavoy.github.io/categories/artificial-intelligence/machine-learning/"}],"tags":[{"name":"人工智能","slug":"artificial-intelligence","permalink":"https://alex-mcavoy.github.io/tags/artificial-intelligence/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://alex-mcavoy.github.io/tags/machine-learning/"}],"author":"Alex_McAvoy"},{"title":"总线标准","slug":"computer-composition/24.总线标准","date":"2019-05-12T11:46:00.000Z","updated":"2022-05-12T17:06:48.786Z","comments":true,"path":"notes/computer-composition/d52ef6b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/d52ef6b.html","excerpt":"【总线标准】基本概念 总线标准：国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范 通用接口：按总线标准设计的接口，在通用接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求 即插即用：自动配置计算机板卡与设备，将物理设备与驱动配合，在设备与其驱动间建立信道 热插拔：带电插拔，允许用户不关闭系统，不切断电源情况下取出，能够有效提高系统的备灾能力","text":"【总线标准】基本概念 总线标准：国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范 通用接口：按总线标准设计的接口，在通用接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求 即插即用：自动配置计算机板卡与设备，将物理设备与驱动配合，在设备与其驱动间建立信道 热插拔：带电插拔，允许用户不关闭系统，不切断电源情况下取出，能够有效提高系统的备灾能力 标准划分 系统总线：连接计算机各功能部件，如 ISA、EISA、VESA、PCI、PCI-Express 设备总线：外设总线，如 IDE、RS-232C、USB、SATA、SCSI、PCMCIA 局部总线：ISA 总线与 CPU 总线间的一段总线，用于节省系统带宽，如 PCI、PCI-E、VESA、AGP 视频线：传输视频信号的总线，如 VGA、DVI、HDMI 【常见标准】系统总线 ISA：工业标准体系结构（ISA，Industry Standard Architecture）总线，工作频率 $8MHz$，需要用 CPU 或 DMA 管理数据传输，不支持总线仲裁，是最早出现的微型计算机的系统总线标准 EISA：扩展的工业标准体系结构（EISA，Extended Industry Standard Architecture）总线，工作频率 $8MHz$，是为配合 $32$ 位 CPU 而设计的总线扩展标准，对 ISA 完全兼容，从 CPU 中分离出总线控制权，支持突发传送 设备总线 USB：通用串行总线（USB，Universal Serial Bus）是一种连接外部设备的 I/O 总线标准，具有即插即用、热播拔等优点，同时具强连接能力，可由低压外设供电 RS-232C：推荐标准（RS-232C，Recommended Standard-232C）总线是由美国电子工业协会（EIA）推荐的一种串行通信总线标准，应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口 IDE：集成设备电路（IDE，Integrated Drive Electronics）是一种接口磁盘驱动器接口类型，硬盘和光驱通过 IDE 接口与主板连接 SATA：串行高级技术附件（SATA，Serial Advanced Technology Attachment）是基于行业标准的串行硬件驱动器接口，由 Intel，IBM、Dell、APT 等公司共同提出的硬盘接口规范，不同于 IDE 的新型硬盘接口 SCSI：小型计算机系统接口（SCSI，Small Computer System Interface）是用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）的系统级接口的独立处理器标准，是一种智能的通用接口标准 PCMCIA：私人计算机记忆器国际标准（PCMCIA，Personal Computer Memory Card International Association）是广泛应用于笔记本电脑中的一种接口标准，是一个小型的用于扩展功能的插槽，低功耗、即插即用 局部总线 PCI：外部设备互连（PCI，Peripheral Component Interconnect）总线，专为高度集成的外围部件、扩充插板和处理器/存储器系统而设计的互联机制，即插即用，可用于将显卡、声卡、网卡等挂载在 CPU 总线上，支持突发传送，可以通过桥连接实现多层 PCI 总线 AGP：加速图形接口（AGP，Accelerated Graphics Pot），是一种视频接口标准，属于 PCI 的扩充，专用于连接主存和图形存储器，为传输视频和三维图形数据提供了切实可行的解决方案 PCI-E：扩展的外部设备互连（PCI-E，Peripheral Component Interconnect Express）总线，全新于 CPI 的架构，运行远快于 PCI，支持热插拔、全双工模式 VESA：视凝电子标准协会（VESA，Video Electronics Standards Association）总线，用于 $32$ 位标准的计算机上，针对多媒体 PC 要求高速传送活动图像的大量数据应运而生的，用于传输大量活动图像的数据，专对传输视频的高数据传输率要求而设计 视频线 VGA：视频图形阵列（VGA，Video Graphics Array）用于给 CRT 显示器或 LCD 显示器传输模拟信号，是显卡上应用最广泛的接口类型 DVI：数字视频接口（DVI，Digital Visual Interface）可所使用较低成本来实现长距离、高质量的数字信号传输 HDMI：高清多媒体接口（HDMI，High Definition Multimedia Interface）可同时传输声音、图像，根据用途可分为三种型号 A 型：用于高清电视、投影仪 C 型：用于平板、MP4 D 型：用于手机、平板","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"总线操作与定时","slug":"computer-composition/23.总线操作与定时","date":"2019-05-12T05:15:00.000Z","updated":"2022-05-12T14:29:08.980Z","comments":true,"path":"notes/computer-composition/b6f11eef.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/b6f11eef.html","excerpt":"【总线传输阶段】一个总线周期通常可分为以下四个阶段： 申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者 寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块 传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权","text":"【总线传输阶段】一个总线周期通常可分为以下四个阶段： 申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者 寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块 传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权 【总线定时】总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，它的实质是一种协议或规则，主要有同步和异步两种基本定时方式 同步定时方式同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系 时钟产生相等的时间间隔，每个间隔构成一个总线周期，在一个总线周期中，发送方和接收方可以进行一次数据传送 因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始 该方式传送速度快，具有较高的传输速率，且总线控制逻辑简单，但主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差，适用于总线长度较短及总线所接部件的存取时间比较接近的系统 异步定时方式异步定时方式，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的握手信号来实现定时控制 通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的请求信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口向主设备发出回答信号 该方式总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合，但比同步控制方式复杂，速度也比同步定时方式慢 根据请求信号和回答信号的撤销是否互锁，异步定时方式又分为以下三种类型 1.不互锁方式 该方式的请求信号与回答信号双方不存在互锁关系 主设备发出请求信号后，不必等到接到从设备的回答信号，而是经过一段时间，便撤销请求信号 从设备在接到请求信号后，发出回答信号，并经过一段时间，自动撤销回答信号 2.半互锁方式 主设备发出请求信号后，必须待接到从设备的回答信号后，才撤销请求信号，有互锁的关系 从设备在接到请求信号后，发出回答信号，但不必等待获知主设备的请求信号已经撤销，而是隔一段时间后自动撤销回答信号，不存在互锁关系 3.全互锁方式 该方式的请求信号与回答信号双方存在互锁关系 主设备发出请求信号后，必须待从设备回答后，才撤销请求信号 从设备发出回答信号，必须待获知主设备请求信号已撤销后，再撤销回答信号","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"总线仲裁","slug":"computer-composition/22.总线仲裁","date":"2019-05-07T11:26:00.000Z","updated":"2022-05-12T14:20:39.299Z","comments":true,"path":"notes/computer-composition/f70b0736.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/f70b0736.html","excerpt":"【总线仲裁】为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始数据传送 总线仲裁方式按其仲裁控制机构的设置可分为以下两种：","text":"【总线仲裁】为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始数据传送 总线仲裁方式按其仲裁控制机构的设置可分为以下两种： 集中仲裁方式：总线控制逻辑基本上集中于一个设备（如 CPU）中，将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决 分布仲裁方式：无中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器，当有总线请求时，通过仲裁号的优先级比较进行仲裁 【集中仲裁方式】链式查询方式总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器 由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线 $BG$ 串行地从一个部件传送到下一个部件，依次查询 若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件，若响应信号到达的部件有总线请求，则信号被截住，不再传下去 在链式查询中离总线控制器越近的部件，其优先级越高；离总线控制器越远的部件，其优先级越低 链式查询方式优先级固定，此外，只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易，但对硬件电路的故障敏感，并且优先级不能改变，当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线 计数器定时查询方式计数器定时查询方式采用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线 $BG$，但仍共用一根总线请求线 当总线控制器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时，中止计数器的计数及查询 需要注意的是，计数可以从 $0$ 开始，此时一旦设备的优先次序被固定，设备的优先级就按 $0,1,…,n$ 的顺序降序排列，而且固定不变；计数也可以从上一次的终点开始，即是一种循环方法，此时设备使用总线的优先级相等；计数器的初值还可以由程序设置，故优先次序可以改变 该方式对电路的故障没有链式查询方式敏感，但增加了控制线数，控制也比相对链式查询相对复杂 独立请求方式每一个设备均有一对总线请求线 $BR_i$ 和总线允许线 $BG_i$，当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，则给该部件发送总线响应信号，该部件接到此信号就获得了总线使用权，开始传送数据 该方式响应速度快，总线允许信号 $BG$ 直接从控制器发送到有关设备，不必在设备间传递或者查询，而且对优先次序的控制相当灵活，但控制线数量多，总线控制逻辑更复杂 【分布仲裁方式】分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器 当它们有总线请求时，把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较 如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号 最后，获胜者的仲裁号保留在仲裁总线上","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"总线概述","slug":"computer-composition/21.总线概述","date":"2019-05-07T03:37:00.000Z","updated":"2022-05-12T14:11:35.094Z","comments":true,"path":"notes/computer-composition/653150c8.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/653150c8.html","excerpt":"【总线的基本概念】1.总线的定义 总线是一组能为多个部件分时共享的公共信息传送线路，具有分时和共享两个特点","text":"【总线的基本概念】1.总线的定义 总线是一组能为多个部件分时共享的公共信息传送线路，具有分时和共享两个特点 分时：指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息 共享：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享，在某一时刻只允许有一个部件向总线发送信息，但多个部件可以同时从总线上接收相同的信息 2.总线设备 总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种 主设备：总线的主设备是指获得总线控制权的设备 从设备：总线的从设备是指被主设备访问的设备，只能响应从主设备发来的各种总线命令 3.总线特性 机械特性：总线的尺寸、形状等 电气特性：总线的传输方向、有效的电平范围等 功能特性：每根总线的传输线的功能 时间特性：总线的信号和时序的关系 4.总线的猝发传输方式 在一个总线周期内传输存储地址连续的多个数据字的总线传输方式 【总线的分类】按总线功能划分，总线分为以下三类： 片内总线：芯片内部的总线，是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线 系统总线：计算机系统内各功能部件（CPU、主存、VO 接口）之间相互连接的总线 数据总线：用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关 地址总线：用来指出数据总线上的源数据或目的数据所在的主存单元或 I/O 端口的地址，它是单向传输总线，地址总线的位数与主存地址空间的大小有关 控制总线：传输的是控制信息，包括 CPU 送出的控制命令和主存（或外设）返回 CPU 的反馈信号 通信总线：用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线 按时序控制方式，总线分为以下两类： 同步总线：设备通过统一时钟进行同步，在规定节拍内进行总线操作 异步总线：设备无统一时钟，依靠各部件内定时装置进行总线操作 按数据传输格式，总线分为以下两类： 并行总线：每次传输多个二进制位，逻辑时序简单，信号线数量多，成本高，适合近距离传输 串行总线：每次传输一个二进制位，只需要一根线，成本低，适合长距离传输，但要进行数据拆卸与装配 【系统总线的结构】单总线结构单总线结构将 CPU、主存、I/O 设备（通过 I/O 接口）都挂在一组总线上，运行 I/O 设备之间、I/O 设备与主存之间直接交换信息 CPU 与主存、CPU 与外设之间可以直接进行信息交换，而无须经过中间设备的干预 该结构简单，成本低，易于接入新的设备，但带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作 需要注意的是，各个功能部件通过数据总线连接形成的数据传输路径称为数据通路，其表示的是数据流经的路径，而数据总线是承载的媒介 双总线结构双总线结构有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送，另一条是 I/O 总线，用于多个外部设备与通道之间进行数据传送 该结构能将较低速的 I/O 设备从单总线上分离出来，实现存储器总线和 I/O 总线分离，但需要增加通道等硬件设备 三总线结构三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I/O 总线和直接内存访问 DMA 总线 主存总线用于 CPU 和内存之间传送地址、数据和控制信息，I/O 总线用于 CPU 和各类外设之间通信，DMA 总线用于内存和高速外设之间直接传送数据 该结构提高了 I/O 设备的性能，使其更快地响应命令，提高了系统吞吐量，但系统工作效率较低 【总线的性能指标】1.总线的传输周期 又称为总线周期，指一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段） 总线传输周期通常由若干个总线时钟周期构成 2.总线时钟周期 总线时钟周期即机器的时钟周期 计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制 3.总线的工作频率 总线上各种操作的频率，为总线周期的倒数，实际上指一秒内传送几次数据 若： 总线周期=n\\:个时钟周期则： 工作频率=\\frac{时钟频率}{n}4.总线的时钟频率 总线的时钟频率即机器的时钟频率，为时钟周期的倒数，即： 时钟频率=\\frac{1}{时钟周期}5.总线宽度 又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数 例如：$32$ 根称为 $32$位（bit）总线 6.总线带宽 6可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示 总线带宽=总线工作频率\\times \\frac{总线宽度}{8}7.总线复用 总线复用是指一种信号线在不同的时间传输不同的信息 该方式可以使用较少的线传输更多的信息，从而节省了空间和成本 8.信号线数 地址总线、数据总线和控制总线三种总线数的总和称为信号线数 其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标 总线带宽=总线宽度\\times 总线频率例如：总线工作频率为 $22MHz$，总线宽度为 $16$ 位，则总线带宽为： 22 MHz\\times \\frac{16}{8}=44MB/s","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"指令流水线","slug":"computer-composition/20.指令流水线","date":"2019-04-30T08:42:00.000Z","updated":"2022-05-11T14:42:10.429Z","comments":true,"path":"notes/computer-composition/484d929e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/484d929e.html","excerpt":"【指令执行阶段】计算机的流水线是把一个重复的过程分解为若干子过程，每个子过程与其他子过程并行执行，采用流水线技术只需要增加少量硬件就能把计算机的运算速度提高几倍 一条指令的执行过程可以分成多个阶段，根据计算机的不同，具体分法也不同，但一条指令的执行过程可以分为如下三个阶段：","text":"【指令执行阶段】计算机的流水线是把一个重复的过程分解为若干子过程，每个子过程与其他子过程并行执行，采用流水线技术只需要增加少量硬件就能把计算机的运算速度提高几倍 一条指令的执行过程可以分成多个阶段，根据计算机的不同，具体分法也不同，但一条指令的执行过程可以分为如下三个阶段： 取指：根据 PC 内容访问主存储器，取出一条指令送到 IR 中 分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA，并从有效地址 EA 中取出操作数 执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中 【指令执行方式】顺序执行方式指令按顺序执行，前一条指令执行完后，才启动下一条指令 设取指、分析、执行三个阶段的时间都相等，用 $t$ 表示，则顺序执行 $n$ 条指令所用时间 $T$ 为： T=3nt传统冯·诺依曼机采用顺序执行方式，又称串行执行方式，其优点是控制简单，硬件代价小，但是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低 一次重叠执行方式这种方式把第 $k$ 条指令的执行阶段和第 $k+1$ 条指令的取指阶段同时进行 采用此种方式时，执行 $n$ 条指令所用的时间为： T=(1+2n)t采用一次重叠执行方式的优点是程序的执行时间缩短了三分之一，各功能部件的利用率明显提高，但为此需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了 二次重叠执行方式为了进一步提高指令的执行速度，可以把取 $k+1$ 条指令提前到分析第 $k$ 条指令的期间完成，而将分析第 $k+1$ 条指令与执行第 $k$ 条指令同时进行 采用此种方式时，执行 $n$ 条指令所用的时间为： T=(2+n)t与顺序执行方式相比，采用二次重叠执行方式能够使指令的执行时间缩短近三分之二，这是一种理想的指令执行方式，在正常情况下，处理机中同时有三条指令在执行 【流水线表示方法】通常用时空图的表示方法来直观地描述流水线的工作过程 在时空图中，横坐标表示时间，也就是输入到流水线中的各个任务在流水线中所经过的时间，当流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段，纵坐标表示空间，即流水线的每一个流水段（对应各执行部件） 如上图所示，第一条指令 $I_1$ 在时刻 $t_0$ 进入流水线，在时刻 $t_4$ 流出流水线，第二条指令 $I_2$ 在时刻 $t_1$ 进入流水线，在时刻 $t_5$ 流出流水线，依此类推，每经过一个 $\\Delta t$ 时间，便有一条指令进入流水线，从时刻 $t_4$ 开始有一条指令流出流水线 从图中可以看出，当 $t_8=8\\Delta t$ 时，流水线上便由 $5$ 条指令流出，如果采用串行方式执行指令，当 $t_8=8\\Delta t$ 时，只能执行 $2$ 条指令，可见使用流水线方式成倍地提高了计算机的速度 【流水线方式的特点】与传统的串行执行方式相比，采用流水线方式具有如下特点： 把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间 流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器，其作用是保存本流水段的执行结果，提供给下一流水段使用 流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流 只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务，在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的任务 流水线需要有装入时间和排空时间，装入时间是指第一个任务进入流水线到输出流水线的时间，排空时间是指最后一个任务进入流水线到输出流水线的时间 【流水线的分类】按照不同的分类标准，可以把流水线分成多种不同的种类 下面从几个不同的角度介绍流水线的基本分类方法： 根据流水线使用的级别的不同，流水线可分为： 部件功能级流水：将复杂的算术逻辑运算组成流水线工作方式，例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等四个子过程 处理机级流水：把一条指令解释过程分成多个子过程，如取指、译码、执行、访存、写回五个子过程 处理机间流水：是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中 根据流水线可以完成的功能，流水线可分为： 单功能流水线：只能实现一种固定的专门功能的流水线 多功能流水线：通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线 根据同一时间内各段之间的连接方式，流水线可分为： 静态流水线：在同一时间内，流水线的各段只能按同一种功能的连接方式工作 动态流水线：在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算，这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂 根据流水线的各个功能段之间是否有反馈信号，流水线可分为： 线性流水线：从输入到输出，每个功能段只允许经过一次，不存在反馈回路 非线性流水线：存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算 【影响流水线的因素】流水线中存在一些相关的情况，它使下一条指令无法在设计的时钟周期内执行，这些相关将降低流水线性能 结构相关又称资源冲突，是指多条指令在同一时刻争用同一资源而形成的冲突 有以下两种解决办法： 前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期 单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重复配置 数据相关又称数据冲突，是指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况 当多条指令重叠处理时就会发生冲突，解决的办法有以下三种： 暂停时钟周期：把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，常用的有硬件阻塞（stall）、软件插入 NOP 指令两种方法 数据旁路技术：设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而是直接把前一条指令的ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行 编译优化：通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关 控制相关又称控制冲突，是指当流水线遇到转移指令和其他改变PC值的指令而造成断流 解决的办法有以下四种： 对转移指令进行分支预测，尽早生成转移目标地址 静态预测：总是预测条件不满足，即继续执行分支指令的后续指令 动态预测：根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率 预取转移成功和不成功两个控制流方向上的目标指令 加快和提前形成条件码 提高转移方向的猜准率 【流水线性能指标】吞吐率在指令级流水线中，吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量 计算流水线吞吐率（TP）的最基本的公式为： TP=\\frac{n}{T_k}式中，$n$ 是任务数，$T$ 是处理完成 $n$ 个任务所用的时间 下面以流水线中各段执行时间都相等为例来讨论流水线的吞吐率，如下图所示的各段执行时间均相等的流水线时空图，当输入到流水线中的任务是连续的理想情况下，一条 $k$ 段线性流水线能够在 $k+n-1$ 个时钟周期内完成 $n$ 个任务，其中，$k$ 为流水线的段数，$\\Delta$ 为时钟周期 易得出流水线的实际吞吐率为： TP=\\frac{n}{(k+n-1)\\Delta t}当连续输入的任务 $n\\rightarrow \\infty$ 时，可得最大吞吐率为： TP_{max} = \\frac{1}{\\Delta t}加速比完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比 设 $T_0$ 表示不使用流水线时的执行时间，即顺序执行所用的时间，$T_k$ 表示使用流水线时的执行时间，则计算流水线加速比（S）的基本公式为： S=\\frac{T_0}{T_k}如果流水线各段执行时间都相等，则一条 $k$ 段流水线完成 $n$ 个任务所需的时间为： T=(k+n-1)\\Delta t而不使用流水线，即顺序执行 $n$ 个任务时，所需的时间为： T_0＝kn\\Delta t将 $T_0$ 和 $T_k$ 值代入上式，得实际加速比为： S=\\frac{kn\\Delta t}{(k+n-1)\\Delta t} = \\frac{kn}{k+n-1}当连续输入的任务 $n\\rightarrow \\infty$ 时，最大加速比为： S_{max} = k效率流水线的设备利用率称为流水线的效率，在时空图上，流水线的效率定义为完成 $n$ 个任务占用的时空区有效面积与 $n$ 个任务所用的时间与k个流水段所围成的时空区总面积之比 因此，流水线的效率包含了时间和空间两个因素 $n$ 个任务占用的时空区有效面积就是顺序执行 $n$ 个任务所使用的总时间 $T_0$，而 $n$ 个任务所用的时间与 $k$ 个流水段所围成的时空区总面积为 $kT_k$，其中 $T_k$ 是流水线完成 $n$ 个任务所使用的总时间，计算流水线效率（E）的一般公式为： E=\\frac{T_0}{kT_k}如果流水线的各段执行时间相等，上式中的分子部分是 $n$ 个任务实际占用的有效面积，分母部分是完成 $n$ 个任务所用的时间与 $k$ 个流水段所围成的总面积 流水线的各段执行时间均相等，当连续输入的任务 $n\\rightarrow \\infty$ 时，最高效率为： E_{max}=1【流水线多发技术】超标量流水线技术每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件 超标量计算机不能调整指令的执行顺序，通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性 超流水线技术在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次 不能调整指令的执行顺序，靠编译程序解决优化问题 超长指令字由编译程序挖掘出指令间潜在的并行性，将多条并行操作的指令组合成一条具有多个操作码字段的超长指令字 超长指令字可达几百位，为此需要采用多个额外的处理部件","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"微程序控制器","slug":"computer-composition/19.微程序控制器","date":"2019-04-26T13:32:00.000Z","updated":"2022-05-11T13:54:29.633Z","comments":true,"path":"notes/computer-composition/11223ba6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/11223ba6.html","excerpt":"【程序与微程序】基本概念微程序设计思想就是将每一条机器指令编写成一个微程序，每一个微程序包含若干条微指令每一条微指令对应一个或几个微操作命令，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令","text":"【程序与微程序】基本概念微程序设计思想就是将每一条机器指令编写成一个微程序，每一个微程序包含若干条微指令每一条微指令对应一个或几个微操作命令，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令 微程序设计技术涉及的基本术语有： 微操作：一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作 微命令：在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位，微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的执行过程，此外，微命令有相容性和互斥性之分： 相容性微命令：可以同时产生、共同完成某一些微操作的微命令 互斥性微命令：在机器中不允许同时出现的微命令 微指令：微指令是若干微命令的集合，一条微指令通常至少包含两大部分信息 操作控制字段：又称操作码字段，用于产生某一步操作所需的各种操作控制信号 顺序控制字段：又称微地址码字段，用于控制产生下一条要执行的微指令地址 微地址：存放微指令的控制存储器的单元地址 微周期：从控制存储器中读取一条微指令并执行相应的微操作所需的时间 程序与微程序程序是指令的有序集合，用于完成特定的功能，微程序是微指令的有序集合，一条指令的功能由一段微程序来实现 微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户 对于程序员来说，计算机系统中微程序的结构和功能是透明的，无须知道。而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的 在计算机中，主存储器用于存放程序和数据，在 CPU 外部，用 RAM 实现；控制存储器（CM）用于存放微程序，在 CPU 内部，用 ROM 实现 此外，与微指令相关的寄存器有： 地址寄存器（MAR）：用于存放主存的读/写地址。 微地址寄存器（CMAR）：用于存放控存的读/写微指令的地址。 指令寄存器（IR）：用于存放从主存中读出的指令 微指令寄存器（CMDR 或 μIR）：用于存放从控存中读出的微指令 微程序与机器指令通常，一条机器指令对应一个微程序 由于任何一条机器指令的取指令操作都是相同的，因此，可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出送至指令寄存器中 此外，也可以编出对应间址周期的微程序和中断周期的微程序，这样控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数 要注意的是，若指令系统中具有 $n$ 种机器指令，则控制存储器中的微程序数至少是 $n+1$ 个，这里的 $1$ 是指公共的取指微程序 【微程序控制器】基本组成 微程序控制器主要包括： 控制存储器：它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可至 CPU 内部和系统总线的控制信号用只读存储器 ROM 构成微地址 微指令寄存器：用于存放从 CM 中取出的形成部件微指令，它的位数同微指令字长相等 微地址形成部件：用于产生初始微地址和后继微地址，以保证微指令的连续执行 微地址寄存器：接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备 工作过程微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下： 执行取微指令公共操作：在机器开始运行时，自动将取指微程序的入口地址送入 CMAR，并从 CM 中读出相应的微指令送入 CMDR，取指微程序的入口地址一般为 CM 的 $0$ 号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中了 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 CMAR 从 CM 中逐条取出对应的微指令并执行 执行完对应于一条机器指令的一个微程序后又回到取指微程序的入口地址，继续第 1 步，以完成取下一条机器指令的公共操作 以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕为止 【微指令编码方式】微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号，编码的目标是在保证速度的情况下，尽量缩短微指令字长 直接编码方式直接编码方式无须进行译码，微指令的微命令字段中每一位都代表一个微命令 设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成 $1$ 或 $0$ 即可，每个微命令对应并控制数据通路中的一个微操作 这种编码的优点是简单、直观，执行速度快，操作并行性好，缺点是微指令字长过长，$n$ 个微命令就要求微指令的操作字段有 $n$ 位，造成控存容量极大 字段直接编码方式将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同的字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式 这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢 微命令字段分段的原则如下： 互斥性微命令分在同一段内，相容性微命令分在不同段内 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间 一般每个小段还要留出一个状态，表示本字段不发出任何微命令，例如：当某字段的长度为 $3$ 位时，最多只能表示 $7$ 个互斥的微命令，$000$ 表示不操作 字段间接编码方式一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码 这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力 因此，通常作为字段直接编码方式的一种辅助手段 【微指令地址形成方式】后继微地址的形成主要有以下两大基本类型： 断定方式：直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址 操作码方式：根据机器指令的操作码形成。当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成 而微指令序列地址的形成方式有以下几种： 增量计数器法：即 $(CMAR)＋1\\rightarrow CMAR$，适用于后继微指令的地址是连续的情况 根据各种标志决定微指令分支转移的地址 通过网络测试形成 由硬件直接产生微程序入口地址 当电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向 CMAR 输入微指令的地址，这个地址即为取指周期微程序的入口地址 【微指令格式】微指令格式与微指令的编码方式有关，通常分水平型微指令、垂直型微指令、混合型微指令 1.水平型微指令 从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属水平型微指令 指令字中的一位对应一个控制信号，有输出时为 $1$，否则为 $0$，一条水平型微指令定义并执行几种并行的基本操作 水平型微指令的微程序短，执行速度快，但是微指令长，编写微程序较麻烦 2.垂直型微指令 一条垂直型微指令只能定义并执行一种基本操作，垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能 垂直型微指令格式的微指令短、简单、规整，便于编写微程序，但是微程序长，执行速度慢，工作效率低 3.混合型微指令 混合型微指令是在垂直型的基础上增加一些不太复杂的并行操作 该方式的微指令较短，仍便于编写，同时微程序也不长，执行速度较快 【微程序控制单元的设计步骤】写出对应机器指令的微操作命令及节拍安排无论是组合逻辑设计，还是微程序设计，对应相同的 CPU 结构，两种控制单元的微操作命令和节拍安排都是极相似的，如微程序控制单元在取指阶段发出的微操作命令及节拍安排如下： $T_0$：$PC\\rightarrow MAR,1\\rightarrow R$ $T_1$：$M(MAR) \\rightarrow MDR,(PC)+1\\rightarrow PC$ $T_2$：$MDR\\rightarrow IR，OP(IR)\\rightarrow$ 微地址形成部件 与硬布线控制单元相比，只在 $T_2$ 节拍内的微操作命令不同 微程序控制单元在 $T_2$ 节拍内要将指令的操作码送至微地址形成部件，即 $OP(IR)\\rightarrow $ 微地址形成部件，以形成该条机器指令的微程序首地址，而硬布线控制单元在 $T_2$ 节拍内要将指令的操作码送至指令译码器，以控制 $CU$ 发出相应的微命令，即 $OP(IR)\\rightarrow ID$ 如果把一个节拍 $T$ 内的微操作安排在一条微指令中完成，上述微操作对应 $3$ 条微指令，但是由于微程序控制的所有控制信号都来自微指令，而微指令又存在控存中，因此，欲完成上述这些微操作，必须先将微指令从控存中读出，即必须先给出这些微指令的地址 在取指微程序中，除第一条微指令外，其余微指令的地址均由上一条微指令的下地址字段直接给出，因此上述每一条微指令都需增加一个将微指令下地址字段送至 $CMAR$ 的微操作，记为 $Ad(CMDR)\\rightarrow CMAR$ 取指微程序的最后一条微指令，其后继微指令的地址是由微地址形成部件形成的，即微地址形成部件$\\rightarrow CMAR$，为反映该地址与操作码有关，故记为：$OP(IR)\\rightarrow$ 微地址形成部件 $\\rightarrow CMAR$ 综上所述，考虑到需要形成后继微指令地址，上述分析的取指操作共需 $6$ 条微指令完成，即： $T_0$：$PC\\rightarrow MAR,1 \\rightarrow R$ $T_1$：$Ad(CMDR)\\rightarrow CMAR$ $T_2$：$M(MAR)\\rightarrow MDR,(PC)+1\\rightarrow PC$ $T_3$：$Ad(CMDR) \\rightarrow CMAR$ $T_4$：$MDR\\rightarrow IR$ $T_5$：$OP(IR)\\rightarrow $ 微地址形成部件 $\\rightarrow CMAR$ 执行阶段的微操作命令及节拍安排，分配原则类似，但与硬布线控制单元微操作命令的节拍安排相比，多了将下一条微指令地址送至 $CMAR$ 的微操作命令，即：$Ad(CMDR)\\rightarrow CMAR$，此外，其余的微操作命令与硬布线控制单元相同 确定微指令格式微指令格式包括微指令的编码方式、后继微指令地址的形成方式和微指令字长等 根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数，由微指令数确定微指令的顺序控制字段的位数，最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长 编写微指令码点根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点 【动态微程序设计和毫微程序设计】动态微程序设计在一台微程序控制的计算机中，假如能根据用户的要求：变微程序，那么这台机器就具有动态微程序设计功能 动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容 实现动态微程序设计可采用可擦除可编程只读存储器（EPROM） 毫微程序设计在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制 如果硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器称为毫微存储器，直接控制硬件的是毫微微指令 【硬布线和微程序控制器的对比】硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件看做专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，不可能通过其他额外修改添加新功能 微程序控制器的优点是同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响了速度 为了便于比较，下面以表格的形式对比二者的不同","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"硬布线控制器","slug":"computer-composition/18.硬布线控制器","date":"2019-04-23T04:36:00.000Z","updated":"2022-05-11T09:58:25.931Z","comments":true,"path":"notes/computer-composition/527a9dd9.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/527a9dd9.html","excerpt":"【硬布线控制单元】硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态情况，按时间的顺序发送一系列微操作控制信号，它由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器 指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键，为了简化控制单元 CU 的逻辑，将指令的操作码译码和节拍发生器从 CU 分离出来，便可得到简化的控制单元图","text":"【硬布线控制单元】硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态情况，按时间的顺序发送一系列微操作控制信号，它由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器 指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键，为了简化控制单元 CU 的逻辑，将指令的操作码译码和节拍发生器从 CU 分离出来，便可得到简化的控制单元图 CU 的输入信号来源如下： 经指令译码器译码产生的指令信息：现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，故指令的操作码字段是控制单元的输入信号，它与时钟配合产生不同的控制信号 时序系统产生的机器周期信号和节拍信号：为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即一个时钟脉冲使控制单元发送一个操作命或发送一组需要同时执行的操作命令 来自执行单元的反馈信息即标志：控制单元有时需依赖 CPU 当前所处的状态产生控制信号 节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令 C（控制信号）按时间的先后发出，个别指令的操作不仅受操作码控制，还受状态标志控制，因此 CU 的输入来自操作码译码电路 ID、节拍发生器及状态标志，其输出至 CPU 内部或外部控制总线上 此外，控制单元还接收来自系统总线（控制总线）的控制信号，如：中断请求、DMA 请求等 【硬布线控制器的时序系统及微操作】时序系统 时钟周期：用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期，在每个节拍内机器可完成一个或几个需同时执行的操作 机器周期：机器周期可看做所有指令执行过程中的一个基准时间，不同指令的操作不同，指令周期也不同，访问一次存储器的时间是固定的，因此，通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期，在存储字长等于指令字长的前提下，取指周期也可看做机器周期 指令周期：一条指令可分为取指周期、间址周期、执行周期这三个工作周期，对于不同的指令，控制单元需发出各种不同的微操作命令 微操作：执行程序的过程中，在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每一个微操作命令 微操作命令分析取指周期无论是什么指令，取指周期都需有下列微操作命令： $PC \\rightarrow MAR$：现行指令地址 $\\rightarrow MAR$ $1\\rightarrow R$：命令存储器读 $M(MAR) \\rightarrow MDR$：现行指令从存储器中读至 $MDR$ $MDR \\rightarrow IR$：现行指令 $\\rightarrow IR$ $OP(IR) \\rightarrow CU$：指令的操作码 $\\rightarrow CU$ 译码 $(PC)+1 \\rightarrow PC$：形成下一条指令的地址 间址周期间址周期完成取操作数地址的任务，具体微操作命令如下： $Ad(IR) \\rightarrow MAR$：将指令字中的形式地址地址码 $\\rightarrow MAR$ $1\\rightarrow R$：命令存储器读 $M(MAR) \\rightarrow MDR$：将有效地址从存储器读至 $MDR$ 执行周期执行周期的微操作命令视不同指令而定，下面给出三类常用的指令的微操作命令 1.非访存指令 指令 作用 微操作 CLA 清 $ACC$ $0\\rightarrow ACC$ COM 取反 $\\overline{ACC}\\rightarrow ACC$ SHR 算术右移 $L(ACC)\\rightarrow R(ACC),ACC_0\\rightarrow ACC_0$ CSL 循环左移 $R(ACC)\\rightarrow L(ACC),ACC_0\\rightarrow ACC_n$ STP 停机指令 $0\\rightarrow G$ 2.访存指令 指令 作用 微操作 ADD X 加法指令 $Ad(IR)\\rightarrow MAR$$1\\rightarrow R$$M(MAR)\\rightarrow MDR$$(ACC)+(MDR)\\rightarrow ACC$ STA X 存数指令 $Ad(IR)\\rightarrow MAR$ $1\\rightarrow W$$ACC\\rightarrow MDR$$MDR\\rightarrow M(MAR)$ LDA X 取数指令 $Ad(IR)\\rightarrow MAR$$1\\rightarrow R$$M(MAR)\\rightarrow MDR$$MDR\\rightarrow ACC$ 3.转移指令 指令 作用 微操作 JMP X 无条件转移 $Ad(IR)\\rightarrow PC$ BAN X 条件转移 $A_0\\cdot Ad(IR)+\\overline{A_0}\\cdot (PC) \\rightarrow PC$ 【CPU 控制方式】控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程 由于不同指令所对应的微操作数及复杂程度不同，因此，每条指令和每个微操作所需的执行时间也不同，主要有以下三种控制方式 1.同步控制方式 同步控制方式，就是系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令 同步控制方式的优点是控制电路简单，缺点是运行速度慢 2.异步控制方式 异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络 异步控制方式的优点是运行速度快，缺点是控制电路比较复杂 3.联合控制方式 联合控制方式是介于同步、异步之间的一种折中 这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法 【硬布线控制单元设计步骤】列出微操作命令的操作时间表先根据微操作节拍安排，列出微操作命令的操作时间表，操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号 如下表，列出了 CLA、COM、SHR 等机器指令微操作命令的操作时间表，表中 $FE$、$IND$ 和 $EX$ 为 CPU 工作周期标志，$T_0\\sim T_2$ 为节拍，$I$ 为间址标志，在取指周期的 $T_2$ 时刻 若测得 $I=1$，则 $IND$ 触发器置 $1$，标志进入间址周期；若 $I=0$，则 $EX$ 触发器置 $1$，标志进入执行周期 同理，在间址周期的 $T_2$ 时刻，若测得 $IND=0$（表示一次间接寻址），则 $EX$ 触发器置 $1$，进入执行周期；若测得 $IND=1$（表示多次间接寻址），则继续间接寻址 在执行周期的 $T2$ 时刻，CPU 要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则 $INT$ 触发器置 $1$，标志进入中断周期 进行微操作信号综合在列出微操作时间表之后，即可对它们进行综合分析、归类，根据微操作时间表可以写出各微操作控制信号的逻辑表达式并进行适当的简化 表达式一般包括下列因素： 微操作控制信号=机器周期\\oplus节拍\\oplus 脉冲\\oplus 操作码\\oplus 机器状态条件根据上表便可列出每一个微操作命令的初始逻辑表达式，经化简、整理便可获得能用现有门电路实现的微操作命令逻辑表达式 例如：可写出 $M(MAR)\\rightarrow MDR$ 微操作命令的逻辑表达式： \\begin{align} M(MAR)\\rightarrow MDR &= FE\\cdot T_1+IND\\cdot T_1(ADD+STA+LDA+JMP+BAN) \\notag\\\\ &\\quad +EX\\cdot T_1(ADD+LDA) \\notag\\\\ &=T_1\\{FE+IND(ADD+STA+LDA+JMP+BAN)\\notag \\\\ &\\quad+ EX(ADD+LDA)\\} \\notag \\end{align}式中，$ADD$、$STA$、$LDA$、$JMP$、$BAN$ 均来自操作码译码器的输出 画出微操作命令的逻辑图根据逻辑表达式可画出对应每一个微操作信号的逻辑电路图，并用逻辑门电路实现 例如：$M(MAR)\\rightarrow MDR$ 的逻辑表达式所对应的逻辑图如下图所示","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"数据通路的功能与基本结构","slug":"computer-composition/17.数据通路的功能与基本结构","date":"2019-04-19T05:17:00.000Z","updated":"2022-05-11T09:33:50.565Z","comments":true,"path":"notes/computer-composition/ffc4a344.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/ffc4a344.html","excerpt":"【数据通路的功能】数据在功能部件之间传送的路径称为数据通路，运算器与各寄存器之间的传送路径就是中央处理器内部数据通路 数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都要加以控制","text":"【数据通路的功能】数据在功能部件之间传送的路径称为数据通路，运算器与各寄存器之间的传送路径就是中央处理器内部数据通路 数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都要加以控制 建立数据通路的任务是由操作控制部件来完成的，数据通路的功能是实现 CPU 内部的运算器与寄存器以及寄存器之间的数据交换 【数据通路的基本结构】数据通路的基本结构主要有以下几种： CPU内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共的通路上，这种结构比较简单，但数据传输存在较多的冲突现象，性能较低 单总线结构：连接各部件的总线只有一条 双总线结构：CPU 中有两条总线 多总线结构：CPU 中有两条以上的总线 CPU 内部三总线方式：将所有寄存器的输入端和输出端都连接到多条公共的通路上，相比之下单总线中一个时钟内只允许传一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同数据，提高效率 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能比较高，但硬件量大 【数据传送】寄存器间的数据传送奇存器之间的数据传送可以通过 CPU 内部总线完成 以 $PC$ 寄存器为例，某寄存器 $AX$ 的输出和输入分别由 $AXout$ 和 $AXin$ 控制，把 $PC$ 内容送至 $MAR$，实现传送操作的流程及控制信号为： $(PC) \\rightarrow Bus$：$PCout$ 有效，$PC$ 内容送总线 $Bus \\rightarrow MAR$：$MARin$ 有效，总线内容送 $MAR$ 主存与 CPU 间的数据传送主存与 CPU 之间的数据传送也要借助 CPU 内部总线完成 以 CPU 从主存读取指令为例说明数据在数据通路中的传送过程，实现传送操作的流程数据通路和控制信号及控制信号为： $PC \\rightarrow Bus \\rightarrow MAR$：$PCout$ 和 $MARin$ 有效，现行指令地址 $\\rightarrow MAR$ $1 \\rightarrow R$：$CU$ 发读命令 $MEM(MAR) \\rightarrow MDR$：$MDRin$ 有效 $MDR \\rightarrow Bus \\rightarrow IR$：$MDRout$ 和 $IRin$ 有效，现行指令 $\\rightarrow IR$ 执行算术或逻辑运算当执行算术或逻辑操作时，由于 $ALU$ 本身是没有内部存储功能的组合电路，因此如要执行加法运算，被相加的两个数必须在 $ALU$ 的两个输入端同时有效 先将一个操作数经 CPU 内部总线送入暂存器 $Y$ 保存起来，$Y$ 的内容在 $ALU$ 的左输入端始终有效，再将另一个操作数经总线直接送到 $ALU$ 的右输入端，这样两个操作数都送入了 $ALU$，运算结果暂存在暂存器 $Z$ 中 $Ad(IR) \\rightarrow Bus \\rightarrow MAR$：$MDRout$ 和 $MARin$ 有效 $1\\rightarrow R$：$CU$ 发读命令 $MEM \\rightarrow$ 数据线 $\\rightarrow MDR$：操作数从存储器 $\\rightarrow$ 数据线 $\\rightarrow MDR$ $MDR \\rightarrow Bus \\rightarrow Y$：$MDRout$ 和 $Yin$ 有效，操作数 $\\rightarrow Y$ $(ACC)+(Y) \\rightarrow Z$：$ACCout$ 和 $ALUin$ 有效，$CU$ 向 $ALU$ 发加命令，结果 $\\rightarrow Z$ $Z \\rightarrow ACC$：$Zout$ 和 $ACCin$ 有效，结果 $\\rightarrow ACC$","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"指令执行过程","slug":"computer-composition/16.指令执行过程","date":"2019-04-13T11:14:00.000Z","updated":"2022-05-11T09:36:33.593Z","comments":true,"path":"notes/computer-composition/7c8a75cc.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/7c8a75cc.html","excerpt":"【指令周期】机器周期CPU 从主存中每取出并执行一条指令所需的全部时间称为指令周期，也就是 CPU 完成一条指令的时间","text":"【指令周期】机器周期CPU 从主存中每取出并执行一条指令所需的全部时间称为指令周期，也就是 CPU 完成一条指令的时间 指令周期常常用若干机器周期来表示，一个机器周期又包含若干时钟周期（也称为节拍或 T 周期，它是 CPU 操作的最基本单位） 每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等 指令周期对于无条件转移指令 JMPX，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期 对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后再访问主存，取出操作数，所以还需包括间址周期，间址周期介于取指周期和执行周期之间 当 CPU 采用中断方式实现主机和 I/O 设备交换信息时，CPU 在每条指令执行结束前，都要发中断查询信号，如果有中断请求，CPU 则进入中断响应阶段，又称中断周期 这样，一个完整的指令周期应包括取指、间址、执行和中断这四个周期，这些周期都有 CPU 访存操作，只是访存目的不同，取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点 【指令周期的数据流】取址周期取指周期的任务是根据 $PC$ 中的内容从主存中取出指令代码并存放在 $IR$ 中 取指周期的数据流如下图所示，$PC$ 中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器 $IR$ 中，取指令的同时，$PC +1$ 取指周期的数据流取指周期的数据流向如下： $PC \\rightarrow MAR \\rightarrow$ 地址总线 $\\rightarrow$ 主存 $CU$ 发出控制信号 $\\rightarrow$ 控制总线 $\\rightarrow$ 主存 主存 $\\rightarrow$ 数据总线 $\\rightarrow MDR \\rightarrow IR$ $CU$ 发出读命令 $\\rightarrow PC +1$ 间址周期间址周期的任务是取操作数有效地址 以一次间址为例，将指令中的地址码送到 $MAR$ 并送至地址总线，此后 $CU$ 向存储器发读命令，以获取有效地址并存至 $MDR$ 一次间址周期的数据流间址周期的数据流向如下： $Ad(IR)\\rightarrow MAR \\rightarrow$ 地址总线 $\\rightarrow$ 主存 $CU$ 发出读命令 $\\rightarrow$ 控制总线 $\\rightarrow$ 主存 主存 $\\rightarrow$ 数据总线 $\\rightarrow MDR$（存放有效地址） 其中，$Ad(IR)$ 表示取出 $IR$ 中存放的指令字的地址字段 执行周期执行周期的任务是根据 $IR$ 中的指令字的操作码和操作数通过 $ALU$ 操作产生执行结果 不同指令的执行周期操作不同，因此没有统一的数据流向 中断周期中断周期的任务是处理中断请求 假设程序断点存入堆栈中，并用 $SP$ 指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据 中断周期的数据流向如下： $CU$ 控制将 $SP -1，SP \\rightarrow MAR \\rightarrow$ 地址总线 $\\rightarrow$ 主存 $CU$ 发出写命令 $\\rightarrow$ 控制总线 $\\rightarrow$ 主存 $PC \\rightarrow MDR \\rightarrow$ 数据总线 $\\rightarrow$ 主存（程序断点存入主存） $CU$（中断服务程序的入口地址） $\\rightarrow PC$ 【指令执行方案】一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和硬件成本等考虑，可以选用以下三种方案来安排指令的执行步骤 单指令周期对所有指令都选用相同的执行时间来完成，称为单指令周期方案 此时每一条指令都在固定的时钟周期内完成，指令之间串行执行，即下一条指令只能在前一条指令执行结束之后才能启动，因此，指令周期取决于执行时间最长的指令的执行时间 对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度 多指令周期对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案 指令之间串行执行，即下一条指令只能在前一条指令执行结束之后才能启动，但可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，而不再要求所有指令占用相同的执行时间 流水线方案指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下，才能达到该效果） 通过在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"CPU 功能与基本结构","slug":"computer-composition/15.CPU功能与基本结构","date":"2019-04-13T07:13:00.000Z","updated":"2022-05-10T13:50:04.806Z","comments":true,"path":"notes/computer-composition/e022bea.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/e022bea.html","excerpt":"【CPU 功能】中央处理器（CPU）由运算器和控制器组成，其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令，运算器的功能是对数据进行加工 CPU 的具体功能包括：","text":"【CPU 功能】中央处理器（CPU）由运算器和控制器组成，其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令，运算器的功能是对数据进行加工 CPU 的具体功能包括： 指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制 操作控制：一条指令的功能往往是由若干操作信号的组合来实现的，CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作 时间控制：对各种操作加以时间上的控制，时间控制要为每条指令按时间顺序提供应有的控制信号 数据加工：对数据进行算术和逻辑运算 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理 【CPU 基本结构】构成计算机系统中，中央处理器主要是由运算器和控制器两大部分组成 运算器运算器是计算机对数据进行加工处理的中心，主要由算术逻辑单元（ALU）、暂存寄存器、累加寄存器（ACC）、通用寄存器组、程序状态字寄存器（PSW）、移位器、计数器（CT）等组成，运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理 算术逻辑单元：主要功能是进行算术、逻辑运算 暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的 累加寄存器：它是一个通用寄存器，用于暂时存放 ALU 运算的结果信息，可以作为加法运算的一个输入端 通用寄存器组：如 AX、BX、CX、DX、SP 等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等，其中 SP 是堆栈指针，用于指示栈顶的地址 程序状态字寄存器 PSW：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等，这些位参与并决定微操作的形成 移位器：对操作数或运算结果进行移位运算 计数器：控制乘除运算的操作步数 控制器控制器是整个系统的指挥中枢，在控制器的控制下，使运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作 控制器的基本功能就是执行指令，每条指令的执行是由控制器发出的一组微操作实现的，控制器由程序计数器（PC）、指令寄存器（IR）、指令译码器、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、时序系统和微操作信号发生器等组成 程序计数器：用于指出下一条指令在主存中的存放地址，CPU 就是根据 PC 的内容去主存中取指令的，因程序中指令通常是顺序执行的，所以 PC 有自增功能 指令寄存器：用于保存当前正在执行的指令 指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号 存储器地址寄存器：用于存放所要访问的主存单元的地址 存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息 时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到 微操作信号发生器：根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种 控制器的工作原理是根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号，计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果 根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的 PC 和 IR 是相同的，但确定和表示指令执行步骤的方法以及给出控制各部件运行所需的控制信号的方案不同","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"CISC 与 RISC 的基本概念","slug":"computer-composition/14.CISC与RISC的基本概念","date":"2019-04-07T08:28:00.000Z","updated":"2022-05-09T11:12:26.831Z","comments":true,"path":"notes/computer-composition/25aeac88.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/25aeac88.html","excerpt":"【指令系统】指令系统是计算机的主要属性，位于硬件和软件的交面上 指令系统的发展朝向两种截然不同的方向，一种是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的是采用 X86 架构的计算机","text":"【指令系统】指令系统是计算机的主要属性，位于硬件和软件的交面上 指令系统的发展朝向两种截然不同的方向，一种是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的是采用 X86 架构的计算机 另一种是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC），典型的是采用 ARM、MIPS 架构的计算机 【CISC】随着 VLSI 技术的发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中增加更多更复杂的指令，以适应不同的应用领域，构成了复杂指令系统计算机（CISC） CISC 的主要特点有： 指令系统复杂庞大，指令数目一般为 $200$ 条以上 指令的长度不固定，指令格式多，寻址方式多 可以访存的指令不受限制 各种指令使用频度相差很大 各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成 控制器大多数采用微程序控制 难以用优化编译生成高效的目标代码程序 面对庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长，后来发现，一味追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径 在对传统CISC指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有 $20％$ 的比较简单的指令被反复使用，约占整个程序的 $80％$，而 $80％$ 左右的指令则很少使用，约占整个程序的 $20％$ 从这一事实出发，人们开始了对指令系统合理性的研究，于是 RISC 随之诞生 【RISC】精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器一寄存器操作指令，指令格式力求一致，RISC的主要特点有： 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现 指令长度固定，指令格式种类少，寻址方式种类少 只有取数/存数指令访存，其余指令的操作都在寄存器之间进行 CPU 中通用寄存器数量相当多 采用指令流水线技术，大部分指令在一个时钟周期内完成 以硬布线控制为主，不用或少用微程序控制 特别重视编译优化工作，以减少程序执行时间 值得注意的是，从指令系统兼容性看， CISC 大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充，但 RISC 简化了指令系统，指令条数少，格式也不同于老机器，因此大多数 RISC 机不能与老机器兼容 由于 RISC 具有更强的实用性，故应该是未来处理器的发展方向，但事实上，当今时代 Intel 几乎一统江湖，且早期很多软件都是根据 CISC 设计的，单纯的 RISC 将无法兼容 此外，现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分，其性能差距已经越来越小，复杂指令 CISC 可以提供更多的功能，这是程序设计所需要的 【CISC 与 RISC 的对比】CISC 与 RISC 的对比如下表： 对比项目 CISC RISC 指令系统 复杂、庞大 简单、精简 指令数目 一般大于 $200$ 条 一般小于 $100$ 条 指令字长 不固定 定长 可访存指令 无限制 只有 Load/Store 指令 各种指令执行时间 相差大 大多在一个周期内完成 各种指令使用频度 相差大 均常用 通用寄存器数量 少 多 目标代码 难以用优化编译生成高效的目标代码程序 采用优化的编译程序生成目标代码程序 控制方式 绝大多数为微程序控制 绝大多数为组合逻辑控制 指令流水线 可不实现 必须实现","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"指令寻址方式","slug":"computer-composition/13.指令寻址方式","date":"2019-04-02T07:46:00.000Z","updated":"2022-05-09T08:27:49.084Z","comments":true,"path":"notes/computer-composition/704a2c6a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/704a2c6a.html","excerpt":"【指令寻址与数据寻址】寻址寻址方式是指寻找指令或操作数有效地址的方式，也就是指确定本条指令的数据地址，以及下一条将要执行的指令地址的方法","text":"【指令寻址与数据寻址】寻址寻址方式是指寻找指令或操作数有效地址的方式，也就是指确定本条指令的数据地址，以及下一条将要执行的指令地址的方法 指令中的地址码字段并不代表操作数的真实地址，称为形式地址 $(A)$，用形式地址并结合寻址方式，可以计算出操作数在存储器中的真实地址，称为有效地址 $(EA)$ 形式地址 $(A)$ 表示地址为 $A$ 的数值，$A$ 既可以是寄存器编号也可以是内存地址，对应的 $(A)$ 就是寄存器中的数值，或相应内存单元的数值，例如：$EA=(A)$ 的意思就是有效地址是地址A中的数值 寻址方式分为指令寻址和数据寻址两大类，寻找下一条将要执行的指令地址称为指令寻址，寻找操作数的地址称为数据寻址 指令寻址指令寻址方式有两种： 顺序寻址：通过程序计数器 $PC$ 自动 $+1$（一个指令字长），自动形成下一条指令的地址 跳跃寻址：通过转移类指令实现，即下条指令的地址码不是由程序计数器给出，而是由本条指令给出下条指令地址的计算方式，跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（对于当前指令地址的偏移量），跳跃的结果是当前指令修改 $PC$ 值，所以下一条指令仍然是通过程序计数器 $PC$ 给出 数据寻址数据寻址就是如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址 数据寻址方式的种类较多，为了区别各种方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式 由此可得指令的格式如下所示： 【数据寻址方式】数据寻址方式对比下表给出了数据寻址方式的有效地址和访存次数的对比 寻址方式 有效地址 访存次数 隐含寻址 程序指定 $0$ 立即寻址 $A$ 即操作数 $0$ 直接寻址 $EA=A$ $1$ 一次间接寻址 $EA=(A)$ $2$ 寄存器寻址 $EA=R_i$ $0$ 寄存器间接寻址 $EA=(R_i)$ $1$ 相对寻址 $EA=(PC)+A$ $1$ 基址寻址 $EA=(BR)+A$ $1$ 变址寻址 $EA=(IX)+A$ $1$ 隐含寻址这种类型的指令，不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址 如单地址的指令格式，就不是明显地在地址字段中指出第二操作数的地址，而是规定累加器 $ACC$ 作为第二操作数地址，指令格式明显指出的仅是第一操作数的地址，因此，累加器 $ACC$ 对单地址指令格式来说是隐含地址 该方式有利于缩短指令字长，但需要增加存储操作数或隐含地址的硬件 立即寻址这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称为立即数，此外，数据是采用补码形式存放的 立即寻址在指令执行阶段不访问主存，指令执行时间最短，但是 $A$ 的位数限制了立即数的范围 直接寻址指令字中的形式地址 $A$ 就是操作数的真实地址 $EA$，即 $EA=A$ 该方式简单便捷，指令在执行阶段仅访问一次主存，不需要专门计算操作数地址，但 $A$ 的位数决定了该指令操作数的寻址范围，操作数的地址不易修改 间接寻址间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即：$EA=(A)$ 间接寻址可扩大寻址范围，可以方便地完成子程序返回，便于编制程序，但指令在执行阶段要多次访存，由于访问速度过慢，这种寻址方式并不常用 寄存器寻址在指令字中直接给出操作数所在的寄存器编号，即 $EA＝R_i$，其操作数在由 $R_i$ 所指的寄存器内 该方式在指令执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，同时支持向量/矩阵运算，但寄存器价格昂贵，计算机中寄存器个数有限 寄存器间接寻址寄存器间接寻址是指在寄存器 $R_i$ 中给出的不是一个操作数，而是操作数所在主存单元的地址，即 $EA=(R_i)$ 寄存器间接寻址与一般间接寻址相比速度更快，但由于操作数在主存中，因此指令的执行阶段需要访问主存 相对寻址相对寻址是把程序计数器 $PC$ 的内容加上指令格式中的形式地址 $A$ 而形成操作数的有效地址，即 $EA=(PC)+A$，其中 $A$ 是相对于当前指令地址的位移量，该位移量用补码表示，同时其位数决定操作数的寻址范围 该寻址方式的操作数的地址不是固定的，它随着 $PC$ 值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，广泛应用于转移指令 需要注意的是，对于转移指令 $JMPA$，当 CPU 从存储器中取出一个字节时，会自动执行 $(PC)+1\\rightarrow PC$，若转移指令的地址为 $X$，且占 $2$ 个字节，在取出该指令后，$PC$ 的值会增 $2$，即 $(PC)=X+2$，这样在执行完该指令后，会自动跳转到 $X+2+A$ 的地址继续执行 基址寻址基址寻址是将 CPU 中基址寄存器 $BR$ 的内容加上指令格式中的形式地址 $A$，而形成操作数的有效地址，即 $EA=(BR)+A$，其中基址寄存器既可采用专用寄存器，也可采用通用寄存器 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性，在程序执行过程中，基址寄存器的内容作为基地址不变，而形式地址作为偏移量可变 当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定 基址寻址可扩大寻址范围，用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序，但作为偏移量的形式地址 $A$ 的位数较短 变址寻址有效地址 $EA$ 等于指令字中的形式地址 $A$ 与变址寄存器 $IX$ 的内容相加之和，即 $EA＝(IX)+A$，其中 $IX$ 为变址寄存器，也可用通用寄存器作为变址寄存器 变址寄存器是面向用户的，在程序执行过程中，变址操作数寄存器的内容作为偏移量可由用户改变，形式地址 $A$ 作为基地址不变 该方式可扩大寻址范围，同时在数组处理过程中，可设定 $A$ 为数组的首地址，不断改变变址寄存器 $IX$ 的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序 显然，变址寻址与基址寻址的有效地址形成过程极为相似，但从本质上来讲，两者有较大区别，基址寻址面向系统，主要用于为多道程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 $A$ 是可变的，变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容是由用户设定的，在程序执行过程中其值可变，而指令字中的 $A$ 是不可变的 堆栈寻址堆栈是存储器中一块特定的按后进先出 LIFO 原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针 $SP$ 堆栈可分为硬堆栈与软堆栈两种： 硬堆栈：即寄存器堆栈，成本比较高，不适合做大容量的堆栈 软堆栈：从主存中划出一段区域来做堆栈 在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了 $SP$，通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对 $SP$ 内容的增量或减量操作","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"指令格式","slug":"computer-composition/12.指令格式","date":"2019-04-02T04:11:00.000Z","updated":"2022-05-09T07:04:55.460Z","comments":true,"path":"notes/computer-composition/873dc349.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/873dc349.html","excerpt":"【指令的基本格式】指令指令，又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位，一台计算机的所有指令的集合构成该机的指令系统，也称为指令集","text":"【指令的基本格式】指令指令，又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位，一台计算机的所有指令的集合构成该机的指令系统，也称为指令集 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码，一条指令通常要包括操作码字段和地址码字段两部分： 其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，地址码用于给出被操作的信息（指令或数据）的地址 操作码是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息，例如：指出是算术加运算，还是减运算；是程序转移，还是返回操作 地址码包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等 指令结构指令的长度是指一条指令中所包含的二进制代码的位数，指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长 通常，把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令 在一个指令系统中，若所有指令的长度都是相等的，称为定长指令字结构，定字长指令的执行速度快，控制简单，若各种指令的长度随指令功能而异，就称为变长指令字结构 指令格式根据指令中的操作数地址码的数目的不同，可将指令分成以下几种格式 1.零地址指令 只给出操作码 $OP$，没有显地址，这种指令有两种可能： 不需要操作数的指令，如空操作指令、停机指令、关中断指令等 零地址的运算类指令仅用在堆栈计算机中，通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入到堆栈中 2.一地址指令 这种指令也有两种常见的形态，根据操作码含义确定它究竟是哪一种： 1）只有目的操作数的单操作数指令 按 $A_1$ 地址读取操作数，进行 $OP$ 操作后，结果存回原地址，指令含义如下： OP(A_1)\\rightarrow A_12）隐含约定目的地址的双操作数指令 按指令地址 $A_1$ 可读取源操作数，指令可隐含约定另一个操作数由累加器 ACC 提供，运算结果也将存放在 ACC 中，指令含义如下： (ACC)OP(A_1)\\rightarrow ACC若指令字长为 $32$ 位，操作码占 $8$ 位，一个地址码字段各占 $24$ 位，则指令操作数的直接寻址最大范围为 $2^{24}＝16M$ 3.二地址指令 对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果，指令含义如下： (A_1)OP(A_2)\\rightarrow A_1若指令字长为 $32$ 位，操作码占 $8$ 位，两个地址码字段各占 $12$ 位，则指令操作数的直接寻址范围为 $2^{12}＝4K$ 4.三地址指令 指令含义： (A_1)OP(A_2)\\rightarrow A_3若指令字长为 $32$ 位，操作码占 $8$ 位，三个地址码字段各占 $8$ 位，则指令操作数的直接寻址范围为 $2^8＝256$ 若地址字段均为主存地址，则完成一条三地址需要 $4$ 次访问存储器，其中取指令 $1$ 次，取两个操作数 $2$ 次，存放结果 $1$ 次 5.四地址指令 指令含义： (A_1)OP(A_2)\\rightarrow A_3,A_4若指令字长为 $32$ 位，操作码占 $8$ 位，四个地址码字段各占 $6$ 位，则指令操作数的直接寻址范围为 $2^6＝64$ 【定长操作码指令格式】定长操作码指令是在指令字的最高位部分分配固定的若干位表示操作码，一般 $n$ 位操作码字段的指令系统最大能够表示 $2^n$ 条指令 定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利，当计算机字长为 $32$ 位或更长时，是常规用法 【扩展操作码指令格式】为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上 显然，这将增加指令译码和分析的难度，使控制器的设计复杂化 最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长 在设计扩展操作码指令格式时，必须注意以下两点： 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同 各指令的操作码一定不能重复 通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间 如下图所示的扩展操作码的安排方式，在该方式中，指令字长为 $16$ 位，其中 $4$ 位为基本操作码字段 $OP$，另有 $3$ 个 $4$ 位长的地址字段 $A_1$、$A_2$、$A_3$ 若 $4$ 位基本操作码若全部用于三地址指令，则共有 $16$ 条，三地址指令为 $15$ 条，$1111$ 留作扩展操作码之用，二地址指令为 $15$ 条，$1111 1111$ 留作扩展操作码之用，一地址指令为 $15$ 条，$111111111111$ 留作扩展操作码之用，零地址指令为 $16$ 条","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"高速缓冲存储器 Cache","slug":"computer-composition/11.高速缓冲存储器Cache","date":"2019-03-24T07:13:00.000Z","updated":"2022-05-08T13:03:02.452Z","comments":true,"path":"notes/computer-composition/73cc498c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/73cc498c.html","excerpt":"【局部性原理】程序访问的局部性原理包括时间局部性和空间局部性： 时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息，这是因为程序存在循环 空间局部性：在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，这是因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组、表等形式簇聚地存储在一起的","text":"【局部性原理】程序访问的局部性原理包括时间局部性和空间局部性： 时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息，这是因为程序存在循环 空间局部性：在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，这是因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组、表等形式簇聚地存储在一起的 高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而使程序的执行速度大大提高 【Cache 工作原理】结构Cache 位于存储器层次结构的顶层，通常由 SRAM 构成 Cache 和主存都被分成若干大小相等的块（Cache 块又称为 Cache 行），每块由若干字节组成，块的长度称为块长（Cache 行长） 由于 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本，故而 Cache 会按照某种策略，预测 CPU 在未来一段时间内欲访存的数据，将其装入 Cache 读请求当 CPU 发出读请求时，如果访存地址在 Cache 中命中，就将此地址转换成 Cache 地址，直接对 Cache 进行读操作，与主存无关；如果 Cache 不命中，则仍需访问主存，并把此字所在的块一次从主存调入 Cache 内 若将块从主存调入 Cache 时，Cache 已满，则需根据某种替换算法，用这个块替换掉 Cache 中原来的某块信息 需要注意的是，CPU 与 Cache 之间的数据交换以字为单位，而 Cache 与主存之间的数据交换则是以 Cache 块为单位 此外，在某些计算机中也采用同时访问 Cache 和主存的方式，若 Cache 命中，则主存访问终止，否则访问主存并替换 Cache 写请求当 CPU 发出写请求时，如果 Cache 命中，有可能会遇到 Cache 与主存中的内容不一致的问题 例如：由于 CPU 写 Cache，把 Cache 某单元中的内容从 $X$ 修改成了 $X’$，而主存对应单元中的内容仍然是 $X$，没有改变 所以如果 Cache 命中，需要按照一定的写策略处理，即：全写法、写回法 而如果 Cache 未命中，也会按照一定的写策略处理，即：写分配法、非写分配法 【Cache 性能指标】CPU 欲访问的信息已在 Cache 中的比率称为 Cache 的命中率 设一个程序执行期间，Cache 的总命中次数为 $N_c$，访问主存的总次数为 $N_m$，则命中率 $H$ 为： H=\\frac{N_c}{N_c+N_m}可见为提高访问效率，命中率 $H$ 越接近 $1$ 越好 设 $t_c$ 为命中时的 Cache 访问时间，$t_m$ 为未命中时的访问时间，$1-H$ 表示未命中率，则 Cache-主存系统的平均访问时间 $T$ 为： T_a=Ht_c+(1-H)t_m【Cache 地址映射】原理在 Cache 中，地址映射是指把主存地址空间映射到 Cache 地址空间，也就是把存放在主存中的程序按照某种规则装入 Cache 中 由于 Cache 块数比主存块数少得多，这样主存中只有一部分块的内容可放在 Cache 中，因此在 Cache 中要为每一块加一个标记，指明它是主存中哪一块的副本，该标记的内容相当于主存中块的编号 为了说明标记是否有效，每个标记至少还应设置一个有效位，该位为 $1$ 时，表示 Cache 映射的主存块数据有效，否则无效 需要注意的是，地址映射不同于地址变换，地址变换是指 CPU 在访存时，将主存地址按映射规则换算成 Cache 地址的过程 直接映射主存数据块只能装入 Cache 中的唯一位置，若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法） 直接映射实现简单，但不够灵活，即使 Cache 存储器的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低 直接映射的关系可定义为： j = i\\:\\: mod \\:\\: 2^c其中，$j$ 是 Cache 的块号，$i$ 是主存的块号，$2^c$ 是 Cache 中的总块数 在这种映射方式中，主存的第 $0$ 块、第 $2^c$ 块、第 $2^{c+1}$ 块、$….$，只能映射到 Cache 的第 $0$ 行，而主存的第 $1$ 块、第 $2^{c+1}$块、$2^{c+1}+1$ 块、$…$，只能映射到 Cache 的第 $1$ 行，依次类推 直接映射的地址结构如下图 全相联映射全相联映射可以把主存数据块装入 Cache 中的任何位置 全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高，缺点是地址变换速度慢，实现成本高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射 全相联映射的地址结构如下图 组相联映射组相联映射将 Cache 空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射，它是对直接映射和全相联映射的一种折中 组相联映射的关系可以定义为： j=i\\:\\:mod\\:\\: Q其中，$j$ 缓存的组号，$i$ 是主存的块号，$Q$ 是 Cache 的组数，当 $Q＝1$ 时变为全相联映射，当 $Q$ 为 Cache 块数时变为直接映射 组相联映射的地址结构如下图所示 【Cache 替换算法】在采用直接映射时，一个给定的主存块只能放到一个唯一的固定 Cache 行中，所以，在对应 Cache 行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，无需考虑替换算法 而在采用全相联映射和组相联映射方式时，从主存向 Cache 传送一个新块，当 Cache 中的空间已被占满时，就需要使用替换算法置换 Cache 行 常用的替换算法有以下几种： 随机算法 RAND：随机地确定替换的 Cache 块，实现简单，但没有依据程序访问的局部性原理，故可能命中率较低 先进先出算法 FIFO：选择最早调入的行进行替换，实现简单，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入 Cache 的块替换掉 近期最少使用算法 LRU：依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，该算法对每行设置一个计数器，Cache 每命中一次，命中行计数器清 $0$，其他各行计数器均 $+1$，需要替换时比较各特定行的计数值，将计数值最大的行换出 最不经常使用算法 LFU：将一段时间内被访问次数最少的存储行换出，每行也设置一个计数器，新行建立后从 $0$ 开始计数，每访问一次，被访问的行计数器 $+1$，需要替换时比较各特定行的计数值，将计数值最小的行换出 【Cache 写策略】因为 Cache 中的内容是主存块副本，当对 Cache 中的内容进行更新时，就需选用写操作策略使 Cache 内容和主存内容保持一致 Cache 写命中全写法全写法是指当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，当某一块需要替换时，不必把这一块写回主存，将新调入的块直接覆盖即可 这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了 Cache 的效率 此外，为减少全写法直接写入主存的时间损耗，会在 Cache 和主存之间加一个写缓冲，CPU 同时写数据到 Cache 和写缓冲中，写缓冲再控制将内容写入主存 写缓冲是一个 FIFO 队列，可以解决速度不匹配的问题，但如果出现频繁写时，会使写缓冲饱和溢出 写回法写回法是指当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存 这种方法减少了访存次数，但存在不一致的隐患，采用这种策略时，每个 Cache 行必须设置一个标志位（脏位），以反映此块是否被CPU修改过 Cache 写不命中写分配法写分配法是指当 CPU 对 Cache 写不命中时，加载主存中的块到 Cache 中，然后更新这个 Cache 块 写分配法试图利用程序的空间局部性，但是每次不命中都需要从主存中读取一块，效率较低 写分配法通常会与写回法配合使用 非写分配法非写分配法是指当 CPU 对 Cache 写不命中时，只写入主存，不进行调块 非写分配法通常会与全写法配合使用 【多级 Cache】现代计算机的 Cache 通常设立多级 Cache（通常为 $3$ 级），假定设 $3$ 级 Cache，按离 CPU 远近可各自命名 L1 Cache、L2 Cache、L3 Cache，离 CPU 越远，访问速度越慢，容量越大 指令 Cache 与数据 Cache 分离一般在 L1 级别，此时通常为写分配法与写回法合用 如下图，是一个含有两级 Cache 的系统，L1 Cache 对 L2 Cache 使用全写法，L2 Cache 对主存使用写回法，由于 L2 Cache 的存在，其访问速度大于主存，这样避免了因频繁写时造成的写缓冲饱和和溢出","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"双端口 RAM 与多模块存储器","slug":"computer-composition/10.双端口RAM与多模块存储器","date":"2019-03-21T15:05:00.000Z","updated":"2022-05-08T11:18:37.037Z","comments":true,"path":"notes/computer-composition/23b63911.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/23b63911.html","excerpt":"【双端口 RAM】双端口 RAM 是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元","text":"【双端口 RAM】双端口 RAM 是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元 当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突，当两个端口同时存取存储器的同一地址单元时，就会因数据冲突造成数据存储或读取错误 两个端口对同一主存操作有以下四种情况： 两个端口不同时对同一地址单元存取数据 两个端口同时对同一地址单元读出数据 两个端口同时对同一地址单元写入数据 两个端口同时对同一地址单元，一个写入数据，另一个读出数据 其中，第 $1$ 种和第 $2$ 种情况不会出现错误，第 $3$ 种情况会出现写入错误，第 $4$ 种情况会出现读出错误 解决方法：置忙信号 $\\overline{BUSY}$ 为 $0$，由判断逻辑决定暂时关闭一个端口（即被延时），未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问 【多模块存储器】为提高访存速度，常采用多模块存储器，常用的有单体多字存储器和多体低位交叉存储器 单体多字存储器单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储 $m$ 个字，总线宽度也为 $m$ 个字，一次并行读出 $m$ 个字，地址必须顺序排列并处于同一存储单元 单体多字系统在一个存取周期内，从同一地址取出 $m$ 条指令，然后逐条将指令送至 CPU 执行，即每隔 $\\frac{1}{m}$ 存取周期，CPU 向主存取一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度 但由于指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显 多体并行存储器多体并行存储器由多体模块组成，每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器，它们既能并行工作，又能交叉工作。 多体并行存储器分为高位交叉编址（顺序方式）和低位交叉编址（交叉方式）两种 高位交叉编址：高位地址表示体号，低位地址为体内地址 低位交叉编址：低位地址表示体号，高位地址为体内地址，由于程序连续存放在相邻体中，因此常称采用此编址方式的存储器为交叉存储器 多体模块结构的存储器采用低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽 设模块字长等于数据总线宽度，模块存取一个字的存取周期为 $T$，总线传送周期为 $r$，为实现流水线方式存取，则存储器交叉模块数应大于等于： m=\\frac{T}{r}式中，$m$ 称为交叉存取度，每经 $r$ 时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于或等于 $m$，以保证启动某模块后经过 $m\\times r$ 的时间后再次启动该模块时，其上次存取操作已经完成（即流水线不间断） 这样连续存取 $m$ 个字所需的时间为： t_1=T+(m-1)r而顺序方式连续读取 $m$ 个字所需时间为： t_2＝mT可见低位交叉存储器的带宽大大提高了 下面给出一个模块数为 $4$ 的流水线方式存取的实例 设存储器容量为 $32$ 个字，字长为 $64$ 位，模块数 $m=4$，分别采用顺序方式和交叉方式进行组织，存储周期 $T＝200ns$，数据总线宽度为 $64$ 位，总线传输周期 $r＝50ns$，在连续读出 $4$ 个字的情况下，求顺序存储器和交叉存储器各自的带宽 顺序存储器和交叉存储器连续读出 $m＝4$ 个字的信息总量均是： q=64bit\\times4=256bit顺序存储器和交叉存储器连续读出 $4$ 个字所需的时间分别是： \\begin{align} t_1=mT=4\\times 200ns=800ns=8\\times10^{-7}s \\\\ t_2=T+(m-1)r=200ns+3\\times50ns=350ns=35\\times10^{-8}s \\end{align}顺序存储器和交叉存储器的带宽分别是： \\begin{align} W_1=\\frac{q}{t_1}=\\frac{256}{(8\\times10-7)}=32\\times10^7bit/s \\\\ W_2=\\frac{q}{t_2}=\\frac{256}{(35\\times10-8)}=73\\times10^7bit/s \\end{align}","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"主存与 CPU 连接","slug":"computer-composition/09.主存与CPU连接","date":"2019-03-21T05:42:00.000Z","updated":"2022-05-07T15:04:43.027Z","comments":true,"path":"notes/computer-composition/31f16c29.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/31f16c29.html","excerpt":"【连接原理】主存储器通过数据总线、地址总线、控制总线与 CPU 连接 其中，数据总线的位数与工作频率的乘积正比于数据传输率，地址总线的位数决定了可寻址的最大内存空间，控制总线指出了总线周期的类型与本次输入/输出操作完成的时刻","text":"【连接原理】主存储器通过数据总线、地址总线、控制总线与 CPU 连接 其中，数据总线的位数与工作频率的乘积正比于数据传输率，地址总线的位数决定了可寻址的最大内存空间，控制总线指出了总线周期的类型与本次输入/输出操作完成的时刻 【主存容量扩展】由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此，需要在字和位两方面进行扩充才能满足实际存储器的容量要求 位扩展法CPU 的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位，即进行位扩展，用多个存储器件对字长进行扩充，增加存储字长，使其数据位数与 CPU 的数据线数相等。 位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出 如下图所示，用 $8$ 片 $8K\\times 1$ 位的 RAM 芯片组成 $8K\\times 8$ 位的存储器，$8$ 片 RAM 芯片的地址线 $A_{12}\\sim A_o$、$\\overline{CS}$、$\\overline{WE}$ 都分别连在一起，每片的数据线依次作为 CPU 数据线的一位 在采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有芯片，因此片选信号 $\\overline{CS}$ 要连接到所有芯片 字扩展法字扩展指的是增加存储器中字的数量，而位数不变 字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围 如图下图所示，用 $4$ 片 $16K\\times 8$ 位的 RAM 芯片组成 $64K\\times 8$ 位的存储器，$4$ 片 RAM 芯片的数据线 $D_0\\sim D_7$ 和 $\\overline{WE}$ 都分别连在一起 将 $A_{15}A_{14}$ 用做片选信号，当 $A_{15}A_{14}=00$ 时，译码器输出端 $0$ 有效，选中最左边的 $1$ 号芯片，当 $A_{15}A_{14}=01$ 时，译码器输出端 $1$ 有效，选中 $2$ 号芯片，依次类推，使得在同一时间内只能有一个芯片被选中 各芯片的地址分配如下： 第一片：最低地址 $00,00000000000000$，最高地址 $00,11111111111111$（$16$ 位） 第二片：最低地址 $01,00000000000000$，最高地址 $01,11111111111111$（$16$ 位） 第三片：最低地址 $10,00000000000000$，最高地址 $10,11111111111111$（$16$ 位） 第四片：最低地址 $11,00000000000000$，最高地址 $11,11111111111111$（$16$ 位） 在采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在同一时刻只需选中部分芯片，因此通过片选信号 $\\overline{CS}$ 或采用译码器设计连接到相应芯片即可 字位同时扩展法实际上，存储器往往需要字和位同时扩充，也就是既增加存储字的数量，又增加存储字长 如图下图所示，用 $8$ 片 $16K\\times 4$ 位的 RAM 芯片组成 $64K\\times 8$ 位的存储器，每两片构成一组 $16K\\times 8$ 位的存储器（位扩展），$4$ 组便构成 $64K\\times 8$ 位的存储器（字扩展） 地址线 $A_{15}A_{14}$ 经译码器得到 $4$ 个片选信号，当 $A_{15}A_{14}=00$ 时，输出端 $0$ 有效，选中第一组的芯片（①和②），当 $A_{15}A_{14}=01$ 时，输出端 $1$ 有效，选中第二组的芯片（③和④），依次类推 采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号 $\\overline{CS}$ 或采用译码器设计连接到相应的芯片 【存储芯片的地址分配与片选】CPU 要实现对存储单元的访问，首先要选择存储芯片，即进行片选，然后再为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行字选 片内的字选通常是由 CPU 送出的 $N$ 条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端，而片选信号是通过线选法或译码片选法产生的 线选法线选法用除片内寻址外的高位地址线直接（或经反相器）分别接至各个存储芯片的片选端，当某地址线信息为 $0$ 时，就选中与之对应的存储芯片 这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组） 线选法不需要地址译码器，线路简单，但地址空间不连续，同时，要求选片的地址线必须分时为低电平，否则不能工作，这不能充分利用系统的存储器空间，造成地址资源的浪费 假设 $4$ 片 $2K\\times 8$ 位存储芯片用线选法构成 $8K\\times 8$ 位存储器，那么各芯片的片选信号通过线选法进行地址分配，各地址如下表所示 芯片 $A_{14}\\sim A_{11}$ $0$ $1110$ $1$ $1101$ $2$ $1011$ $3$ $0111$ 译码片选法译码片选法用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号 如用 $8$ 片 $8K\\times 8$ 位的存储芯片组成 $64K\\times 8$ 位存储器（地址线为 $16$ 位，数据线为 $8$ 位），需要 $8$ 个片选信号 若采用线选法，除去片内寻址的 $13$ 位地址线，仅余高 $3$ 位，不足以产生 $8$ 个片选信号 【存储器与 CPU 的连接】1.合理选择存储芯片 要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型（RAM 或 ROM）和数量的选择 通常选用 ROM 存放系统程序、标准子程序和各类常数，RAM 则是为用户编程而设置的 此外，在考虑芯片数量时，要尽量使连线简单、方便 2.地址线的连接 存储芯片的容量不同，其地址线数也不同，而 CPU 的地址线数往往比存储芯片的地址线数要多 通常将 CPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选），这部分的译码是由芯片片内逻辑完成的 而 CPU 地址线的高位则在扩充存储芯片时用，以用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成 例如，设 CPU 地址线为 $16$ 位，即 $A_{15}\\sim A_0$，$1K\\times 4$ 位的存储芯片仅有 $10$ 根地址线，此时，可将 CPU 的低位地址 $A_9\\sim A_0$ 与存储芯片的地址线 $A_9\\sim A_0$ 相连 3.数据线的连接 CPU 的数据线与存储芯片的数据线数不一定相等，在相等时可直接相连，在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等 4.读写命令线的连接 CPU 读写命令线一般可直接与存储芯片的读写控制端相连，通常高电平为读，低电平为写 有些 CPU 的读写命令线是分开的（读为 $\\overline{RD}$，写为 $\\overline{WE}$，均为低电平有效），此时 CPU 的读命令线应与存储芯片的允许读控制端相连，而 CPU 的写命令线则应与存储芯片的允许写控制端相连 5.片选线的连接 片选线的连接是 CPU 与存储芯片连接的关键 存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端 $\\overline{CS}$ 是否能接收到来自CPU的片选有效信号 片选有效信号与 CPU 的访存控制信号 $\\overline{MREQ}$（低电平有效）有关，因为只有当 CPU 要求访存时，才要求选中存储芯片 若 CPU 访问 I/O，则 $\\overline{MREQ}$ 为高，表示不要求存储器工作","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"Kruskal 算法","slug":"graph/02.spanning-tree/01.minimum-spanning-tree/03.Kruskal算法","date":"2019-03-19T09:00:15.000Z","updated":"2021-09-08T14:20:44.107Z","comments":true,"path":"oi-acm/graph/spanning-tree/minimum-spanning-tree/f27ebd78.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/spanning-tree/minimum-spanning-tree/f27ebd78.html","excerpt":"【基本思想】$Kruskal$ 算法基本思想是并查集思想 初始时，将所有边升序排序，认为每一个点都是孤立的，分属 $n$ 个独立的集合","text":"【基本思想】$Kruskal$ 算法基本思想是并查集思想 初始时，将所有边升序排序，认为每一个点都是孤立的，分属 $n$ 个独立的集合 之后，按顺序枚举每一条边： 若这条边连接的两个点分属两个不同的集合，那么就将这条边加入最小生成树，即这两个不同的集合合并为一个集合 若这条边连接的两个点属于同一集合，那么就跳过 重复上述过程，直到选取 $n-1$ 条边为止（只剩一个集合） 其时间复杂度为：$O(|E|log|E|)$，仅与图的边数有关，适合顶点多的稀疏图 【算法分析】以下图为例 开始时，存在 $5$ 个集合 {1},{2},{3},{4},{5}，生成树中没有边，MST=0 第一次选择 $(1,2)$ 这条边，将边加入生成树中，将两个顶点 $1$，$2$ 合并为一个集合 此时，有 $4$ 个集合 {1,2},{3},{4},{5}，$1$ 条边 {(1,2)}，MST=2 第二次选择的是 $(4,5)$ 这条边，将这条边加入生成树中，将两个顶点 $4$，$5$ 合并为一个集合 此时，有 $3$ 个集合 {1,2},{3},{4,5}，$2$ 条边 {(1,2),(4,5)}，MST=5 第三次选择的是 $(3,5)$ 这条边，将这条边加入生成树中，将它的两个顶点 $3$，$5$ 所在的两个集合合并为一个集合 此时，有 $2$ 个集合 {1,2},{3,4,5}，$3$ 条边 {(1,2),(4,5),{3,5}}，MST=11 第三次选择的是 $(2,5)$ 这条边，将这条边加入生成树中，将它的两个顶点 $2$，$5$ 所在的两个集合合并为一个集合 此时，有 $1$ 个集合 {1,2,3,4,5}，$4$ 条边 {(1,2),(4,5),{3,5},{2,5}}，MST=19 【实现】1234567891011121314151617181920212223242526272829303132333435363738394041struct Edge &#123; int x, y; int dis; bool operator&lt;(Edge K) const &#123; return dis &lt; K.dis; &#125;&#125; edge[N];int father[N]; //并查集父结点int Find(int x) &#123; //并查集查询根结点 if (father[x] == x) return x; return father[x] = Find(father[x]);&#125;int kruskal(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) //并查集初始化 father[i] = i; sort(edge + 1, edge + m + 1); //边升序排序 int MST = 0; int edgeNum = 0; //边数 for (int i = 1; i &lt;= m; i++) &#123; int fx = Find(edge[i].x); //点x的根结点 int fy = Find(edge[i].y); //点y的根结点 if (fx != fy) &#123; //合并 father[fx] = fy; MST += edge[i].dis; edgeNum++; &#125; if (edgeNum == n - 1) &#123; // n-1条边时停止 return MST; &#125; &#125;&#125;int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); //n个结点m条边 for (int i = 1; i &lt;= m; ++i) scanf(\"%d%d%d\", &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].dis); int MST = kruskal(n, m); printf(\"%d\\n\", MST); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"生成树问题","slug":"oi-acm/graph/spanning-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/spanning-tree/"},{"name":"最小生成树","slug":"oi-acm/graph/spanning-tree/minimum-spanning-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/spanning-tree/minimum-spanning-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"生成树问题","slug":"spanning-tree","permalink":"https://alex-mcavoy.github.io/tags/spanning-tree/"},{"name":"最小生成树","slug":"minimum-spanning-tree","permalink":"https://alex-mcavoy.github.io/tags/minimum-spanning-tree/"}],"author":"Alex_McAvoy"},{"title":"Prim 算法","slug":"graph/02.spanning-tree/01.minimum-spanning-tree/02.Prim算法","date":"2019-03-19T04:00:15.000Z","updated":"2021-09-08T14:13:21.898Z","comments":true,"path":"oi-acm/graph/spanning-tree/minimum-spanning-tree/93356716.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/spanning-tree/minimum-spanning-tree/93356716.html","excerpt":"【基本思想】Prim 算法基本思想是贪心的蓝白点思想，用白点代表已进入最小生成树的点，蓝点代表未进入最小生成树的点，初始时，所有的点都是蓝点 每次循环都将一个蓝点 $u$ 变为白点，并且此蓝点 $u$ 与白点相连的最小边权 $min[u]$ 是当前所有蓝点中最小的","text":"【基本思想】Prim 算法基本思想是贪心的蓝白点思想，用白点代表已进入最小生成树的点，蓝点代表未进入最小生成树的点，初始时，所有的点都是蓝点 每次循环都将一个蓝点 $u$ 变为白点，并且此蓝点 $u$ 与白点相连的最小边权 $min[u]$ 是当前所有蓝点中最小的 这相当于每次循环让一个新的点加入生成树，让一条最小边加入生成树，$n-1$ 次循环就能生成一棵含有 $n$ 个点的树，最后得到的一定是最小生成树 其时间复杂度为：$O(|V|^2)$，仅与点数有关，适合稠密图 【算法分析】以下图为例，蓝点和虚线代表未进入最小生成树的点、边，白点和实现代表已进入最小生成树是点、边 初始时，所有点都是蓝点，dis[1] = 0，dis[2] ~ dis[5] = INF，权值和 MST = 0 第一次循环找到 dis[1] = 0 最小的蓝点 $1$，将 $1$ 变为白点，接着枚举与 $1$ 相连的所有蓝点 $2$，$3$，$4$，修改它们与白点相连的最小边权 故有：dis[2] = G[1][2] = 2，dis[3] = G[1][3] = 4，dis[4] = G[1][4] = 7，MST = 0 第二次循环是找到 dis[2] 最小的蓝点 $2$，将 $2$ 变为白点，接着枚举与 $2$ 相连的所有蓝点 $3$，$5$，修改它们与白点相连的最小边权 故有：dis[3] = G[2][3] = 1，dis[5] = G[2][5] = 2，MST = 2 第三次循环是找到 dis[3] 最小的蓝点 $3$，将 $3$ 变为白点，接着枚举与 $3$ 相邻的所有蓝点 $4$，$5$，修改它们与白点相连的最小边权 故有：dis[4] = G[3][4] = 1 同时，由于 dis[5] = 2 &lt; G[3][5] = 6，所以不修改 dis[5] 的值，即 MST = 3 最后两轮循环将点 $4$，$5$ 以及边 G[2][5]，G[3][4] 添加进最小生成树 最后权值之和 MST = 6 【实现】12345678910111213141516171819202122232425262728293031323334353637383940#define INF 0x3f3f3fint G[N][N]; //邻接矩阵int dis[N]; //权值数组bool vis[N]; //蓝白点标记数组int Prim(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; int k; int minn = INF; for (int j = 1; j &lt;= n; j++) &#123; //枚举所有点 if (!vis[j] &amp;&amp; dis[j] &lt; minn) &#123; //寻找与白点相连的权值最小的蓝点u minn = dis[j]; k = j; &#125; &#125; vis[k] = true; //蓝点u加入生成树，标记为白点 for (int j = 1; j &lt;= n; j++) //修改所有与u相连的蓝点 if (!vis[j] &amp;&amp; dis[j] &gt; G[k][j]) dis[j] = G[k][j]; &#125; int MST = 0; for (int i = 1; i &lt;= n; i++) //权值和的计算 MST += dis[i]; return MST;&#125;int main() &#123; int n, m; //n个点m条边 scanf(\"%d%d\", &amp;n, &amp;m); memset(vis, false, sizeof(vis)); memset(dis, INF, sizeof(dis)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf(\"%d\", &amp;G[i][j]); for (int i = 1; i &lt;= n; i++) dis[i] = G[1][i]; int MST = Prim(n, m); printf(\"%d\\n\", MST); system(\"pause\"); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"生成树问题","slug":"oi-acm/graph/spanning-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/spanning-tree/"},{"name":"最小生成树","slug":"oi-acm/graph/spanning-tree/minimum-spanning-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/spanning-tree/minimum-spanning-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"生成树问题","slug":"spanning-tree","permalink":"https://alex-mcavoy.github.io/tags/spanning-tree/"},{"name":"最小生成树","slug":"minimum-spanning-tree","permalink":"https://alex-mcavoy.github.io/tags/minimum-spanning-tree/"}],"author":"Alex_McAvoy"},{"title":"最小生成树","slug":"graph/02.spanning-tree/01.minimum-spanning-tree/01.最小生成树","date":"2019-03-17T12:10:14.000Z","updated":"2021-09-08T14:01:56.242Z","comments":true,"path":"oi-acm/graph/spanning-tree/minimum-spanning-tree/9acb5cb3.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/spanning-tree/minimum-spanning-tree/9acb5cb3.html","excerpt":"对一个具有 $n$ 个点的连通图进行遍历，对于遍历后的子图，若其包含原图中所有的点且保持图连通，那么这个连通图是在边最少的情况下保持图连通的子图，即极小连通子图，其结构一定是一个具有 $n-1$ 条边的树，通常称为生成树 对于生成树来说，若除去其一条边，则会变为非连通图，若添加一条边，则会形成图中的一条回路","text":"对一个具有 $n$ 个点的连通图进行遍历，对于遍历后的子图，若其包含原图中所有的点且保持图连通，那么这个连通图是在边最少的情况下保持图连通的子图，即极小连通子图，其结构一定是一个具有 $n-1$ 条边的树，通常称为生成树 对于生成树来说，若除去其一条边，则会变为非连通图，若添加一条边，则会形成图中的一条回路 在生成树问题中，最常见的问题就是最小生成树问题，所谓最小生成树，就是对于一个有 $n$ 个点的无向连通图的生成树，其包含原图中的所有点，且保持图连通的边权总和最少的边 简单来说，对于一个有 $n$ 个点的图，边一定是大于等于 $n-1$ 条的，最小生成树，就是在这些边中选择 $n-1$ 条出来连接所有的 $n$ 个点，且这 $n-1$ 条边的边权之和是所有方案中最小的 最小生成树具有以下两条性质： 切割性质：连接点 $x$、$y$ 的边权最小的边必定被生成树包含 回路性质：任意回路/环上的边权最大的边必不被生成树包含 解决最小生成树问题的算法有： Prim 算法 Kruskal 算法","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"生成树问题","slug":"oi-acm/graph/spanning-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/spanning-tree/"},{"name":"最小生成树","slug":"oi-acm/graph/spanning-tree/minimum-spanning-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/spanning-tree/minimum-spanning-tree/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"生成树问题","slug":"spanning-tree","permalink":"https://alex-mcavoy.github.io/tags/spanning-tree/"},{"name":"最小生成树","slug":"minimum-spanning-tree","permalink":"https://alex-mcavoy.github.io/tags/minimum-spanning-tree/"}],"author":"Alex_McAvoy"},{"title":"半导体随机存储器","slug":"computer-composition/08.半导体随机存储器","date":"2019-03-15T07:49:00.000Z","updated":"2022-05-07T12:34:31.389Z","comments":true,"path":"notes/computer-composition/bbed585f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/bbed585f.html","excerpt":"【半导体存储芯片】基本结构半导体存储芯片内集成有存储矩阵、译码驱动电路、读写电路等，其基本结构如下图","text":"【半导体存储芯片】基本结构半导体存储芯片内集成有存储矩阵、译码驱动电路、读写电路等，其基本结构如下图 存储矩阵：由大量相同的位存储单元阵列构成 译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读写操作 读写电路：包括读出放大器和写入电路，用来完成读写操作 读写控制线：决定芯片进行读写操作 片选线：确定哪个存储芯片被选中 地址线：是单向输入的，其位数与存储字的个数有关 数据线：是双向的，其位数与读出或写入的数据位数有关，数据线数和地址线数共同反映存储芯片容量的大小，如地址线 $10$ 根，数据线 $8$ 根，则芯片容量为 $210\\times 8=8K$ 位 半导体随机存取存储器按其存储信息的原理不同，可分为静态 RAM 和动态 RAM 两种，静态 RAM 大多用于高速缓冲存储器中，动态 RAM 大多用于主存中 74138 译码器译码是编码的逆过程， 实现译码功能的电路被称为译码器 常见的译码器为 74138 译码器，输入是 $3$ 位二进制码，输出端的 $8$ 个端口对应 $8$ 种输入状态，因此又被称为 3/8 译码器 其中，$A$、$B$、$C$ 为译码地址输入端，$G_1$、$\\overline{G_{2A}}$、$\\overline{G_{2B}}$ 为选通端，$\\overline{Y_0}\\sim \\overline{Y_7}$ 为译码输出端（低电平有效） 当选通端 $G_1$ 为高电平，另两个选通端 $\\overline{G_{2A}}$、$\\overline{G_{2B}}$ 为低电平时，才可将地址端 $A$、$B$、$C$ 的二进制码在一个对应的输出端以低电平译出 【RAM 存储器】概述通常把存放一个二进制位的物理器件称为存储元，其是存储器的最基本构件，地址码相同的多个存储元构成一个存储单元，若干存储单元的集合构成存储体 对于 RAM 存储器来说，其分为静态随机存储器（SRAM）和动态随机存储器（DRAM）两种，两者对比如下表 SRAM 存储器存储原理静态随机存储器（SRAM）的存储元是用双稳态触发器（六管 MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出），但是，只要电源被切断，原来的保存信息便会丢失，故它属易失性半导体存储器 SRAM 的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器 DRAM 存储器存储原理动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，常见的 DRAM 的基本存储电路通常分为三管式和单管式，同时 DRAM 采用地址复用技术，即地址线是原来的一半，且地址信号分行、列两次传送 相对于 SRAM 来说，DRAM 具有容易集成、位价低、容量大和功耗低等优点，但是 DRAM 的存取速度比 SRAM 慢，一般用来组成大容量主存系统 DRAM 电容上的电荷一般只能维持一到两毫秒，因此即使电源不掉电，信息也会自动消失，为此，每隔一定时间必须刷新，通常取 $2ms$，这个时间称为刷新周期 常用的刷新方式有以下三种： 集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为死时间，又称为访存死区，该方法读写操作时不受刷新工作的影响，因此系统的存取速度比较高，但在集中刷新期间（死区）不能访问存储器 分散刷新：把对每一行的刷新分散到各个工作周期中去，这样，一个存储器的系统工作周期分为两部分：前半部分用于正常读、写或保持；后半部分用于刷新某一行，这种刷新方式没有死区，但加长了系统的存取周期，降低了整机速度 异步刷新：异步刷新是前两种方法的结合，既可缩短死时间，又充分利用最大刷新间隔为 $2ms$ 的特点，具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔 $t$，然后利用逻辑电路每隔时间 $t$ 产生一次刷新请求，这样可以避免使 CPU 连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率 如果将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，也不会产生死时间，这是分散刷新方式的发展，也称作透明刷新 对于 DRAM，其刷新需注意以下问题： 刷新对 CPU 是透明的，即刷新不依赖于外部的访问 动态 RAM 的刷新单位是行，故刷新操作时仅需要行地址 刷新操作类似于读操作，但又有所不同 刷新操作仅是给栅极电容补充电荷，不需要信息输出 刷新时不需要选片，即整个存储器中的所有芯片同时被刷新 RAM 的读写周期RAM 的读周期从给出有效地址后，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间称为读出时间 $t_A$，地址片选信号 $\\overline{CS}$ 必须保持到数据稳定输出，$t_{CO}$ 为片选的保持时间，在读周期中 $\\overline{WE}$ 为高电平 RAM 芯片的读周期时序图如下所示 需要注意的是，读周期和读出时间是两个不同的概念，读周期时间 $t_{RC}$ 表示存储芯片进行两次连续读操作时所必须间隔的时间，其总是大于或等于读出时间 ROM 的写周期要实现写操作，必须要求片选信号 $\\overline{CS}$ 和写命令信号 $\\overline{WE}$ 都为低电平，同时为使数据总线上的信息能够可靠地写入存储器，要求 $\\overline{CS}$ 信号与 $\\overline{WE}$ 信号的与操作的宽度至少为 $t_w$ 若要去在地址变化期间不会发生错误写入而破坏存储器的内容，$\\overline{WE}$ 信号在地址变化期间必须为高电平 此外，为保证有效数据的可靠写入，地址有效的时间至少应为： t_{wc}＝t_{AW}＋t_W＋t_{WR}若要求在 $\\overline{WE}$ 和 $\\overline{CS}$ 变为无效前能把数据可靠地写入，要求写入的数据必须在 $t_{DW}$ 以前在数据总线上已经稳定 RAM 芯片的写周期时序图如下所示 【ROM 存储器】ROM 特点ROM 和 RAM 都是支持随机存取的存储器，其中 SRAM 和 DRAM 均为易失性存储器，而 ROM 中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的存储器 ROM 器件有两个显著的优点： 结构简单，位密度比可读写存储器高 具有非易失性，可靠性高 ROM 类型根据制造工艺的不同，ROM 可分为以下几种： 掩膜式只读存储器 MROM：内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人都无法改变其内容，可靠性高，集成度高，价格便宜，但灵活性差 一次可编程只读存储器 PROM：可以实现一次性编程的只读存储器，允许用户利用专门的设备（编程器）写入自己的程序，一旦写入后，内容就无法改变 可擦除可编程只读存储器 EPROM：不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写，当需要修改EPROM的内容时，先将其全部内容擦除，然后再编程，虽然 EPROM 可读又可写，但由于 EPROM 的编程次数有限，且写入时间过长，所以其不能取代 RAM，同时，根据擦除方式，ERPOM 可分为紫外线擦除 UVEPROM 和电擦除 EPROM 两种 闪速存储器 Flash Memory：又称闪存，其是在 EPROM 与 EPROM 基础上发展起来的，既可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写，价格便宜、集成度高，同时可擦除重写，且擦除重写的速度快 固态硬盘 SSD：基于闪存的固态硬盘是用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH 芯片）组成，保留了闪存长期保存信息、快速擦除与重写的特性，对比传统硬盘也具有读写速度快，低功耗的特性，但价格较高","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"存储器分类与指标","slug":"computer-composition/07.存储器分类与指标","date":"2019-03-15T04:36:00.000Z","updated":"2022-05-07T08:24:34.132Z","comments":true,"path":"notes/computer-composition/d7e92617.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/d7e92617.html","excerpt":"【存储器分类】按层次 主存储器：又称主存、内存，用来存放计算机运行期间所需的大量程序和数据，CPU 可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）以及辅助存储器交换数据，容量较小、存取速度较快、每位价格较高 辅助存储器：又称辅存、外存，是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，不能与 CPU 直接交换信息，容量极大、存取速度较慢、单位成本低 高速缓冲存储器：即 Cache，位于主存和 CPU 之间，用来存放正在执行的程序段和数据，以便 CPU 能高速地使用它们，其存取速度可以与 CPU 的速度相匹配，但存储容量小、价格高","text":"【存储器分类】按层次 主存储器：又称主存、内存，用来存放计算机运行期间所需的大量程序和数据，CPU 可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）以及辅助存储器交换数据，容量较小、存取速度较快、每位价格较高 辅助存储器：又称辅存、外存，是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，不能与 CPU 直接交换信息，容量极大、存取速度较慢、单位成本低 高速缓冲存储器：即 Cache，位于主存和 CPU 之间，用来存放正在执行的程序段和数据，以便 CPU 能高速地使用它们，其存取速度可以与 CPU 的速度相匹配，但存储容量小、价格高 按存储介质 磁表面存储器：磁盘、磁带 磁芯存储器半导体存储器：MOS 型存储器、双极型存储器 光存储器：光盘 按存取方式 随机存储器：即 RAM，其任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关，读写方便、使用灵活，主要用做主存或高速缓冲存储器 静态 RAM：以触发器原理寄存信息 动态 RAM：以电容充电原理寄存信息 只读存储器：即 ROM，内容只能随机读出而不能写入，信息一旦写入存储器就固定不变了，即使断电内容也不会丢失，通常存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化，与 RAM 共同作为主存的一部分，统一构成主存的地址域 串行访问存储器：对存储单元进行读写操作时，需按其物理位置的先后顺序寻址 顺序存取存储器：如磁带，其内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，存取速度慢 直接存取存储器：如磁盘，既不像 RAM 那样随机地访问任一个存储单元，也不像顺序存取存储器那样完全按顺序存取，而是介于两者之间，存取信息时通常先寻找整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找 按信息的可保存性 易失性存储器：如 RAM，断电后，存储信息即消失的存储器 非易失性存储器：如 ROM，断电后信息仍保持的存储器 磁表面存储器：如磁盘、磁带 光存储器：如光盘 如果某个存储单元所存储的信息被读出时，原存储信息将被破坏，则称为破坏性读出；如果读出时，被读单元原存储信息不被破坏，则称为非破坏性读出 具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息 【存储器性能指标】存储器有 $3$ 个主要性能指标，即存储容量、单位成本和存储速度，这 $3$ 个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度 存储容量 存储容量=存储字数\\times 字长存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量，如 $1M\\times 8位$ 单位成本 每位价格＝\\frac{总成本}{总容量}存储速度 数据传输率＝\\frac{数据的宽度}{存储周期} 存取时间 $T_a$：从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间 存取周期 $T_m$：又称为读写周期、访问周期，指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔 主存带宽 $B_a$：又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒、位/秒 存取时间不等于存储周期，通常存储周期大于存取时间。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可以达到 $T＝2T$，这是因为存储器中的信息读出后需要马上进行再生 存取时间与存取周期的关系如下图所示 【存储器层次化结构】为了解决存储系统大容量、高速度和低成本这些相互制约的矛盾，在计算机系统中，通常采用多级存储器结构 在图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU 访问的频度也越来越低 实际上，存储系统层次结构主要体现在 Cache-主存层次和主存-辅存层次，前者主要解决 CPU 和主存速度不匹配的问题，后者主要解决存储系统的容量问题 在存储体系中，Cache、主存能与 CPU 直接交换信息，辅存则需要通过主存与 CPU 交换信息 从 CPU 的角度看，Cache-主存层次速度接近于 Cache，容量和位价却接近于主存，从主存-辅存层次分析，其速度接近于主存，容量和位价却接近于辅存，这就解决了速度、容量、成本这三者之间的矛盾，现代计算机系统几乎都采用这种三级存储系统 需要注意的是，主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的，而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，仅对应用程序员是透明的 随着在主存-辅存层次的不断发展，逐渐形成了虚拟存储系统，在这个系统中，可以令程序员编程的地址范围与虚拟存储器的地址空间相对应，使得对具有虚拟存储器的计算机系统而言，编程时可用的地址空间远远大于主存空间","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"浮点数的表示与加减运算","slug":"computer-composition/06.浮点数的表示与加减运算","date":"2019-03-07T13:15:00.000Z","updated":"2022-05-06T15:13:15.138Z","comments":true,"path":"notes/computer-composition/73592ba1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/73592ba1.html","excerpt":"【浮点数表示】表示格式通常，浮点数被表示为：","text":"【浮点数表示】表示格式通常，浮点数被表示为： N = r^E \\times M其中，$r$ 是浮点数阶码的底，与尾数的基数相同，通常 $r=2$，$E$、$M$ 是带符号的定点数，$E$ 被称为阶码，$M$ 被称为尾数 如下图，显示了浮点数的一般格式，阶符 $J_f$ 和阶码的位数 $m$ 合起来反映浮点数的表示范围与小数点的实际位置，数符 $S_f$ 表示浮点数的符号，尾数的位数 $n$ 反映了浮点数的精度 规格化浮点数规格化操作为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值 非规格化浮点数需要进行规格化操作才能变成规格化浮点数，规格化操作就是通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值 规格化操作有以下两种： 左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算术左移一位，阶码 $-1$ 的 右规：当浮点数运算的结果尾数出现溢出（双符号位为 $01$ 或 $10$）时，将尾数算术右移一位，阶码 $+1$ 左规可能要进行多次，右规只需进行一次 规格化尾数在规格化后，规格化浮点数的尾数 $M$ 的绝对值应满足： \\frac{1}{r} \\leq |M| \\leq 1在计算机中，常取 $r=2$，故有： \\frac{1}{2} \\leq |M| \\leq 1而规格化表示的尾数形式如下： 1.原码规格化 对于正数为 $0.1xx···x$ 的形式，其最大值表示为 $0.11···1$，最小值表示为 $0.100···0$，此时尾数的表示范围为： \\frac{1}{2} \\leq M \\leq 1-2^{-n}对于负数为 $1.1xx···x$的形式，其最大值表示为 $1.10···0$，最小值表示为 $1.11··1$，此时尾数的表示范围为： -(1-2^{-n})\\leq M \\leq -\\frac{1}{2}2.补码规格化 对于正数为 $0.1xx···x$ 的形式，其最大值表示为 $0.11···1$，最小值表示为 $0.100···0$，此时尾数的表示范围为： \\frac{1}{2} \\leq M \\leq 1-2^{-n}对于负数为 $1.0xx···x$ 的形式，其最大值表示为 $1.01···1$，最小值表示为 $1.00···0$，此时尾数的表示范围为： -1\\leq M \\leq -(\\frac{1}{2}+2^{-n})需要注意的是，当浮点数尾数的基数为 $2$ 时，原码规格化数的尾数最高位一定是 $1$，补码规格化数的尾数最高位一定与尾数符号位相反 同时，基数不同，浮点数的规格化形式也不同，例如：当基数为 $4$ 时，原码规格化形式的尾数最高两位不全为 $0$；当基数为 $8$ 时，原码规格化形式的尾数最高 $3$ 位不全为 $0$ 溢出当运算结果大于最大正数称为正上溢，小于绝对值最大负数称为负上溢，正上溢和负上溢统称为上溢，数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理 当运算结果在 $0$ 至最小正数之间称为正下溢，在 $0$ 至绝对值最小负数之间称为负下溢，正下溢和负下溢统称为下溢，数据下溢时，浮点数数值趋于 $0$，计算机会将其当作机器零进行处理 IEEE754 标准IEEE754 标准规定常用的浮点数格式如下 在该标准中，规定常用的浮点数格式有短浮点数（单精度 float 型）、长浮点数（双精度 double 型）、临时浮点数上中年，具体格式要求如下表 对于短浮点数和长浮点数来说，尾数用隐藏位策略的原码表示，阶码用移码表示，故对于真值，有： 短浮点数：$(-1)^s \\times 1.M \\times 2^{E-127}$ 长浮点数：$(-1)^s \\times 1.M \\times 2^{E-1023}$ 其中，$s=0$ 表示正数，$s=1$ 表示负数；短浮点数 $E$ 为 $8$ 位表示，其取值为 $1 \\sim 254$，$M$ 为 $23$ 位，共 $32$ 位；长浮点数 $E$ 的取值为 $11$ 位表示，其取值为 $1\\sim 2046$，$M$ 为 $52$ 位 ，共 $64$ 位 综上，IEEE754 标准浮点数范围可见下表： 格式 最小值 最大值 单精度 $E=1$，$M=0$$1.0\\times 2^{1-127}=2^{-126}$ $E=254$，$M=.111…$$1.111…1\\times 2^{254-127}=2^{127}\\times (2-2^{-23})$ 双精度 $E=1$，$M=0$$1.0\\times 2^{1-1023}=2^{-1022}$ $E=2046$，$M=.111…$$1.111…1\\times 2^{2046-1023}=2^{1023}\\times (2-2^{-52})$ 【浮点数的加减运算】步骤浮点数的加减运算一律采用补码，其特点是阶码运算和尾数运算分开进行，具体步骤如下： 1.对阶 对阶的目的是使两个操作数的小数点位置对齐，即使两个数的阶码相等 对阶的步骤是：先求阶差，然后按小阶向大阶看齐的原则，将阶码小的尾数右移一位，同时阶 $+1$，直到两个数的阶码相等为止 要注意的是，在进行尾数右移时，舍弃掉有效位会产生误差，影响计算精度 2.尾数求和 在对阶后，将对阶的尾数按定点数加减运算规则进行计算 关于定点数加减法的运算规则具体见：定点数的表示与加减运算 3.规格化 以双符号位为例，当尾数大于 $0$ 时，其补码规格化形式为： [S]_补 = 00.1xx...x当尾数小于 $0$ 时，其补码规格化形式为： [S]_补 = 11.0xx...x可见，当尾数最高数值位与符号位不同时，即为规格化形式 规格化分为左规和右规两种： 左规：当尾数出现 $00.0xx…x$ 或 $11.1xx…x$ 时，需要进行左规，即尾数左移 $1$ 位，和的阶码 $-1$，直到尾数为 $00.1xx…x$ 或 $11.0xx…x$ 右规：当尾数求和结果溢出，即尾数出现 $10.xx…x$ 或 $01.xx…x$ 的形式时，需要进行右规，即尾数右移 $1$ 位，和的阶码 $+1$ 4.舍入 在对阶和右规的过程中，对尾数进行了舍入，这个过程可能会将尾数低位丢失，引起误差，影响精度 常见的舍入方法两种有： $0$ 舍 $1$ 入法：类似于十进制数运算中的四舍五入即在尾数右移时，被移去的最高数值位为 $0$，则舍去；被移去的最高数值位为 $1$，则在尾数的末位 $+1$，这样做可能会使尾数又溢出，此时需再做一次右规 恒置 $1$ 法：尾数右移时，不论丢掉的最高数值位是 $1$ 还是 $0$，都使右移后的尾数末位恒置 $1$，这种方法可能会使尾数变大，也可能会使尾数变小 5.溢出判断 与定点数加减法一样，浮点数加减运算最后一步也需判断溢出 在浮点数规格化中已指出，当尾数之和或尾数之差出现 $01.xx···x$或 $10.xx···x$ 时，并不表示溢出，只有将此数右规后，再根据阶码来判断浮点数运算结果是否溢出 而浮点数的溢出与否是由阶码的符号决定的，以双符号位补码为例，当阶码的符号位出现 $01$ 时，即阶码大于最大阶码，表示上溢，进入中断处理；当阶码的符号位出现 $10$ 时，即阶码小于最小阶码，表示下溢，按机器零处理 实际原理还是阶码符号位不同表示溢出，且真实符号位和高位符号位一致 实例设浮点数阶码、尾数用补码表示，采用双符号位，阶码位数为 $5$，尾数位数为 $7$ 已知 $x=2^7 \\times \\frac{29}{32}$，$y=2^5\\times \\frac{5}{8}$，求 $x+y$ 对于 $x$，将其转成二进制形式有： \\begin{align} x &= 2^7 \\times \\frac{29}{32} \\notag \\\\ &= 2^{00,111}\\times 00,11101 \\notag \\\\ &= 00,111;00,11101 \\notag \\end{align}对于 $y$，将其转成二进制形式有： \\begin{align} y &= 2^5\\times \\frac{5}{8} \\notag \\\\ &= 2^{00,101}\\times 00,10100 \\notag \\\\ &= 00,101;00,101000 \\notag \\end{align}首先进行对阶，$x$、$y$ 的阶码相减有： \\begin{align} \\Delta E &= 00,111-00,101 \\notag \\\\ &= 00,111+11,011 \\notag \\\\ &= 00,010 \\notag \\end{align}易得 $x$ 阶码比 $y$ 大 $2$，将 $y$ 的阶码 $+2$，尾数右移 $2$ 位，有： y = 00,111;00,00101之后，令对阶后的 $x$、$y$ 的尾数相加，有： 00,11101+00,00101=01,00010可以发现符号位为 $01$，需要进行右规 令尾数右移一位，阶码 $+1$，有： x+y=01,000;00,001此时，阶码符号位为 $01$，可以判断发生上溢，进入中断处理","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"定点数的表示与加减运算","slug":"computer-composition/05.定点数的表示与加减运算","date":"2019-03-07T11:53:00.000Z","updated":"2022-05-04T17:21:34.676Z","comments":true,"path":"notes/computer-composition/de65be17.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/de65be17.html","excerpt":"【定点数的表示】无符号数与有符号数计算机中，参与运算的机器数有两类：无符号数、有符号数","text":"【定点数的表示】无符号数与有符号数计算机中，参与运算的机器数有两类：无符号数、有符号数 无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值 有符号数：有符号数用 0 表示正号，用 1 表示负号，从而将符号数值化，并通常约定二进制的最高位为符号位，即将符号位放在有效数字的前面 机器数的定点表示根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示、浮点表示 定点表示即约定机器数中的小数点位置是固定不变的，小数点不再使用 . 表示，而是约定它的位置 理论上，小数点位置固定在哪一位都可以，但在计算机中通常采用两种简单的约定：将小数点的位置固定在数据的最高位之前，或者是固定在最低位之后 一般常称前者为定点小数，后者为定点整数 定点小数定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前 若数据 $X$ 的形式为 $X＝x_0x_1x_2…x_n$，则在计算机中的表示形式如下： 当 $x_0＝0$，$x_1 \\sim x_n$ 均为 $1$时，$X$ 为其所能表示的最大正数，真值等于 $1-2^{-n}”$ 当 $x_0＝1$，$x_1 \\sim x_n$ 均为 $1$时，$X$ 为其所能表示的最小负数，真值等于 $-(1-2^{-n})$ 其中，$x_0$ 为符号位，$x_1 \\sim x_n$ 是数值的有效部分，称为尾数 定点整数定点整数是纯整数，约定小数点位置在有效数值部分最低位之后 若数据 $X$ 的形式为 $X＝x_0x_1x_2…x_n$，则在计算机中的表示形式如下： 当 $x_0＝0$，$x_1 \\sim x_n$ 均为 $1$时，$X$ 为其所能表示的最大正数，真值等于 $2^{n}-1”$ 当 $x_0＝1$，$x_1 \\sim x_n$ 均为 $1$时，$X$ 为其所能表示的最小负数，真值等于 $-(2^{n}-1)$ 其中，$x_0$ 为符号位，$x_1 \\sim x_n$ 是数值的有效部分，称为尾数 符号扩展在计算机算术运算中，有时必须将采用给定位数表示的数转换成具有不同位数的某种表示形式 例如，某个程序需要将一个 $8$ 位数与另外一个 $32$ 位数相加，要想得到正确的结果，在将 $8$ 位数与 $32$ 位数相加之前，必须将 $8$ 位数转换成 $32$ 位数形式，这称为符号扩展 对于正数来说，将原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 $0$ 进行填充即可 对于负数来说，其符号扩展方法根据机器数的不同而不同 原码：表示负数的符号扩展方法与正数相同，但此时符号位为 $1$ 补码：原有形式的符号位移动到新形式的符号位上，对于整数，新表示形式的所有附加位都用 $1$ 进行填充，对于小数则用 $0$ 进行填充 反码：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 $1$ 进行填充 【定点数的运算】定点数的移位运算算术移位算式移位的对象是带符号数，在移位过程中符号位保持不变 对于正数，由于 $[x]_真 =[x]_原= [x]_补 =[x]_反$，因此移位后出现的空位均添加 $0$ 对于负数，由于原码、补码、反码表现形式不同，对移位后出现的空位的添补规则也不同 具体的补位规则见下表 逻辑移位逻辑移位将操作数当做无符号数看待，具体规则如下： 逻辑左移：高位移丢，低位补 $0$ 逻辑右移：低位移丢，高位补 $0$ 循环移位循环移位操作适用于将数据的低字节数据和高字节数据互换，具体分为带进位标志位 CF 的循环移位（大循环），和不带进位标志位 CF 的循环移位（小循环），其过程如下图所示 原码定点数的加减运算对于 $[X]_原 = x_s.x_1x_2…x_n$ 和 $[Y]_原 = y_s.y_1y_2…y_n$，在进行加减运算时，规则如下： 加法规则：判断符号位，若相同，则绝对值相加，结果符号位不变；若不同，则令绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同 减法规则：两原码表示的数相减，首先将减数符号取反，然后令被减数与符号取反后的减数进行原码加法计算 补码定点数加减运算运算规则由于补码加减运算规则简单，因此在计算机中，多采用补码进行加减运算，其特点如下： 参加运算的两操作数均用补码表示 按二进制运算规则，逢二进一 符号位与数值位按同样规则一起运算，符号位产生的进位要丢弃，结果的符号位由运算得出 补码运算的结果亦为补码 具体运算规则如下： \\begin{align} [A+B]_补=[A]_补+[B]_补 \\quad mod\\: M\\\\ [A-B]_补=[A]_补+[-B]_补 \\quad mod\\: M \\end{align}取模运算是为了丢弃溢出位，当参与运算的数是定点小数时，$M=2$，当参与运算的数是定点整数时，$M=2^{n+1}$，$n+1$ 为机器字长 溢出溢出是指运算结果超过了数的表示范围 通常，称大于机器所能表示的最大正数为上溢，小于机器所能表示的最小负数为下溢 仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出，例如两个正数相加，而结果的符号位却为 $1$，又例如一个负数减去一个正数，结果的符号位却为 $0$ 补码定点数加减法运算判断溢出的方式有三种： 1.单符号位判断溢出 由于减法运算在计算机中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数符号相同，结果却与原操作数符号不同，就说明结果溢出 设 $A$ 的符号为 $A_s$，$B$ 的符号为 $B_s$，运算结果符号为 $S_s$，则溢出逻辑表达式为： V=A_sB_s\\overline{S_s}+\\overline{A_xB_s}S_s当 $V=1$ 时，说明结果溢出 2.双符号位判断溢出 双符号位又称模 $4$ 补码，当运算结果的两个符号位相同时，说明未溢出，当运算结果的两个符号位不同时，说明溢出，此时最高位符号位代表真正的符号 对于符号位 $S_{s1}$ 和 $S_{s2}$ 的各种情况如下： $S_{s1}S_{s2}=00$：结果为正数，未溢出 $S_{s1}S_{s2}=01$：出现正溢出 $S_{s1}S_{s2}=10$：出现负溢出 $S_{s1}S_{s2}=11$：结果为负数，未溢出 溢出逻辑表达式如下： V=S_{s1}\\oplus S_{s2}当 $V=1$ 时，说明结果溢出 3.单符号位根据进位判断溢出 若符号位的进位 $C_s$ 与最高数位 $C_1$ 相同时，说明未发生溢出 溢出逻辑表达式如下： V=C_s\\oplus C_1当 $V=1$ 时，说明结果溢出","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"原码、补码、反码与移码","slug":"computer-composition/04.原码、补码、反码与移码","date":"2019-03-07T05:27:00.000Z","updated":"2022-05-04T15:38:24.920Z","comments":true,"path":"notes/computer-composition/13382db3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/13382db3.html","excerpt":"【原码】原码是一种简单、直观的机器数表示法，用机器数的最高位表示该数的符号，其余各位表示数的绝对值 纯小数","text":"【原码】原码是一种简单、直观的机器数表示法，用机器数的最高位表示该数的符号，其余各位表示数的绝对值 纯小数纯小数的原码定义如下： [x]_原 = \\left\\{ \\begin{array}{rl} x, & 0\\leq x < 1 \\\\ 1-x = 1+|x|, & -1","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"计算机性能指标","slug":"computer-composition/03.计算机性能指标","date":"2019-03-03T09:36:22.000Z","updated":"2022-05-04T09:38:47.036Z","comments":true,"path":"notes/computer-composition/4277ef71.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/4277ef71.html","excerpt":"1.数据通路带宽 数据通路带宽是指数据总线一次所能并行传送信息的位数 一般说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同","text":"1.数据通路带宽 数据通路带宽是指数据总线一次所能并行传送信息的位数 一般说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同 2.机器字长 机器字长是指计算机进行一次定点整数运算所能处理的二进制数据的位数，通常与 CPU 的寄存器位数、加法器有关 机器字长一般等于内部寄存器的大小，字长越长数的表示范围越大，计算精度就越高，通常都选定为字节（Byte，8位）的整数倍 不同的计算机，字长可能不相同 3.主存容量 主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可以用 存储单元个数（字数）x 存储字长（例如 512K x 16位）来表示存储容量 其中，存储单元的个数即 MAR 的位数，存储字长即 MAR 的位数，表示可寻址范围的最大值 例如，MAR 为 $16$ 位，表示 $2^{16}＝65536$，即此存储体内有 $65536$ 个存储单元（可称作 $64K$ 内存），若 MDR 为 32 位，表示存储容量为 64K x 32位 4.吞吐量 吞吐量指系统在单位时间内处理请求的数量，它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备 这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期 5.响应时间 响应时间指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间 通常包括 CPU 时间（运行一个程序所花费的时间）、等待时间（用于磁盘访问、存储器访问、I／O操作、操作系统开销等时间） 6.主频与 CPU 时钟周期 主频，又称 CPU 时钟频率，其是机器内部主时钟的频率，是衡量机器速度的重要参数，通常以 MHz（兆赫兹）为单位，1Hz 表示每秒 1 次 CPU 时钟周期，即主频的倒数，其是 CPU 中最小的时间单位，每个动作至少需要一个时钟周期 对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快 执行一条指令所需的时钟周期数被称为 CPI（Clock cycle Per Instruction） 7.CPU 执行时间 CPU 执行时间，指运行一个程序所花费的时间 其计算公式如下： 执行时间＝ \\frac{时钟周期数}{主频}＝\\frac{指令条数\\times CPI}{主频}上式表明，CPU 的性能取决于主频、每条指令执行所用的时钟周期数、指令条数这三个因素 8.MIPS、MFLOPS、GFLOPS和TFLOPS MIPS（Million Instructions Per Second），即每秒执行多少百万条指令，计算公式如下： MIPS ＝ \\frac{指令条数}{执行时间 \\times 10^6} ＝ \\frac{主频}{CPI}MFLOPS（Mega Floating-point Operations Per Second），即每秒执行多少百万次浮点运算，计算公式如下： MFLOPS＝\\frac{浮点操作次数}{执行时间\\times 10^6}GFLOPS（Giga Floating-point Operations Per Second），即每秒执行多少十亿次浮点运算，计算公式如下： GFLOPS = \\frac{浮点操作次数}{执行时间 \\times 10^9}TFLOPS（Tera Floating-point Operations Per Second），即每秒执行多少万亿次浮点运算，计算公式如下： TFLOPS = \\frac{浮点操作次数}{执行时间 \\times 10^{12}}","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"冯诺依曼架构与硬件部件","slug":"computer-composition/02.冯诺依曼架构与硬件部件","date":"2019-03-03T07:23:56.000Z","updated":"2022-05-04T11:44:28.679Z","comments":true,"path":"notes/computer-composition/43a9bbae.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/43a9bbae.html","excerpt":"【冯诺依曼体系】冯诺依曼机冯诺依曼在研究 EDVAC 机时提出了存储程序的概念，该思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机统称为冯诺依曼机，其特点如下：","text":"【冯诺依曼体系】冯诺依曼机冯诺依曼在研究 EDVAC 机时提出了存储程序的概念，该思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机统称为冯诺依曼机，其特点如下： 硬件系统由运算器、存储器、控制器、输入设备、输出设备组成 指令与数据以同等地位存于存储器内，且可按地址寻访 指令与数据均以二进制码表示 指令由操作码和地址码组成，操作码表示操作的性质，地址码表示操作数在存储器中的位置 指令在存储器内按顺序存放，通常指令按顺序执行，在特定条件下，可根据运算结果或设定条件改变执行顺序 以运算器为中心，输入、输出设备通过运算器和存储器传送数据 现代计算机的组织结构在微处理器问世前，运算器与控制器分离，且存储器容量很小，故以运算器为中心，其他部件均通过运算器完成信息传递 随着微电子技术的进步，现代计算机已经发展为以存储器为中心，使 I/O 操作尽可能绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率 【计算机的功能部件】1.输入设备 输入设备的主要功能是将程序、数据以机器所能识别和接受的信息形式输入到计算机 常用的输入设备有键盘、鼠标、扫描仪、摄像机等 2.输出设备 输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出 常用的输出设备有显示器、打印机等 3.存储器 存储器是计算机的存储部件，用来存放程序和数据 存储器分为主存储器、辅助存储器，主存储器又称内存，CPU 能够直接访问，辅助存储器又称外存，用来帮助主存存储更多信息，其中的内容必须调入主存后才可被 CPU 访问 主存由许多存储单元组成，每个存储单元包含若干存储元件，每一元件存储一位二进制代码，因此每一存储单元可存储一连串的二进制代码，这串代码被称为存储字，存储字的位数被称为存储字长，其是一个字节（8 bit）或字节的二次幂整数倍 同时，主存是按存储单元地址进行存取的，这种存取方式被称为按地址存取 主存由地址寄存器（MAR）、数据寄存器（MDR）、存储体、时序控制逻辑四部分组成 MAR：存放访存地址，以便于主存进行寻址访问，在经过地址译码后即可找到所选的存储单元，其位数对应着存储单元的个数，长度与控制器的 PC 长度相等 MDR：主存和其他部件的中介机构，用于暂存存储器中要读写的信息，其位数与存储字长相当，一般为字节的二次幂整数倍 时序控制逻辑：产生存储器操作所需的各种时序信号 4.运算器 运算器是计算机的执行部件，用于对数据进行加工处理，完成算术运算和逻辑运算 运算器的核心是算术逻辑单元 ALU，同时还包含若干通用寄存器，用于暂存操作数和中间结果，如：累加器 ACC、乘商寄存器 MQ、操作数寄存器 X、变址寄存器 IX、基址寄存器 BR、程序状态寄存器 PSW 等 5.控制器 控制器是计算机的指挥中心，其由程序计数器 PC、指令寄存器 IR、控制单元 CU 组成 PC：存放当前要执行指令的地址，可以自动 $+1$ 以形成下一条指令的地址，与主存的 MAR 间有一条直接通路 IR：存放当前指令，内容来自主存的 MDR，指令中的操作码 OP(IR) 会送至 CU，以分析指令并发出各种微操作命令序列，地址码 Ad(IR) 会送往 MAR 来获取操作数 【计算机工作过程】计算机的工作过程分为以下几个步骤。 把程序和数据装入到主存储器中 从程序的起始地址运行程序 用程序的首地址从存储器中取出第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成这条指令功能，并计算下一条指令的地址 用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止，每一条指令都是在取指、译码和执行的循环过程中完成的 下面以取数指令（将指令地址码指示的存储单元中的操作数取出后送至运算器的 ACC）为例，其信息流程如下： 取指令：PC → MAR → M → MDR → IR 分析指令：OP(IR) → CU 执行指令：Ad(IR) → MAR → M → MDR → ACC 此外，每取完一条指令，还必须为取下条指令作准备，形成下一条指令的地址，即：(PC)＋1 【计算机系统的多级层次结构】现代计算机是一个硬件与软件组成的综合体，由于面对的应用范围越来越广，所以必须有复杂的系统软件和硬件的支持 由于软件、硬件的设计者和使用者都从不同的角度，以及各种不同的语言对待同一个计算机系统，因此，他们各自看到的计算机系统的属性及对计算机系统提出的要求也就不一样 计算机系统的多级层次结构，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统 关于计算机系统层次结构的分层方式，目前一般分为五层： 第一层：微程序机器层，一个实在的硬件层，由机器硬件直接执行微指令 第二层：传统机器语言层，一个实际的机器层，由微程序解释机器指令系统 第三层：操作系统层，由操作系统程序实现 第四层：汇编语言层，为用户提供一种符号化的语言，借此可编写汇编语言源程序，这一层由汇编程序支持和执行 第五层：高级语言层，是面向用户的，为方便用户编写应用程序而设置的，该层由各种高级语言编译程序支持和执行 在高级语言层之上，还可以有应用层，由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等 通常把没有配备软件的纯硬件系统称为裸机，第三到第五层称为虚拟机，简单来说，就是软件实现的机器 层次之间的关系紧密，下层是上层的基础，上层是下层的扩展，但随着超大规模集成电路技术的不断发展，部分软件功能也能由硬件来实现，因而软硬件交界面的划分也不是绝对的","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"计算机发展历程","slug":"computer-composition/01.计算机发展历程","date":"2019-03-03T06:59:00.000Z","updated":"2022-05-04T09:12:29.418Z","comments":true,"path":"notes/computer-composition/8d4c152b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/computer-composition/8d4c152b.html","excerpt":"【发展历程】自 1946 年世界上第一台电子数字计算机 ENIAC（Electronic Numerical Integrator And Computer）问世以来，计算机发展已经经历了四代 第一代计算机：电子管时代","text":"【发展历程】自 1946 年世界上第一台电子数字计算机 ENIAC（Electronic Numerical Integrator And Computer）问世以来，计算机发展已经经历了四代 第一代计算机：电子管时代 自 1946 年到 1957 年，计算机的逻辑元件采用电子管，主存采用延迟线或者磁鼓来存储信息，使用机器语言进行编程，每秒运算几千到几万次 具有容量小、体积大、成本高、运算速度低的特点 第二代计算机：晶体管时代 自 1958 到 1964 年，计算机的逻辑元件采用晶体管，主存采用磁芯存储器来存储信息，软件开始使用 FORTRAN 等高级语言进行编程，同时有了操作系统的雏形，运算速度提高到每秒几万到几十万次 第三代计算机：中小规模集成电路时代 自 1965 到 1971 年，计算机的逻辑元件开始采用中小规模集成电路，半导体存储器开始取代磁芯存储器，高级语言发展迅速，操作系统也进一步发展，出现了分时操作系统 第四代计算机：超大规模集成电路时代 自 1972 年至今，计算机的逻辑元件逐步采用大规模集成电路和超大规模集成电路，并产生了微处理器，并行、流水线、高速缓存、虚拟存储器等概念逐步应用到计算机中 【计算机分类与发展方向】从数据表示来说，计算机可分为模拟计算机、数字计算机两类： 模拟计算机：用一种连续变化的模拟量作为被运算的对象的计算机，其以相似原理、并行计算为基础，计算速度快，但灵活性很差 数字计算机：以数字形式的量值在机器内部进行运算和存储的计算机，数的表示常采用二进制，能够高速地进行大量数值计算 依据效率、速度、价格、适应性等因素，数字计算机又可分为专用计算机、通用计算机两类： 专用计算机：为了解决某一特定问题而设计制造的计算机，结构简单、速度快、可靠性高 通用计算机：通用计算机适用于科学计算、数据处理、过程控制等，与专用计算机相比，其结构复杂、价格昂贵，但其适用性较广 通用计算机又可分为巨型机、大型机、中型机、小型机、微型机、单片机，它们的体积、功耗、性能、数据存储量、指令系统的复杂程度、价格依次递减 此外，按照指令与数据流，计算机可划分为以下四类： 单指令流与单数据流系统（SISD）：传统的冯诺依曼体系结构 单指令流与多数据流系统（SIMD）：阵列处理器、向量处理器系统 多指令流与单数据流系统（MISD）：实际上不存在 多指令流与多数据流系统（MIMD）：多处理器系统、多计算机系统 目前来说，计算机的发展趋势两极分化，微型计算机向着微型化、网络化、高性能、多用途方向发展，巨型计算机向着巨型化、超高速、智能化、并行处理方向发展 【计算机软件的分类】软件按其功能分类可以分为系统软件和应用软件 系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用，常见的有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等 应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等 【计算机语言】计算机语言指用于人与计算机之间通讯的语言，分为以下三类： 机器语言：二进制代码语言，需要编程人员记忆每一条指令的二进制编码，是计算机唯一可以直接识别和执行的语言 汇编语言：用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解，汇编语言的程序必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行 高级语言：如 C、C＋＋、Java 等，更多地是为了方便程序设计人员写出解决问题的处理方案和解题过程的程序，通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或者直接由高级语言程序翻译成机器语言程序","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"计算机组成","slug":"notes/computer-composition","permalink":"https://alex-mcavoy.github.io/categories/notes/computer-composition/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"计算机组成","slug":"computer-composition","permalink":"https://alex-mcavoy.github.io/tags/computer-composition/"}],"author":"Alex_McAvoy"},{"title":"Dijkstra 算法","slug":"graph/03.short-path/03.Dijkstra算法","date":"2019-02-12T11:36:24.000Z","updated":"2021-09-09T13:32:44.618Z","comments":true,"path":"oi-acm/graph/short-path/4b5b9f66.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/short-path/4b5b9f66.html","excerpt":"【基本思想】Dijkstra 算法是贪心的蓝白点思想，其将点分为两类，一类是已确定最短路径的白点，一类是未确定最短路径的蓝点 求一个点的最短路径，就是把这个点由蓝点变为白点，从起点到蓝点的最短路径上的中转点在这个时刻只能是白点","text":"【基本思想】Dijkstra 算法是贪心的蓝白点思想，其将点分为两类，一类是已确定最短路径的白点，一类是未确定最短路径的蓝点 求一个点的最短路径，就是把这个点由蓝点变为白点，从起点到蓝点的最短路径上的中转点在这个时刻只能是白点 初始时，将起点到终点的距离标记为 $0$，而后进行 $n$ 次循环，每次找出一个到起点距离 $dis[u]$ 最短的点 $u$ ，将它从蓝点变为白点，随后枚举所有白点 $v_i$，如果以此白点为中转到达蓝点 $v_i$ 的路径 $dis[u]+w[u][v_i]$ 更短的话，这将它作为 $v_i$ 的更短路径（此时还不能确定是不是 $v_i$ 的最短路径） 以此类推，每找到一个白点，就尝试用它修改其他所有蓝点，中转点先于终点变成白点，故每一个终点一定能被它的最后一个中转点所修改，从而求得最短路径 【算法分析】以下图为例 算法开始时，作为起点的 dis[1]=0，其他的点 dis[i]=INF 第一轮循环找到 dis[1] 最小，将 $1$ 变为白点，对所有蓝点进行修改，使得：dis[2]=2，dis[3]=4，dis[4]=7 此时，dis[2]、dis[3]、dis[4] 被它的最后一个中转点 $1$ 修改了最短路径 第二轮循环找到 dis[2] 最小，将 $2$ 变成白点，对所有蓝点进行修改，使得：dis[3]=3、dis[5]=4 此时，dis[3]、dis[5] 被它的最后一个中转点 $2$ 修改了最短路径 第三轮循环找到 dis[3] 最小，将 $3$ 变成白点，对所有蓝点进行修改，使得：dis[4]=4 此时，dis[4] 被它的最后一个中转点 $3$ 修改了最短路径，但发现以 $3$ 为中转不能修改 $5$，说明 $3$ 不是 $5$ 的最后一个中转点 接下来两轮循环将 $4$、$5$ 也变成白点 循环结束，所有点的最短路径均可求出 【实现】123456789101112131415161718192021222324252627282930313233343536373839404142int dis[N]; //单源最短距离int G[N][N]; //邻接矩阵bool vis[N]; //表示dis[i]是否已经计算完void dijkstra(int n, int s) &#123; //简化版，不可处理重边 for (int i = 1; i &lt;= n; i++) &#123; int x; //x标记当前最短距离的点 int min_dis = INF; //记录当前最小距离 for (int y = 1; y &lt;= n; y++) &#123; if (!vis[y] &amp;&amp; min_dis &gt;= dis[y]) &#123; x = y; min_dis = dis[x]; &#125; &#125; vis[x] = true; for (int y = 1; y &lt;= n; y++) dis[y] = min(dis[y], dis[x] + G[x][y]); &#125;&#125;int main() &#123; memset(dis, INF, sizeof(dis)); memset(vis, false, sizeof(vis)); int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y, dis; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;dis); G[x][y] = dis; G[y][x] = dis; &#125; int start; scanf(\"%d\", &amp;start); dijkstra(n, start); for (int i = 1; i &lt;= n; i++) printf(\"%d\\n\", dis[i]); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"最短路","slug":"oi-acm/graph/short-path","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/short-path/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"最短路","slug":"short-path","permalink":"https://alex-mcavoy.github.io/tags/short-path/"}],"author":"Alex_McAvoy"},{"title":"Floyd 算法","slug":"graph/03.short-path/02.Floyd算法","date":"2019-02-12T04:36:24.000Z","updated":"2021-09-09T13:16:04.217Z","comments":true,"path":"oi-acm/graph/short-path/1f96885c.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/short-path/1f96885c.html","excerpt":"【基本思想】Floyd 算法是基于动态规划思想的求解单源最短路的算法，其基本思想如下： 递推产生一个 $n$ 阶方阵序列：","text":"【基本思想】Floyd 算法是基于动态规划思想的求解单源最短路的算法，其基本思想如下： 递推产生一个 $n$ 阶方阵序列： A^{(-1)},A^{(0)},..,A^{(k),..,A^{(n-1)}}其中 $A^{k}[i][j]$ 代表从点 $v_i$ 到点 $v_j$ 的路径长度，$k$ 为绕行第 $k$ 个顶点的运算步骤 初始时，对任意两点 $v_i$ 与 $v_j$，若它们间存在边，则以此边上的权值作为两点最短路；若他们间不存在边，以一个极大数 INF 作为两点最短路，代表不可达 之后，逐步尝试在原路径中加入点 $k$，作为中间结点，若增加中间结点后，新路径路径长度比原路径路径长度减小，则用新路径替代原路径，即： A^{k}[i][j]=min\\{A^{k-1}[i][j],A^{k-1}[i][k]+A^{k-1}[k][j] \\}【算法分析】以下图为例 初始时，邻接矩阵为 A^{(-1)}=\\begin{bmatrix} 0 & 6 & 13 \\\\ 10 & 0 & 4 \\\\ 5 & INF & 0 \\end{bmatrix}第一次选择 $0$ 号点作为中间结点，有： A^{(-1)}[2][1]>A^{-1}[2][0]+A^{-1}[0][1]=11令 $A^{0}[2][1]=11$，进行更新，更新后有： A^{(0)}=\\begin{bmatrix} 0 & 6 & 13 \\\\ 10 & 0 & 4 \\\\ 5 & 11 & 0 \\end{bmatrix}第二次选择 $1$ 号点作为中间结点，有： A^{(0)}[0][2]>A^{0}[0][1]+A^{0}[1][2]=10令 $A^{1}[0][2]=10$，进行更新，更新后有： A^{(1)}=\\begin{bmatrix} 0 & 6 & 10 \\\\ 10 & 0 & 4 \\\\ 5 & 11 & 0 \\end{bmatrix}第三次选择 $2$ 号点作为中间结点，有： A^{(1)}[1][0]>A^{1}[1][2]+A^{1}[2][0]=9令 $A^{2}[1][0]=9$，进行更新，更新后有： A^{(2)}= \\begin{bmatrix} 0 & 6 & 10 \\\\ 9 & 0 & 4 \\\\ 5 & 11 & 0 \\end{bmatrix}【实现】123456789101112131415161718192021222324252627282930#define INF 0x3f3f3f3fint G[N][N]; //邻接矩阵bool visit[N]; //访问数组int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); //n个点m条边 //邻接矩阵初始化 for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) G[i][j] = INF; //建图 for (int i = 1; i &lt;= m; i++) &#123; int x, y, w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); if (w &lt; G[x][y]) &#123; G[x][y] = w; G[y][x] = w; &#125; &#125; for (int k = 1; k &lt;= n; k++) //枚举中间点 for (int i = 1; i &lt;= n; i++) //枚举起点 for (int j = 1; j &lt;= n; j++) //枚举终点 G[i][j] = min(G[i][j], G[i][k] + G[k][j]); printf(\"%d\\n\", G[1][n]); //从起点1到起点n的最短路长度 return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"最短路","slug":"oi-acm/graph/short-path","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/short-path/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"最短路","slug":"short-path","permalink":"https://alex-mcavoy.github.io/tags/short-path/"}],"author":"Alex_McAvoy"},{"title":"最短路问题","slug":"graph/03.short-path/01.最短路问题","date":"2019-02-11T09:21:24.000Z","updated":"2021-09-09T13:05:56.401Z","comments":true,"path":"oi-acm/graph/short-path/6bbbc5e9.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/short-path/6bbbc5e9.html","excerpt":"最短路是图论中十分常见的一个问题，对于图 $G(V,E)$，从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u,v)$ 为从 $u$ 到 $v$ 的任何路径中最小的边权和 最短路可分为以下两种： 单源最短路：图中某一顶点到其他各顶点的最短路 全源最短路：图中每个顶点间的最短路径","text":"最短路是图论中十分常见的一个问题，对于图 $G(V,E)$，从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u,v)$ 为从 $u$ 到 $v$ 的任何路径中最小的边权和 最短路可分为以下两种： 单源最短路：图中某一顶点到其他各顶点的最短路 全源最短路：图中每个顶点间的最短路径 求解最短路径的算法都依赖于一条性质：两点间的最短路包含了路径上其他顶点间的最短路 对于单源最短路和全源最短路，其基本求解算法如下： Dijkstra 算法：求解单源最短路，$O(|E|+|V|log|V|)$ Bellman-Ford 算法：求解单源最短路，适用于带负权值的图，$O(|V||E|)$ SPFA 算法：求解单源最短路，Bellman-Ford 的优化算法 Floyd 算法：求解全源最短路，利用动态规划思想，$O(|V|^3)$ Johnson 算法：求解全源最短路，基于 Dijkstra 算法，$O(|V||E|+|V|^2log|V|)$","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"最短路","slug":"oi-acm/graph/short-path","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/short-path/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"最短路","slug":"short-path","permalink":"https://alex-mcavoy.github.io/tags/short-path/"}],"author":"Alex_McAvoy"},{"title":"仪式感","slug":"ego/01.仪式感","date":"2019-02-02T15:38:00.000Z","updated":"2021-09-22T08:08:49.613Z","comments":true,"path":"essay/ego/5d203459.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/ego/5d203459.html","excerpt":"睡不着的夜晚，无非是两个原因，一个是咖啡因作祟，另一个则是因为某些原因，想起了某些无法释怀的人或事。 谁没有过失眠呢？不管是因为咖啡因或是心事烦躁，总归会有那么几次，望着天花板发呆久久不能入眠的夜晚。 似乎我们苦苦追求的某些东西，其实并没有唯一正确的答案？那些人之常情，其实也只是人之常情罢了？如果一辈子都没有烦恼，会不会又过的太过苍白？到底，人就是人，都有各自的悲欢离合。","text":"睡不着的夜晚，无非是两个原因，一个是咖啡因作祟，另一个则是因为某些原因，想起了某些无法释怀的人或事。 谁没有过失眠呢？不管是因为咖啡因或是心事烦躁，总归会有那么几次，望着天花板发呆久久不能入眠的夜晚。 似乎我们苦苦追求的某些东西，其实并没有唯一正确的答案？那些人之常情，其实也只是人之常情罢了？如果一辈子都没有烦恼，会不会又过的太过苍白？到底，人就是人，都有各自的悲欢离合。 不管过去的这段时间经历了什么，的确是需要一些仪式感，来去确认自己是存在过的。 不如听些音乐吧。你对自己说。 晚安。","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Ego","slug":"essay/ego","permalink":"https://alex-mcavoy.github.io/categories/essay/ego/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Ego","slug":"ego","permalink":"https://alex-mcavoy.github.io/tags/ego/"}],"author":"Alex_McAvoy"},{"title":"二叉排序树 BST","slug":"data-structure/10.bst-avl/01.bst/01.二叉排序树BST","date":"2018-11-11T14:17:03.000Z","updated":"2021-09-22T12:04:04.228Z","comments":true,"path":"oi-acm/data-structure/bst-avl/bst/317052a9.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/bst-avl/bst/317052a9.html","excerpt":"【结构】二叉排序树（Binary Sort Tree，BST），又称二叉搜索树（Binary Search Tree），属于数据结构中的一类，在需要经常进行查找的情景中，该数据结构常被使用，在一般情况下，查询效率比链表结构要高 二叉排序树或是一棵空树，或是一棵具有以下性质的二叉树：","text":"【结构】二叉排序树（Binary Sort Tree，BST），又称二叉搜索树（Binary Search Tree），属于数据结构中的一类，在需要经常进行查找的情景中，该数据结构常被使用，在一般情况下，查询效率比链表结构要高 二叉排序树或是一棵空树，或是一棵具有以下性质的二叉树： 若左子树非空，则左子树上的所有结点值均小于根结点值 若右子树非空，则右子树上的所有结点值均大于根结点值 左、右子树分别也是一棵二叉排序树 根据上述定义可以看出，对于二叉排序树来说，左子树结点值 $&lt;$ 根结点值 $&lt;$ 右子树结点值 因此，当对二叉排序树进行中序遍历时，可以得到一个递增的有序序列 值得注意的是，在二叉排序树中，要求任意两个结点值不相同 【查找】二叉排序树的查找，是从根结点开始，沿着某个分支逐渐向下比较的过程 如果二叉排序树非空，那么先将给定元素 elem 与根结点 root 的值比较，具体过程如下： 若 elem == root-&gt;data，查找成功 若 elem &lt; root-&gt;data，在 root 的左子树上进行查找 若 elem &gt; root-&gt;data，在 root 的右子树上进行查找 上述过程一直持续到 elem 被找到或者待查找的子树为空，若待查找的子树为空，则查找失败 值得注意的是，当查找失败时，恰好找到了以 elem 为键值的新结点在二叉排序树中的插入位置 12345678910BSTNode *searchBST(BSTree root, int elem) &#123; //查找elem所在结点 if (root == NULL) return NULL; if (root-&gt;data == elem) return root; if (elem &lt; root-&gt;data) return searchBST(root-&gt;lchild, elem); if (elem &gt; root-&gt;data) return searchBST(root-&gt;rchild, elem);&#125; 【插入】二叉排序树是一种动态树表，其树的结构通常不是一次生成的，而是在查找过程中，发现不存在相应结点时，进行插入的 向二叉排序树中插入一个元素 elem 的过程如下： 若 root 是空树，则将 elem 作为根节点插入 若 elem == root-&gt;data，则插入失败 若 elem &lt; root-&gt;data，则将 elem 插入到 root 的左子树中 若 elem &gt; root-&gt;data，则将 elem 插入到 root 的右子树中 如上图，在图中依次插入结点 $28$ 和 $58$，可以看出，插入的结点是作为叶结点插入到二叉排序树中的 123456789101112131415bool insertBST(BSTree &amp;root, int elem) &#123; //插入elem if (root == NULL) &#123; root = (BSTree)malloc(sizeof(BSTNode)); root-&gt;data = elem; root-&gt;lchild = NULL; root-&gt;rchild = NULL; return true; &#125; if (elem == root-&gt;data) return false; if (elem &lt; root-&gt;data) insertBST(root-&gt;lchild, elem); if (elem &gt; root-&gt;data) insertBST(root-&gt;rchild, elem);&#125; 【构造】从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置，本质上，就是不断将元素插入到二叉排序树中 12345void creatBST(BSTree &amp;root, int elems[], int n) &#123; //构造二叉排序树 root = NULL; for (int i = 0; i &lt; n; i++) insertBST(root, elems[i]);&#125; 【删除】在二叉排序中，在删除一个结点时，由于删除的可能是叶结点，也有可能是分支结点，因此在删除时，需要重新修改指针，使得在删除结点后，仍能保持二叉排序树的特性 对于二叉排序树的删除操作，可以分为以下三种情况来处理： 1）待删除结点为叶结点 如下图，待删除结点 p 为叶结点，可以直接将结点 p 的父结点的相应指针域改为空即可，即有：f-&gt;lchild 2）待删除结点只有一棵左子树或右子树 如下图，待删除结点 p 只有一棵左子树 pl 或右子树 pr 时，将子树替换为待删除结点 p 的父结点 f 的子树即可，即有：f-&gt;lchild = p-&gt;lchild 或 f-&gt;rchild = p-rchild 3）待删除结点既有左子树又有右子树 如下图，待删除结点 p 既有左子树 pl 又有右子树 pr，那么就寻找该二叉排序树的中序序列中 p 的直接后继或直接前驱来替换结点 p 然后再从树中删除这个被替换的结点，从而将删除情况转换成了情况 1）或情况 2） 1234567891011121314151617181920212223242526272829303132333435363738394041void deleteBST(BSTree p, BSTree f) &#123; //删除结点p if (p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL) &#123; // p是叶结点 if (f-&gt;lchild == p) // p是f的左孩子 f-&gt;lchild = NULL; else // p是f的右孩子 f-&gt;rchild = NULL; free(p); return; &#125; if (p-&gt;rchild == NULL) &#123; // p只有左子树 if (f-&gt;lchild == p) // p是f的左孩子 f-&gt;lchild = p-&gt;lchild; else // p是f的右孩子 f-&gt;rchild = p-&gt;lchild; free(p); return; &#125; if (p-&gt;lchild == NULL) &#123; // p只有右子树 if (f-&gt;lchild == p) // p是f的左孩子 f-&gt;lchild=p-&gt;rchild; else // p是f的右孩子 f-&gt;rchild=p-&gt;rchild; free(p); return; &#125; if (p-&gt;lchild != NULL &amp;&amp; p-&gt;rchild != NULL) &#123; //p左右子树均不空 f=p; BSTNode *s=p-&gt;rchild; while (s-&gt;lchild != NULL) &#123; //查找最左下结点 f=s; s=s-&gt;lchild; &#125; p-&gt;data=s-&gt;data; if (f == p) //特殊情况 p-&gt;rchild=s-&gt;rchild; else //一般情况 f-&gt;lchild=s-&gt;rchild; free(p); return; &#125;&#125; 【判定】对于二叉排序树来说，其中序遍历序列为一递增有序序列 因此，对于给定的二叉树进行中序遍历，若其始终能保持前一个值比后一个值小，则说明该二叉树为一个二叉排序树 12345678910111213//调用时，pre初值为-0x3f3f3f3fbool judge(BSTree root, int pre) &#123; //二叉排序树判定 if (root == NULL) return true; bool lflag = judge(root-&gt;lchild, pre); //判左子树 if (!lflag) //左子树不是 return false; if (root-&gt;data &lt;= pre) //当前结点小于其前驱 return false; pre = root-&gt;data; bool rflag = judge(root-&gt;rchild, pre); //判右子树 return rflag;&#125; 【最大最小关键字】最大关键字在一棵二叉排序树中，最右下结点即为关键字最大的结点 1234567int getMaxKey(BSTree root) &#123; //求最大关键字 if (root == NULL) return -1; while (root-&gt;rchild != NULL) root = root-&gt;rchild; return root-&gt;data;&#125; 最小关键字在一棵二叉排序树中，最左下结点即为关键字最小的结点 1234567int getMinKey(BSTree root) &#123; //求最小关键字 if (root == NULL) return -1; while (root-&gt;lchild != NULL) root = root-&gt;lchild; return root-&gt;data;&#125; 【查找效率分析】时间复杂度二叉排序树的查找效率与二叉排序树的高度有关 在最坏情况下，构造二叉排序树的输入序列是有序的，会形成一个斜树，此时树的高度为 $n$，时间复杂度为 $O(n)$ 从查找过程来看，二叉排序树的查找与二分查找类似，但二分查找判定树唯一，则二叉排序树不唯一，这是因为相同关键字插入顺序的不同，可能会生成不同的二叉排序树 就维护表的有序性而言，二叉排序树无须移动结点，仅需修改指针即可完成插入与删除操作，时间复杂度为 $O(log_2n)$ 平均查找长度对于二叉排序树，其查找成功的 $ASL$ 为第 $i$ 个结点的层数和除以结点总个数 如上图，由序列 $\\{3, 1, 2, 5, 4\\}$ 构造的二叉排序树，有： ASL_{成功}=\\frac{1+2+2+3+3}{5}=2.2","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"二叉排序树&平衡树","slug":"oi-acm/data-structure/bst-avl","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/bst-avl/"},{"name":"二叉排序树","slug":"oi-acm/data-structure/bst-avl/bst","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/bst-avl/bst/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"二叉排序树&平衡树","slug":"bst-avl","permalink":"https://alex-mcavoy.github.io/tags/bst-avl/"},{"name":"二叉排序树","slug":"bst","permalink":"https://alex-mcavoy.github.io/tags/bst/"}],"author":"Alex_McAvoy"},{"title":"图的存储结构","slug":"basic/01.theory/06.图的存储结构","date":"2018-11-11T08:53:00.000Z","updated":"2021-09-25T08:40:00.223Z","comments":true,"path":"oi-acm/basic/theory/d96fe4f4.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/d96fe4f4.html","excerpt":"【邻接矩阵】结构图的邻接矩阵存储也称数组表示法，其方法是用一个一维数组存储图中的顶点，用一个二维数组存储图中的所有的边，存储顶点之间邻接关系的二维数组称为邻接矩阵","text":"【邻接矩阵】结构图的邻接矩阵存储也称数组表示法，其方法是用一个一维数组存储图中的顶点，用一个二维数组存储图中的所有的边，存储顶点之间邻接关系的二维数组称为邻接矩阵 设图 $G=(V,E)$ 具有 $n$ 个顶点，则其邻接矩阵是一个 $n*n$ 的方阵，定义为： G[i][j]=\\left\\{\\begin{matrix}1,(v_i,v_j)\\in E\\:\\:or\\:\\:\\in E \\\\ 0, (v_i,v_j)\\notin E\\:\\:and\\:\\:\\notin E \\end{matrix}\\right.若 $G$ 是网图，则有： G[i][j]=\\left\\{\\begin{matrix}w_{ij},(v_i,v_j)\\in E\\:\\:or\\:\\:\\in E \\\\ INF , (v_i,v_j)\\notin E\\:\\:and\\:\\:\\notin E \\end{matrix}\\right.其中 $w_{ij}$ 是边 $(v_i,v_j)$ 或弧 $&lt; v_i,v_j &gt;$ 上的权值，$INF$ 代表一极大的数，其大于所有边的权值 特点邻接矩阵存储图，其表示方式唯一，具有如下特点： 对于无向图的邻接矩阵，其第 $i$ 行或第 $i$ 列非零元素的个数为第 $i$ 个顶点的度 对于有向图的邻接矩阵，其第 $i$ 行非零元素的个数为第 $i$ 个顶点的出度，第 $i$ 列非零元素的个数为第 $i$ 个顶点的入度 对于图 $G(V,E)$ 的邻接矩阵 $A$，$A^n$ 的元素 $A^n[i][j]$ 为由点 $i$ 到点 $j$ 的长度为 $n$ 的路径的数目 无向图的邻接矩阵是对称矩阵，对于规模大的可以使用压缩存储的方式仅存储上三角或下三角矩阵 邻接矩阵对边的操作效率高，但对于稀疏图来说造成了极大的浪费，因此其只适用于存储点较少的图或稠密图 实现12345678910int G[N][N];void init(int n) &#123; memset(G, 0, sizeof(G)); //图的初始化 while (n--) &#123; int x, y, w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); //读入两个顶点序号及权值 G[x][y] = w; //对于不带权的图，可令g[x][y]=1 G[y][x] = w; //无向图的对称性 &#125;&#125; 【邻接表】结构邻接表是一种顺序存储与链接存储相结合的存储方法，类似于树的孩子链表表示法 对于图 $G$ 的每个顶点 $v_i$，将所有邻接于 $v_i$ 的顶点链成一个单链表，称为 $v_i$ 的边表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边，若图 $G$ 是一有向图，则称为 $v_i$ 的出边表 为方便对所有边表的头指针进行存储操作，使用顺序存储，这样，存储边表头指针的数组和存储顶点信息的数组构成了邻接表的表头数组，称为顶点表 顶点表结点由顶点域 pos 和指针域 firstEdge 构成，顶点域存放结点信息（一般为结点编号），指针域指向第一条邻接边的指针 边表结点由位置域 pos、数据域 dis 和指针域 next 构成，pos 指示邻接点（该边附着的另一个结点编号），数据域存放网图的边权，指针域指向下一条邻接边 特点对于邻接表的存储，其表示方式不唯一，具有如下特点： 若 $G(V,E)$ 为无向图，则存储空间为 $O(|V|+2|E|)$ 若 $G(V,E)$ 为有向图，则存储空间为 $O(|V|+|E|)$ 对于无向图的邻接表，顶点表结点 $i$ 的边表中结点个数为结点 $i$ 的度 对于有向图的邻接表，顶点表结点 $i$ 的边表结点个数为结点 $i$ 的出度，邻接表中所有编号为 $i$ 的边表结点个数为结点 $i$ 的入度 邻接矩阵对点的操作效率高，对于给定的结点，可以轻易的找出其所有邻接边，对不确定的边操作较为方便，可以很好的处理稀疏图 实现12345678910111213141516171819202122232425262728struct Edge &#123; //边表 int pos; //位置域，存放该顶点的邻接点在顶点表中的下标 int dis; //数据域，对于网图，增设一存取边上信息的域 Edge *next; //指针域，指向边表中下一结点&#125;;struct Node &#123; //顶点表 int pos; //顶点域，存放顶点信息 Edge *firstEdge; //指针域，指向边表中的第一个结点&#125; node[N];void init(int n, int m) &#123; for (int i = 0; i &lt; n; i++) &#123; //n个点 scanf(\"%d\", &amp;node[i].pos); node[i].firstEdge = NULL; &#125; for (int i = 0; i &lt; m; i++) &#123; //m条边 int x, y; scanf(\"%d%d\", &amp;x, &amp;y); //边所依附的两点编号 Edge *p; //边表结点 //添边x-&gt;y p-&gt;pos = y; p-&gt;next = node[x].firstEdge; node[x].firstEdge = p; //添边y-&gt;x p-&gt;pos = x; p-&gt;next = node[y].firstEdge; node[y].firstEdge = p; &#125;&#125; 邻接表与邻接矩阵的转换123456789101112131415161718192021222324252627282930313233struct Edge&#123; int pos; int dis; Edge *next;&#125;;struct Node &#123; int pos; Edge *firstEdge;&#125; node[N]; //邻接表int G[N][N]; //邻接矩阵int adListToAdMatrix(int n) &#123; //邻接表转邻接矩阵 for (int i = 0; i &lt; n; i++) &#123; //枚举邻接表中每个点 Edge *p = node[i].firstEdge; while (p != NULL) &#123; //枚举每个点的每条边 G[i][p-&gt;pos] = p-&gt;dis; p = p-&gt;next; &#125; &#125;&#125;void adMatrixToAdList(int n) &#123; //邻接矩阵转邻接表 for (int i = 0; i &lt; n; i++) //邻接表初始化 node[i].firstEdge = NULL; for (int i = 0; i &lt; n; i++) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; if (G[i][j] != 0) &#123; //边存在，头插法建边 Edge *p = (Edge *)malloc(sizeof(Edge)); p-&gt;pos = j; p-&gt;next = node[i].firstEdge; node[i].firstEdge = p; &#125; &#125; &#125;&#125; 【前向星与链式前向星】前向星对于邻接矩阵来说，其方便但效率低，对于邻接表来说，其虽效率较高但实现较为困难 前向星是一种介于两者之间的较为中庸的结构，虽然好写，但效率较邻接表来说较低，且其不能直接用顶点进行定位，对重边不好处理，只能与邻接表一样遍历判重 前向星借助 STL 中的 vector 容器来储存边的方式来存储图，其通过读入每条边的信息，将边存放在数组中，把数组中的边按照起点顺序排序进行构造 常用于具有多个点或两点间具有多条弧的情况，其缺点是不能直接用顶点进行定位 1234567891011int n, m;vector&lt;int&gt; edge[N];void init() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; //边所依附的两点编号 edge[x].push_back(y);//添边x-&gt;y edge[y].push_back(x);//添边y-&gt;x &#125;&#125; 链式前向星由于借助 vector 实现的前向星的效率并不高，为此借助结构体来模拟链式结构，从而将其进行优化 在优化后，内存利用率高，效率也得到了极大的提升，在常见的图论问题中，链式前向星几乎可适用于所有的图，但其缺点也很明显，如操作复杂化、不好处理重边等 12345678910111213141516171819202122232425262728293031323334struct Edge &#123; int next; //下一条边的数组下标 int to; //该边的另一个顶点 int dis; //该边的权值&#125; edge[N];int n, m; //点数，边数int head[N]; //head[i]表示顶点i的第一条边的数组下标，-1表示顶点i没有边int tot; //边的条数即边序号void addEdge (int from, int to, int dis) &#123; edge[tot].dis = dis; //权值 edge[tot].to = to; //另一顶点 edge[tot].next = head[from];//同结点下该边的下一条边 head[from] = tot++; //结点from的第一条边&#125;int mian() &#123; memset(head, -1, sizeof(head)); tot = 0; for (int i = 0; i &lt; m; i++) &#123; int x, y, w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); addEdge(x, y, w); //添边x-&gt;y addEdge(y, x, w); //添边y-&gt;x &#125; //遍历从x出发的所有边 int x = 0; for (int i = head[x]; i != -1; i = edge[i].next) &#123; int y = edge[i].to; ... &#125; ... return 0;&#125; 【十字链表与邻接多重表】十字链表与邻接多重表也是图的一种存储方法，但由于操作复杂、内存利用率不高等因素常不被使用 十字链表十字链表是有向图的一种存储方法，其实质上是邻接表与逆邻接表的结合 顶点表结点由数据域 data ，入边表头指针firstIn ，出边表头指针 firstOut 构成， 其中， 数据域存放顶点信息（一般为点编号），入边表头指针指向以该顶点为终点的弧构成的链表中的第一个结点；出边表头指针指向以该顶点为始点的弧构成的链表中的第一个结点 边表结点由数据域 data、尾域tailPos 、头域 headPost、入边表指针域headLink、出边表指针域tailLink，其中数据域存放网图的边权，尾域为弧的起点在顶点表中的下标，头域为弧的终点在顶点表中的下标，入边表指针域指向终点相同的下一条边，出边表指针域指向起点相同的下一条边 headLink 为入边表指针域，指向终点相同的下一条边；tailLink 为出边表指针域，指向起点相同的下一条边 邻接多重表邻接多重表是无向图的一种存储方法，在用邻接表存储无向图时，每条边的两个顶点分别在以该边所依附的两个顶点的边表中，这种重复存储给图的某些操作带来不便，在其基础上有了邻接多重表，两者的差别仅在于同一条边在邻接表用两个结点表示，在邻接多重表用一个结点表示 顶点表结点由数据域 data、边表头指针 firstEdge 构成，其中数据域存放顶点信息（一般为结点编号），边表头指针指向第一条依附于该点的边 边表结点由数据域 data、标志域 mark 、位置域 iPos 与 jPos、位置指针域 iLink与 jLink 构成，其中数据域存放网图的边权，标志域用于标记该边是否被搜索过，位置域分别为某边依附的两结点在顶点表中的下标，位置指针域分别指向依附于结点 iPos 与 jPos 的下一条边","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"}],"author":"Alex_McAvoy"},{"title":"平衡二叉树 AVL","slug":"data-structure/10.bst-avl/02.avl/01.平衡二叉树AVL","date":"2018-11-05T13:17:03.000Z","updated":"2021-09-22T07:19:52.282Z","comments":true,"path":"oi-acm/data-structure/bst-avl/avl/4263f441.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/bst-avl/avl/4263f441.html","excerpt":"【结构】结构二叉树排序树 BST 的查找效率取决于二叉排序树的形态，而构造一棵形态均匀的二叉排序树与结点的插入次序有关，但结点的插入次序不是随人的意志决定的，这就要求找到一种动态平衡的方法，对于任意给定的关键码序列都能构造一棵形态均匀、平衡的二叉排序树，这种二叉排序树被称为平衡二叉树（Balance Binary Tree）","text":"【结构】结构二叉树排序树 BST 的查找效率取决于二叉排序树的形态，而构造一棵形态均匀的二叉排序树与结点的插入次序有关，但结点的插入次序不是随人的意志决定的，这就要求找到一种动态平衡的方法，对于任意给定的关键码序列都能构造一棵形态均匀、平衡的二叉排序树，这种二叉排序树被称为平衡二叉树（Balance Binary Tree） 平衡二叉树最早由 G. M. Adelson-Velsky 和 E. M. Landis 提出，因此，平衡二叉树常称为 AVL 树 AVL 树其或是一棵空的二叉排序树，或是满足如下性质的二叉排序树： 根结点的左子树和右子树深度最多差 $1$ 根结点的左子树和右子树也是平衡二叉树 平衡因子与最小平衡子树将平衡二叉树中某个结点的左右子树的深度之差称为平衡因子（Balance Factor），根据平衡二叉树的定义，平衡因子只可能取值 $-1,0,1$ 在平衡二叉树构造过程中，以距离插入结点最近的、平衡因子绝对值大于 $1$ 的结点为根的子树，称为最小不平衡子树（Minimal Unbalance Subtree） 【构造】基本思想构造平衡二叉树的基本思想是：在构造二叉排序树的过程中，每插入一个结点时，首先检查是否因结点插入而破坏了树的平衡性，若破坏了平衡性，则找出最小不平衡子树，在保持二叉排序树的特性前提下，调整最小不平衡子树中各结点的位置，进行相应旋转，使其成为新的平衡子树 设结点 $A$ 为最小平衡子树的根结点，对该子树进行平衡调整归纳起来有以下四种情况： LL 型：右单旋转，顺时针旋转一次 RR 型：左单旋转，逆时针旋转一次 LR 型：先左后右双旋转，逆时针旋转一次，再顺时针旋转一次 RL 型：先有后左双旋转，顺时针选择一次，再逆时针旋转一次 在旋转时，规定旋转优先，即在以某结点为支撑点旋转时，令旋转方向一侧的子树不动 顺时针旋转时，旋转前为右子树，旋转后仍为右子树 逆时针旋转时，旋转前为左子树，旋转后仍为左子树 LL 型当新插入的结点，是插在结点 $A$ 的左孩子的左子树上，即为 LL 型 设结点 $B$ 是结点 $A$ 的左孩子，$B_L$、$B_R$ 分别为结点 $B$ 的左右子树，$A_R$ 为结点 $A$ 的右子树，且 $B_L$、$B_R$、$A_R$ 三棵子树的深度均为 $h$ 此时，将结点 $X$ 插入到结点 $B$ 的左子树 $B_L$ 上，导致结点 $A$ 的平衡因子由 $1$ 变为 $2$，从而使得以结点 $A$ 为根的子树失去了平衡 为了使树保持平衡，将支撑点由 $A$ 改为 $B$，相应的进行顺时针旋转，旋转后，结点 $A$ 及其右子树 $A_R$ 和结点 $B$ 的右子树 $B_R$ 发生冲突 根据旋转优先原则，即令结点 $A$ 成为 $B$ 的右孩子结点，结点 $B$ 的右子树 $B_R$ 成为结点 $A$ 的左子树 RR 型当新插入的结点，是插在结点 $A$ 的右孩子的右子树上，即为 RR 型 设结点 $B$ 是结点 $A$ 的右子树的根结点，$B_L$、$B_R$ 分别为结点 $B$ 的左右子树，$A_L$ 为结点 $A$ 的左子树，且 $B_L$、$B_R$、$A_R$ 三棵子树的深度均为 $h$ 此时，将结点 $X$ 插入到结点 $B$ 的右子树 $B_R$ 上，导致结点 $A$ 的平衡因子由 $-1$ 变为 $-2$，使得以结点 $A$ 为根的子树失去了平衡 为了使树保持平衡，将支撑点由 $A$ 改为 $B$，相应的进行逆时针旋转，旋转后，结点 $A$ 及其左子树 $A_L$ 和结点 $B$ 的左子树 $B_L$ 发生冲突 根据旋转优先原则，结点 $A$ 成为 $B$ 的左孩子结点，结点 $B$ 的左子树 $B_L$ 成为结点 $A$ 的右子树 LR 型当新插入的结点，是插在结点 $A$ 的左孩子的右子树上，即为 LR 型 设结点 $B$ 是结点 $A$ 的左子树的根结点，结点 $C$ 是结点 $B$ 的右子树的根节点，$A_R$ 为结点 $A$ 的右子树，$B_L$ 为结点 $B$ 的左子树，$C_L$、$C_R$ 分别为结点 $C$ 的左右子树，且 $B_L$、$A_R$ 两棵子树的深度为 $h$，$C_L$、$C_R$ 两棵子树的深度为 $h-1$ 此时，将结点 $x$ 插入到结点 $C$ 的左子树 $C_L$ 上，导致结点 $A$ 的平衡因子由 $1$ 变为 $2$，使得以结点 $A$ 为根的子树失去了平衡 为了使树保持平衡，需要旋转两次： 第一次旋转时，令根节点 $A$ 不动，调整结点 $A$ 的左子树，将支撑点由结点 $B$ 调整到结点 $C$ 处，相应的进行逆时针旋转，旋转后，结点 $B$ 及其左子树与结点 $C$ 的左子树 $C_L$ 发生冲突，按旋转优先原则，结点 $C$ 的左子树成为 $B$ 的右子树 第二次旋转时，将支撑点由结点 $A$ 调整到结点 $C$， 相应的进行顺时针旋转，旋转后，结点 $A$ 及其右子树 $A_R$ 与结点 $C$ 的右子树 $C_R$ 发生冲突，按旋转优先原则，结点 $C$ 的右子树成为结点 $A$ 的左子树 RL 型当新插入的结点，是插在结点 $A$ 的右孩子的左子树上，即为 RL 型 设结点 $B$ 是结点 $A$ 的右子树的根结点，结点 $C$ 是结点 $B$ 的左子树的根节点，$A_L$ 为结点 $A$ 的左子树，$B_R$ 为结点 $B$ 的右子树，$C_L$、$C_R$ 分别为结点 $C$ 的左右子树，且 $B_R$、$A_L$ 两棵子树的深度为 $h$，$C_L$、$C_R$ 两棵子树的深度为 $h-1$ 将结点 $x$ 插入到结点 $C$ 的右子树 $C_R$ 上，导致结点 $A$ 的平衡因子由 $-1$ 变为 $-2$，使得以结点 $A$ 为根的子树失去了平衡 为了使树保持平衡，需要旋转两次： 第一次旋转时，令根节点 $A$ 不动，调整结点 $A$ 的右子树，将支撑点由结点 $B$ 调整到结点 $C$ 处，相应的进行顺时针旋转，旋转后，结点 $B$ 及其右子树与结点 $C$ 的右子树 $C_R$ 发生冲突，按旋转优先原则，结点 $C$ 的右子树成为 $B$ 的左子树 第二次旋转时，将支撑点由结点 $A$ 调整到结点 $C$， 相应的进行逆时针旋转，旋转后，结点 $A$ 及其左子树 $A_R$ 与结点 $C$ 的左子树 $C_L$ 发生冲突，按旋转优先原则，结点 $C$ 的左子树成为结点 $A$ 的右子树 【查找】在平衡二叉树上进行查找的过程与二叉排序树相同，因此，在查找过程中，与给定值比较的关键字的个数不超过树的深度 假设以 $n_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数（平衡因子为 $1$），则有如下递推公式： \\left\\{ \\begin{aligned} n_0&=0 \\\\ n_1&=1 \\\\ n_h & = 1+n_{h-1}+n_{h-2} \\end{aligned} \\right.那么，含 $n$ 个结点的平衡二叉树的最大深度为 $O(log_2n)$","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"二叉排序树&平衡树","slug":"oi-acm/data-structure/bst-avl","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/bst-avl/"},{"name":"平衡二叉树","slug":"oi-acm/data-structure/bst-avl/avl","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/bst-avl/avl/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"二叉排序树&平衡树","slug":"bst-avl","permalink":"https://alex-mcavoy.github.io/tags/bst-avl/"},{"name":"平衡二叉树","slug":"avl","permalink":"https://alex-mcavoy.github.io/tags/avl/"}],"author":"Alex_McAvoy"},{"title":"图的基本概念","slug":"basic/01.theory/05.图的基本概念","date":"2018-11-05T01:48:00.000Z","updated":"2021-09-25T08:37:55.708Z","comments":true,"path":"oi-acm/basic/theory/22bce5e7.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/22bce5e7.html","excerpt":"【图】图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：$G=(V,E)$，其中 $V$ 是非空有限集合，代表顶点，$E$ 是可以为空的有限集合，代表边 若顶点 $v_i$ 和 $ v_j$ 间的边没有方向，则称这条边为无向边，用无序偶对 $(v_i,v_j)$ 表示；若顶点 $v_i$ 和 $v_j$ 间的边有方向，则称这条边为有向边（弧），用有序偶对 $&lt; v_i,v_j &gt;$ 表示，其中 $v_i$ 称为弧头，$v_j$ 称为弧尾","text":"【图】图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：$G=(V,E)$，其中 $V$ 是非空有限集合，代表顶点，$E$ 是可以为空的有限集合，代表边 若顶点 $v_i$ 和 $ v_j$ 间的边没有方向，则称这条边为无向边，用无序偶对 $(v_i,v_j)$ 表示；若顶点 $v_i$ 和 $v_j$ 间的边有方向，则称这条边为有向边（弧），用有序偶对 $&lt; v_i,v_j &gt;$ 表示，其中 $v_i$ 称为弧头，$v_j$ 称为弧尾 在一个无向图中，对于任意两个顶点 $v_i$ 和顶点 $v_j$，若存在边 $(v_i,v_j)$，则称顶点 $v_i$ 和顶点 $v_j$ 互为邻接点，同时称边 $(v_i,v_j)$ 依附于顶点 $v_i$ 和顶点 $v_j$ 在一个有向图中，对于任意两个顶点 $v_i$ 和顶点 $v_j$，若存在弧 $&lt; v_i,v_j &gt;$，则称顶点 $v_i$ 邻接到顶点 $v_j$，顶点 $v_j$ 邻接自顶点 $v_i$，同时称弧 $&lt; v_i,v_j &gt;$ 依附于顶点 $v_i$ 和顶点 $v_j$ 若图的任意两个顶点之间的边都是无向边，则称该图为无向图；若图的任意两个顶点之间的边都是有向边，则称该图为有向图 【基本术语】度 在无向图中，依附于顶点 $v$ 的边数称为顶点的度，记为 $TD(v)$，在 $n$ 个顶点 $m$ 条边的无向图中，所有点的度的和为 $2m$，且有：$TD(v)=ID(v)+OD(v)$ 在有向图中，以顶点 $v$ 为弧头的弧的数目称为顶点的入度，记为 $ID(v)$，在 $n$ 个顶点 $m$ 条边的有向图中，所有点的入度和为 $m$ 在有向图中，以顶点 $v$ 为弧尾的弧的数目称为顶点的出度，记为 $OD(v)$，在 $n$ 个顶点 $m$ 条边的有向图中，所有点的出度和为 $m$ 路径与回路 在无向图 $G=(V,E)$ 中，对于一个满足 $(v_{ij-1},v_{ij})\\in E(1\\leq j\\leq m)$的顶点序列 ${v_p=v_{i_0},v_{i_1},v_{i_2},…, v_{i_m}=v_q}$称为从顶点 $v_p$ 到顶点 $v_q$ 之间的路径，若 $G$ 是有向图，则 $G$ 的路径是有方向的 在路径序列中，起点和终点相同的路径称为回路（环） 在路径序列中，顶点不重复出现的路径称为简单路径 在路径序列中，除起点终点外，其余顶点不重复出现的回路称为简单回路 对于一个非带权图，路径上边的个数称为路径长度，对于一个带权图，路径上各边权的和称为路径长度 连通性 对于图 $G=(V,E)$ 和 $G’=(V’,E’)$，若 $V’\\subseteq V,E’\\subseteq E$，则称 $G’$ 为 $G$ 的子图，一个图可以有多个子图 在无向图中，如果从一个顶点 $v_i$ 到另一个顶点 $v_j(i≠j)$ 有路径，则称顶点 $v_i$ 和 $v_j$ 是连通的，如果图中任意两个顶点都是连通的，则称该图是连通图 对于无向图来说，非连通图的极大连通子图称为连通分量，其中，极大是指包括所有连通的顶点及这些顶点相关联的所有边 在有向图中，对图中任意一对顶点 $v_i$ 和 $v_j(i≠j)$，若从顶点 $v_i$ 到顶点 $v_j$ 和从顶点 $v_j$ 到顶点 $v_i$ 均有路径，则称该有向图是强连通图 对于有向图来说，非强连通图的极大强连通子图称为强连通分量，其中，极大是指包括所有连通的顶点及这些顶点相关联的所有边 对于一个具有 $n$ 个顶点的连通图 $G$ ，包含 $G$ 中全部顶点的一个极小连通子图称为生成树，其中，极小是指子图中只有一个入度为 $0$ 的点且其他点的入度均为 $1$，一个连通图的生成树可以有多个 在非连通图中，由每个连通分量都可以得到一棵生成树，这些连通分量的生成树就组成了一个非连通图的生成森林 对于 $n$ 个点的无向图 $G(V,E)$ 来说，要保证在任何情况下都是连通的，在最极端的情况下，$n-1$ 个顶点构成一个完全无向图，剩下一个点再加一条边后必然与该图构成一个连通图，即最少需要的边数为： \\frac{(n-1)(n-2)}{2}+1对于 $m$ 条边的非连通无向图 $G(V,E)$ 来说，最极端的情况下，由 $n$ 个顶点构成的完全图与一个独立的顶点构成，假设最少要 $n$ 个点，那么边数 $m$ 满足： m=\\frac{(n-1)(n-2)}{2}【特殊形态的图】 在一个图中，不存在顶点到其自身的边，且同一条边不重复，则称图为简单图 在一个无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图，其有 $\\frac{n*(n-1)}{2}$ 条边 在一个有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图，其有 $n*(n-1)$ 条边。 一个边数接近完全图的图称为稠密图，一个边数远远少于完全图的图称为稀疏图 对边赋予的有意义的数值量称为权（权值），边上带权的图，称为网（带权图），根据图是无向图或有向图，分为有向网图、无向网图","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"}],"author":"Alex_McAvoy"},{"title":"AOV 网与拓扑排序","slug":"graph/04.aov-topological-order/1.AOV网与拓扑排序","date":"2018-11-04T06:46:55.000Z","updated":"2021-09-12T13:59:05.827Z","comments":true,"path":"oi-acm/graph/aov-topological-order/d0fe14af.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/aov-topological-order/d0fe14af.html","excerpt":"【AOV 网】日常生活中，一项大的工程可以看作是由若干个子工程组成的集合，这些子工程之间必定存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始 用结点表示活动，用弧表示活动间优先关系的无权 DAG 图，被称为顶点活动网络（Activity On Vertex Network，AOV 网）","text":"【AOV 网】日常生活中，一项大的工程可以看作是由若干个子工程组成的集合，这些子工程之间必定存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始 用结点表示活动，用弧表示活动间优先关系的无权 DAG 图，被称为顶点活动网络（Activity On Vertex Network，AOV 网） 在 AOV 网中，有如下定义： 活动：子工程组成的集合，每个子工程即为一个活动 前驱活动：有向边起点的活动称为终点的前驱活动，只有当一个活动的前驱全部都完成后，这个活动才能进行 后继活动：有向边终点的活动称为起点的后继活动 源点：工程开始的结点，入度为 $0$ 汇点：工程结束的结点，出度为 $0$ 【拓扑序列】对于 AOV 网来说，其主要用于活动的依赖管理，因此，要对其求拓扑序列 拓扑序列是图的所有顶点的线性序列，且该序列满足以下两个条件： 每个顶点出现且仅出现一次 若存在一条从点 $A$ 到点 $B$ 的路径，那么在序列中，点 $A$ 出现在点 $B$ 前 在 AOV 网中，经过拓扑排序，即可得到拓扑序列，需要注意的是，拓扑序列并不唯一 此外，若一个有向图的顶点，无法排成一个拓扑序列，那么说明该有向图含有顶点数大于 $1$ 的强连通分量（存在环） 【拓扑排序】算法流程拓扑排序用于求 AOV 网的拓扑序列，其算法基本流程如下： 1）从 DAG 图中选择一个没有前驱的结点（入度为 $0$）输出 2）从图中删除该顶点，与所有以该顶点为起点的有向边 3）重复 1） 和 2） 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止 若算法结束后， DAG 图为空，说明求得的序列为以拓扑序列，否则图中必然存在环 若想求逆拓扑序列，只需要从没有后继的结点（出度为 $0$）开始即可 算法分析在整个拓扑排序的过程，要暂存入度为 $0$ 的结点，可以借助栈或队列来完成 以下图为例 开始时，只有 $A$ 入度为 $0$，令 $A$ 入栈，此时有： 栈中元素：$A$ 拓扑序列：$空$ 之后，令栈顶元素 $A$ 出栈，输出 $A$，$A$ 的后继节点 $B$、$C$ 入度减 $1$，相当于删除 $A$ 的所有关联边，此时有： 栈中元素：$空$ 拓扑序列：$A$ 有向图可以视为如下图中的结构，$B$、$C$ 入度均为 $0$，将 $B$、$C$ 依次入栈 此时，有： 栈中元素：$BC$（入栈顺序不唯一） 拓扑序列：$A$ 令栈顶元素 $C$ 出栈，输出 $C$，$C$ 的后继结点 $D$ 入度减 $1$，相当于删除 $C$ 的所有关联边，此时有： 栈中元素：$B$ 拓扑序列：$AC$ 有向图可以视为如下图中的结构，$B$、$C$ 入度均为 $0$，将 $B$、$C$ 依次入栈 再令栈顶元素 $B$ 出栈，输出 $B$，$B$ 的后继结点 $D$ 入度减 $1$，相当于删除 $B$ 的所有关联边，此时有： 栈中元素：$空$ 拓扑序列：$ACB$ 有向图可以视为如下图中的结构，$D$ 的入度为 $0$，令其入栈 最后，令栈顶元素 $D$ 出栈，再输出 $D$，有： 栈中元素：$空$ 拓扑序列：$ACBD$（不唯一） 【实现】AOV 网的判定当给出一个 $n$ 个点 $m$ 条边的有向图，若要判定该有向图是否是 AOV 网，也即判断图是否可以进行拓扑排序 一个有向图无法进行拓扑排序时只有一种情况：有向图中存在环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;int&gt; G[N];//G[i]表示i节点所指向的所有其他点int in[N]; //节点入度bool judgeTopSort (int n, int m) &#123; //判断该图是否可拓扑排序 stack&lt;int&gt; S; int cnt = 0; //记录可拆解的点数目 for (int i = 1; i &lt;= n; i++) if (in[i] == 0) //入度为0，入栈 S.push(i); while (!S.empty()) &#123; int x = S.top(); //取栈顶元素 S.pop(); cnt++; //可拆点数+1 for (int i = 0; i &lt; G[x].size(); i++) &#123; int y = G[x][i]; in[y]--; //入度减一 if (in[y] == 0) //入度为0，入栈 S.push(y); &#125; &#125; if (cnt == n) //AOV网点数等于图的点数，不存在环 return true; else //AOV网点数不等于图的点数，存在环 return false;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; memset(in, 0, sizeof(in)); for (int i = 1; i &lt;= n; i++) G[i].clear(); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); in[y]++; &#125; printf(\"%s\\n\", judgeTopSort(n, m) ? \"YES\" : \"NO\"); &#125; return 0;&#125; 输出任意一条拓扑序列当给出一 $n$ 个点 $m$ 条边的有向图时，要输出一个可行的点的拓扑序列，此时可根据上述的 AOV 网判定代码，修改后存储路径输出即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;int&gt; G[N];//G[i]表示i节点所指向的所有其他点int in[N]; //节点入度int path[N]; //存储路径bool topSort (int n, int m) &#123; //判断该图是否可拓扑排序 stack&lt;int&gt; S; int cnt = 0; //记录可拆解的点数目 for (int i = 1; i &lt;= n; i++) if (in[i] == 0) //入度为0，入栈 S.push(i); while (!S.empty()) &#123; int x = S.top(); //取栈顶元素 S.pop(); path[++cnt] = x; //存储可拆点 for (int i = 0; i &lt; G[x].size(); i++) &#123; int y = G[x][i]; in[y]--; //入度减一 if (in[y] == 0) //入度为0，入栈 S.push(y); &#125; &#125; if (cnt == n) //AOV网点数等于图的点数，不存在环 return true; else //AOV网点数不等于图的点数，存在环 return false;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; memset(in, 0, sizeof(in)); memset(path, 0, sizeof(path)); for (int i = 1; i &lt;= n; i++) G[i].clear(); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); in[y]++; &#125; if (topSort(n,m) &#123; for (int i = 1; i &lt;= n; i++) printf(\"%d \", path[i]); printf(\"\\n\"); &#125; else printf(\"No topology sequence exists.\") &#125; return 0;&#125; 输出按字典序最小或最大的拓扑序列拓扑序列可能不唯一，有时会要求输出字典序最小或字典序最大的拓扑序列 这时，就要借助优先队列，其大致思想是队列 Q 总是将当前在入度为 $0$ 的字典序最小或最大的结点优先取出，从而保证整体字典序最小或最大 下面给出输出字典序最小的拓扑序列的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;int&gt; G[N];//G[i]表示i节点所指向的所有其他点int in[N]; //节点入度int path[N]; //存储路径bool topSort (int n, int m) &#123; //判断该图是否可拓扑排序 priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q;//最小值先出列 int cnt = 0; //记录可拆解的点数目 for (int i = 1; i &lt;= n; i++) if (in[i] == 0) //入度为0，入队 Q.push(i); while (!Q.empty()) &#123; int x=Q.top();//队列首元素 Q.pop(); path[++cnt] = x; //存储可拆点 for (int i = 0; i &lt; G[x].size(); i++) &#123; int y = G[x][i]; in[y]--; //入度减一 if (in[y] == 0) //入度为0，入队 Q.push(y); &#125; &#125; if (cnt == n) //AOV网点数等于图的点数，不存在环 return true; else //AOV网点数不等于图的点数，存在环 return false;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; memset(in, 0, sizeof(in)); memset(path, 0, sizeof(path)); for (int i = 1; i &lt;= n; i++) G[i].clear(); while (m--) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); G[x].push_back(y); in[y]++; &#125; if (topSort(n,m) &#123; for (int i = 1; i &lt;= n; i++) printf(\"%d \", path[i]); printf(\"\\n\"); &#125; else printf(\"No topology sequence exists.\") &#125; return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"AOV网与拓扑排序","slug":"oi-acm/graph/aov-topological-order","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/aov-topological-order/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"AOV网与拓扑排序","slug":"aov-topological-order","permalink":"https://alex-mcavoy.github.io/tags/aov-topological-order/"}],"author":"Alex_McAvoy"},{"title":"线索二叉树的遍历","slug":"data-structure/05.thread-binary-tree/04.线索二叉树的遍历","date":"2018-11-01T02:29:00.000Z","updated":"2021-09-01T13:57:20.388Z","comments":true,"path":"oi-acm/data-structure/thread-binary-tree/f27e6025.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/thread-binary-tree/f27e6025.html","excerpt":"【概述】在 线索二叉树前驱结点与后继结点的查找 中，介绍了在线索二叉树中前驱结点与后继结点的查找 下面首先对查找过程进行总结：","text":"【概述】在 线索二叉树前驱结点与后继结点的查找 中，介绍了在线索二叉树中前驱结点与后继结点的查找 下面首先对查找过程进行总结： 当给定结点 p 时，若 p-&gt;ltag = 1 或 p-&gt;rtag = 1，说明进行了线索化，可以通过 p-&gt;lchild 来访问 p 的前驱，通过 p-&gt;rchild 来访问 p 的后驱 而当 p-&gt;ltag = 1 或 p-&gt;rtag = 1，说明未进行线索化，查找前驱、后继结点过程可以总结为下表： 前序线索二叉树 中序线索二叉树 后序线索二叉树 找前驱 需要三叉链表线索化 寻找最右下结点 依据右孩子是否存在判断 找后继 依据左孩子是否存在判断 寻找最左下结点 需要三叉链表线索化 在对线索二叉树进行遍历时，执行前/中/后序线索二叉树的遍历就相当于对二叉树进行前/中/后序遍历，只是正向遍历是通过寻找后继结点的方式来实现的，逆向遍历是通过寻找前驱结点的方式实现的 因此，在执行遍历前，需要先构建线索二叉树，然后再进行线索二叉树的遍历 此外，由于前序线索二叉树的找前驱与后序线索二叉树的找后继要由三叉链表来实现，因此不再给出前序线索二叉树的逆向前序遍历和后序线索二叉树的后序正向遍历 【访问函数】在对线索二叉树遍历时，每访问一个结点可能要对该结点进行某些操作，为此，封装一访问函数 visit()，在实际问题中，根据需要来更改该函数即可 123456void visit(ThNode *p) &#123; //访问函数 if (p == NULL) printf(\"Null\\n\"); else printf(\"%d\\n\", p-&gt;data);&#125; 【中序线索二叉树】中序线索二叉树的正向遍历前序线索二叉树的正向遍历即对二叉树进行正向中序遍历，从整棵二叉树的最左下方的结点开始，不断寻找后继结点进行输出即可 要求在遍历前先进行中序线索二叉树的构建，即调用 createInThreadTree() 函数，然后寻找到最左下方的结点，之后进行遍历 12345678910111213141516171819void inOrder(ThNode *p) &#123; //中序线索二叉树的遍历 while (p != NULL) &#123; visit(p); p = findPostByInThreadTree(p); //寻找后继 &#125;&#125;int main() &#123; ThTree root; //build tree createInThreadTree(root); //创建中序线索二叉树 ThNode *p = root; while (p-&gt;ltag == 0) //寻找以p为根的子树中，最左下结点 p = p-&gt;lchild; inOrder(p); //中序遍历 system(\"pause\"); return 0;&#125; 中序线索二叉树的逆向遍历中序线索二叉树的逆向遍历即对二叉树进行逆向中序遍历，从整棵二叉树的最右下方的结点开始，不断寻找前驱结点进行输出即可 要求在遍历前先进行中序线索二叉树的构建，即调用 createInThreadTree() 函数，然后寻找到最右下方的结点，之后进行遍历 12345678910111213141516171819void revInOrder(ThNode *p) &#123; //中序线索二叉树的逆向遍历 while (p != NULL) &#123; visit(p); p = findPreByInThreadTree(p); //寻找前驱 &#125;&#125;int main() &#123; ThTree root; //build tree createInThreadTree(root); //创建中序线索二叉树 ThNode *p = root; while (p-&gt;rtag == 0) //寻找以p为根的子树中，最右下结点 p = p-&gt;rchild; revInOrder(p); //逆向中序遍历 system(\"pause\"); return 0;&#125; 【前序线索二叉树的正向遍历】前序线索二叉树的正向遍历即对二叉树进行正向前序遍历，从根结点开始，不断寻找后继结点进行输出即可 要求在遍历前先进行前序线索二叉树的构建，即调用 createPreThreadTree() 函数，之后从根结点开始进行遍历 12345678910111213141516void preOrder(ThNode *p) &#123; //前序线索二叉树的正向遍历 while (p != NULL) &#123; visit(p); p = findPostByPreThreadTree(p); //寻找后继 &#125;&#125;int main() &#123; ThTree root; //build tree createPreThreadTree(root); //创建前序线索二叉树 preOrder(root); //前序遍历 system(\"pause\"); return 0;&#125; 【后序线索二叉树的逆向遍历】后序线索二叉树的逆向遍历即对二叉树进行逆向后序遍历，从根结点开始，不断寻找前驱结点进行输出即可 要求在遍历前先进行后序线索二叉树的构建，即调用 createPostThreadTree() 函数，之后从根结点开始进行遍历 1234567891011121314151617void revPostOrder(ThNode *p) &#123; //后序线索二叉树的逆向遍历 ThNode *p = root; while (p != NULL) &#123; visit(p); p = findPreByPostThreadTree(p); //寻找前驱 &#125;&#125;int main() &#123; ThTree root; //build tree createPostThreadTree(root); //创建后序线索二叉树 revPostOrder(root); //逆向后序遍历 system(\"pause\"); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线索二叉树","slug":"oi-acm/data-structure/thread-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/thread-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线索二叉树","slug":"thread-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/thread-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"数据库镜像","slug":"database/53.数据库镜像","date":"2018-10-30T15:38:00.000Z","updated":"2021-08-23T13:46:33.494Z","comments":true,"path":"notes/database/67a16a4a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/67a16a4a.html","excerpt":"数据库镜像是指：根据数据库管理员的要求，DBMS 自动把整个数据库或其中的关键数据复制到另一个磁盘上，每当主数据库更新时，DBMS 会自动将更新后的数据复制过去，由 DBMS 自动保证镜像数据和主数据库的一致性 当出现介质故障时，由镜像磁盘继续提供使用，同时 DBMS 自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本","text":"数据库镜像是指：根据数据库管理员的要求，DBMS 自动把整个数据库或其中的关键数据复制到另一个磁盘上，每当主数据库更新时，DBMS 会自动将更新后的数据复制过去，由 DBMS 自动保证镜像数据和主数据库的一致性 当出现介质故障时，由镜像磁盘继续提供使用，同时 DBMS 自动利用镜像磁盘数据进行数据库恢复，不需要关闭系统和重装数据库副本 在没有出现故障时，数据库镜像还可用于并发操作，即当一个用户对数据加排他锁修改数据时，其他用户可以读镜像数据库上的数据，不必等待该用户释放锁","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库日志检查点技术","slug":"database/52.数据库日志检查点技术","date":"2018-10-30T12:24:00.000Z","updated":"2021-08-23T13:46:27.774Z","comments":true,"path":"notes/database/fe316895.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/fe316895.html","excerpt":"【检查点技术】检查点记录与重新开始文件含有检查点记录的日志的内容包括：","text":"【检查点技术】检查点记录与重新开始文件含有检查点记录的日志的内容包括： 建立检查点时刻所有正在执行的事务清单 这些事务最近一个日志记录的地址 重新开始文件用来记录各个检查点记录在日志文件中的地址 如下图，说明了建立检查点 $C_i$ 时刻时对应的日志文件和重新开始文件 动态维护日志文件方法动态维护日志文件的方法是周期性执行建立检查点、保存数据库状态的操作，具体步骤如下： 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上 在日志文件中写入一个检查点记录 将当前数据缓冲区的所有数据记录写入磁盘的数据库中 把检查点记录在日志文件中的地址写入一个重新开始文件 建立检查点恢复子系统可以定期或不定期地建立检查点，保存数据库状态 定期建立：按照预定的时间间隔建立，如每隔一小时建立一个检查点 不定期建立：按照某种规则建立，如日志文件已写满一半建立一个检查点 【利用检查点的恢复策略】恢复策略使用检查点方法可以改善恢复效率，当事务 $T$ 在一个检查点之前提交，$T$ 对数据库所做的修改一定都已写入数据库，写入时间是这个检查点建立之前或在这个检查点建立之时 这样，在进行恢复处理时，没有必要对事务 $T$ 执行重做操作 如下图，系统出现故障时，恢复子系统会根据事务的不同状态来采取不同的恢复策略 恢复步骤系统使用检查点方法进行恢复的步骤如下： 1.从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录 2.由该检查点记录得到检查点建立时刻所有正在执行的事务清单 ACTIVE-LIST，建立撤销队列 UNDO-LIST 与重做队列 REDO-LIST，并将 ACTIVE-LIST 暂时放入 UNDO-LIST，REDO-LIST 暂时为空 3.从检查点开始正向扫描日志文件，直到日志文件结束 如有新开始的事务 $T_i$，把 $T_i$ 暂时放入 UNDO-LIST 如有提交的事务 $T_j$，把 $T_j$ 从 UNDO-LIST 移到 REDO-LIST 4.对 UNDO-LIST 中的每个事务执行 UNDO 操作，并对 REDO-LIST 中的每个事务执行 REDO 操作","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库故障恢复策略","slug":"database/51.数据库故障恢复策略","date":"2018-10-30T11:33:00.000Z","updated":"2021-04-13T11:32:56.790Z","comments":true,"path":"notes/database/213852c8.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/213852c8.html","excerpt":"【事务故障的恢复】事务故障是指事务在运行至正常终止点前被终止，此时恢复子系统应利用日志文件撤销次事务已对数据库进行的新修改 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预，其步骤如下：","text":"【事务故障的恢复】事务故障是指事务在运行至正常终止点前被终止，此时恢复子系统应利用日志文件撤销次事务已对数据库进行的新修改 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预，其步骤如下： 1.反向扫描文件日志，查找该事务的更新操作 2.对该事务的更新操作执行逆操作，即将日志记录中更新前的值写入数据库 若是插入操作：更新前的值为空，则相当于做删除操作 若是删除操作：更新后的值为空，则相当于做插入操作 若是修改操作：相当于用修改前值代替修改后值 3.继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理 4.如此处理下去，直至读到此事务的开始标记，事务故障恢复完成 【系统故障的恢复】在 数据库系统的故障种类 中，介绍过系统故障发生的原因： 未完成事务对数据库的更新可能以写入数据库 已提交事务对数据库的更新可能停留在缓冲区，未来得及写入数据库 因此，对于系统故障的恢复，就是撤销故障发生时未完成的事务，重做已完成的事务 系统故障的恢复是由系统在重启时自动完成的，不需要用户的干预，其步骤如下： 1.正向扫描日志文件，寻找以下两类事务： 故障发生前已提交的事务（即有 BEGIN TRANSACTION 记录，也有 COMMIT 记录），将事务标识记入重做队列 REDO-LIST 故障发生时尚未完成的事务（只有 BEGIN TRANSACTION 记录），将其事务标识记入撤销队列 UNDO-LIST 2.对撤销队列 UNDO-LIST 中的各事务进行撤销处理，即反向扫描日志文件，对每个 UNDO 事务的更新执行逆操作（将日志记录中更新前的值写入数据库） 3.对重做队列 REDO-LIST 中的各事务进行重做处理，即正向扫描日志文件，对每个 REDO 事务重新执行登记操作（将日志记录中更新后的值写入数据库） 【介质故障的恢复】发生截止故障后，磁盘上的物理数据和日志文件被损坏，恢复的方法是重装数据库，然后重做已完成的事务，具体步骤如下： 1.装入离故障发生时最近的转储副本，使数据库恢复到最近一次转储时的一致性状态 对于静态转储的数据库副本：装入后数据库即处于一致性状态 对于动态转储的数据库副本：还需同时装入转储时的日志文件副本，利用恢复系统故障的方法（REDO 与 UNDO 操作），使数据库恢复到一致性状态 2.装入转储结束时刻的日志文件副本，重做已完成的事务 扫描日志文件，找出故障发生时已提交的事务标识，将其记入重做队列 REDO-LIST 对重做队列 REDO-LIST 中的各事务进行重做处理，即正向扫描日志文件，对每个 REDO 事务重新执行登记操作（将日志记录中更新后的值写入数据库） 需要说明的是，介质故障的恢复需要数据库管理员的介入，但数据库管理员仅需重装最近转储的数据库副本和日志文件副本，然后执行系统提供的恢复命令即可，具体的恢复操作仍由 DBMS 完成","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库冗余数据建立技术","slug":"database/50.数据库冗余数据建立技术","date":"2018-10-30T08:19:00.000Z","updated":"2021-04-13T11:33:48.363Z","comments":true,"path":"notes/database/c21706e6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/c21706e6.html","excerpt":"【数据转储】概述数据转储是数据库恢复中采用的最基本的技术，即数据库管理员定期将整个数据库复制到磁带、磁盘、其他存储介质上保存起来的过程，这些备用的数据被称为后备副本(Backup)","text":"【数据转储】概述数据转储是数据库恢复中采用的最基本的技术，即数据库管理员定期将整个数据库复制到磁带、磁盘、其他存储介质上保存起来的过程，这些备用的数据被称为后备副本(Backup) 当数据库遭到破坏后，可以将后备副本重新装入，但重装后备副本只能将数据库恢复到转储时的状态，要想恢复到故障发生时的状态，必须重新运行自转储后的所有更新事务 如下图，系统在 $T_a$ 时刻停止运行事务，进行数据库转储，在 $T_b$ 时刻转储完毕，得到 $T_b$ 时刻的数据库一致性副本，当系统运行到 $T_f$ 时刻时，发生故障，为恢复数据库，数据库管理员重装数据库后备副本，将数据库恢复到 $T_b$ 时刻的状态，然后重新运行自 $T_b$ 到 $T_f$ 时刻的所有更新事务 数据转储分类转储状态静态转储是在系统中无运行事务时进行的转储操作，即转储开始时数据库处于一致性状态，且转储期间不允许对数据库进行任何存取、修改活动 静态转储实现简单，得到的一定是一个数据一致性的副本，但降低了数据库的可用性，即转储必须等待正运行的用户事务结束，且新的事务必须等转储结束 动态转储是在指转储期间允许对数据库进行存取、修改，即转储与用户事务可以并发执行 动态转储不用等待正在运行的用户事务结束，也不会影响新事务的运行，但不能保证副本中的数据正确有效，为此，需要将动态转储期间各事务对数据库的修改活动登记下来，建立日志文件，利用后备副本与日志文件一起将数据库恢复到某一时刻的正确状态 转储方式海量转储又称完全转储，是指每次转储全部的数据库；增量转储是指每次只转储上次转储后更新过的数据 从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便，但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效 分类综上所述，数据转储有海量转储、增量转储两种转储方式，有动态转储、静态转储两种转储状态，因此，数据转储方式可以分为以下 4 类 【登录日志文件】日志文件的内容日志文件是用来记录事务对数据库的更新操作的文件，不同数据库系统采用的日志文件格式不同，主要有以记录为单位和以数据块为单位的日志文件 对于以记录为单位的日志文件，需要登记的内容有： 各事务的开始标记 BEGIN TRANSACTION 各事务的结束标记 COMMIT 或 ROLLBACK 各事务的所有更新操作：事务标识、操作类型、操作对象、更新前后数据的新值与旧值 对于以数据块为单位的日志文件，需要登记的内容有： 事务标识：标明是哪个事务 被更新的数据块 日志文件作用日志文件在数据库恢复中，主要用来进行事务故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复 如下图，系统在 $T_a$ 时刻停止运行事务，进行数据库转储；在 $T_b$ 时刻转储完毕，得到 $T_b$ 时刻的数据库一致性副本；当系统运行到 $T_f$ 时刻时，发生故障；为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复到 $T_b$ 时刻状态，然后运行 $T_b$ 到 $T_f$ 时刻的所有更新事务，将数据库恢复到故障发生前的一致状态 登录日志文件原则为保证数据库是可恢复的，登录日志文件必须遵循以下两条原则： 登记的次序严格按并发事务执行的时间顺序 必须先将修改的日志记录写到日志文件，再将对数据的修改写入数据库 对数据的修改写到数据库和将表示这个修改的日志记录写到日志文件中，是两个不同的操作，可能在这两个操作间发生故障，即这两个写操作仅完成了一个 如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改 而如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的 UNDO 操作，并不会影响数据库的正确性","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库系统的故障种类","slug":"database/49.数据库系统的故障种类","date":"2018-10-30T06:31:00.000Z","updated":"2021-08-23T13:46:40.122Z","comments":true,"path":"notes/database/4176130.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/4176130.html","excerpt":"【事务内部故障】事务故障意味着事务没有达到预期的终点 COMMIT 或 ROLLBACK，因此，数据库可能处于不正确状态 恢复程序要在不影响其他事务运行的情况下，强行回滚该事务，即撤销该事务已作出的任何对数据库的修改，使得该事务好像没有启动，这类恢复操作被称为事务撤销 UNDO 操作","text":"【事务内部故障】事务故障意味着事务没有达到预期的终点 COMMIT 或 ROLLBACK，因此，数据库可能处于不正确状态 恢复程序要在不影响其他事务运行的情况下，强行回滚该事务，即撤销该事务已作出的任何对数据库的修改，使得该事务好像没有启动，这类恢复操作被称为事务撤销 UNDO 操作 事务内部故障有些可以通过事务程序本身发现 例如，银行转账事务，该事务将一笔金额从一个账户甲转给另一个账户乙 该例中，若产生账户甲余额不足的情况，应用程序可以发现并让事务回滚，撤销已做的修改，恢复数据库到正常状态 1234567891011121314BEGIN TRANSACTION 读账户甲的余额 BALANCE; BALANCE = BALANCE - AMOUNT; /*AMOUNT为转账金额*/ 写回 BALANCE; IF (BALANCE &lt; 0 ) THEN &#123; 打印 '金额不足，不能转账'; /*事务内部可能造成事务回滚*/ ROLLBACK; /*撤销刚才的修改，恢复事务*/ &#125; ELSE &#123; 读账户乙的余额 BALANCE1; BALANCE1 = BALANCE1 + AMOUNT; 写回BALANCE1; COMMIT; &#125; 而事务内部故障更多的是非预期的，不能由事务程序处理，例如：运算溢出、并发事务出现死锁、违反某些完整性限制而被终止等 【系统故障】系统故障又被称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动 例如，特定的硬件错误、操作系统错误、DBMS 代码错误、系统断电等，这类故障影响所有正在运行的事务，但不会破坏数据库 发生系统故障时，一些尚未完成的事务的结果可能已被送入物理数据库，从而可能造成数据库处于不正确状态，为保证数据的一致性，恢复子系统需要清除这些事务对数据库的所有修改，即进行事务撤销 UNDO 操作 另一方面，发生系统故障时，有些已完成的事务可能一部分甚至全部留在缓冲区，尚未写回物理数据库中，此时，在系统重启后，恢复子系统除了进行事务撤销 UNDO 操作外，还需要进行重做 REDO 所有已提交的事务，将数据库恢复到真正一致状态 【介质故障】介质故障又被称为硬故障，是指外存故障，该类故障发生的概率较小，但破坏力极强，这类故障将破坏部分或全部数据库的数据，并影响正在存取这部分数据的全部事务 对于该类故障，恢复的方法是装入数据库发生介质故障前某个时刻的数据副本，并重做 REDO 自此时始的所有成功事务，将这些事务已提交的结果重新记入数据库 常见的介质故障有：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰等 【计算机病毒】计算机病毒是一种可以繁殖和传播的人为的故障或破坏，是由一些恶作剧者研制的一种计算机程序 计算机病毒不仅会破坏、盗窃系统中的数据，有时还会破坏系统文件，目前已成为计算机系统和数据库系统的主要威胁","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库系统恢复概述","slug":"database/48.数据库系统恢复概述","date":"2018-10-30T02:16:00.000Z","updated":"2021-08-23T13:46:44.388Z","comments":true,"path":"notes/database/ff9a8113.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/ff9a8113.html","excerpt":"【概述】尽管数据库系统中采取了各种保护措施来防止数据库的安全性和完整性被破坏，保证并发事务的正确执行，但是计算机系统中软硬件的错误、操作员的失误、恶意的破坏，这些故障轻则导致运行事务非正常中断，影响数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失 因此 DBMS 必须具有将数据库从错误状态恢复到某一已知的正确状态的功能，即数据库的恢复","text":"【概述】尽管数据库系统中采取了各种保护措施来防止数据库的安全性和完整性被破坏，保证并发事务的正确执行，但是计算机系统中软硬件的错误、操作员的失误、恶意的破坏，这些故障轻则导致运行事务非正常中断，影响数据的正确性，重则破坏数据库，使数据库中全部或部分数据丢失 因此 DBMS 必须具有将数据库从错误状态恢复到某一已知的正确状态的功能，即数据库的恢复 【事务的基本概念】事务在讨论数据库恢复技术之前，要先清楚事务的基本概念与性质 事务，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位 事务和程序是两个概念，一般地讲，一个程序中包含多个事务，事务的开始和结束可以由用户显式控制，如果用户没有显式定义事务，则由 DBMS 按默认规定自动划分事务 SQL 划分事务在 SQL 中，用户可以使用 BEGIN TRANSACTION、COMMIT、ROLLBACK 这三条语句来显式的划分事务 事务通常是以 BEGIN TRANSACTION 开始，以 COMMIT 或 ROLLBACK 结束 COMMIT 表示提交，即提交事务的所有操作，具体来说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库上，事务正常结束 ROLLBACK 表示回滚，即在事务运行过程中发生了某些故障，事务不能继续运行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态 ACID 特性事务具有 4 个特性，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability），这 4 个特性合称 ACID 特性 1.原子性 事务是数据库的逻辑单位，事务中的诸操作要么都做，要么都不做 2.一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 所谓一致性状态，是指当数据库只包含成功事务提交的结果时的状态 如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分写入物理数据库，此时数据库就处于一种不正确的状态 3.隔离性 一个事务的执行不能被其他事务干扰，即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务间不能相互干扰 4.持续性 持续性也称永久性，是指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应对其执行结果有任何影响 ACID 特性的保证保证事务 ACID 特性是事务管理的重要任务，ACID 特性可能遭到破坏的因素有： 多个事务并行运行时，不同事务的操作交叉执行 事务在运行过程中被强行停止 在第一种情况下，DBMS 必须保证多个事务的交叉运行不影响这些事务的原子性；在第二种情况下，DBMS 必须保证被强行终止的事务对数据库和其他事务没有任何影响 【故障的种类】数据库系统中可能发生各种各样的故障，大致可分为事务内部故障、系统故障、介质故障、计算机病毒这 4 类 各类故障，对数据库的影响有两种可能性，一是数据库本身被破坏，二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的 关于故障种类的详细介绍：点击这里 【恢复技术】冗余数据建立当数据库出现故障时，需要进行数据库恢复，恢复的原理十分简单，即数据库中任何一部分被破坏或不正确的数据可以利用冗余数据进行重建 恢复机制尽管原理简单，但实施起来较为复杂，其涉及的两个关键问题是如何建立冗余数据、如何利用冗余数据实施数据库恢复 目前，建立冗余数据最常用的技术是数据转储、登记日志文件 关于建立冗余数据的技术的详细介绍：点击这里 故障恢复策略当系统运行过程中发生了故障，即可利用数据转储产生的数据库后备副本和日志文件，将数据库恢复到故障前的某一一致性状态，对于事务故障、系统故障、介质故障这三类故障，不同的故障恢复的策略也不同 关于故障恢复策略的详细介绍：点击这里 日志检查点在进行数据库恢复时，当利用日志技术，恢复子系统必须搜索日志，以确定哪些事务需要重做，哪些事务需要撤销 一般来说，需要检查所有的日志记录，这样做存在两个问题： 搜索整个日志耗费大量时间 许多重做处理事务实际上已经将他们的更新操作结果写入数据库 为解决这两个问题，发展出了具有检查点的恢复技术，这种技术在日志文件中增加了一类新的记录，即检查点记录，同时增加了重新开始文件，并让恢复子系统在登录日志文件期间动态维护日志 关于日志检查点技术的详细介绍：点击这里 数据库镜像介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性，而且由于介质故障恢复比较费时，为预防介质故障，数据库管理员必须周期性地转储数据库，加重了数据库管理员的负担 如果不及时且正确的转储数据库，一旦发生介质错误，会造成极大的损失，随着技术的发展，磁盘容量越来越大，价格也越来越便宜，为提高数据库可用性，许多 DBMS 提供了数据库镜像的功能，用于数据库恢复 关于数据库镜像的详细介绍：点击这里","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"线索二叉树前驱结点与后继结点的查找","slug":"data-structure/05.thread-binary-tree/03.线索二叉树前驱结点与后继结点的查找","date":"2018-10-29T05:07:00.000Z","updated":"2021-09-01T13:45:17.787Z","comments":true,"path":"oi-acm/data-structure/thread-binary-tree/c85d228b.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/thread-binary-tree/c85d228b.html","excerpt":"【中序线索二叉树】前驱结点对于中序线索二叉树来说，当给出指定结点 p，要找到其中序前驱结点 pre，可按照如下步骤：","text":"【中序线索二叉树】前驱结点对于中序线索二叉树来说，当给出指定结点 p，要找到其中序前驱结点 pre，可按照如下步骤： 若 p-&gt;ltag=1，说明进行了线索化，那么 pre=p-&gt;lchild 若 p-&gt;ltag=0，说明其必有左孩子，那么 pre 为 p 的左子树中最右下结点 12345678910ThNode *findPreByInThreadTree(ThNode *p) &#123; //中序线索二叉树找前驱 if (p-&gt;ltag == 1) //已线索化 return p-&gt;lchild; else&#123; //未线索化 p = p-&gt;lchild; //p的左子树 while (p-&gt;rtag == 0) //寻找以p为根的子树中，最右下方的结点 p = p-&gt;rchild; return p; &#125;&#125; 后继结点对于中序线索二叉树来说，当指定结点 p，要找到其中序后继结点 post，可按照如下步骤： 若 p-&gt;rtag=1，说明进行了线索化，那么 post=p-&gt;rchild 若 p-&gt;rtag=0，说明其必有右孩子，那么 post 为 p 的右子树中最左下结点 12345678910ThNode *findPostByInThreadTree(ThNode *p) &#123; //中序线索二叉树找后继 if (p-&gt;rtag == 1) //已线索化 return p-&gt;rchild; else &#123; //未线索化 p = p-&gt;rchild; //p的右子树 while (p-&gt;ltag == 0) //寻找以p为根的子树中，最左下方的结点 p = p-&gt;lchild; return p; &#125;&#125; 【前序线索二叉树】前驱结点对于前序线索二叉树来说，当指定结点 p，要找到其前序前驱结点 pre，可按照如下步骤： 若 p-&gt;ltag=1，说明进行了线索化，那么 post=p-&gt;lchild 若 p-&gt;ltag=0，说明没有进行线索化，此时 p 的前驱与 p 的父结点有关，因此只能从头开始遍历 为克服上述问题，一般采用三叉链表线索化的来建立前序线索二叉树，这样一来，可以很容易的找到其前驱： 若 p-&gt;ltag=1，说明进行了线索化，那么 post=p-&gt;lchild 若 p-&gt;ltag=0，说明没有进行线索化，此时根据三叉链表的 parent 指针，寻找 p 的父结点： 若能找到 p 的父结点，且 p 是左孩子，那么 p 的父结点即为前驱 若能找到 p 的父结点，且 p 是右孩子，左兄弟为空，那么 p 的父结点即为前驱 若能找到 p 的父结点，且 p 是右孩子，左兄弟非空，那么 p 的左兄弟子树中最后一个被先序遍历的点即为前驱 若不能找到 p 的父结点，即 p 是根结点，则 p 没有前序前驱 后继结点对于前序线索二叉树来说，当指定结点 p，要找到其前序后继结点 post，可按照如下步骤： 若 p-&gt;rtag=1，说明进行了线索化，那么 post=p-&gt;rchild 若 p-&gt;rtag=0，说明没有进行线索化，必有右孩子，那么 post 为 p 的子树中第一个被先序遍历的结点 若 p 有左孩子，则先序后继为左孩子 若 p 没有左孩子，则先序后继为右孩子 12345678910ThNode *findPostByPreThreadTree(ThNode *p) &#123; //前序线索二叉树找后继 if (p-&gt;rtag == 1) //已线索化 return p-&gt;rchild; else &#123; //未线索化 if (p-&gt;lchild != NULL) //左孩子存在 return p-&gt;lchild; else //左孩子不存在 return p-&gt;rchild; &#125;&#125; 【后序线索二叉树】前驱结点对于后序线索二叉树来说，当指定结点 p，要找到其后序前驱结点 pre，可按照如下步骤： 若 p-&gt;ltag=1，说明进行了线索化，那么 pre=p-&gt;lchild 若 p-&gt;ltag=0，说明没有进行线索化，必有左孩子，那么 pre 为 p 的子树中最后一个被后序遍历的结点 若 p 有右孩子，则前驱为 p 的右孩子 若 p 没有右孩子，则前驱为 p 的左孩子 12345678910ThNode *findPreByPostThreadTree(ThNode *p) &#123; //后序线索二叉树找前驱 if (p-&gt;ltag == 1) //已线索化 return p-&gt;lchild; else &#123; //未线索化 if (p-&gt;rchild != NULL) //右孩子存在 return p-&gt;rchild; else //左孩子不存在 return p-&gt;lchild; &#125;&#125; 后继结点对于后序线索二叉树来说，当指定结点 p，要找到其后序后继结点 post，可按照如下步骤： 若 p-&gt;rtag=1，说明进行了线索化，那么 post=p-&gt;rchild 若 p-&gt;rtag=0，说明没有进行线索化，此时 p 的左右结点只可能是其前驱，p 的后继与 p 的父结点有关，因此只能从头开始遍历 为克服上述问题，一般采用三叉链表线索化的来建立后序线索二叉树，这样一来，可以很容易的找到其后继： 若 p-&gt;rtag=1，说明进行了线索化，那么 post=p-&gt;rchild 若 p-&gt;rtag=0，说明没有进行线索化，此时根据三叉链表的 parent 指针，寻找 p 的父结点： 若能找到 p 的父结点，且 p 是右孩子，则 p 的父结点为其后继 若能找到 p 的父结点，且 p 是左孩子，其右兄弟为空，则 p 的父结点为其后继 若能找到 p 的父结点，且 p 是左孩子，其右兄弟非空，则 p 的右兄弟子树中第一个被后序遍历的结点为其后继 若不能找到 p 的父结点，即 p 是根结点，则 p 没有后序后继","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线索二叉树","slug":"oi-acm/data-structure/thread-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/thread-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线索二叉树","slug":"thread-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/thread-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"数据库审计","slug":"database/47.数据库审计","date":"2018-10-26T12:01:00.000Z","updated":"2021-08-23T13:46:48.489Z","comments":true,"path":"notes/database/9e8e2b3e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/9e8e2b3e.html","excerpt":"【概述】审计，是 DBMS 达到 C2 以上安全级别必不可少的一项指标 审计功能将用户对数据库的所有操作自动记录下来存入审计日志中，审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列审计事件，找出非法存取数据的人、时间、内容","text":"【概述】审计，是 DBMS 达到 C2 以上安全级别必不可少的一项指标 审计功能将用户对数据库的所有操作自动记录下来存入审计日志中，审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列审计事件，找出非法存取数据的人、时间、内容 可审计事件有服务器事件、系统权限、语句事件、模式对象事件等，其能对普通和特权用户行为、各种表操作、身份鉴别、自主和强制访问控制等操作进行审计 由于审计是十分浪费时间和空间的，其主要用于安全性要求较高的部门，因此 DBMS 往往都将审计设置为可选特征，允许数据库管理员根据具体应用对安全性的要求灵活地打开或关闭审计功能 审计设置与审计日志一般存于数据字典中，必须要将审计开关打开，即系统参数 audit_trail 设为 true，才可以在系统表 SYS_AUDITTRAIL 中看到审计信息 【审计事件】审计事件一般有多个类别，常见的有： 服务器事件：审计数据库服务器发生的事件，包含数据库服务器的启动、停止、配置文件的重新加载 系统权限：对系统拥有的结构或模式对象进行操作的审计，要求改操作的权限是通过系统权限取得的 语句事件：对 SQL 语句的审计 模式对象事件：对特定模式对象上进行的 SELECT 或 DML 操作的审计 【审计功能】审计功能主要包括以下几方面的内容： 基本功能：提供基本的、可选的、有限的三种审计查阅方式 审计规则：一般在数据库初始化时设定，以方便审计员管理 审计日志管理功能：包括防止审计员误删审计记录、只允许审计员查阅和转储审计记录等 审计分析与报表：提供供审计员查看的审计分析记录与报表 审计设置与审计记录的视图：系统提供查询审计设置、审计记录的视图，通过相关的系统表直接查看 【审计类型】审计一般分为用户级审计和系统级审计 用户级审计是任何用户可设置的审计，主要针对用户对自己创建的数据库表或视图，记录所有用户对这些表或视图成功、不成功的访问要求与 SQL 操作 系统级审计只能由数据库管理员设置，用来监控成功或失败的登录要求、监测授权与收回操作、其他数据库级权限下的操作等 【SQL 中的审计】在 SQL 中，RDBMS 提供了 AUDIT 语句和 NOAUDIT 语句来设置、取消审计功能 例如，对修改 sc 表结构或修改 sc 表数据的操作进行审计 12AUDIT ALTER, UPDATEON sc; 例如，取消对 sc 表的所有审计 12NOAUDIT *ON sc;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库存取控制","slug":"database/46.数据库存取控制","date":"2018-10-26T06:37:00.000Z","updated":"2021-08-23T14:04:51.487Z","comments":true,"path":"notes/database/7fd9d48.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/7fd9d48.html","excerpt":"【概述】数据库安全最重要的就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过存取控制来实现 存取控制机制主要包括两部分：","text":"【概述】数据库安全最重要的就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过存取控制来实现 存取控制机制主要包括两部分： 用户权限定义：将用户权限登记到数据字典中 合法权限检查：当用户发出存取数据库请求后，DBMS 查找数据字典，进行合法权限检查，若操作请求超出定义的权限，拒绝该次操作 用户权限定义和合法权限检查一起组成了 DBMS 的存取控制安全子系统，C2 级的 DBMS 系统支持自主权限控制 DAC，B1 级的 DBMS 支持强制存取控制 MAC 【自主存取控制】自主存取控制方法对于自主存取控制 DAC来说，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户可将其拥有的权限转授给其他用户，十分灵活 用户权限由数据库对象、操作类型两个要素组成，定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作，这个过程被称为授权 在非关系数据库系统中，用户只能对数据进行操作，存取控制的数据库对象也仅限于数据本身 在关系数据库系统中，存取控制的对象不仅有数据本身，还有数据库模式，如下表，列出了关系数据库系统中的存取权限 授权与收回在 SQL 中，使用 GRANT 和 REVOKE 语句向用户授权、收回权限 GRANT 语句GRANT 语句用于将对指定操作对象的指定操作权限授予指定用户，其语法如下 1234GRANT &lt;权限1&gt; [,&lt;权限2&gt;,...,&lt;权限n&gt;]ON &lt;对象类型1&gt; &lt;对象名1&gt; [,&lt;对象类型2&gt; &lt;对象名2&gt;,...,&lt;对象类型n&gt; &lt;对象名n&gt;]TO &lt;用户1&gt; [,&lt;用户2&gt;,...,&lt;用户n&gt;][WITH GRANT OPTION]; 发出 GRANT 语句的可以是数据库管理员，也可以是该数据库创建者（属主 owner），还可以是已拥有该权限的用户 接受权限的用户可以是一个或多个具体用户，也可以是全体用户 PUBLIC 如果指定了 WITH GRANT OPTION 子句，则获得某种权限的用户可以将该种权限再授权给其他用户，如果没有指定，则获取权限的用户不可再传播权限 例如，将查询 student 表的权限授予给用户 user1 123GRANT SELECTON TABLE studentTO user1; 要注意的是，WITH GRANT OPTION 子句不允许循环授权，即被授权者不能再将权限授权给授权者或其祖先 REVOKE 语句REVOKE 语句用于收回已赋予的权限，其语法如下 1234REVOKE &lt;权限1&gt; [,&lt;权限2&gt;,...,&lt;权限n&gt;]ON &lt;对象类型1&gt; &lt;对象名1&gt; [,&lt;对象类型2&gt; &lt;对象名2&gt;,...,&lt;对象类型n&gt; &lt;对象名n&gt;]FROM &lt;用户1&gt; [,&lt;用户2&gt;,...,&lt;用户n&gt;][CASCADE|RESTRICT]; 例如，将用户 user1 修改 student 表学生学号的权限收回 123REVOKE UPDATE(Sno)ON TABLE studentFROM user1; 创建数据库模式权限对创建数据库模式一类的数据库对线下的授权，由数据库管理员使用 CREATE USER 语句在创建用户时实现 CREATE USER 语句的语法如下 1CREATE USER &lt;用户名&gt; [WITH] [DBA|RESOURCE|CONNECT]; 只有系统的超级用户才有权创建一个新的数据库用户，新创建的数据库用户有 DBA、RESOURCE、CONNECT 三种权限，具体权限说明如下 拥有权限 CREATE USER CREATE SCHEMA CREATE TABLE 操纵数据 DBA 可以 可以 可以 可以 RESOURCE 不可以 不可以 可以 可以 CONNECT 不可以 不可以 不可以 可以，但必须拥有相应权限 数据库角色数据库角色是一组被命名的与数据库操作相关的权限，与 Windows 中的用户组十分相似 角色是权限的集合，因此可以为一组具有相同权限的用户创建一个角色，来简化授权的过程 在 SQL 中，使用 CREATE ROLE 语句来创建角色，用 GRANT 语句为角色授权，用 REVOKE 语句收回权限 1.角色创建 CREATE ROLE 语句用于来创建角色，其语法如下 1CREATE ROLE &lt;角色名&gt;; 2.角色授权 刚创建的角色是空的，没有任何内容，用 GRANT 语句为角色授权，其语法如下 123GRANT &lt;权限1&gt; [,&lt;权限2&gt;,...,&lt;权限n&gt;]ON &lt;对象类型1&gt; &lt;对象名1&gt; [,&lt;对象类型2&gt; &lt;对象名2&gt;,...,&lt;对象类型n&gt; &lt;对象名n&gt;]TO &lt;角色1&gt; [,&lt;角色2&gt;,...,&lt;角色n&gt;]; 3.角色授予 一个角色的权限是直接授予这个角色的权限加上其他角色授予这个角色的权限的总和 当想将一个角色授权给某个用户，或者授予另一个角色时，同样可以使用 GRANT 语句来授权，语法如下 123GRANT &lt;角色1&gt; [,&lt;角色2&gt;,...,&lt;角色n&gt;]TO &lt;角色或用户1&gt; [,&lt;角色或用户2&gt;,...,&lt;角色或用户n&gt;][WITH ADMIN OPTION]; 当指定了 WITH ADMIN OPTION 子句，则获得某种权限的角色或用户还可以将这种权限再授予其他角色 4.收回权限 REVOKE 语句用于收回权限，其语法如下 123REVOKE &lt;权限1&gt; [,&lt;权限2&gt;,...,&lt;权限n&gt;]ON &lt;对象类型1&gt; &lt;对象名1&gt; [,&lt;对象类型2&gt; &lt;对象名2&gt;,...,&lt;对象类型n&gt; &lt;对象名n&gt;]FROM &lt;角色1&gt; [,&lt;角色2&gt;,...,&lt;角色n&gt;]; 【强制存取控制】实体划分对于强制存取控制 MAC来说，每一个数据库对被标记一定的密级，没一个用户也被授权某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取，因此该方法比较严格 在 MAC 中，DBMS 所管理的全部实体被分为主体、客体两大类 主体：系统中活动的实体，包括 DBMS 管理的实际用户、代表用户的各进程 客体：系统中的被动实体，受主体操纵，包括文件、基本表、索引、视图等 敏感度标记对于主体与客体，DBMS 为他们每个实例指派一个敏感度标记 label，其被分为若干级别：绝密 TS、机密 S、可信 C、公开 P，其次序是 $TS\\geq S\\geq C\\geq P$ 主体的敏感度标记被称为许可证级别，客体的敏感度标记被称为密级，强制存取控制就是通过对比主体的敏感度标记和客体的敏感度标记，最终确定主体是否能够存取客体 存取规则当某一用户以标记 label 注册进系统时，系统要求他对任何客体的存取必须遵循如下规则： 当主体的许可证级别 $\\geq$ 客体的密级时，该主体才能读取相应的客体 当主体的许可证级别 $\\leq$ 客体的密级时，该主体才能写相应的客体 强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据 【安全检查机制】较高安全级别提供的安全保护要包含较低级别的所有保护，因此在实现强制存取控制的安全保护，就要先实现自主存取控制，即自主存取控制与强制存取控制共同构成 DBMS 的安全检查机制 如下图，系统首先进行自主存取控制检查，对通过自主存取控制检查的允许存取的数据库对象，再由系统自动进行强制存取控制检查，只有通过强制存取控制检查的数据库对象才可存取","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"二叉树的线索化","slug":"data-structure/05.thread-binary-tree/02.二叉树的线索化","date":"2018-10-25T09:06:00.000Z","updated":"2021-09-02T13:47:14.347Z","comments":true,"path":"oi-acm/data-structure/thread-binary-tree/480c4b9d.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/thread-binary-tree/480c4b9d.html","excerpt":"【线索化】对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化，依据二叉树遍历次序的不同，分为前序、中序、后序三种线索二叉树 线索化的核心是建立线索，之后无论是何种形式的线索二叉树，只要在其前、中、序遍历递归过程中，更改线索建立的位置即可","text":"【线索化】对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化，依据二叉树遍历次序的不同，分为前序、中序、后序三种线索二叉树 线索化的核心是建立线索，之后无论是何种形式的线索二叉树，只要在其前、中、序遍历递归过程中，更改线索建立的位置即可 在建立线索时，需要一个前驱指针 pre，用于指向当前节点 p 的前驱结点 若当前结点 p 没有左孩子：让 p 的左孩子指针指向当前结点的前驱 pre ，以建立前驱关系 若前驱结点 pre 非空，且没有右孩子：让 pre 的右孩子指针指向当前结点 p，以建立后继关系 同时，在每次完成线索建立后，令 pre 指向 p，以保持 pre 总是指向当前结点的前驱 123456789101112131415161718192021typedef struct ThNode &#123; //线索链表 int data; //数据域 struct ThNode *lchild; //左指针 struct ThNode *rchild; //右指针 int ltag, rtag; //标志位&#125; ThNode, *ThTree;void buildThread(ThNode *p, ThNode *&amp;pre) &#123; //建立线索 if (p-&gt;lchild == NULL) &#123; //当前结点p没有左孩子 p-&gt;lchild = pre; //p的左孩子指针指向p的前驱pre p-&gt;ltag = 1; //修改标志位 &#125; if (pre != NULL) &#123; //前驱结点pre存在 if (pre-&gt;rchild == NULL) &#123; //前驱结点pre没有右孩子 pre-&gt;rchild = p; // pre的右孩子指向当前结点p pre-&gt;rtag = 1; //修改标志位 &#125; pre = p; //保持pre指向p的前驱 &#125;&#125; 【中序线索二叉树】对于中序线索二叉树来说，其按照中序遍历顺序，先访问左子树，再访问根结点，最后再访问右子树 1234567891011121314void inThread(ThTree p, ThNode *&amp;pre) &#123; //中序线索化 inThread(p-&gt;lchild, pre); //递归左子树线索化 buildThread(p, pre); //当前结点线索化 inThread(p-&gt;rchild, pre); //递归右子树线索化&#125;void createInThreadTree(ThTree root) &#123; //建立中序线索二叉树 if (root == NULL) return; ThTree pre = NULL; //当前结点p的前驱结点pre inThread(root, pre); //中序线索化 if (pre-&gt;rchild == NULL) //处理遍历的最后一个结点 pre-&gt;rtag = 1;&#125; 【前序线索二叉树】对于前序线索二叉树来说，其按照前序遍历顺序，先访问根结点，再访问左子树，最后再访问右子树 在线索化过程时，由于进入递归函数后会先进行线索化，因此，这相较于中序线索二叉树来说，可能导致 pre 出现绕圈问题 为避免可能出现的绕圈，要加一个判断，即当左孩子指针 lchild 不是前驱线索时，才进行左子树线索化 123456789101112131415void preThread(ThTree p, ThNode *&amp;pre) &#123; //前序线索化 buildThread(p, pre); //当前结点线索化 if (p-&gt;ltag == 0) // lchild不是前驱线索 preThread(p-&gt;lchild, pre); //递归左子树线索化 preThread(p-&gt;rchild, pre); //递归右子树线索化&#125;void createPreThreadTree(ThTree root) &#123; //建立前序线索二叉树 if (root == NULL) return; ThTree pre = NULL; //当前结点p的前驱结点pre preThread(root, pre); //前序线索化 if (pre-&gt;rchild == NULL) //处理遍历的最后一个结点 pre-&gt;rtag = 1;&#125; 【后序线索二叉树】对于后序线索二叉树来说，其按照后序遍历顺序，先访问左子树，再访问右子树，最后再访问根结点 12345678910111213void postThread(ThTree p, ThNode *&amp;pre) &#123; //后序线索化 postThread(p-&gt;lchild, pre); //递归左子树线索化 postThread(p-&gt;rchild, pre); //递归右子树线索化 buildThread(p, pre); //当前结点线索化&#125;void createPostThreadTree(ThTree root) &#123; //建立后序线索二叉树 if (root == NULL) return; ThTree pre = NULL; //当前结点p的前驱结点pre postThread(root, pre); //后序线索化 if (pre-&gt;rchild == NULL) //处理遍历的最后一个结点 pre-&gt;rtag = 1;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线索二叉树","slug":"oi-acm/data-structure/thread-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/thread-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线索二叉树","slug":"thread-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/thread-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"线索二叉树及其存储结构","slug":"data-structure/05.thread-binary-tree/01.线索二叉树及其存储结构","date":"2018-10-25T04:05:00.000Z","updated":"2021-09-02T13:47:17.477Z","comments":true,"path":"oi-acm/data-structure/thread-binary-tree/38f06f7a.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/thread-binary-tree/38f06f7a.html","excerpt":"【线索链表】对于二叉链表来说，在 $n$ 个结点的二叉树中，每个叶结点有 $2$ 个空指针，每个度为 $1$ 的结点有 $1$ 个空指针 假设叶结点的个数为 $n_0$，度为 $1$ 的结点个数为 $n_1$，度为 $2$ 的结点个数为 $n_2$","text":"【线索链表】对于二叉链表来说，在 $n$ 个结点的二叉树中，每个叶结点有 $2$ 个空指针，每个度为 $1$ 的结点有 $1$ 个空指针 假设叶结点的个数为 $n_0$，度为 $1$ 的结点个数为 $n_1$，度为 $2$ 的结点个数为 $n_2$ 那么，对于二叉链表来说，共有 $2n_0+n_1$ 个空指针 而根据二叉树的性质，有：$n_0=n_2+1$ 联立两式，可知二叉链表共有 $n_0+n_1+n_2+1 = n+1$ 个空指针 对于二叉链表来说，每个结点有一个数据域、一个左指针、一个右指针 12345typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree; 因此，在二叉链表上，只能知道每个结点的左右孩子的地址，无法知道某个结点在某种遍历序列下的前驱和后继 如果想要知道某个结点结点在某种序列遍历下的前驱或后继，要想知道，则必须从根结点开始遍历，而且以后每想知道都要遍历一次，这无疑浪费了时间 综合以上两个方面，可以考虑利用空地址，存放指向结点在某种遍历次序下的前驱与后继，将指向前驱与后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树 【存储结构】在二叉链表的基础上将二叉链表中的空指针改为指向前驱或后继的线索，因此其存储结构相较于二叉链表有了更改： 若无左子树，令 lchild 指向其遍历序列的前驱结点 若无右子树，令 rchild 指向其遍历序列的后继结点 增设两个标志位 ltag、rtag，指示指针域是指向左右子树还是指向前驱后继结点 123456789101112typedef struct ThNode &#123; //线索链表 int data; //数据域 struct ThNode *lchild; //左指针 struct ThNode *rchild; //右指针 int ltag, rtag; //标志位&#125; ThNode, *ThTree;bool initThTree(ThTree &amp;root) &#123; //初始化 root = NULL; //空树 ltag = 0; //建树时设为0 rtag = 0; //建树时设为0 return true;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线索二叉树","slug":"oi-acm/data-structure/thread-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/thread-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线索二叉树","slug":"thread-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/thread-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"数据库用户身份鉴别","slug":"database/45.数据库用户身份鉴别","date":"2018-10-23T07:31:00.000Z","updated":"2021-08-23T13:46:55.884Z","comments":true,"path":"notes/database/3d59043f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/3d59043f.html","excerpt":"【概述】用户身份鉴别是数据库管理系统提供的最外层安全保护措施，每个用户在系统中都有一个用户标识，每个用户标识都由用户名、用户标识号（UID）两部分组成 UID 在系统的整个生命周期内是唯一的，系统内部记录着所有合法用户的标识，系统鉴别是指由系统提供一定方式令用户标识自己的名字或身份，每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供使用 DBMS 的权限","text":"【概述】用户身份鉴别是数据库管理系统提供的最外层安全保护措施，每个用户在系统中都有一个用户标识，每个用户标识都由用户名、用户标识号（UID）两部分组成 UID 在系统的整个生命周期内是唯一的，系统内部记录着所有合法用户的标识，系统鉴别是指由系统提供一定方式令用户标识自己的名字或身份，每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供使用 DBMS 的权限 用户身份鉴别的方法有多种，且在一个系统中往往是多种方法的结合，常用的用户身份鉴别方法有静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别 【静态口令鉴别】静态口令鉴别是目前最常用鉴别方式，一般由用户自己设置，在鉴别时只要输入正确的口令，系统即允许用户使用 该种方法安全性较低，易被攻击 【动态口令鉴别】动态口令鉴别是目前较为安全的鉴别方式，这种方式的口令是动态变化的，每次鉴别均需要使用动态产生的新口令登录 DBMS，即一次一密，与静态口令鉴别相比，该种方式增加了口令被窃取、被破解的难度，安全性相对高一些 常见的方式有短信密码、动态令牌方式 【生物特征鉴别】生物特征鉴别是通过生物特征进行认证的技术，这种方式与传统的口令鉴别相比，产生了质的飞跃，安全性较高 生物特征是生物体唯一具有的，可测量、可识别、可验证的稳定生物特征，如：指纹、虹膜、掌纹等 【智能卡鉴别】智能卡是一种不可复制的硬件，内置集成电路芯片，具有硬件加密功能，用户随身携带智能卡，每次登陆 DBMS 时将其插入专用的读卡器进行验证 由于每次从智能卡中读取的数据是静态的，通过内存扫描、网络监听等技术仍是可能被截取的，存在安全隐患 在实际中，通常使用个人身份识别码 PIN 和智能卡结合的方式","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库系统安全性概述","slug":"database/44.数据库系统安全性概述","date":"2018-10-23T04:24:00.000Z","updated":"2021-08-23T14:05:22.616Z","comments":true,"path":"notes/database/7034af4e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/7034af4e.html","excerpt":"【概述】数据库的安全性是指保护数据库以防止不合法使用造成的数据泄露、更改、破坏 安全性问题不是数据库独有的，所有计算机系统都存在不安全因素，只是在数据库系统中由于大量数据集中存放，且为众多最终用户直接共享，从而使安全性问题更为突出","text":"【概述】数据库的安全性是指保护数据库以防止不合法使用造成的数据泄露、更改、破坏 安全性问题不是数据库独有的，所有计算机系统都存在不安全因素，只是在数据库系统中由于大量数据集中存放，且为众多最终用户直接共享，从而使安全性问题更为突出 对数据库安全性产生威胁的因素，主要有以下方面： 非授权用户对数据库的恶意存取与破坏 数据库中重要或敏感的数据被泄漏 安全环境的脆弱性 【安全标准】概述计算机及信息安全技术方面有一系列的安全标准，目前最有影响的是 TCSEC 标准和 CC 标准 TCSEC 是 1985 年美国国防部正式颁布的 《DoD 可信计算机系统评估准则》，在 TCSEC 推出后的十年里，不同的国家都开始启动开发建立在 TCSEC 概念上的评估准则，包括欧洲的 ITSEC、加拿大的 CTCPEC 等 为满足全球 IT 市场互认标准化安全评估结果的需要，TCSEC、ITSEC、CTCPEC 等发起组织于 1993 年开始联合行动，解决原标准中概念和技术上的差异，确定了一组单一的、能广泛使用的 IT 安全准则，即**通用准则 CC TCSEC 标准TCSEC 又称桔皮书，后续又将其扩展到数据库管理系统，称为 TCSEC/TDI，其中定义了 DBMS 的设计与实现中要满足和用以进行安全性级别评估的标准，从安全策略、责任、保证、文档这 4 个方面来描述安全级别划分的指标 根据计算机系统对各项指标的支持情况，TCSEC/TDI 将系统划分为 4 组 7 个等级，按系统可靠或可信程度逐渐增高，具体安全级别如下表所示 安全级别 定义 D 最小保护 C1 自主安全保护 C2 受控的存取保护 B1 标记安全保护 B2 结构化保护 B3 安全域 A1 验证设计 这些安全级别的含义具体如下： D 级：最低级别，将一切不符合更高标准的系统统统归为 D 组 C1 级：提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行自主存取控制 DAC，包含、限制用户权限的传播 C2 级：实际上是安全产品的最低档，提供受控的存取保护，即将 C1 级的 DAC 进一步细化，以个人身份注册负责，并实施审计和资源隔离 B1 级：对系统的数据加以标记，并对标记的主体和客体实施存取控制 MAC 与审计等安全机制，满足该等级的产品才被认为是真正意义上的安全产品 B2 级：建立形式化的安全策略模型，并对系统内的所有主体和客体实施 DAC、MAC B3 级：该级的可信计算基础 TCB 必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程 A 级：在提供 B3 级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现 CC 标准CC 标准是在 TCSEC/TDI 的基础上，结合各评估准则及具体实践的基础上通过相互总结和互补发展而来的，目前 CC 已经取代了 TCSEC，成为评估信息产品安全性的主要标准 CC 的文本由三部分组成，相互依存，缺一不可： 简介与一般模型：介绍 CC 中的有关术语、基本概念、一般模型、与评估有关的一些框架 安全功能要求：列出 11 个类、66 个子类、135 组件 安全保证要求：列出 7 个保证类、26 个子类、74 个组件 根据系统对安全保证要求的支持情况，提出了评估保证级 EAL，总共分为 7 个等级，按保证程度逐渐增高，具体划分如下表 评估保证级 定义 TCSEC 安全级别（近似） EAL 1 功能测试 EAL 2 结构测试 C1 EAL 3 系统测试与检查 C2 EAL 4 系统设计、测试与复查 B1 EAL 5 半形式化设计与测试 B2 EAL 6 半形式化验证的设计与测试 B3 EAL 7 形式化验证的设计与测试 A1 【数据库安全性控制】计算机系统中，安全措施是一级一级设置的 如上图，包含四个层次： 用户标识鉴定用户身份，合法用户准许进入系统 数据库管理系统还要进行存取控制，只允许用户执行合法操作 操作系统有自己的保护措施 数据以密文形式存储到数据库中 在与数据库有关的安全性中，主要包括用户身份鉴别、多层存取控制、审计、视图、数据加密等，数据库系统安全性控制模型如下 详细介绍如下： 用户身份鉴别：点击这里 存取控制：点击这里 审计：点击这里","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"二叉树的基本算法","slug":"data-structure/04.tree-binary-tree/09.二叉树的基本算法","date":"2018-10-22T07:20:00.000Z","updated":"2021-08-31T08:13:28.895Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/60c2b7a7.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/60c2b7a7.html","excerpt":"【结点个数计算】结点个数计算先统计出左子树、右子树的结点个数，再加上根结点即可，利用后序遍历即可解决","text":"【结点个数计算】结点个数计算先统计出左子树、右子树的结点个数，再加上根结点即可，利用后序遍历即可解决 123456789101112typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;int getNodeNum(BiTree &amp;root) &#123; //计算结点个数 if (root == NULL) return 0; int left = getNodeNum(root-&gt;lchild); int right = getNodeNum(root-&gt;rchild); return left + right + 1;&#125; 叶结点个数计算只有当一个结点的左指针右指针指向 NULL 时，才说明该结点是叶结点 12345678910111213141516typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;int getLeafNodeNum(BiTree &amp;root) &#123; //统计叶结点个数 if (root == NULL) return 0; else if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return 1; else &#123; int left = getLeafNodeNum(root-&gt;lchild); int right = getLeafNodeNum(root-&gt;rchild); return left + right; &#125;&#125; 满结点个数计算在二叉树中，满结点即双分支结点，是度为 $2$ 的结点，因此在统计时，仅有当左右子树均不为空时，个数 $+1$ 1234567891011121314151617181920typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;int getFullNodeNum(BiTree &amp;root) &#123; //统计满结点个数 if (root == NULL) return 0; else if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return 0; else if (root-&gt;lchild != NULL &amp;&amp; root-&gt;rchild == NULL) return getFullNodeNum(root-&gt;lchild); else if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild != NULL) return getFullNodeNum(root-&gt;rchild); else &#123; int left = getFullNodeNum(root-&gt;lchild); int right = getFullNodeNum(root-&gt;rchild); return left + right + 1; &#125;&#125; 除上述方法外，由于在二叉树中，当叶结点个数为 $n_0$，度为 $2$ 结点个数为 $n_2$ 时，有 $n_2=n_0-1$，故还有如下解法： 12345678typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;int getFullNodeNum(BiTree &amp;root) &#123; //统计满结点个数 return getLeafNodeNum(root) &gt; 0 ? getLeafNodeNum(root)-1 : 0;&#125; 【深度计算】由于树的深度 = max(左子树深度，右子树深度)+1，因此要先统计出左子树、右子树的深度，才能得到树的深度，利用后序遍历即可解决 123456789101112typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;int getDepth(BiTree &amp;root) &#123; //计算深度 if (root == NULL) return 0; int left = getDepth(root-&gt;lchild); int right = getDepth(root-&gt;rchild); return (left &gt; right ? left : right) + 1;&#125; 【宽度计算】二叉树的宽度即是最宽的一层的节点数，利用层序遍历的思想，计算每层的结点数，然后找出最大的即可 123456789101112131415161718192021222324252627282930313233typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;int getWidth(BiTree root) &#123; //计算宽度 if (root == NULL) return 0; queue&lt;BiTree&gt; Q; Q.push(root); int width = 1; //宽度 int count = 1; //每层的结点数 while (!Q.empty()) &#123; int temp = 0; //临时保存下层节点数 for (int i = 0; i &lt; count; i++) &#123; BiTree p = Q.front(); Q.pop(); if (p-&gt;lchild != NULL) &#123; temp++; Q.push(p-&gt;lchild); &#125; if (p-&gt;rchild != NULL) &#123; temp++; Q.push(p-&gt;rchild); &#125; &#125; if (temp == 0) //下一层没有结点，结束 break; width = width &gt; temp ? width : temp; count = temp; &#125; return width;&#125; 【二叉树判定】完全二叉树判定对于完全二叉树来说，其叶结点只能出现在最下两层，因此考虑利用层序遍历的思想，一旦在队列中读到空指针，那么必将完全二叉树遍历完全，若空指针后还有要访问的元素，那么不是完全二叉树 1234567891011121314151617181920212223242526typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;bool isCompleteBiTree(BiTree root) &#123; //完全二叉树判定 if (root == NULL) return true; queue&lt;BiTree&gt; Q; Q.push(root); while (!Q.empty()) &#123; BiTree p = Q.front(); Q.pop(); if (p == NULL) //读到空指针，终止 break; Q.push(p-&gt;lchild); Q.push(p-&gt;rchild); &#125; while (!Q.empty()) &#123; //检查队列中未访问到的结点 BiTree p = Q.front(); Q.pop(); if (p != NULL) // p非空 return false; &#125; return true;&#125; 满二叉树判定对于满二叉树来说，其除最后一层是叶结点外，每一层都是满的，即每一个节点都有左右孩子 因此，利用层序遍历的思想，统计结点数与层数，然后利用 $结点数=2^{层数}-1$ 的关系，即可判断二叉树是否为满二叉树 1234567891011121314151617181920212223242526272829303132333435363738typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;bool isFullBiTree(BiTree root) &#123; //满二叉树判定 if (root == NULL) return true; int nodes = 0; //节点数 int layers = 0; //层数 BiTNode *tail = root; //尾指针 BiTNode *nxt = NULL; //后继指针 queue&lt;BiTree&gt; Q; Q.push(root); while (!Q.empty()) &#123; root = Q.front(); Q.pop(); nodes++; if (root-&gt;lchild != NULL) &#123; Q.push(root-&gt;lchild); nxt = root-&gt;lchild; &#125; if (root-&gt;rchild != NULL) &#123; Q.push(root-&gt;rchild); nxt = root-&gt;rchild; &#125; if (root == tail) &#123; tail = nxt; nxt = NULL; layers++; &#125; &#125; if (nodes == pow(2, layers) - 1) //节点数=2^层数-1 return true; return false;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"图的搜索","slug":"graph/01.graph-search/1.图的搜索","date":"2018-10-19T13:39:03.000Z","updated":"2021-09-06T14:30:51.552Z","comments":true,"path":"oi-acm/graph/graph-search/aff51b39.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/graph/graph-search/aff51b39.html","excerpt":"【概述】图的搜索是指从图中某结点出发，按某种搜索方法沿着图中的边对图中的所有结点进行访问，且每个结点仅访问一次 为避免同一结点被多次访问，常通过一个标记数组 vis[] 来记录结点是否被访问过","text":"【概述】图的搜索是指从图中某结点出发，按某种搜索方法沿着图中的边对图中的所有结点进行访问，且每个结点仅访问一次 为避免同一结点被多次访问，常通过一个标记数组 vis[] 来记录结点是否被访问过 图的搜索有两类，一类是在图上采用广度优先搜索 BFS 的思想进行搜索，另一类是在图上采用深度优先搜索 DFS 的思想进行搜索 【图的广度优先搜索】基本过程图的广度优先搜索的基本过程为： 从图中某个顶点 $v$ 出发，首先访问 $v$，将 $v$ 加入队列 将队首元素的未被访问过的邻接点加入队列，访问队首元素并将队首元素出队，直到队列为空 若此时图中仍有未被访问的结点，则另选图中的一个未被访问的顶点作为起始点，重复步骤 1，直到图中的所有节点均被访问过 对于无权图来说，由于 $BFS$ 总是按照距离由近到远来遍历图中的每个点，因此在每访问一个点时，令其路径长度 $+1$，即可得到无权图的单源最短路 在如下图所示的无向图中，若以 $A$ 为起点进行广度优先搜索，会按次序将 $A$ 的邻接点 $B$、$D$、$E$ 依次加入队列中，之后，令 $B$ 出队，将 $B$ 的邻接点 $C$ 加入队列中，以此类推，直到所有结点访问完毕 广度优先生成树在图的广度优先遍历过程中，可以得到一棵树，这棵树即广度优先生成树 对于邻接矩阵来说，图的存储方式是唯一的，那么对应的广度优先生成树也是唯一的 对于邻接表来说，图的存储方式不唯一，那么对应的广度优先生成树不唯一 在如上图所示的无向图中，若以 $v_1$ 为起点进行广度优先搜索，得到的广度优先生成树如下图所示 时间复杂度BFS 需要借助一个队列来完成，每个结点都要入队一次，因此实际时间复杂度取决于搜索结点的邻接点的时间复杂度 当采用邻接矩阵存储时，搜索某结点的邻接点的时间复杂度为 $O(|V|)$，那么，总时间复杂度为： O(|V|^2)当采用邻接表存储时，搜索某结点的邻接点时，每条边至少访问一次，其时间复杂度为 $O(|E|)$，那么，总时间复杂度为： O(|V|+|E|)框架下面给出一个由 C++ 实现的采用邻接矩阵方式存储的 BFS 框架 12345678910111213141516171819202122232425262728293031323334int n,m; //n个点m条边char G[N][N]; //邻接矩阵bool vis[N][N]; //标记数组int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; //搜索方向数组struct Node &#123; int x; int y;&#125;; //结点void bfs(int x, int y) &#123; Node start&#123;x, y&#125;; vis[x][y] = true; queue&lt;Node&gt; Q; Q.push(start); //初始数据入队 while (!Q.empty()) &#123; Node temp = Q.front(); Q.pop(); if (G[temp.x][temp.y] == 'E') &#123; //满足条件终止 // do something return; &#125; for (int i = 0; i &lt; 4; i++) &#123; //朝上下左右四个方向搜索 int nx = temp.x + dir[i][0]; //下一结点的x坐标 int ny = temp.y + dir[i][1]; //下一结点的y坐标 if (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m) &#123; if (!vis[nx][ny]) &#123; vis[nx][ny] = true; //标记 Node endd&#123;nx, ny&#125;; Q.push(endd); //元素入队 &#125; &#125; &#125; &#125;&#125; 【图的深度优先搜索】基本过程图的深度优先遍历的基本过程为： 从图中某个顶点 $v_0$ 出发，首先访问 $v_0$ 访问结点 $v_0$ 的第一个邻接点，以这个邻接点 $v_t$ 作为一个新节点，访问 $v_t$ 所有邻接点，直到以 $v_t$ 出发的所有节点都被访问 回溯到 $v_0$ 的下一个未被访问过的邻接点，以这个邻结点为新节点，重复步骤 2，直到图中所有与 $v_0$ 相通的所有节点都被访问 若此时图中仍有未被访问的结点，则另选图中的一个未被访问的顶点作为起始点，重复步骤 1，直到图中的所有节点均被访问 在如下图所示的无向图中，若以 $A$ 为起点进行深度优先搜索，会按 $A$、$B$、$C$、$F$ 的次序进行递归，当到达 $F$ 后，发现无法继续向下递归，开始回溯，回溯到 $B$ 时，从 $B$ 的邻接点开始向下递归，以此类推，直到所有结点访问完毕 深度优先生成树与图的广度优先搜索类似，在图的深度优先搜索过程中，同样可以得到一棵树，这棵树即深度优先生成树 对于邻接矩阵来说，图的存储方式是唯一的，那么对应的广度优先生成树也是唯一的 对于邻接表来说，图的存储方式不唯一，那么对应的广度优先生成树不唯一 在如上图所示的无向图中，若以 $v_1$ 为起点进行广度优先搜索，得到的广度优先生成树如下图所示 时间复杂度DFS 是一个递归的算法，需要借助一个递归工作栈来完成，因此实际时间复杂度取决于搜索结点的邻接点的时间复杂度 当采用邻接矩阵存储时，搜索某结点的邻接点时，时间复杂度为 $O(|V|)$，那么总时间复杂度为： O(|V|^2)当采用邻接表存储时，搜索某结点的邻接点时，每条边至少访问一次，时间复杂度为 $O(|E|)$，那么总时间复杂度为： O(|V|+|E|)框架下面给出一个由 C++ 实现的采用邻接矩阵方式存储的 DFS 框架 1234567891011121314151617181920int n,m; //n个点m条边char G[N][N]; //邻接矩阵bool vis[N][N]; //标记数组int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; //搜索方向数组void dfs(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; //朝上下左右四个方向搜索 int nx = x + dir[i][0]; //下一结点的x坐标 int ny = y + dir[i][1]; //下一结点的y坐标 if (G[nx][ny] == 'E') &#123; //满足条件终止 // do something return; &#125; if (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m)&#123; if (!vis[nx][ny]) &#123; vis[nx][ny] = true; dfs(nx, ny); //向下递归 &#125; &#125; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"图论","slug":"oi-acm/graph","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/"},{"name":"图的搜索","slug":"oi-acm/graph/graph-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/graph/graph-search/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"图论","slug":"graph","permalink":"https://alex-mcavoy.github.io/tags/graph/"},{"name":"图的搜索","slug":"graph-search","permalink":"https://alex-mcavoy.github.io/tags/graph-search/"}],"author":"Alex_McAvoy"},{"title":"SQL 触发器","slug":"database/43.SQL触发器","date":"2018-10-19T12:04:00.000Z","updated":"2021-08-23T13:57:14.239Z","comments":true,"path":"notes/database/fdd06222.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/fdd06222.html","excerpt":"【触发器定义】基本语法触发器又称事件-条件-动作规则，当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作","text":"【触发器定义】基本语法触发器又称事件-条件-动作规则，当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作 规则中的动作体可以很复杂，可以涉及其他表和其他数据库对象，通常是一段 SQL 存储过程 SQL 中，使用 CREATE TRIGGER 命令建立触发器，其语法如下 12345CREATE TRIGGER &lt;触发器名&gt; /*每当触发事件发生时，该触发器被激活*/&#123;BEFORE|AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt; /*指明触发器激活的时间*/REFERENCING NEW|OLD ROW AS &lt;变量&gt; /*指出引用的变量*/FOR EACH &#123;ROW|STATEMENT&#125; /*定义触发器的类型，指明动作体执行的频率*/[WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;; /*触发动作体*/ 语句说明1.创建者 表的拥有者才可创建触发器，一个表上允许有多个触发器，具体数量由具体的 RDBMS 在设计时确定 2.触发器名 触发器名可以包含模式名，也可不包含模式名 同一模式向下，触发器名必须唯一，且触发器名与表名必须在同一模式下 3.触发事件 触发事件有 INSERT、DELETE、UPDATE 等，也可是他们的组合 触发的时机由 BEFORE 与 AFTER 决定，代表触发事件之前或之后触发触发器 4.表名 触发器只能定义在基本表上，不能定义在视图上 当基本表变化时，将激活定义在该表上相应触发事件的触发器 5.触发器类型 根据触发动作的间隔尺寸区分，触发器分为行级触发器 FOR EACH ROW和语句级触发器 FOR EACH STATEMENT 假设表有 1000 行，如果是行级触发器，则执行 1000 次，如果是语句级触发器，则执行 1 次 6.触发条件 触发器被激活时，只有当触发条件为真时，触发动作体才被执行 如果省略 WHEN 触发条件，则触发动作体在触发器激活后立刻执行 7.触发动作体 触发动作体既可以是一个匿名 PL/SQL 数据块，也可以是对已创建存储过程的调用 8.引用变量 如果是行级触发器，用户可以在出触发动作体中，使用 NEW 引用 UPDATE 或 INSERT 事件之后的新值，或使用 OLD 引用 UPDATE 或 DELETE 事件前的旧值 如果是语句级触发器，则不能在触发动作体中使用 NEW 或 OLD 进行引用 实例当表 sc 的 Grade 属性进行修改时，若分数增加了 10%，则将此次操作记录到另一个表 sc_u(Sno, Cno, OldGrade, NewGrade) 中 12345678910CREATE TRIGGER sc_t /*触发器名*/AFTER UPDATE Grade ON sc /*触发事件*/REFERENCING /*引用变量*/ OLD ROW AS OldTuple, NEW ROW AS NewTupleFOR EACH ROW /*行级触发器*/WHEN(NewTuple.Grade &gt;= 1.1*OldTuple.Grade) /*触发条件*/ INSERT INTO sc_u(Sno, Cno, OldGrade, NewGrade) VALUES(OldTuple.Sno, OldTuple.Cno, OldTuple.Grade, NewTuple.Grade); 【触发器激活】触发器的执行，是由触发事件激活的，并由数据库服务器自动执行 一个数据表上可能定义了多个触发器，同一个表上的多个触发器激活时遵循如下的执行顺序： 执行该表上的 BEFORE 触发器 激活触发器的 SQL 语句 执行该表上的 AFTER 触发器 对于同一个表上的多个 BEFORE 或 ALTER 触发器，遵循谁先创建谁执行的原则，即按照触发器创建的时间先后顺序执行 【触发器删除】删除触发器时，要求触发器必须是已创建的触发器，且具有相应权限 删除触发器的语法如下 1DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 完整性约束命名子句","slug":"database/42.SQL完整性约束命名子句","date":"2018-10-19T11:44:00.000Z","updated":"2021-08-23T13:57:16.144Z","comments":true,"path":"notes/database/11ea588a.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/11ea588a.html","excerpt":"【完整性约束命名子句】在 SQL 中，完整性约束命名子句为 CONSTRAINT 语句，其语法如下 1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;","text":"【完整性约束命名子句】在 SQL 中，完整性约束命名子句为 CONSTRAINT 语句，其语法如下 1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;; 其中，&lt;完整性约束条件&gt; 包括 NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK 等 例如，建立学生表 student，要求学号在 90000~99999 之间，姓名不能为空，年龄小于 30，性别只能是男或女 1234567891011CREATE TABLE Student ( Sno NUMERIC(6) CONSTRAINT C1 CHECK(Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 NOT NULL, Sage NUMERIC(3) CONSTRAINT C3 CHECK(Sage&lt;30), Ssex CHAR(2) CONSTRAINT C4 CHECK(Ssex IN('男', '女')), CONSTRAINT StudentKey PRIMARY KEY(Sno)); 如上，在 student 表上建立了 5 个约束条件，包括主码约束 StudentKey、C1、C2、C3、C4 这 4 个列级约束 【完整性约束的修改】使用 ALTER TABLE 语句可以删除、添加表中的完整性约束限制 例如，将上例中的 C3 列级约束由年龄不能小于 30 改为不能小于 25 1234567/*先删除原来的*/ALTER TABLE student DROP CONSTRAINT C3; /*再添加新的*/ALTER TABLE student ADD CONSTRAINT C3 CHECK(Sage &lt; 25);","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 用户定义的完整性","slug":"database/41.SQL用户定义的完整性","date":"2018-10-19T10:49:00.000Z","updated":"2021-08-23T13:57:19.635Z","comments":true,"path":"notes/database/20196bc9.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/20196bc9.html","excerpt":"【属性上的约束条件】属性上约束的定义在 SQL 中，使用 CREATE TABLE 语句定义属性的同时，可以根据应用要求定义属性上的约束条件，即属性值的限制，包括：","text":"【属性上的约束条件】属性上约束的定义在 SQL 中，使用 CREATE TABLE 语句定义属性的同时，可以根据应用要求定义属性上的约束条件，即属性值的限制，包括： 列值非空 NOT NULL 列值唯一 UNIQUE 属性值限制 CHECK（检查列值是否满足一条件表达式） 关于列值非空和列值唯一，在 SQL 基本表的数据定义 进行过介绍，下面仅介绍 CHECK 短语的用法 例如，student 表中的性别属性仅允许取男、女 1234567CREATE TABLE student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) NOT NULL, Ssex CHAR(2) CHECK(Ssex IN ('男', '女')), /*属性值限制*/ Sage SMALLINT(6), Sdept CHAR(20)); 属性上约束条件的检查与违约处理在向表中插入元组或修改属性值时，RDBMS 会检查属性上的约束条件是否满足 若不满足，则操作会被拒绝执行 【元组上的约束条件】元组上约束条件的定义与属性上约束条件的定义类似，在 CREATE TABLE 语句中，可以使用 CHECK 短语定义元组上的约束条件，即元组级限制 与属性值限制相比，元组级限制可以设置不同属性间取值的相互约束条件 例如，当学生性别是男时，其名字不能以 Ms. 开头 12345678CREATE TABLE student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT(6), Sdept CHAR(20), CHECK (Ssex = '女' OR Sname NOT LIKE 'Ms.%') /*元组级限制*/); 元组约束条件的检查与违约处理在向表中插入元组或修改属性值时，RDBMS 会检查元组上的约束条件是否满足 若不满足，则操作会被拒绝执行","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 参照完整性","slug":"database/40.SQL参照完整性","date":"2018-10-19T07:05:00.000Z","updated":"2021-08-23T13:58:55.390Z","comments":true,"path":"notes/database/b8deb587.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/b8deb587.html","excerpt":"【参照完整性定义】在 SQL 中，关系模型的参照完整性在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码，用 REFERENCES 短语指明这些外码参照哪些吗的主码 例如，关系 sc 中一个元组表示一个学生选修的某门课程的成绩，其中 Sno、Cno 为主码，用分别参照引用 student 表的主码和 course 表的主码","text":"【参照完整性定义】在 SQL 中，关系模型的参照完整性在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码，用 REFERENCES 短语指明这些外码参照哪些吗的主码 例如，关系 sc 中一个元组表示一个学生选修的某门课程的成绩，其中 Sno、Cno 为主码，用分别参照引用 student 表的主码和 course 表的主码 12345678CREATE TABLE sc ( Sno CHAR(9) NOT NULL, Cno CHAR(4) NOT NULL, Grade SMALLINT, PRIMARY KEY(Sno, Cno), FOREIGN KEY(Sno) REFERENCES student(Sno), FOREIGN KEY(Cno) REFERENCES course(Cno)); 【参照完整性检查与违约处理】可能破坏参照完整性的情况参照完整性将两个表中的相应元组联系了起来，因此，对被参照表和参照表进行增、删、改操作时，可能破坏参照完整性，必须进行检查以保证这两个表的相容性 以 student 表和 sc 表为例，可能破坏参照完整性的情况及违约处理如下 违约处理当出现破坏参照完整性的情况时，系统可采用以下策略进行处理： 拒绝执行 NO ACTION：不允许执行该操作执行，一般设为默认策略 级联 CASCADE：删除或修改参照表的一个元组导致与被参照表不一致时，删除或修改参照表中所有导致不一致的元组 设为空值 NULL：删除或修改被参照表的一个元组造成不一致时，将参照表中所欲造成不一致的元组的对应属性设为空值 需要注意的是，对于参照完整性，除了定义外码，还应定义外码列是否允许空值 实例显示说明参照完整性的违约处理示例 1234567891011121314CREATE TABLE sc ( Sno CHAR(9) NOT NULL, Cno CHAR(4) NOT NULL， Grade SMALLINT， PRIMARY KEY(Sno，Cno)， FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE, /*级联删除sc表中相应的元组*/ ON UPDATE CASCADE， /*级联更新sc表中相应的元组*/ FOREIGN KEY (Cno) REFERENCES Course(Cno) /*当删除course表中的元组造成了与sc表不一致时拒绝删除*/ ON DELETE NO ACTION, /*当更新course表中的cno时，级联更新sc表中相应的元组*/ ON UPDATE CASCADE,);","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 实体完整性","slug":"database/39.SQL实体完整性","date":"2018-10-19T06:45:00.000Z","updated":"2021-08-23T13:56:31.237Z","comments":true,"path":"notes/database/11284110.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/11284110.html","excerpt":"【实体完整性定义】在 SQL 中，关系模型的实体完整性在 CREATE TABLE 语句中用 PRIMARY KEY 短语来定义 对于单属性构成的码，既可以定义为列级约束条件，又可以定义为表级约束条件","text":"【实体完整性定义】在 SQL 中，关系模型的实体完整性在 CREATE TABLE 语句中用 PRIMARY KEY 短语来定义 对于单属性构成的码，既可以定义为列级约束条件，又可以定义为表级约束条件 例如，将 student 表中的 Sno 属性定义为码 123456789101112131415161718/*列级定义主码*/CREATE TABLE student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT(6), Sdept CHAR(20));/*表级定义主码*/CREATE TABLE student ( Sno CHAR(9), Sname CHAR(20) NOT NULL, Sse` CHAR(2), Sage SMALLINT(6), Sdept CHAR(20), PRIMARY KEY(Sno)); 对于多属性构成的码，只能定义为表级约束条件 例如，将 sc 表中的 Sno、Cno 属性定义为码 123456CREATE TABLE sc ( Sno CHAR(9) NOT NULL, Cno CHAR(4) NOT NULL, Grade SMALLINT, PRIMARY KEY(Sno, Cno)); 【实体完整性检查与违约处理】用 PRIMARY KEY 短语定义了关系的主码后，每当用户程序对基本表插入一条记录或对主码列进行更新时，RDBMS 会按照实体完整性规则进行检查，包括： 检查主码值是否唯一：如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空：只要有一个为空就拒绝插入或修改 检查记录中主码值是否唯一的一种方法是进行全表扫描，依次判断表中每一条记录的主码值与插入或修改的新主码值是否相同 但全表扫描是极其耗时的，为避免对基本表进行扫描，RDBMS 一般都在主码上自动建立一个索引，通过索引查找基本表中是否已存在新主码值，目前，最常用的索引是 B+ 树索引","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"数据库完整性概述","slug":"database/38.数据库完整性概述","date":"2018-10-19T05:52:00.000Z","updated":"2021-08-23T13:44:35.458Z","comments":true,"path":"notes/database/d36d6dea.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/d36d6dea.html","excerpt":"【概述】数据库完整性是指数据的正确性和相容性，正确性是指数据是符合现实世界语义、反映当前实际情况的，相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的 数据库的完整性与安全性是两个不同的概念，完整性是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据，安全性是为了保护数据库防止恶意的破坏和非法的存取","text":"【概述】数据库完整性是指数据的正确性和相容性，正确性是指数据是符合现实世界语义、反映当前实际情况的，相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的 数据库的完整性与安全性是两个不同的概念，完整性是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据，安全性是为了保护数据库防止恶意的破坏和非法的存取 因此，完整性检查和控制的防范对象是不合语义、不正确的数据，防止他们存入数据库，安全性控制的防范对象是非法用户、非法操作，防止他们对数据库的非法存取 【DBMS 提供功能】为为维护数据库的完整性，DBMS 必须具有以下功能： 提供定义完整性约束条件的机制：通过完整性约束条件，来限定符合数据模型的数据库状态及其变化，以保证数据的正确、有效、相容 提供完整性检查的方法：检查数据是否满足完整性约束条件，一般在 INSERT、UPDATE、DELETE 语句执行后，或在事务提交时检查 违约处理：DBMS 在发现用户操作违背完整性约束条件后，进行违约处理以保证数据完整性 【具体实现】三大完整性约束在 关系的完整性约束 中已经介绍了关系数据库的三类完整性约束的基本概念，关于在 SQL 语言中如何实现这些完整性约束见下： 实体完整性：点击这里 参照完整性：点击这里 用户定义的完整性：点击这里 完整性约束命名子句在 SQL 中，实体、参照、用户定义的完整性均在 CREATE TABLE 语句中定义，一经定义无法修改 为弥补上述缺陷，SQL 在 CREATE TABLE 语句中提供了完整性约束命名子句 CONSTRAINT，用于对完整性约束条件命名，从而能够更灵活地增删完整性约束条件 关于完整性约束命名子句的详细内容：点击这里 触发器触发器（Trigger），是用户定义在关系表上的一类由事件驱动的特殊过程，一旦定义，触发器将被保存在数据库服务器中 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器，在 RDBMS 核心层进行集中的完整性控制 触发器类似于完整性约束，但比完整性约束更加灵活，可以实施更为复杂的检查和操作，具有更精细、更强大的数据控制能力 关于触发器的详细内容：点击这里","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"二叉树的构造","slug":"data-structure/04.tree-binary-tree/08.二叉树的构造","date":"2018-10-18T04:16:00.000Z","updated":"2021-08-31T08:13:21.790Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/c13c2dcb.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/c13c2dcb.html","excerpt":"【序列的异同】在先序中序、后序中序、层序这三种情况的任意一种下，可唯一确定一颗二叉树 对于非空二叉树来说，当给出前中后序序列中任意两种，根据其相反或相同，有以下判断：","text":"【序列的异同】在先序中序、后序中序、层序这三种情况的任意一种下，可唯一确定一颗二叉树 对于非空二叉树来说，当给出前中后序序列中任意两种，根据其相反或相同，有以下判断： 1.前序和中序 若相同，则二叉树为右斜树 若相反，则二叉树为左斜树 2.前序和后序 若相同，则二叉树仅有根结点 若相反，则每层仅有一个结点，即二叉树高度为结点个数 3.中序和后序 若相同，则二叉树为左斜树 若相反，则每层仅有一个结点，即二叉树高度为结点个数 【前序与中序确定二叉树】前序序列中，第一个结点一定是根结点 在中序序列中，根结点将中序序列分割成左右两个子序列： 左子序列：根结点的左子树的中序序列 右子序列：根结点的右子树的中序序列 根据这两个序列，在前序序列中找出对应的序列，然后如此递归下去，即可确定唯一的一棵二叉树 1234567891011121314151617181920212223242526272829303132333435363738typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;BiTree createPreInTree(char pre[], char in[], int inStart, int inEnd) &#123; //前序中序构造二叉链表 static int preIndex = 0; //注意此处为静态变量 if (inStart &gt; inEnd) return NULL; BiTNode *root = (BiTNode *)malloc(sizeof(BiTNode)); root-&gt;data = pre[preIndex++]; //取出前序序列第1个结点作为根结点 root-&gt;lchild = NULL; root-&gt;rchild = NULL; if (inStart == inEnd) //结点没有孩子则返回 return root; //查找根结点在中序序列中的位置 int inIndex; for (inIndex = inStart; inIndex &lt;= inEnd; inIndex++) if (in[inIndex] == root-&gt;data) break; //利用中序序列递归构造左子树与右子树，注意先左后右 root-&gt;lchild = createPreInTree(pre, in, inStart, inIndex - 1); root-&gt;rchild = createPreInTree(pre, in, inIndex + 1, inEnd);&#125;int main() &#123; char pre[6] = &#123;'A', 'B', 'D', 'E', 'C'&#125;; char in[6] = &#123;'D', 'B', 'E', 'A', 'C'&#125;; int n = 5; BiTree root = createPreInTree(pre, in, 0, n - 1); //do something system(\"pause\"); return 0;&#125; 【后序与中序确定二叉树】后序序列中，最后一个结点一定是根结点 在中序序列中，根结点将中序序列分割成左右两个子序列： 左子序列：根结点的左子树的中序序列 右子序列：根结点的右子树的中序序列 根据这两个序列，在后序序列中找出对应的序列，然后如此递归下去，即可确定唯一的一棵二叉树 1234567891011121314151617181920212223242526272829303132333435363738typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;BiTree createPostInTree(char post[], char in[], int inStart, int inEnd, int n) &#123; //后序中序构造二叉链表 static int postIndex = n - 1; //注意此处为静态变量 if (inStart &gt; inEnd) return NULL; BiTNode *root = (BiTNode *)malloc(sizeof(BiTNode)); root-&gt;data = post[postIndex--]; //取出后序序列最后1个结点作为根结点 root-&gt;lchild = NULL; root-&gt;rchild = NULL; if (inStart == inEnd) //结点没有孩子则返回 return root; //查找根结点在中序序列中的位置 int inIndex; for (inIndex = inStart; inIndex &lt;= inEnd; inIndex++) if (in[inIndex] == root-&gt;data) break; //利用中序序列递归构造左子树与右子树，注意先右后左 root-&gt;rchild = createPostInTree(post, in, inIndex + 1, inEnd, n); root-&gt;lchild = createPostInTree(post, in, inStart, inIndex - 1, n);&#125;int main() &#123; char in[6] = &#123;'D', 'B', 'E', 'A', 'C'&#125;; char post[6] = &#123;'D', 'E', 'B', 'C', 'A'&#125;; int n = 5; BiTree root = createPostInTree(post, in, 0, n - 1, n); //do something system(\"pause\"); return 0;&#125; 【层序与中序确定二叉树】层序序列中，第一个结点一定是根结点，之后的结点从左到右从上到下按顺序编号 在中序序列中，根结点将中序序列分割成左右两个子序列： 左子序列：根结点的左子树的中序序列 右子序列：根结点的右子树的中序序列 根据这两个序列，在层序序列中找出对应的序列，然后如此递归下去，即可确定唯一的一棵二叉树","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"有序表的顺序查找","slug":"search/01.sequential-search/02.有序表的顺序查找","date":"2018-10-18T03:24:02.000Z","updated":"2021-09-13T13:46:13.282Z","comments":true,"path":"oi-acm/search/sequential-search/accc3ff1.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/search/sequential-search/accc3ff1.html","excerpt":"【概述】顺序查找（Sequential search），又称线性查找，其可分为无序表的查找和有序表的查找 若在查找之前，就已经知道查找表中的关键字是有序的，那么此时的顺序查找即有序表的查找","text":"【概述】顺序查找（Sequential search），又称线性查找，其可分为无序表的查找和有序表的查找 若在查找之前，就已经知道查找表中的关键字是有序的，那么此时的顺序查找即有序表的查找 对于有序表的顺序查找来说，当查找失败时，可以不用再比较到表尾，即可返回查找失败的信息，从而降低查找失败的平均查找长度 【查找过程】假设表 $L$ 是从小到大排列的，查找的顺序是从前向后，待查找元素的关键字为 key，当查找到第 $i$ 个元素时，发现第 $i$ 个元素对应的关键字小于 key，但第 $i+1$ 个元素对应的关键字大于 key，此时就可以返回查找失败的信息 这是因为第 $i$ 个元素后的所有元素对应的关键字均大于 key，因此查找表中不存在关键字为 key 的元素 可以用如下图所示的查找判定树来描述有序顺序表的查找过程 树中的圆形结点表示有序顺序表中存在的元素，称为成功结点；矩形结点表示有序顺序表中不存在的数据集合，称为失败结点，若有 $n$ 个成功结点，则相应地有 $n+1$ 个失败结点 【平均查找长度】在有序表的顺序查找中，查找成功的平均查找长度与暴力搜索中的平均查找长度一样，均为： ASL_{成功}=\\sum_{i=1}^n \\frac{1}{n}\\cdot(n-i+1)=\\frac{n+1}{2}而当查找失败时，查找指针一定指向了某个失败结点，但失败结点实际上是不存在的，其只是虚构用来表示查找失败的情况 因此，到达失败结点时，所查找的长度，等于其上一层的成功结点所在的层数，故查找不成功时的平均查找长度为： ASL_{失败}=\\sum_{j=1}^n q_j(l_j-1)其中，$q_j$ 为到达第 $j$ 个失败结点的概率，在查找概率相等的情况下，有 $q_j=\\frac{1}{n+1}$；$l_j$ 为第 $j$ 个失败结点所在的层数 故有： \\begin{align} ASL_{失败} &= \\sum_{j=1}^n q_j(l_j-1) \\notag \\\\ &= \\frac{1}{n+1}\\cdot(1+2+...+n+n) \\notag \\\\ &= \\frac{n}{2}+\\frac{n}{n+1} \\notag \\end{align}","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"查找&搜索","slug":"oi-acm/search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/"},{"name":"顺序查找","slug":"oi-acm/search/sequential-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/sequential-search/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"},{"name":"顺序查找","slug":"sequential-search","permalink":"https://alex-mcavoy.github.io/tags/sequential-search/"}],"author":"Alex_McAvoy"},{"title":"数据库逻辑结构设计","slug":"database/37.数据库逻辑结构设计","date":"2018-10-17T13:11:00.000Z","updated":"2021-08-23T13:45:00.747Z","comments":true,"path":"notes/database/4287dfd6.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/4287dfd6.html","excerpt":"【概述】概念结构是独立于任何一种数据模型的信息结构，逻辑结构设计的任务就是将概念模型设计好的 E-R 图转换为选用 DBMS 支持的数据模型相符合的逻辑结构","text":"【概述】概念结构是独立于任何一种数据模型的信息结构，逻辑结构设计的任务就是将概念模型设计好的 E-R 图转换为选用 DBMS 支持的数据模型相符合的逻辑结构 目前的数据库应用系统都采用支持关系数据模型的 RDBMS，因此这里仅介绍 E-R 图向关系数据模型的转换 【E-R 图向关系模型的转换】E-R 图向关系模型的转换要解决的问题有两个： 如何将实体型和实体间的联系转换为关系模式 如何确定这些关系模式的属性和码 关系模型的逻辑结构是一组关系模式的集合，E-R 图是由实体型、实体属性、实体型间的联系这三个要素组成的，因此将 E-R 图转换为关系模型，实质上就是将上述的三个要素转换为关系模式 将一个实体型转换为一个关系模式，转换的一般原则如下： 1.对于 1:1 联系，可以转换为一个独立的关系模式，与该联系相连的各实体的码及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码；也可与某一端实体对应的关系模式合并，需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性 2.对于 1:m 联系，可以转换为一个独立的关系模式，与该联系相连的各实体的码及联系本身的属性均转换为关系的属性，关系的码为 n 端实体的码；也可与 n 端对应的关系模式合并 3.对于 n:m 联系，可以转换为一个关系模式，与该联系相连的各实体的码及联系本身的属性，均转换为关系的属性，各实体的码组成关系的码或关系码的一部分 4.对于三个或三个以上实体间的多元联系，可以转换为一个关系模式，与该多元联系相连的各实体的码及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分 5.具有相同码的关系模式可以合并，即将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性，并适当调整属性的次序 【数据模型的优化】数据库逻辑设计的结果不是唯一的，为进一步提高数据库系统的性能，应当根据应用需求进行适当的修改、调整数据模型的结构，即数据模型的优化 关系数据模型的优化以规范化理论为指导，具体方法如下： 1.确定数据依赖：按照需求分析阶段得到的语义，分别写出每个关系模式内部各属性间的数据依赖、不同关系模式属性间的数据依赖 2.消除冗余联系：对各关系模式间的数据依赖进行极小化处理，消除冗余的联系 3.确定所属范式：按照数据依赖理论对关系模式逐一分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，从而确定各关系模式分别属于第几范式（并非规范化程度越高的关系就越优，一般来说，3NF 足够） 4.对模式合并或分解：根据需求分析阶段得到的处理要求，分析对于当前的应用环境，这些模式是否合适，以确定是否对某些模式进行合并或分解 5.垂直分解或水平分解：对关系模式进行水平分解或垂直分解，以提高数据操作效率和存储空间利用率","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库概念结构设计","slug":"database/36.数据库概念结构设计","date":"2018-10-17T11:11:00.000Z","updated":"2021-08-23T13:44:40.653Z","comments":true,"path":"notes/database/3ca0768.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/3ca0768.html","excerpt":"【概述】在 数据库概念模型 中，简单介绍了概念模型，这里对概念模型的设计与 E-R 图进行具体介绍 概念结构设计，是将需求分析得到的用户需求抽象为概念模型的过程，这是整个数据库设计的关键，常用的方法有：自顶向下、自底向上、逐步扩张、混合策略，具体内容","text":"【概述】在 数据库概念模型 中，简单介绍了概念模型，这里对概念模型的设计与 E-R 图进行具体介绍 概念结构设计，是将需求分析得到的用户需求抽象为概念模型的过程，这是整个数据库设计的关键，常用的方法有：自顶向下、自底向上、逐步扩张、混合策略，具体内容 抽象是指对实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节，并把这些特性用各种概念精确地加以描述，常用的抽象方法有：分类、聚集、概括 关于设计概念结构的方法和抽象，在软件工程中有详细的介绍，具体不再展开，这里仅介绍 E-R 图 【E-R 图】E-R 图提供了表示实体、属性、联系的方法： 用矩形表示实体，矩形框内写明实体名 用椭圆形表示属性，用无向边将其与相应的实体连接 用菱形表示联系，菱形框内写明联系名，并用无向边分别与有关实体型连接，同时在无向边上表注联系的类型（1:1、1:m、n:m） 如下图，是一个销售管理系统的 E-R 图 【E-R 图的设计】设计步骤E-R 图的设计步骤分为三步为： 选择局部应用 逐一设计分 E-R 图 分 E-R 图集成为总 E-R 图 选择局部应用在多层的数据流图中选择一个适当层次的数据流图，作为设计分 E-R 图的出发点，通常以中层数据流图作为设计分 E-R 图的依据 逐一设计分 E-R 图该步是将各局部应用涉及的数据分别从数据字典中抽取出来，参照数据流图，标定各局部应用中的实体、实体的属性、标识实体的码，同时确定实体之间的联系（1:1、1:m、n:m） 在设计分 E-R 图时，关键是抽象实体与属性，即现实世界中一组具有某些共同特性和行为的对象就可以抽象为一个实体，对象类型的组成成分可以抽象为实体的属性 设计过程遵循两个原则： 属性不能再具有需要描述的性质，即属性必须是不可分的数据项，不能再由另一些属性组成 属性不能与其他实体具有联系，联系只发生在实体之间 分 E-R 图集成为总 E-R 图概述各局部 E-R 图建立好后，还需要对它们进行合并，集成为一个整体的数据概念结构，即总 E-R 图 集成总 E-R 图主要有两步： 合并：解决各分 E-R 图间的冲突，将各分 E-R 图合并起来生成初步 E-R 图 修改与重构：将初步 E-R 图消除不必要的冗余，生成基本 E-R 图 冲突合并分 E-R 图的主要工作就是合理消除各 E-R 图的冲突，即各分 E-R 图间必定存在不一致的地方 冲突分为三类：属性冲突、命名冲突、结构冲突 1.属性冲突 属性冲突主要包含以下两类冲突： 属性域冲突：属性值的类型、取值范围、取值集合不同 属性取值单位冲突：属性的单位不同 属性冲突理论上十分好解决，只需要各部门讨论协商即可 2.命名冲突 命名冲突主要包含以下两类冲突： 同名异义：不同意义的对象在不同的局部应用中有相同的名字 异名同义：同一意义的对象在不同的局部应用中有不同的名字 命名冲突可能发生在实体、联系一级上，也可能发生在属性一级上，其中属性的命名冲突最为常见，处理命名冲突通常也像处理属性冲突一样，通过讨论、协商等行政手段即可解决 3.结构冲突 结构冲突主要包含以下三类冲突： 同一对象在不同应用中具有不同的抽象 同一实体在不同分E-R图中所包含的属性个数和属性排列次序不完全相同 实体之间的联系在不同局部视图中呈现不同的类型 冗余在合并完各分 E-R 图后，形成的是初步 E-R 图，其中可能存在一些冗余数据和实体间冗余联系，冗余数据是指可由基本数据导出的数据，冗余联系是指可由其他联系导出的联系 冗余数据和冗余联系容易破坏数据库的完整性，给数据库的维护增加困难，应当进行消除，消除冗余后的初步 E-R 图称为基本 E-R 图 消除冗余的主要方法是分析法，即采用数据字典与数据流图作为依据，根据数据字典中关于数据项间逻辑关系的说明来消除冗余 如下图，$Q_3=Q_1*Q_2$，$Q_4=\\sum Q_5$，此时 $Q_3$ 和 $Q_4$ 冗余，可以将其消去，同时由于 $Q_3$ 消去，产品与材料间 $m:n$ 联系也应消去 但不是所有的冗余数据与冗余联系都必须消除，有时不得不以冗余数据代价来提高效率，因此在设计概念结构时，哪些信息要保留、要消除必须根据用户的整体需求来确定 如果人为保留了一些冗余数据，应将数据字典中数据关联的说明作为完整性约束条件","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库设计的需求分析","slug":"database/35.数据库设计的需求分析","date":"2018-10-17T05:11:00.000Z","updated":"2021-08-23T13:45:10.946Z","comments":true,"path":"notes/database/38b88178.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/38b88178.html","excerpt":"【需求分析的任务】需求分析的任务是通过详细调查现实世界要处理的对象，充分了解原系统的工作概括，明确用户的各种需求，然后在此基础上确定新系统的功能，并充分考虑今后可能的扩充与改变 调查的重点是数据与处理，通过调查、收集、分析，获得用户对数据库的如下要求：","text":"【需求分析的任务】需求分析的任务是通过详细调查现实世界要处理的对象，充分了解原系统的工作概括，明确用户的各种需求，然后在此基础上确定新系统的功能，并充分考虑今后可能的扩充与改变 调查的重点是数据与处理，通过调查、收集、分析，获得用户对数据库的如下要求： 信息要求：用户要从数据库获取信息的内容与性质 处理要求：用户要完成的数据处理功能 安全性与完整性要求：数据库的安全性、完整性要求 【需求分析的方法】需求分析首先要调查清楚用户的实际要求，与用户达成共识，并分析与表达这些需求 在充分了解用户需求后，还需进一步分析、表达用户的需求，在众多的分析方法中，最简单实用的技术是结构化分析（SA），其从最上层的系统组织机构入手，采用自顶向下、逐层分解的方式分析系统 其过程如下： 1.将系统抽象为数据来源、数据处理、数据存储、数据输出四大部分 2.分解处理功能与数据 分解处理功能：将处理功能的具体内容分解为若干子功能 分解数据：在处理功能逐步分解同时，逐级分解所用数据，形成若干层次的数据流图 表达方法：对于处理逻辑，使用判定表或判定树来表述；对于数据，用数据字典来描述 3.将分析结果报告提交给用户，征得用户认可 【数据字典】概述数据字典是进行详细的数据收集和数据分析获得的主要成果，是关于数据库中数据的描述，即元数据 数据字典是在需求分析阶段建立的，在数据库过程中不断修改、充实、完善，通常包括：数据项、数据结构、数据流、数据存储、处理过程这几部分 其中，数据项是数据的最小组成单位，若干数据项组成一个数据结构，通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容 数据项数据项是不可再分的数据单位，对于数据项的描述结构如下： 1234567891011数据项描述 = &#123; 数据项名, 数据项含义说明, 别名, 数据类型, 长度, 取值范围, 取值含义, 与其他数据项的逻辑关系, 数据项间的联系&#125; 其中，取值范围、与其他数据项的逻辑关系定义了数据的完整性约束条件，是设计数据检验功能的依据 以学生学号为例，其数据项说明如下： 内容 实例 数据项 学号 含义说明 唯一标识每个学生 别名 学生编号 数据类型 字符型 长度 8 取值范围 000000 到 999999 取值含义 前两位标识学生专业，后四位按顺序编号 数据结构数据结构反映了数据项间的组合关系，一个数据结构可由若干数据项组成，也可由若干数据结构组成，或由若干数据项和数据结构混合组成 对于数据结构的描述结构如下： 12345数据结构描述 = &#123; 数据结构名, 数据结构含义说明, 组成: &#123; 数据项 或 数据结构 &#125;&#125; 以学生为例，其数据结构说明如下： 内容 实例 数据结构名 学生 数据结构含义说明 学籍管理系统的主体数据结构，定义了一个学生的有关信息 组成 学号、姓名、性别、年龄、所在专业、年级 数据流数据流是数据结构在系统内的传输路径，对于数据流的描述结构如下： 123456789数据流描述 = &#123; 数据流名, 数据流含义说明, 数据流来源, 数据流去向, 组成: &#123;数据结构&#125;, 平均流量, 高峰期流量&#125; 其中，数据流来源是说明数据流来自哪个过程；数据流去向是说明数据流要到哪个过程去；平均流量是指每天、每周、每月的传输次数；高峰期流量是指高峰时期的数据流量 以为学生体检结果为例，其数据流说明如下： 内容 实例 数据流名 体检结果 数据流说明 学生参加体检的结果 数据流来源 体检 数据流去向 学生体检结果登记表 组成 学号、各项体检结果 平均流量 每天 100 次 高峰期流量 每小时 50 次 数据存储数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一，其可以是手工文档，也可以是计算机文档 对于数据存储的描述结构如下： 1234567891011数据存储描述 = &#123; 数据存储名, 数据存储说明, 数据存储编号, 输入数据流, 输出数据流, 组成: &#123;数据结构&#125;, 数据量, 存取频度, 存取方式&#125; 其中，存取频度是指每天、每周、每月存取次数及每次存取的数据量等信息；存取方式是批处理还是联机处理、是检索还是更新、是顺序检索还是随机检索等；输入数据流要指出来源，输出数据流要指明去向 以为学生体检结果登记表为例，其数据存储说明如下： 内容 实例 数据存储名 学生体检结果登记表 数据存储说明 记录学生体检结果的基本情况 数据存储编号 0001 输入数据流 体检结果 输出数据流 学生体检结果登记表 组成 体检编号、学生学号、学生体检结果 数据量 每年 3000 张 存取频度 每周 100 次 存取方式 随机存取 处理过程处理过程是说明性信息的描述，具体处理逻辑一般用判定表或判定树来描述 对于处理过程的描述结构如下： 1234567处理过程描述 = &#123; 处理过程名, 处理过程说明, 输入: &#123;数据流&#125;, 输出: &#123;数据流&#125;, 处理: &#123;简要说明&#125;&#125; 以为学生分配宿舍为例，其处理过程说明如下： 内容 实例 处理过程名 分配宿舍 处理过程说明 为学生分配宿舍 输入 学生、宿舍 输出 宿舍安排情况 处理 同一间宿舍只能安排同一性别的学生每个宿舍只能安排不超过 6 名学生每个学生的居住面积不小于 3 平方米","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库设计概述","slug":"database/34.数据库设计概述","date":"2018-10-17T02:38:00.000Z","updated":"2021-04-13T11:19:48.553Z","comments":true,"path":"notes/database/8f856c5b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/8f856c5b.html","excerpt":"【概述】数据库设计，广义来讲，是数据库及其应用系统的设计，即设计整个数据库应用系统；狭义来讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，属于数据库应用系统设计的一部分 数据库设计的一般定义为：对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求","text":"【概述】数据库设计，广义来讲，是数据库及其应用系统的设计，即设计整个数据库应用系统；狭义来讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，属于数据库应用系统设计的一部分 数据库设计的一般定义为：对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求 【设计的准备工作】进行数据库设计的前期工作，必不可少的即选定参加设计的人，具体来说，分为以下三类： 自始至终参与数据库设计：系统分析人员、数据库设计人员 主要参与需求分析与数据库运行维护：用户、数据库管理员 实施阶段参与，负责准备软硬件环境与编制程序：程序员、操作员 【设计的基本步骤】按照结构化系统设计的方法，考虑数据库及其应用系统开发的过程，数据库设计分为以下六个阶段： 需求分析：是最困难、最耗费时间的一步，要准确了解与分析用户需求，包括数据与处理 概念结构设计：是整个数据库设计的关键，通过对用户需求进行综合、归纳、抽象，形成一个独立于具体 DBMS 的概念模型 逻辑结构设计：将概念结构转换为某个 DBMS 所支持的数据模型，并对其进行优化 物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构，包括存储结构和存取方法 数据库实施：运用 DBMS 提供的数据库语言及宿主语言，根据逻辑设计和物理设计的结果建立数据库、编制与调试应用程序、组织数据入库、进行试运行 数据库运行与维护：数据库应用系统经过试运行后即可投入正式运行，在数据库系统运行过程中必须不断地对其进行评价、调整、修改 其中，需求分析与概念设计，独立于任何 DBMS，逻辑设计和物理设计与选用的 DBMS 密切相关 这里仅介绍需求分析、概念结构设计、逻辑结构设计，具体见下： 需求分析：点击这里 概念结构设计：点击这里 逻辑结构设计：点击这里 【设计阶段与设计描述】在数据库设计过程中，应将数据库的设计和对数据库中数据处理的设计紧密联系起来，将这两方面的需求分析、抽象、设计、实现在各个阶段同时进行，互相参照、补充，以完善两方面的设计 有关处理特性的设计描述，包括设计原理、采用的设计方法、工具等，在软件工程的课程中有详细介绍，这里仅给出设计过程各个阶段关于数据特性的设计描述 设计阶段 设计描述 需求分析 数字字典、全系统中数据项、数据结构、数据流、数据存取描述 概念结构设计 E-R 图、数据字典 逻辑结构设计 选择关系模型 物理结构设计 存储安排、存取方法选择、存取路径建立 数据库实施 创建数据库模式、装入数据、数据库试运行 数据库运行和维护 性能检测、转储与恢复、数据库重组与重构 【设计过程中的各级模式】数据库设计的不同阶段形成数据库的各级模式，概括来说，在各阶段的模式形成如下： 需求分析：综合各用户的应用需求 概念设计：形成独立于机器特点、各个 DBMS 产品的概念模式（一般为 E-R 图） 逻辑结构设计 将 E-R 图转换成具体的数据库产品支持的数据模型（一般为关系模型），形成数据库逻辑模式 根据用户处理的要求、安全性的考虑，在基本表的基础上建立必要的视图，形成外模式 物理结构设计：根据 DBMS 特点与处理的需要，进行物理存储安排、建立索引，形成数据库内模式 如下图所示","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"暴力搜索","slug":"search/01.sequential-search/01.暴力搜索","date":"2018-10-16T03:24:02.000Z","updated":"2021-09-13T13:39:23.471Z","comments":true,"path":"oi-acm/search/sequential-search/da244316.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/search/sequential-search/da244316.html","excerpt":"【概述】顺序查找（Sequential search），又称线性查找，其可分为无序表的查找和有序表的查找 对无序表的查找即暴力搜索，其核心思想是：将所有情况都列举到线性表或数组中，根据要求找一个合适的维度，枚举每一个元素，并对每一个元素判断其是否符合条件","text":"【概述】顺序查找（Sequential search），又称线性查找，其可分为无序表的查找和有序表的查找 对无序表的查找即暴力搜索，其核心思想是：将所有情况都列举到线性表或数组中，根据要求找一个合适的维度，枚举每一个元素，并对每一个元素判断其是否符合条件 在编程实现上，暴力搜索枚举的内容需要已知，不能在枚举到某个地方的时候出现未知 一般主流的 OJ 中，1000ms 的时间限制下可以运行操作数为 10^7 以内的运算（10^6 以内较保险），所以在采用枚举方法之前最好看一下数据范围，确保整个程序的执行操作数不会超过 10^6~10^7 量级 【模板】123456int search(int a[], int n) &#123; //对长度为n的数组a进行暴力搜索 for (int i = 0; i &lt; n ;i++) &#123; if (a[i] 满足某个条件) return a[i] &#125;&#125; 【平均查找长度】对于含有 $n$ 个元素的查找表，假设枚举到第 $i$ 个元素时，与所给的关键字相同，即需要进行 $n-i+1$ 次关键字的比较 那么，查找成功时，平均查找长度为： ASL=\\sum_{i=1}^nP_i\\cdot(n-i+1)当每个元素的查找概率相等时，有： ASL_{成功}=\\sum_{i=1}^n \\frac{1}{n}\\cdot(n-i+1)=\\frac{n+1}{2}而查找不成功，说明从表首枚举到表尾无一元素与关键字匹配，此时与表中各关键字的比较次数显然是 $n+1$ 次 那么，查找不成功时的平均查找长度为： ASL_{失败}=n+1","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"查找&搜索","slug":"oi-acm/search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/"},{"name":"顺序查找","slug":"oi-acm/search/sequential-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/sequential-search/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"},{"name":"顺序查找","slug":"sequential-search","permalink":"https://alex-mcavoy.github.io/tags/sequential-search/"}],"author":"Alex_McAvoy"},{"title":"范式","slug":"database/33.范式","date":"2018-10-15T14:40:00.000Z","updated":"2021-08-23T13:45:33.168Z","comments":true,"path":"notes/database/29bcc608.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/29bcc608.html","excerpt":"【概述】对于范式来说，数据依赖和函数依赖下定义的码是必不可缺的前置内容，其详细介绍见下： 数据依赖：点击这里 函数依赖下定义的码：点击这里","text":"【概述】对于范式来说，数据依赖和函数依赖下定义的码是必不可缺的前置内容，其详细介绍见下： 数据依赖：点击这里 函数依赖下定义的码：点击这里 关系数据库中的关系是要满足一定条件的，满足不同程度要求的为不同范式，满足最低要求的称为第一范式（1NF），在第一范式中进一步满足要求的称为第二范式（2NF），以此类推，直到第五范式 所谓第几范式，是表示关系的某一种级别，所以常称某一关系模式 $R$ 为第几范式，通常可将范式理解成符合某一级别的关系模式的集合，即 $R$ 属于第几范式，就写为 $R\\in xNF$ 对于各种范式间的关系有：$5NF\\subset 4NF\\subset BCNF \\subset 3NF \\subset 2NF \\subset 1NF$ 简单来说，各范式的特点如下： 1NF：字段是最小的单元，不可再分 2NF：满足 1NF，表中字段必须完全依赖于全部主键 3NF：满足 2NF，非主键外的所有字段必须互不依赖 BCNF：满足 3NF，且主属性内部不能有部分依赖、传递依赖 4NF：满足 3NF，消除多值依赖 5NF（较少探讨）：满足 4NF，消除连接依赖 【1NF】第一范式（1NF）的定义为：若关系模式 $R$ 的每一分量都是不可分割的数据项，则 $R\\in 1NF$ 如下表，就不符合 1NF 的要求 1NF 是所有关系型数据库的最基本要求，在 RDBMS 创建数据表时，如果数据表的设计不符合这个最基本的要求，是无法创建的 也就是说，只要在 RDBMS 中存在的表，一定是满足 1NF 的 如果想要在 RDBMS 中表现出上表中的数据，就要设计成如下表的形式 【2NF】第二范式（2NF）的定义为：若 $R\\in 1NF$ 且每一非主属性完全函数依赖于任何一个候选码，则 $R\\in 2NF$ 下面举一个不是 $2NF$ 的例子 在关系模式 SLC(Sno, Sdept, Sloc, Cno, Grade) 中，Sloc 为学生的住址（每个系的学生住在一个地方），主码为 (Sno, Cno)，那么函数依赖包括： $(Sno, Cno)\\xrightarrow{F} Grade$ $Sno\\rightarrow Sdept$，$(Sno, Cno)\\xrightarrow{P} Sdept$ $Sno\\rightarrow Sloc$，$(Sno, Cno)\\xrightarrow{P} Sloc$ $Sdpt\\rightarrow Sloc$ 该关系模式中 Sdept、Sloc 部分函数依赖于主码，不符合 $2NF$，其存在如下问题： 插入异常：假定插入一个未选课的学生，由于 Cno 为 NULL，无法插入 删除异常：假定某个学生只选了一门课，如果删除了这门课，这个学生的其余信息就丢失了 修改困难：假定某个学生选修了 k 门课，Sdpet、Sloc 重复存储了 k 次，要修改一个学生的 Sdept 时，需要重复修改 $k$ 次 数据冗余量大：假定某个学生选修了 k 门课，Sdpet、Sloc 重复存储了 k 次 可以发现，上述例子符合 $1NF$ 但不符合 $2NF$，存在诸多问题，并不是一个好的关系模式 可以利用投影分解法，将这个符合 $1NF$ 但不符合 $2NF$ 的关系模式分解为两个符合 $2NF$ 的关系模式，以一定程度上减轻原来存在的各种异常情况与数据冗余问题 即将关系模式 SLC(Sno, Sdept, Sloc, Cno, Grade) 中部分函数依赖于主码的非主属性 Sdept、Sloc 分解出去，变为两个关系模式 SC(Sno, Cno, Grade) 和 SL(Sno, Sdept, Sloc)，其中前者的主码是 (Sno, Cno)，后者的主码是 Sno，这样使得非主属性对主码均是完全函数依赖 【3NF】第三范式（3NF）的定义为：若 $R\\in 1NF$ 且 $R$ 中不存在码 $X$、属性组 $Y$、非属性组 $Z\\nsubseteq Y$，使得 $X\\rightarrow Y$，$Y\\rightarrow Z$ 成立，且 $Y\\nrightarrow X$，则 $R\\in 3NF$ 简单来说，$3NF$ 在 $2NF$ 的基础上，消除了非主属性对于码的传递函数依赖，也就是说，如果存在非主属性对于码的传递函数依赖，则不符合 $3NF$ 的要求 如上例，在将关系模式 SLC(Sno, Sdept, Sloc, Cno, Grade) 分解为 SC(Sno, Cno, Grade) 和 SL(Sno, Sdept, Sloc) 后，对于关系模式 SL，其存在函数依赖： $Sno\\rightarrow Sdept$ $Sdept\\rightarrow Sloc$ 在该种情况下，存在非主属性码的函数传递依赖，即：$Sno\\xrightarrow{传递} Sloc$，此时出现修改复杂问题，例如：一个系的学生换了宿舍楼 可以发现，将一个 $1NF$ 分解为多个 $2NF$ 后，并不能完全消除关系模式中的异常情况和数据冗余，此时可以利用投影分解法，进一步进行分解，消除传递函数依赖 即将关系模式 SL(Sno, Sdept, Sloc) 分解为两个满足 $3NF$ 的关系模式 SD(Sno, Sdept) 和 DL(Sdept, Sloc) 符合 $3NF$ 要求的数据库设计，基本上解决了数据冗余过大与各种异常问题，在实际应用上，往往为了性能上或者应对扩展的需要，做到 $2NF$ 或者 $1NF$ 即可 【BCNF】$BCNF$ 比 $3NF$ 更进了一步，通常被认为是修正的第三范式，其定义为：若 $R\\in 1NF$ 且 $X\\rightarrow Y$ 且 $Y\\nsubseteq X$ 时，$X$ 必包含码，则 $R\\in BCNF$ 简单来说，如果对于一个关系模式 $R$，如果每一个决定属性因素都包含有码，那么 $R\\in BCNF$ 由 $BCNF$ 的定义可以得到如下结论，即一个满足 $BCNF$ 的关系模式有： 所有非主属性对每一个码都是完整函数依赖 所有主属性对每一个不包含它的码都是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性 由于 $R\\in BCNF$ 按定义排除了任何属性对码的传递依赖与部分依赖，因此 $R\\in 3NF$，但是如果 $R\\in 3NF$，未必有 $R\\in BCNF$ 例如，对于仓库管理关系 WM(Wno, Mno, Ano, Num)，其中 Wno 为仓库号，Ino 为物品号，Ano 为管理员号，Num 为物品数量，满足一个管理员仅在一个仓库工作，一个仓库可以存储多种物品，则存在以下关系： $(Wno, Ino)\\rightarrow (Ano, Num)$ $(Ano, Num)\\rightarrow (Wno, Ino)$ 可以发现，$(Wno, Ino)$ 和 $(Ano, Num)$ 都是该关系的候选码，表中唯一非关键字段是数量 Num，这个关系是符合 $3NF$ 的 但由于存在如下关系： $Wno \\rightarrow Ano$ $Ano\\rightarrow Wno$ 即存在关键字段决定关键字段的情况，这是不符合 $BCNF$ 的，此时可以利用投影分解法，进一步进行分解，消除属性对码的依赖 即将关系模式 WM(Wno, Ino, Ano, Num) 分解为两个满足 $BCNF$ 的关系模式 WA(Wno, Ano) 和 WI(Wno, Ino, Num) 【4NF】第四范式（4NF）的定义为：若关系模式 $R\\in 1NF$ 且对于 $R$ 的每个非平凡多值依赖 $X\\rightarrow\\rightarrow Y (Y\\nsubseteq X)$，$X$ 都有码，则 $R\\in 4NF$ 简单来说，如果 $R\\in 4NF$，则： 不允许有非平凡且非函数依赖的多值依赖 允许有非平凡多字依赖是函数依赖 【如何判断关系 R 是第几范式】已知一个关系模式的属性之间的语义，也就是相互依赖的关系，如何判断该模式满足第几范式？ 1.首先要通过语义把属性之间的函数依赖关系列出来 2.然后确定哪些属性组合可以候选码，从而找出非主属性和主属性 3.然后判断是否存在非主属性与码之间的部分函数依赖关系，如果存在，则不满足 2NF，如不存在部分函数依赖，则属于 2NF 4.继续进行下一步判断，判断非主属性与码之间存在传递依赖关系，不存在，则为 3NF 5.决定因素是否包含码，满足条件则为 BCNF","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"函数依赖下的码","slug":"database/32.函数依赖下的码","date":"2018-10-15T13:04:00.000Z","updated":"2021-08-23T14:03:19.212Z","comments":true,"path":"notes/database/7fa3d81d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/7fa3d81d.html","excerpt":"【候选码与主码】设 $K$ 是 $R &lt; U,F &gt;$ 中的属性或属性组合，若 $K\\xrightarrow{F} U$，则称 $K$ 为 $R$ 的候选码（Candidate Key），若候选码多于一个，则选定其中一个为主码（Primary Key） 例如，在关系模式 student(Sno, Sname, Sage) 中，Sno 是可以唯一标识一个元组的，同样的 (Sno, Sage) 也可以唯一标识一个元组，但这个组合不能称为候选码，因为即使去掉 Sname 属性，剩下的 Sno 也完全可以唯一标识一个元组","text":"【候选码与主码】设 $K$ 是 $R &lt; U,F &gt;$ 中的属性或属性组合，若 $K\\xrightarrow{F} U$，则称 $K$ 为 $R$ 的候选码（Candidate Key），若候选码多于一个，则选定其中一个为主码（Primary Key） 例如，在关系模式 student(Sno, Sname, Sage) 中，Sno 是可以唯一标识一个元组的，同样的 (Sno, Sage) 也可以唯一标识一个元组，但这个组合不能称为候选码，因为即使去掉 Sname 属性，剩下的 Sno 也完全可以唯一标识一个元组 简单来说，候选码就是可以唯一标识一个元组的最少的属性集合 【主属性与非主属性】包含在任何一个候选码中的属性称为主属性（Prime Attribute），不包含在任何码中的属性称为非主属性（Non-prime Attribute）或非码属性（Non-key Attribute） 简单来说，一个表可以有多个候选码，对于某个属性来说，如果这个属性存在于所有的候选码中，那么这个属性就是主属性；反之，如果一个属性不在任何码中，那么这个属性就是非主属性 【全码】最简单的情况下，单个属性为码；最极端的情况下，整个属性组为码，称为全码（All-key） 例如，在选课关系模式 SC(Sno, Cno) 中，(Sno, Cno) 共同标识一个元组，那么 (Sno, Cno) 即为全码 【外码】关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的外码（Foreign Key） 由此，关系间的联系可以通过主码与外码联系 例如，在 SC(Sno, Cno, Grade) 中，(Sno, Cno) 是主码，而 Sno 不是码，但在 student(Sno, Sname, Sage) 中，Sno 是主码，因此 Sno 是关系模式 SC 的外码","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"树、二叉树、森林的相互转换","slug":"data-structure/04.tree-binary-tree/05.树、二叉树、森林的相互转换","date":"2018-10-15T06:59:00.000Z","updated":"2021-09-02T13:46:50.226Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/c104fe4d.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/c104fe4d.html","excerpt":"【树的遍历】树中最基本的操作是遍历，从根结点出发，按照某种次序访问树中的所有结点，使得每个结点仅被访问一次 根据树的定义可知：一棵树由根结点和 $m$ 棵子树构成，因此只要递归的遍历根结点和 $m$ 棵子树即可遍历整棵树","text":"【树的遍历】树中最基本的操作是遍历，从根结点出发，按照某种次序访问树中的所有结点，使得每个结点仅被访问一次 根据树的定义可知：一棵树由根结点和 $m$ 棵子树构成，因此只要递归的遍历根结点和 $m$ 棵子树即可遍历整棵树 树的遍历通常分为三种方式： 前序遍历：先访问根结点，再从左到右遍历各棵子树（实质：DFS） 后序遍历：先从左到右遍历各棵子树，再访问根结点（实质：DFS） 层次遍历：按层次从小到大逐个访问，同一层次按照从左到右的次序（实质：BFS） 从树的孩子兄弟表示法和二叉树的二叉链表表示法可以看出，树的孩子兄弟表示法实质上是二叉树的二叉链表存储形式，因此，从物理结构上来看，两者是相同的，只是解释不同 因此，以二叉链表为媒介，可导出树与二叉树间的对应关系，也就是说，给出一棵树，可以找到一棵唯一的二叉树与之对应，这样一来，对树的操作即可借助二叉树的存储，利用二叉树上的操作实现 根据树与二叉树的转换关系以及二叉树的遍历操作可知： 树的前序遍历 $&lt;=&gt;$ 二叉树的前序遍历 树的后序遍历 $&lt;=&gt;$ 二叉树的中序遍历 【森林的遍历】$m（m&gt;=0）$棵互不相交的树的集合称为森林（forest） 森林有两种遍历方法：森林的前序遍历、森林的后序遍历 根据森林与二叉树的转换关系以及二叉树的遍历操作可知： 森林的前序遍历 $&lt;=&gt;$ 森林中每棵树的前序遍历 $&lt;=&gt;$ 二叉树的前序遍历 森林的后序遍历 $&lt;=&gt;$ 森林中每棵树的后序遍历 $&lt;=&gt;$ 二叉树的中序遍历 【树转二叉树】将一棵树转为二叉树的方法是： 1）加线：树中所有相邻兄弟结点间加一条线 2）去线：对树中的每个结点，只保留他与第一个子结点的连线，删除与其他子结点的连线 3）层次调整：以根结点为轴心，将树顺时针旋转一定角度，使之层次分明 【森林转二叉树】森林是若干棵树的集合，将森林转成二叉树时，只要先将森林中的每棵树转为二叉树，再将每棵树的根结点视为兄弟即可 将森林转为二叉树的方法是： 1）转树：将森林中的每棵树转换成二叉树 2）连接：从第二棵树二叉树开始，依次将后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子 【二叉树转树或森林】树和森林都能转成二叉树，二者的不同是树转成的二叉树其根结点无右子树，森林转成的二叉树其根结点有右子树 显然，这一转换过程是可逆的，即：根据二叉树的根结点有无右子树，将其还原成树或森林 将一棵二叉树转成树或森林的方法是： 1）加线：若某结点 $x$ 是其双亲 $y$ 的左孩子，则把结点 $x$ 的右孩子、右孩子的右孩子$…$，都与结点 $y$ 用线连起来 2）去线：删去原二叉树中所有的双亲结点与右孩子结点的连线 3）层次调整：整理 1）、2）步得到的树或森林，使之层次分明","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"数据依赖","slug":"database/31.数据依赖","date":"2018-10-15T06:57:00.000Z","updated":"2021-08-23T13:45:18.622Z","comments":true,"path":"notes/database/74458c25.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/74458c25.html","excerpt":"【函数依赖】函数依赖设 $R(U)$ 是属性集 $U$ 上的关系模式，$X$、$Y$ 是 $U$ 的子集，若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而 $Y$ 上的属性值不等，则称 $X$ 函数确定 $Y$，或 $Y$ 函数依赖于 $X$，记作：$X\\rightarrow Y$","text":"【函数依赖】函数依赖设 $R(U)$ 是属性集 $U$ 上的关系模式，$X$、$Y$ 是 $U$ 的子集，若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而 $Y$ 上的属性值不等，则称 $X$ 函数确定 $Y$，或 $Y$ 函数依赖于 $X$，记作：$X\\rightarrow Y$ 需要指出的是： 1.函数依赖不是指关系模式 $R$ 的某个或某些关系满足的约束条件，而是指 $R$ 的一切关系均要满足的约束条件，即所有的关系实例均要满足 2.函数依赖与其他的数据依赖均是语义范畴的概念，即只能根据语义来确定一个函数依赖，例如：姓名 $\\rightarrow$ 年龄这个函数依赖只能在没有同名人的情况下成立 3.数据库设计者可以对现实世界作强制性规定，例如：规定不允许有同名人出现，从而使得姓名 $\\rightarrow$ 年龄这个函数依赖成立，这样当插入某个元组时发现有同名人，则拒绝插入该元组 平凡与非平凡函数依赖在关系模式 $R(U)$ 中，对于 $U$ 的子集 $X$、$Y$： 如果 $X\\rightarrow Y$，但 $Y \\subseteq X$，则称 $X\\rightarrow Y$ 是平凡的函数依赖 如果 $X\\rightarrow Y$，但 $Y \\nsubseteq X$，则称 $X\\rightarrow Y$ 是非平凡的函数依赖 例如，在关系 SC(Sno, Cno, Grade) 中，(Sno, Cno) → Sno 和 (Sno, Cno) → Cno 是平凡函数依赖，(Sno, Cno) → Grade 是非平凡的函数依赖 对于任一关系模式，平凡函数依赖都是必然成立的，其不反映新的语义，因此，若不特别声明，讨论的总是非平凡函数依赖 完全与部分函数依赖在介绍完全函数依赖与部分函数依赖前，先给出以下几个定义： 若 $X\\rightarrow Y$ ，则 $X$ 称为这个函数依赖的决定属性组，也称为决定因素 若 $X\\rightarrow Y$ 且 $Y\\rightarrow X$，则记作：$X\\leftarrow\\rightarrow Y$ 若 $Y$ 不依赖于 $X$，则记作：$X\\nrightarrow Y$ 在 $R(U)$ 中，如果 $X\\rightarrow Y$，且对于 $X$ 的任何一个真子集 $X’$，都有 $X’ \\nrightarrow Y$，则称 $Y$ 对 $X$ 完全函数依赖，记作：$X\\xrightarrow{F}Y$ 若 $X\\rightarrow Y$，但 $Y$ 不完全函数依赖于 $X$，则称 $Y$ 对 $X$ 部分函数依赖，记作：$X\\xrightarrow{P}Y$ 例如，在关系 SC(Sno, Cno, Grade, Sdept) 中，(Sno, Cno) → Grade 是完全函数依赖，(Sno, Cno) → Sdept 是部分函数依赖，因为 Sno → Sdept 成立，而 Sno 是 (Sno, Cno) 的真子集 直接与传递函数依赖在 $R(U)$ 中，如果满、$X\\leftarrow\\rightarrow Y$、$Y\\rightarrow Z$ 则称 $Z$ 对 $X$ 直接函数依赖，记为：$X\\xrightarrow{直接}Y$ 在 $R(U)$ 中，如果满足 $X\\rightarrow Y$、$Y\\nrightarrow X$、$Y\\rightarrow Z$，则称 $Z$ 对 $X$ 传递函数依赖，记为：$X\\xrightarrow{传递}Y$ 例如，在关系 SC(Sno, Cno, Grade, Sdept, Mname) 中，有 Sno → Sdept ，Sdept → Mname 成立，故有传递函数依赖 Sno → Mname 属性间联系决定函数依赖关系假如 $X$、$Y$ 有 $1:1$ 关系，则：$X\\rightarrow Y$ 且 $Y\\rightarrow X$，可表示为 $X\\leftarrow\\rightarrow Y$ 假如 $X$、$Y$ 有 $1:m$ 关系，则：$Y\\rightarrow X$，但 $X\\nrightarrow Y$ 假如 $X$、$Y$ 有 $n:m$ 关系，则：$X$、$Y$ 不存在任何函数依赖 【多值依赖】引入对于 1NF、2NF、3NF、BCNF 来说，都是在函数依赖的范畴内进行讨论，但 BCNF 并非十分完美（关于范式：点击这里） 如下例，学校中某一门课程由多个教师教授，使用相同的参考书，每个教师可以讲授多门课程，每种参考书可以供多门课程使用，可以用一个非规范化的关系来表示教师 T、课程 C、参考书 B 间的关系 可以将这个关系以非规范化的形式列出，如下表 可以发现，关系模式 teaching(C, T, B) 的码 $(C, T, B)$ 是全键（All-Key），其属于 BCNF，将其转为规范化的二维表，如下 当某一课程增加一名教师时，必须插入多个元组，例如：物理课程添加一名讲课老师张三时，要插入三个元组 (物理, 张三, 普通物理学)、(物理, 张三, 光学原理)、(物理, 张三, 物理习题集) 这对数据的增删改十分不方便，数据的冗余性也十分明显，考察这类的关系模式，发现其具有一种称为多值依赖的数据依赖 多值依赖设 $R(U)$ 是属性集 $U$ 上的一个关系模式，$X$、$Y$、$Z$ 是 $U$ 的子集，且 $Z=U-X-Y$，当且仅当满足对 $R(U)$ 的任一关系 $r$，给定一对 $(x,z)$ 值，有一组 $y$ 值，且这组值仅决定于 $x$ 值而与 $z$ 值无关时 ，关系模式 $R(U)$ 中多值依赖成立，记作：$X\\rightarrow\\rightarrow Y$ 例如，在关系模式 teaching(C, T, B) 中，对于一个 (物理, 光学原理) 有一组 $T$ 值 {李勇, 王军}，这组值仅决定于课程 $C$ 上的值，即对于另一组值 (物理, 普通物理学) 来说，尽管此时参考书 $B$ 的值已经改变，但其对应的一组 $T$ 值仍为 {李勇, 王军}，因此 $T$ 多值依赖于 $C$，即：$C\\rightarrow\\rightarrow T$ 平凡与非平凡多值依赖若 $X\\rightarrow\\rightarrow Y$，而 $Z=\\phi$，即 $Z$ 为空，则称 $X\\rightarrow\\rightarrow Y$ 为平凡的多值依赖 若 $X\\rightarrow\\rightarrow Y$，而 $Z\\neq \\phi$，即 $Z$ 不为空，则称 $X\\rightarrow\\rightarrow Y$ 为非平凡的多值依赖 一般来说，常见的多值依赖均为非平凡多值依赖 多值依赖的性质多值依赖具有以下性质： 1.对称性：若 $X\\rightarrow\\rightarrow Y$，则 $X\\rightarrow\\rightarrow Z$，其中 $Z=U-X-Y$ 2.传递性：若 $X\\rightarrow\\rightarrow Y$，$Y\\rightarrow\\rightarrow Z$，则 $X\\rightarrow\\rightarrow Z-Y$ 3.函数依赖是多值依赖的特殊情况：若 $X\\rightarrow Y$，则 $X\\rightarrow\\rightarrow Y$ 4.若 $X\\rightarrow\\rightarrow Y$ 且 $X\\rightarrow\\rightarrow Z$，则 $X\\rightarrow\\rightarrow Y\\cup Z$ 5.若 $X\\rightarrow\\rightarrow Y$ 且 $X\\rightarrow\\rightarrow Z$，则 $X\\rightarrow\\rightarrow Y\\cap Z$ 6.若 $X\\rightarrow\\rightarrow Y$ 且 $X\\rightarrow\\rightarrow Z$，则 $X\\rightarrow\\rightarrow Y-Z$ 且 $X\\rightarrow\\rightarrow Z-Y$ 【函数依赖与多值依赖的关系】函数依赖是多值依赖的特殊情况，即当 $X\\rightarrow Y$ 时，有 $X\\rightarrow\\rightarrow Y$，这是因为，当 $X\\rightarrow Y$ 时，对 $X$ 的每个值 $x$，$Y$ 都有一个确定值 $y$ 与其对应 但多值依赖与函数依赖相比，有以下两个区别： 1.多值依赖的有效性与属性集范围有关 若 $X\\rightarrow\\rightarrow Y$ 在 $U$ 上成立，则在 $W(XY\\subseteq W\\subseteq U)$上一定成立 反之不然，即若 $X\\rightarrow\\rightarrow Y$ 在 $W(XY\\subseteq W\\subseteq U)$上成立，则在 $U$ 上不一定成立 这是因为多值依赖的定义中不仅涉及属性组 $X$ 和 $Y$，还涉及 $U$ 中其余属性 $Z$ 一般地，在 $R(U)$ 上若有 $X\\rightarrow\\rightarrow Y$ 在 $W(W\\subset U)$ 上成立，则称 $X\\rightarrow\\rightarrow Y$ 为 $R(U)$ 的嵌入型多值依赖 2.多值依赖的子集不成立性 若函数依赖 $X\\rightarrow Y$ 在 $R(U)$ 上成立，则对于任何 $Y’\\subset Y$ 均有 $X\\rightarrow Y$ 若多值依赖 $X\\rightarrow\\rightarrow Y$ 在 $R(U)$ 上成立，无法断言对于任何 $Y’\\subset Y$ 有 $X\\rightarrow\\rightarrow Y$ 成立","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"关系数据理论","slug":"database/30.关系数据理论","date":"2018-10-15T05:54:00.000Z","updated":"2021-08-23T13:44:24.197Z","comments":true,"path":"notes/database/91f1e6ed.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/91f1e6ed.html","excerpt":"【问题的提出】之前已经介绍过关系数据库的基本概念、关系模型的三部分、关系数据库的标准语言 SQL，但有一个很基本的问题没有涉及：针对一个具体问题，应该如何构造一个适合它的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等 这个问题确切来讲是关系数据库逻辑设计问题，由于关系模型有严格的数学理论基础，且可以向别的数据模型转换，因此，以关系模型为背景讨论这个问题，形成了数据库逻辑设计的一个有力工具，即关系数据库规范化理论","text":"【问题的提出】之前已经介绍过关系数据库的基本概念、关系模型的三部分、关系数据库的标准语言 SQL，但有一个很基本的问题没有涉及：针对一个具体问题，应该如何构造一个适合它的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等 这个问题确切来讲是关系数据库逻辑设计问题，由于关系模型有严格的数学理论基础，且可以向别的数据模型转换，因此，以关系模型为背景讨论这个问题，形成了数据库逻辑设计的一个有力工具，即关系数据库规范化理论 【关系模式】在 关系数据结构 中介绍过，一个关系模式是一个五元组 $R(U,D,DOM,F)$ 其中，关系名 $R$ 是符号化的元组语义，$U$ 为一组属性，$D$ 为属性组 $U$ 中属性来自的域，$DOM$ 为属性到域的映射，$F$ 为属性组 $U$ 上的一组数据依赖 由于 $D$、$DOM$ 与模式设计关系不大，因此在研究关系数据理论时，可将关系模式看作一个三元组 $R$，当且仅当 $U$ 上的一个关系 $r$ 满足 $F$ 时，称 $r$ 为关系模式 $R$ 的一个关系 【关系模式的设计】概述在模式设计中，假设已知一个模式 $S\\phi$，其仅由单个关系模式组成，问题是要设计一个模式 $SD$，其与 $S\\phi$ 等价，但在某些指定的方面更好一些 评价一个关系模式是否足够好，主要是看两方面：避免数据冗余、避免数据更新时的各种异常，如果能达到上述的两点，则可以认为该关系模式是一个好的模式 如果一个关系模式 $R$ 的并不是一个好模式的话，就要将其分解成多个模式的集合 $\\{R_1,R_2,…,R_n\\}$，从而保证每个模式是一个好模式，并且分解是无损连接的 分解模式的理论依据有： 数据依赖：函数依赖、多值依赖 规范化理论：范式（NF） 数据依赖数据依赖是一个关系内部属性与属性间的约束关系，这种约束关系是通过属性间的值是否相等来体现数据间相关联系的，其是客观世界属性间相互联系的抽象，是数据内在的性质、语义的体现 简单来说，对于客观世界中事物，实体与实体间的联系是通过数据模型来体现的，实体内部属性间的联系是通过数据依赖来体现的 目前，已经提出了多种数据依赖，其中最重要的是函数依赖（FD）和多值依赖（MVD） 关于数据依赖的具体介绍：点击这里 码码是关系模式中的一个重要概念，其与范式息息相关，在 关系数据结构 中介绍过码的概念，这里用函数依赖的概念来定义码 关于函数依赖下的码的具体介绍：点击这里 规范化规范化是用来改造关系模式的，通过分解关系模式来消除其中不合适的数据依赖，以解决插入、删除、更新异常，以及数据冗余问题 简单来说，所谓规范化，就是将低一级的范式通过模式分解，转换为若干高一级关系模式的集合 关于范式的具体介绍：点击这里","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"二叉树的遍历","slug":"data-structure/04.tree-binary-tree/07.二叉树的遍历","date":"2018-10-15T03:48:00.000Z","updated":"2021-08-31T08:13:15.353Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/ea4681d0.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/ea4681d0.html","excerpt":"【概述】树中最基本的操作是遍历，即从根结点出发，按照某种次序访问树中的所有结点，使得每个结点仅被访问一次 在二叉树中，有两种遍历方式，一种是基于树的递归特性的前/中/后序遍历，一种是基于树的层次特性的层次遍历","text":"【概述】树中最基本的操作是遍历，即从根结点出发，按照某种次序访问树中的所有结点，使得每个结点仅被访问一次 在二叉树中，有两种遍历方式，一种是基于树的递归特性的前/中/后序遍历，一种是基于树的层次特性的层次遍历 【访问函数】通常来说，二叉树都是使用二叉链表实现的，即： 123456789typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;bool initBiTree(BiTree &amp;root) &#123; //初始化 root = NULL; //空树 return true;&#125; 在使用二叉链表实现的二叉树中，从构建二叉树，到求二叉树的深度，以及求叶结点个数等操作，都是在遍历操作基础上来进行的，因此在实际应用时，在遍历操作的基础上修改访问函数 visit() 即可得到大部分操作 1234567void visit(BiTree p) &#123; //访问 //根据实际需要更改该函数 if (p == NULL) printf(\"null\\n\"); else printf(\"%d\\n\", p-&gt;data);&#125; 【前中后序遍历的递归实现】前序遍历前序遍历，是按照根结点、左子树、右子树的顺序对二叉树进行遍历 1234567void preOrder(BiTree root) &#123; //递归先序遍历 if (root == NULL) return; visit(root); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild);&#125; 中序遍历中序遍历，是按照左子树、根结点、右子树的顺序对二叉树进行遍历 1234567void inOrder(BiTree root) &#123; //递归中序遍历 if (root == NULL) return; inOrder(root-&gt;lchild); visit(root); inOrder(root-&gt;rchild);&#125; 后序遍历后序遍历，是按照左子树、右子树、根结点的顺序对二叉树进行遍历 1234567void postOrder(BiTree root) &#123; //递归后序遍历 if (root == NULL) return; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); visit(root);&#125; 【前中后序遍历的非递归实现】前序遍历对于前序遍历，其非递归算法如下： 1）每遇到一个结点，若其不空，首先访问该结点，然后将其压入栈中，再访问它的左孩子，若当前结点为空且栈空时，算法结束 2）若其左孩子不空，转到步骤 1） 3）若其左孩子为空，说明已经到达该子树的最左底端，此时从栈中取出其父结点，访问父结点的右孩子，转到步骤 1） 123456789101112131415void preOrderByStack(BiTree root)&#123;//非递归前序遍历 stack&lt;BiTree&gt; S; BiTree p = root; //工作指针 while (p != NULL || !S.empty()) &#123; if (p != NULL) &#123; //当前结点存在 visit(p); S.push(p); //当前结点入栈 p = p-&gt;lchild; //指向其左孩子 &#125; else &#123; //当前结点不存在，到达子树最底端 p = S.top(); //从栈中获取当前结点的父结点 S.pop(); //父结点出栈 p = p-&gt;rchild; //访问父结点的右孩子 &#125; &#125;&#125; 中序遍历对于中序遍历，其非递归算法如下： 1）每遇到一个结点，若其不空，首先将其压入栈中，再访问它的左孩子，若当前结点为空且栈空时，算法结束 2）若其左孩子不空，转到步骤 1） 3）若其左孩子为空，说明已经到达该子树的最左底端，此时从栈中取出其父结点，访问该结点，再访问父结点的右孩子，转到步骤 1） 12345678910111213141516void inOrderByStack(BiTree root) &#123; //非递归中序遍历 stack&lt;BiTree&gt; S; BiTree p = root; //工作指针 while (p != NULL || !S.empty()) &#123; if (p != NULL) &#123; //当前结点存在 S.push(p); //当前结点入栈 p = p-&gt;lchild; //指向其左孩子 &#125; else &#123; //当前结点不存在，到达子树最底端 p = S.top(); //从栈中获取当前结点的父结点 visit(p); S.pop(); //父结点出栈 p = p-&gt;rchild; //访问父结点的右孩子 &#125; &#125;&#125; 后序遍历后序遍历要求先访问左子树和右子树后再访问根结点，在进行后序遍历时，首先访问左孩子，将父结点存于栈中，但当元素弹出时，如果利用非递归的前序中序遍历的思想，无法判断此时该访问右孩子还是访问父结点，因此其非递归实现需要一个标记，用于记录该结点的右孩子是否被访问过 后序遍历的非递归算法如下： 1）每遇到一个结点，若其不空，将其标记设为 0，代表其右孩子未被访问，然后将其压入栈中，再访问其左孩子，若当前结点为空且栈空时，算法结束 2）若其左孩子不空，转到步骤 1） 3）若其左孩子为空，说明已经到达该子树的最左底端，此时从栈中取出一个结点，通过标记判断右孩子是否被访问过 4）若取出结点的标记为 0，说明该结点的右孩子未被访问过，那么将标记改为 1，重新压入栈中，访问该结点的右孩子，转到步骤 1） 5）若取出结点的标记为 1，说明该结点的左右孩子均被访问过，访问该结点 6）若当前结点为空，但栈非空，说明已到达该子树的最右底端，此时从栈中取出一个结点，判断该结点的标记，若标记为 0，转到步骤 4），若标记为 1，转到步骤 5） 12345678910111213141516171819202122232425262728293031void postOrderByStack(BiTree root) &#123; //非递归后序遍历 struct stackNode &#123; BiTree t; int tag; &#125;; stack&lt;stackNode&gt; S; BiTree p = root; //工作指针 while (p != NULL || !S.empty()) &#123; if (p != NULL) &#123; //当前结点存在 stackNode temp; temp.t = p; temp.tag = 1; //父结点标记设为 1 S.push(temp); p = p-&gt;lchild; //访问左孩子 &#125; else &#123; //当前结点不存在，到达子树最底端 stackNode temp; temp = S.top(); //当前栈顶元素 S.pop(); if (temp.tag == 1) &#123; //右孩子未被访问过 temp.tag = 0; //改变当前结点访问状态 S.push(temp); //将该结点重新压入栈中 p = temp.t-&gt;rchild; //访问该结点的右孩子 &#125; else //右孩子已被访问过，访问该结点 visit(temp.t); &#125; &#125;&#125; 说明：在后序遍历的非递归实现中，当访问一个结点 p 时，栈中的结点恰好是 p 的所有祖先，从栈底到栈顶的结点再加上 p，就构成了从根到结点 p 的一条路径，利用该思想，可以求解根到某结点的路径、求两结点的最近公共祖先 【层次遍历】层序遍历，是按层序从小到大逐个访问，同一层次按照从左到右的顺序访问 123456789101112131415void levelOrder(BiTree root) &#123; //层序遍历 queue&lt;BiTree&gt; Q; if (root != NULL) //根结点加入队列 Q.push(root); BiTree p; while (!Q.empty()) &#123; BiTree p = Q.front(); //取队首元素 Q.pop(); visit(p); //访问该结点 if (p-&gt;lchild != NULL) //左孩子加入队列 Q.push(p-&gt;lchild); if (p-&gt;rchild != NULL) //右孩子加入队列 Q.push(p-&gt;rchild); &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"树的数据生成器","slug":"data-structure/04.tree-binary-tree/06.树的数据生成器","date":"2018-10-13T06:56:00.000Z","updated":"2021-08-31T08:13:08.846Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/f5a3043d.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/f5a3043d.html","excerpt":"为方便测试与树相关的算法而编写的树的随机数据生成器 树的结点为 1~10 个，边权为 1~100，各点编号随机化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;ctime&gt;using namespace std;#define N 50struct Edge &#123; int x, y; int dis;&#125; edge[N];int n,edgeTot;int tot, x[N], y[N], dis[N];int id[N], father[N];int Find(int x) &#123; return father[x] == x ? x : Find(father[x]); &#125;int main() &#123; srand(time(0)); n = rand() % 10 + 1; printf(\"%d\\n\", n); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; x[++tot] = i; y[tot] = j; dis[tot] = rand() % 100 + 1; &#125; &#125; for (int i = 1; i &lt;= tot; ++i)&#123; id[i] = i; father[i] = i; &#125; random_shuffle(id + 1, id + tot + 1); for (int i = 1; i &lt;= tot; ++i) &#123; int pos = id[i]; int fx = Find(x[pos]); int fy = Find(y[pos]); if (fx == fy) continue; father[fy] = fx; edge[++edgeTot].x = x[pos]; edge[edgeTot].y = y[pos]; edge[edgeTot].dis = dis[pos]; if (edgeTot == n - 1) break; &#125; for ( int i = 1; i &lt;= edgeTot; i++) printf(\"%d %d %d\\n\", edge[i].x, edge[i].y, edge[i].dis); system(\"pause\"); return 0;&#125;","text":"为方便测试与树相关的算法而编写的树的随机数据生成器 树的结点为 1~10 个，边权为 1~100，各点编号随机化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;ctime&gt;using namespace std;#define N 50struct Edge &#123; int x, y; int dis;&#125; edge[N];int n,edgeTot;int tot, x[N], y[N], dis[N];int id[N], father[N];int Find(int x) &#123; return father[x] == x ? x : Find(father[x]); &#125;int main() &#123; srand(time(0)); n = rand() % 10 + 1; printf(\"%d\\n\", n); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; x[++tot] = i; y[tot] = j; dis[tot] = rand() % 100 + 1; &#125; &#125; for (int i = 1; i &lt;= tot; ++i)&#123; id[i] = i; father[i] = i; &#125; random_shuffle(id + 1, id + tot + 1); for (int i = 1; i &lt;= tot; ++i) &#123; int pos = id[i]; int fx = Find(x[pos]); int fy = Find(y[pos]); if (fx == fy) continue; father[fy] = fx; edge[++edgeTot].x = x[pos]; edge[edgeTot].y = y[pos]; edge[edgeTot].dis = dis[pos]; if (edgeTot == n - 1) break; &#125; for ( int i = 1; i &lt;= edgeTot; i++) printf(\"%d %d %d\\n\", edge[i].x, edge[i].y, edge[i].dis); system(\"pause\"); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"SQL 的空值处理","slug":"database/29.SQL的空值处理","date":"2018-10-11T09:13:00.000Z","updated":"2021-08-23T13:56:38.235Z","comments":true,"path":"notes/database/cbaf099f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/cbaf099f.html","excerpt":"【空值的产生】在向基本表中插入一个元组时，若还不知道具体的值，可以显式的指定空值 例如，向 sc 表中插入一个元组（学生号：3，课程号：1，成绩：空）","text":"【空值的产生】在向基本表中插入一个元组时，若还不知道具体的值，可以显式的指定空值 例如，向 sc 表中插入一个元组（学生号：3，课程号：1，成绩：空） 123INSERT INTO sc(Sno, Cno, Grade)VALUES(3, 1, NULL); 在插入语句 INSERT 中没有赋值的属性，RDBMS 将自动赋为空值 123INSERTINTO sc(Sno, Cno)VALUES(3, 1); 在修改语句 UPDATE 中，可以直接将元组的属性赋为空值 例如，将 student 表中学生号为 1 的学生的所属系设为空值 123UPDATE studentSET Sdept = NULLWHERE Sno = 1; 此外，外连接也会产生空值，详见：SQL 连接查询 【空值的判断】用 IS NULL 或 IS NOT NULL 来判断一个属性的值是否为空值 例如，从 student 表中，找出所属系或年龄为空的学生信息 1234SELECT *FROM studentWHERE Sdept IS NULL OR Sage IS NULL; 【空值的约束条件】对于以下三种情况，不能取空值： 对于定义有 NOT NULL 约束条件的属性，不能取空值 对于定义有 UNIQUE 约束条件的属性，不能取空值 对于码属性（主码、外码），不能取空值 【空值的运算】空值的运算有算术运算、比较运算、逻辑运算 其中，空值与另一个值的算术运算结果为空值，比较运算结果为 UNKNOWN 在有了 UNKNOWN 后，传统的逻辑运算中二值逻辑就被扩展为三值逻辑（TRUE、FALSE、UNKNOWN） 三值逻辑的真值表如下 x y x AND y x OR y NOT x T T T T F T U U T F T F F T F U T U T U U U U U U U F F U U F T F T T F U F U T F F F F T","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 视图更新","slug":"database/28.SQL视图更新","date":"2018-10-11T08:20:00.000Z","updated":"2021-08-23T13:56:44.134Z","comments":true,"path":"notes/database/3c471e0f.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/3c471e0f.html","excerpt":"【视图更新】更新视图是通过 INSERT、UPDATE、DELETE 来对视图进行操作，由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新 像查询视图那样，对视图的更新也是通过视图消解，转换为对基本表的更新","text":"【视图更新】更新视图是通过 INSERT、UPDATE、DELETE 来对视图进行操作，由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新 像查询视图那样，对视图的更新也是通过视图消解，转换为对基本表的更新 为防止用户通过视图进行更新时，有意无意地对不属于视图范围内的基本表数据进行操作，可以在定义视图时加上 WITH CHECK OPTION 子句，使得在更新数据时，RDBMS 自动检查视图定义中的条件，当不满足时拒绝执行更新操作，关于视图的定义，详见 SQL 视图的数据定义 【实例】1.插入 例如，向 CS 系学生视图 cs_student 中插入一个新的学生记录（学号：5，姓名：钱七，年龄：20） 123INSERTINTO cs_studentVALUES(5, '钱七', 20); 该语句会转为对基本表的更新 123INSERTINTO student(Sno, Sname, Sage, Sdept)VALUES(5, '钱七', 20, 'CS'); 2.修改 例如，将 CS 系学生视图 cs_student 中学号为 5 的学生姓名改为周八 123UPDATE cs_studentSET Sname = '周八'WHERE Sno = 5; 该语句会转为对基本表的更新 123UPDATE studentSET Sname = '周八'WHERE Sno = 5 AND Sdept = 'CS'; 3.删除 例如，删除 CS 系学生视图 cs_student 中学号为 5 的记录 123DELETEFROM cs_studentWHERE Sno = 5; 该语句会转为对基本表的更新 123DELETEFROM studentWHERE Sno = 5 AND Sdept = 'CS';","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"二叉树的存储结构","slug":"data-structure/04.tree-binary-tree/04.二叉树的存储结构","date":"2018-10-11T07:03:00.000Z","updated":"2021-09-22T07:25:12.514Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/de8d2b40.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/de8d2b40.html","excerpt":"【顺序结构】由于树与二叉树的性质，顺序存储存储完全二叉树、满二叉树较为合适，其利用一组地址连续的存储单元，自上而下，自左到右存储完全二叉树上的结点元素，即将 $i$ 号结点存储在数组下标 $i-1$ 的分量中 而对于一般的二叉树，为了让数组下标能反应二叉树结点中的逻辑关系，只能添加不存在的空结点，以让每个结点与完全二叉树上的结点对照，再存储到相应的数组分量中","text":"【顺序结构】由于树与二叉树的性质，顺序存储存储完全二叉树、满二叉树较为合适，其利用一组地址连续的存储单元，自上而下，自左到右存储完全二叉树上的结点元素，即将 $i$ 号结点存储在数组下标 $i-1$ 的分量中 而对于一般的二叉树，为了让数组下标能反应二叉树结点中的逻辑关系，只能添加不存在的空结点，以让每个结点与完全二叉树上的结点对照，再存储到相应的数组分量中 对于给定编号为 $i$ 的结点，其左孩子为 $2i$，右孩子为 $2i+1$，父结点为 $\\left\\lfloor \\frac{i}{2} \\right\\rfloor$ 1234struct BiTNode &#123; int data; //数据域 bool isEmpty; //结点是否为空&#125; tree[N]; 在最坏情况下，高度为 $h$ 的只有 $h$ 个结点的斜树要占据 $2^h-1$ 个存储单元，这极大的浪费了存储空间 因此，二叉树的顺序存储结构一般仅用于存储完全二叉树 【链式结构】由于顺序存储的空间利用率低，因此二叉树一般采用链式存储结构，即用链表结点存储二叉树中的结点 二叉链表每个存储结点包含一个数据域 data，一个指向其左孩子的左指针lchild，一个指向其右孩子的右指针rchild 123456789typedef struct BiTNode &#123; //二叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针&#125; BiTNode, *BiTree;bool initBiTree(BiTree &amp;root) &#123; //初始化 root = NULL; //空树 return true;&#125; 可以发现，$n$ 个结点的二叉链表共有 $n+1$ 个空链域，这无疑浪费了空间，在二叉链表的基础上，后来又有了线索链表，通过线索链表表示的二叉树，一般称为线索二叉树 三叉链表在二叉链表的存储方式下，从某结点出发可以直接访问到它的孩子结点，但要找到某个结点的父结点需要从根结点开始搜索，最坏情况下，需要遍历整个二叉链表 而三叉链表，在二叉链表的基础上加了一个指向父结点的指针域 parent，使得即便于查找孩子结点，又便于查找父结点，但相对二叉链表而言，加大了空间开销 12345678910typedef struct BiTNode &#123; //三叉链表 int data; //数据域 struct BiTNode *lchild; //左指针 struct BiTNode *rchild; //右指针 struct BiTNode *parent; //父指针&#125; BiTNode, *BiTree;bool initBiTree(BiTree &amp;root) &#123; //初始化 root = NULL; //空树 return true;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"树的存储结构","slug":"data-structure/04.tree-binary-tree/03.树的存储结构","date":"2018-10-11T05:33:00.000Z","updated":"2021-09-02T13:46:36.387Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/26449a4c.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/26449a4c.html","excerpt":"【双亲表示法】双亲表示法利用树中每个结点均有且仅有一个父结点的一特性，借助一维数组按层序来存储树的各个结点（顺序存储） 数组中的每个元素对应树中一个结点，每个结点记录两类信息：结点的数据信息、该结点的父结点在数组中的下标","text":"【双亲表示法】双亲表示法利用树中每个结点均有且仅有一个父结点的一特性，借助一维数组按层序来存储树的各个结点（顺序存储） 数组中的每个元素对应树中一个结点，每个结点记录两类信息：结点的数据信息、该结点的父结点在数组中的下标 同时规定根结点存储在数组的 0 号存储单元，其指针域设为 -1 表示没有父结点 对于给出的指定结点 p，容易查找到其父结点，但查找 p 的子结点只能从头到尾遍历整个数组 双亲表示法的存储结构描述如下 12345678struct PTNode &#123; int data; int parent; //父结点在数组中的下标&#125;;struct PTree &#123; int n; //结点数 PTNode nodes[N];&#125; tree; 【孩子表示法】孩子表示法是顺序存储与链式存储的结合，由于树中的每个结点都可能有多个孩子，将每个结点的孩子链接成一个单链表，这样 $n$ 个结点共有 $n$ 个孩子链表，其中叶结点的孩子链表为空 那么 $n$ 个孩子链表共有 $n$ 个头指针，将这 $n$ 个头指针存放在数组中，数组中的每个元素为一表头结点 最后再将结点数、根结点在表头数组中的位置、表头数组封装，即得到一棵用单链表表示的树 对于给出的指定结点 p，很容易找到其所有孩子，但查找 p 的父结点只能从头到尾遍历整个数组 孩子表示法的存储结构描述如下 12345678910111213struct CTNode &#123; //孩子结点 int child; //孩子结点在数组中的下标 struct CTNode *next; //下一个孩子&#125;;struct tableNode &#123; //表头结点 int data; struct CTNode *firstChild; //第一个孩子&#125;;struct CTree &#123; int n; //结点数 int root; //根结点位置 tableNode nodes[N]; //表头数组&#125; tree; 【孩子兄弟表示法】孩子兄弟表示法，从存储结构上来看与二叉链表相同，但其存储结构不同，其链表中的每个结点除数据域外，还设置了两个指针分别指向该结点的第一个孩子和右兄弟 该表示法本质上是将树转化为二叉树，然后用二叉树的操作来对树进行操作 孩子兄弟表示法的存储结构描述如下 12345typedef struct CSNode &#123; int data; struct CSNode *firstChild; //第一个孩子 struct CSNode *nextSibling; //右兄弟&#125; CSNode, *CSTree;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"二叉树的基本概念","slug":"data-structure/04.tree-binary-tree/02.二叉树的基本概念","date":"2018-10-11T04:45:00.000Z","updated":"2021-09-02T13:46:16.307Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/255e2a53.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/255e2a53.html","excerpt":"【二叉树的定义】二叉树（ binary tree）是 $n(n \\geq 0)$ 个结点的有限集合，$n=0$ 时为空二叉树 对于非空二叉树，有：","text":"【二叉树的定义】二叉树（ binary tree）是 $n(n \\geq 0)$ 个结点的有限集合，$n=0$ 时为空二叉树 对于非空二叉树，有： 除根结点外，每个结点或为空 每个结点或由一个根结点与两棵互不相交的，称为根结点的左子树、右子树的二叉树构成 二叉树具有以下特点： 每个结点最多有两棵子树，即不存在 $degree&gt;2$ 的结点 二叉树是有序树，即使树中的某个结点只有一棵子树，也要区分它是左子树还是右子树 二叉树存在以下五种基本形态 【特殊二叉树】斜树所有的结点都只有左子树的二叉树称为左斜树，所有的结点都只有右子树的二叉树称为右斜树 在斜树中，每层只有一个结点，因此斜树的结点个数与其深度相同 满二叉树在一棵二叉树中，若所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层上，则称为满二叉树 满二叉树具有以下特点： 叶子只能出现在最下一层 除叶结点度为 $0$ 外，其他结点度均为 $2$ 高度为 $h$ 的满二叉树，具有 $2^h-1$ 个结点 由于满二叉树的特性可知：满二叉树在同样深度的二叉树中结点个数、叶结点个数最多 从根结点起，对满二叉树自上而下，自左到右进行编号，这称为层序编号，对于编号为 $i$ 的结点，双亲编号为 $\\left\\lfloor \\frac{i}{2} \\right\\rfloor$，左孩子编号为 $2i$，右孩子编号为 $2i+1$ 完全二叉树对一棵具 $n$ 个结点的二叉树按层序编号，若编号为 $i$ 的结点与同样深度的满二叉树中编号 $i$ 的结点在二叉树中的位置完全相同，则称为完全二叉树，那么显然有：满二叉树是完全二叉树 完全二叉树具有以下特点： 叶结点只能出现在最下两层，且最下层的叶结点都集中在二叉树左侧连续的位置 若有度为 $1$ 的结点，只可能有一个，且其只有左孩子 深度为 $k$ 的完全二叉树在 $k -1$ 层上一定是满二叉树 对于具有 $n$ 个结点的完全二叉树，当第 $i$ 个结点满足 $i \\leq \\left\\lfloor \\frac{n}{2} \\right\\rfloor$ 时为分支结点，当 $i &gt; \\left\\lfloor \\frac{n}{2} \\right\\rfloor$ 时为叶结点 简单来说，在满二叉树中，从最后一个结点开始，连续去掉任意个的结点，即是一棵完全二叉树 其他除斜树、完全二叉树、满二叉树外，还有具有其他特点的二叉树，常见的有： 堆：每个结点值都大于等于或小于等于左右孩子结点的值的二叉树 霍夫曼树：WPL 最小的二叉树 二叉排序树：左子树结点值小于根结点，右子树结点值大于根结点值的二叉树 平衡二叉树：左右子树高度差的绝对值不超过 $1$ 的二叉树 【二叉树的性质】二叉树具有以下性质： 1.二叉树的第 $i$ 层上最多有 $2^{i-1},i\\geq1$ 个结点 2.在一棵高度为 $h$ 的二叉树中，最多有 $2^h-1$ 个结点，最少有 $h$ 个结点 推论：高度为 $h$ 且具 $2^h-1$ 个结点的二叉树一定是满二叉树，但深度为 $h$ 具有 $h$ 个结点的二叉树不一定是斜树 3.具有 $n$ 个结点的二叉树，其分支数（边）：$B=n-1$，对于任意一个结点，每度贡献一个分支，即：度为 $0$ 的结点贡献 $0$ 个分支，度为 $1$ 的结点贡献 $1$ 个分支，度为 $2$ 的结点贡献 $2$ 个分支 4.在一棵二叉树中，若叶结点个数为 $n_0$，度为 $2$ 结点个数为 $n_2$，那么有：$n_0=n_2+1$ 5.具有 $n$ 个结点的完全二叉树的高度为 $\\left\\lfloor log_2(n+1) \\right\\rfloor$ 或 $\\left\\lfloor log_2n \\right\\rfloor +1 $ 6.具有 $n$ 个结点的完全二叉树，可由结点数推出度为 $0,1,2$ 的结点个数 $n_0,n_1,n_2$ 完全二叉树最多只有一个度为 $1$ 的结点，即：$n_1=0$ 或 $n_1=1$ 完全二叉树叶结点个数为双分支结点个数 $+1$，即：$n_0=n_2+1$ 若完全二叉树有 $2k$ 个结点，则有：$n_1=1,n_0=k,n_2=k-1$ 若完全二叉树有 $2k+1$ 个结点，则有：$n_1=0,n_0=k,n_2=k-1$ 7.对一棵具有 $n$ 个结点的完全二叉树，从 $1$ 开始按层序编号，则对于任意编号 $i$ 的结点，有： 若 $i=1$，则结点 $i$ 为根结点；若 $i&gt;1$，则结点 $i$ 的父结点编号为 $\\left\\lfloor \\frac{i}{2} \\right\\rfloor$ 若 $i&gt;\\left\\lfloor \\frac{i}{2} \\right\\rfloor$ 则结点 $i$ 为叶结点，若 $i \\leq \\left\\lfloor \\frac{i}{2} \\right\\rfloor$ 则结点 $i$ 为分支结点 若 $2i\\leq n$，则：结点 $i$ 的左孩子编号为 $2i$；若 $2i&gt;n$，则结点 $i$ 无左孩子 若 $2i+1 \\leq n$，则：结点 $i$ 的右孩子编号为 $2i+1$；若 $2i+1&gt;n$，则结点 $i$ 无右孩子 结点 $i$ 的层次为 $\\left\\lfloor log_2(n+1) \\right\\rfloor$ 或 $\\left\\lfloor log_2n \\right\\rfloor +1 $","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"树的基本概念","slug":"data-structure/04.tree-binary-tree/01.树的基本概念","date":"2018-10-11T00:31:00.000Z","updated":"2021-09-02T13:45:54.783Z","comments":true,"path":"oi-acm/data-structure/tree-binary-tree/dd979b5f.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/tree-binary-tree/dd979b5f.html","excerpt":"【树的定义】树，是 $n(n \\geq 0)$ 个结点的有限集合，当 $n=0$ 时，树称为空树 对于任意一棵非空树，其满足：","text":"【树的定义】树，是 $n(n \\geq 0)$ 个结点的有限集合，当 $n=0$ 时，树称为空树 对于任意一棵非空树，其满足： 有且仅有一个特定的根结点 $n&gt;1$ 时，其余结点可分为 $m(m&gt;0)$ 个互不相交的有限集合 $T_1,T_2,..,T_m$，每个集合本身又是一棵树，被称为根结点的子树 树具有以下特点： 是一种递归的数据结构 根结点没有前驱，除根结点外的所有结点有且仅有一个前驱 所有的结点可以有零到多个后继 $n$ 个结点的树有 $n-1$ 条边 【基本术语】上端结点为下端结点的父结点（parent node），下端结点为上端结点的子结点（children node），同一个父结点的多个子结点互称兄弟结点（brother node），同一层的结点互称堂兄弟结点（cousin node） 从根结点到某个子结点所经过的所有结点称为这个子结点的祖先（ancestor），以某个结点为根的子树中的任一结点都是该结点的子孙（descendant） 一个结点的孩子个数，称为结点的度（degree），树中各结点的度的最大值称为这棵树的度（tree degree） 度为 $0$ 的结点称为叶结点（leaf node），度不为 $0$ 的结点称为分支结点（branch node），根以外的分支结点称为内部结点（internal node） 连接两个相关联的结点的线段称为树枝（branch） 对于树中任意两个不同的结点，如果从一个结点出发，自上而下沿着树中连着结点的线段能到达另一结点，则称它们之间存在着一条唯一的路径（path），路径上经过的边数称为路径长度（path length），从根结点出发，到树中的其余结点一定存在着一条路径，不同子树上的结点之间不存在路径。 若一棵树中结点的各子树从左到右是有次序的，即若交换结点各子树的相对位置会构成不同的树，则称为有序树（ordered tree），反之，交换结点各子树的相对位置后为同一棵树，则为无序树（unordered tree） 规定一棵树的根结点的层次（level）为 $1$，其它结点的层次等于它的父结点层次 $+1$ 一棵树中所有的结点的层次的最大值称为树的深度（depth） 将树中结点按照从上层到下层，同层中从左到右的次序依次从 1 开始编号，这种编号方式称为层序编号（level code），通过层序编号可以将一棵树变为线性序列 以下图为例： 这棵树的根结点为：$1$，叶结点有：$3$、$5$、$6$、$8$、$9$，分支结点有：$1$、$2$、$4$、$7$，内部结点有：$2$、$4$、$7$，整个树的度为：$3$ 对于根结点 $1$ 来说，它是 $2$、$3$、$4$ 的父结点，同时 $2$、$3$、$4$ 是结点 $1$ 的子结点，它们又是兄弟结点 对于结点 $8$ 来说，$1$、$4$、$7$ 是它的祖先；对于结点 $4$ 来说，$7$、$8$、$9$ 是它的子孙 根结点 $1$ 的层次为 $1$，结点 $2$、$3$、$4$ 的层次为 $2$，结点 $5$、$6$、$7$ 的层次为 $3$，结点 $8$、$9$ 的层次为 $4$，这棵树的深度为 $4$ 对于结点 $1$ 与结点 $8$ 之间存在的路径，可用 $1$、$4$、$7$、$8$ 来表示该路径，该路径的长度为 $3$ 【树的性质】树具有以下最基本的性质： 树中结点数 = 总度数 $+1$ 度为 $m$ 的树中第 $i$ 层上最多有 $m^{i-1}$ 个结点 度为 $m$ 的树，若高度为 $h$，最少有 $h+m-1$ 个结点 对于 $m$ 叉树，即每个结点最多只能有 $m$ 个孩子的树来说，其具有以下性质： 高度为 $h$ 的 $m$ 叉树最多有 $\\frac{m^h-1}{m-1}$ 个结点，最少有 $h$ 个结点 $n$ 个结点的 $m$ 叉树最小高度为 $\\left\\lceil log_m(n(m-1)+1) \\right\\rceil$ 度为 $m$ 的树与 $m$ 叉树的对比如下表 度为 $m$ 的树 $m$ 叉树 任意结点的度 $\\leq m$（最多 $m$ 个孩子） 任意结点的度 $\\leq m$（最多 $m$ 个孩子） 至少一个结点度 $=m$ （有 $m$ 个孩子） 允许所有结点的度 $&lt;m$ 一定是非空树，至少有 $m+1$ 个结点 可以是空树 子树不要求有序 子树是有序的，次序不能任意颠倒","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"树与二叉树","slug":"oi-acm/data-structure/tree-binary-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/tree-binary-tree/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"树与二叉树","slug":"tree-binary-tree","permalink":"https://alex-mcavoy.github.io/tags/tree-binary-tree/"}],"author":"Alex_McAvoy"},{"title":"KMP 算法","slug":"string/01.single-pattern-matching/04.KMP算法","date":"2018-10-08T11:21:00.000Z","updated":"2021-09-02T13:41:02.815Z","comments":true,"path":"oi-acm/string/single-pattern-matching/36b55f59.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/string/single-pattern-matching/36b55f59.html","excerpt":"【从 MP 算法到 KMP 算法】在 MP 算法中，介绍了求 next 数组的步骤，但其仍存在一个缺陷 以下图为例，文本串 T=&#39;ABACBCDHI&#39;，模式串 P=&quot;ABAB&quot;，模式串的 next 数组为 next[4]={-1,0,0,1}","text":"【从 MP 算法到 KMP 算法】在 MP 算法中，介绍了求 next 数组的步骤，但其仍存在一个缺陷 以下图为例，文本串 T=&#39;ABACBCDHI&#39;，模式串 P=&quot;ABAB&quot;，模式串的 next 数组为 next[4]={-1,0,0,1} 当出现文本串的字符 C 与模式串的字符 B 不匹配时，应将模式指针 $j$ 移动到位置 $1$ 但从上图中不难发现，由于文本串的 C 以及和模式串的最后的字符 B 已经不匹配了，那么其与模式串前面的 B 也一定是不匹配的，因此，这一步是没有意义的 由此， D.E.Knuth 在 MP 算法上进行了改进，即 KMP （Knuth-Morris-Pratt ）算法 【nextVal 数组】next 数组与 nextVal 数组显然，问题发生在 $next[j]=k$ 这一步上，因此，可以加一个条件，当 $P[j]=P[k]$ 时，直接跳过，即令： next[j]=next[k]采用上述方法得到的 next 数组，即为 KMP 算法下的 next 数组，为与 MP 算法中的 next 数组区分，常称为 nextVal 数组 以 aaaab 为例，给出其 next 数组与 nextVal 数组 编号 0 1 2 3 4 string a a a a b next -1 0 1 2 3 nextVal -1 -1 -1 -1 3 nextVal 数组的实现与求 next 数组相比，求 nextVal 数组与其几乎完全相同，唯一的区别就是当 $P[j]=P[k]$ 时，将 $next[j]=k$ 改为 $next[j]=next[k]$ 计算 nextVal 数组的代码如下： 123456789101112131415161718192021222324int nextVal[N];void getNextVal(char P[]) &#123; //获取字符数组p的nextVal数组 nextVal[0] = -1; //初始化 int len = strlen(P); //模式串长度 int j = 0; //模式指针j int k = -1; //位置k while (j &lt; len) &#123; if (k == -1) &#123; //初始化时 k++; //此前有nextVal[j]=k j++; //指针后移 nextVal[j] = k; &#125; else if (P[j] == P[k]) &#123; //nextVal[j] = nextVal[k] k++; //此前有nextVal[j]=k j++; //指针后移 nextVal[j] = nextVal[k]; &#125; else &#123; //k=nextVal[k] k = nextVal[k]; &#125; &#125;&#125; 【KMP 算法的匹配】MP 算法与 KMP 算法的区别仅在于 next 数组的不同，在匹配时，KMP 与 MP 的匹配过程相同 1234567891011121314151617181920212223int MP(char T[], char P[]) &#123; //KMP算法 int tLen = strlen(T); //文本串长度 int pLen = strlen(P); //模式串长度 int i = 0; //文本串指针 int j = 0; //模式串指针 getNextVal(P); //获取KMP的nextVal数组 while (i &lt; tLen &amp;&amp; j &lt; pLen) &#123; if (j == -1 || T[i] == P[j]) &#123; //当j=-1时，要移动的是i，同样j也要归零 i++; j++; &#125; else &#123; j = nextVal[j]; //j回到指定位置 &#125; &#125; if (j == pLen) //匹配成功 return i - j; return -1;&#125; 【KMP 算法的应用】KMP 算法的核心是求 next 数组，其除了用于单模式匹配外，还可用来求模式串的出现次数、最小循环节的长度 求模式串出现次数若想求模式串 P 出现的次数，仅需在进行匹配时，当模式串 P 匹配成功后记录一次次数即可 需要注意的是，在匹配成功后，是否要初始化模式串指针位置要根据实际问题情况来判断 123456789101112131415161718192021222324252627int KMP(char T[], char P[]) &#123; int tLen = strlen(T); int pLen = strlen(P); getNext(P); int res = 0; int j = 0; //初始化在模式串的第一个位置 for (int i = 0; i &lt; tLen; i++) &#123; //遍历文本串 while (j &amp;&amp; P[j] != T[i]) &#123; //顺着失配边走，直到可以匹配，最坏情况是j=0 j = next[j]; &#125; if (P[j] == T[i]) &#123; //匹配成功，继续下一个位置 j++; &#125; if (j == pLen) &#123; //计算模式串在文本串中出现的次数 res++; /* 若可使用重复字符，下面的j=0需注释掉 若不可使用重复字符，下面的j=0无需注释 原因：是否需要初始化模式串指针位置 */ j = 0; &#125; &#125; return res;&#125; 求最小循环节长度对于 next数组来说，next[j] 代表当前字符 $j$ 之前的字符串中，最大前缀与后缀的匹配数，即：next[j]=k 代表 $j$ 之前的字符串中有最大长度为 $k$ 的相同前缀后缀 例如： i 0 1 2 3 4 5 p[i] a b c b a next[i] -1 0 0 0 0 1 对于长度为 $n$ 的模式串，由于 $next[j]=k$ 表示 $p[1..i-1]$ 最大前缀与后缀的匹配数，那么，模式串第 $1$ 位到第 $next[n]$ 位与模式串第 $n-next[n]$ 位到第 $n$ 位是匹配的 因此，当 $next[j]&gt;0$ 时，$j-next[j]$ 为字符串匹配时移动的位数 故而当 $n%(n-next[n])=0$ 时，说明模式串中存在重复连续的子串，且其长度为 len=n-next[n]进而可得字符串的最小周期为 T=\\frac{n}{len}=\\frac{n}{n-next[n]}1234567891011121314151617int next[N];int main() &#123; char P[N]; scanf(\"%s\", P); int n = strlen(P); //模式串长度 getNext(P); //获取next数组 int len = n - next[n]; //与前缀相同的后缀长度 if (n % len == 0) &#123; //存在循环节 int res = n / len; //循环节长度 printf(\"%d\\n\", res); &#125; else //不存在循环节，长度为1 printf(\"1\\n\"); return 0;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"字符串","slug":"oi-acm/string","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/"},{"name":"单模式匹配","slug":"oi-acm/string/single-pattern-matching","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/single-pattern-matching/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"字符串","slug":"string","permalink":"https://alex-mcavoy.github.io/tags/string/"},{"name":"单模式匹配","slug":"single-pattern-matching","permalink":"https://alex-mcavoy.github.io/tags/single-pattern-matching/"}],"author":"Alex_McAvoy"},{"title":"MP 算法","slug":"string/01.single-pattern-matching/03.MP算法","date":"2018-10-08T07:11:00.000Z","updated":"2021-12-14T14:29:23.192Z","comments":true,"path":"oi-acm/string/single-pattern-matching/556cdfd6.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/string/single-pattern-matching/556cdfd6.html","excerpt":"【从 BP 算法到 MP 算法】BP 算法是最简单的模式匹配算法，其本质是暴力枚举 在 BP 算法中，当文本串 T 的某些子串与模式串 P 能部分匹配时，文本串的扫描指针 i 每次都是后移一位再从头开始比较，而当某轮已匹配相等的字符序列是模式串 P 的某个前缀时再进行比较，相当于模式串不断地自我比较","text":"【从 BP 算法到 MP 算法】BP 算法是最简单的模式匹配算法，其本质是暴力枚举 在 BP 算法中，当文本串 T 的某些子串与模式串 P 能部分匹配时，文本串的扫描指针 i 每次都是后移一位再从头开始比较，而当某轮已匹配相等的字符序列是模式串 P 的某个前缀时再进行比较，相当于模式串不断地自我比较 针对上述问题，对 BF 算法进行改进，即得到了 MP（Morris-Pratt）算法，其是以 James Morris 和 Vaughan Pratt 两人的姓来命名的 MP 最大的特点是：只让模式串 P 的指针 j 回溯，让文本串 T 的指针 i 不变 如下图所示，文本串的 C 与模式串的 B 不匹配 可以利用已匹配的信息，将模式指针 $j$ 移动到位置 $2$ 上，文本指针 $i$ 不变 【基本原理】通过上面两个例子可以发现，当匹配失败时，文本指针 $i$ 的位置不变，模式指针 $j$ 要移动到新的位置 $k$ 这个位置 $k$ 满足：模式串前面的 $k$ 个字符与模式指针 $j$ 前的 $k$ 个字符相同 即有： P[0,...,k-1]=P[j-k,...,j-1]当出现文本串的第 $i$ 个字符与模式串的第 $j$ 个字符不匹配时，可以知道，文本串位置 $i$ 前的 $j-1$ 个字符与模式串位置 $j$ 前的 $j-1$ 个字符相同 即当 $T[i]!=P[j]$ 时，有： T[i-j,...,i-1]=P[0,...,j-1] 根据 $P[0,…,k-1]=P[j-k,…,j-1]$，可得： T[i-k,...,i-1]=[0,...,k-1]因此，可直接将 $j$ 移动到 $k$，无需再比较前面的 $k$ 个字符 【next 数组】next 数组与 PM 表通过上面的论述，可以发现，MP 算法关键是求得 $k$ 由于在模式 P 的每一个位置都可能发生不匹配，也就是说，可以采用预处理的思想，计算模式 P 中每一个位置 $j$ 所对应的 $k$，这样当出现不匹配时，直接令模式指针 $j$ 指向 $k$ 的位置 通常，使用一个数组 next[] 来保存每一个位置 $j$ 所对应的 $k$，即令 next[j]=k 来表示当 T[i]!=P[j] 时，指针 $j$ 要指向的下一个位置 模式串的部分匹配值即可满足 next 数组的要求，每当匹配失败时，就去找它前一个元素的部分匹配值，从而令模式串 P 再文本串 T 的指针 $i$ 的基础上，后移 已匹配位数-对应部分匹配值 但由于每次都要找前一个元素的部分匹配值，使用起来并不方便，因此将 PM 表整体右移一位，其有如下考虑： 第一个元素右移后的空缺用 $-1$ 填充，即：next[0]=-1，因为若第一个元素匹配失败，则需将子串整体后移一位，不需要去计算子串移动位数 最后一个元素右移溢出，将其舍去即可，因为在模式串中，最后一个元素的部分匹配值是下一个元素使用的，但显然以没有下一个元素，故直接舍去 因此，在人工求 next 数组时，可以先求出模式串 P 的 PM 表，然后令其整体右移，首位用 $-1$ 填充即可 例如，ababa 的 PM 表与 next 数组如下： 编号 0 1 2 3 4 string a b a b a PM 0 0 1 2 3 next -1 0 0 1 2 next 数组的实现根据上面的论述，在 $P[j]$ 之前已经有 $P[0,…,k-1]=P[j-k,…,j-1]$ 成立 ，即： next[j]=k 那么，当 $P[k]=P[j]$ 时，有： P[0,...,k-1]+P[k]=P[j-k,...,j-1]+P[j]合并后，有： P[0,...,k]=P[j-k,...,j]即： next[j+1]=k+1 而当 $P[k]!=P[j]$ 时，根据 $P[0,…,k-1]=P[j-k,…,j-1]$，有： next[j]=k 合并后，有： next[k]=k 计算 next 数组的代码如下： 123456789101112131415161718int next[N];void getNext(char p[]) &#123; //获取字符数组p的next数组 next[0] = -1; //初始化 int len = strlen(p); //模式串长度 int j = 0; //模式指针j int k = -1; //位置k while (j &lt; len) &#123; if (k == -1 || p[j] == p[k]) &#123; //next[j+1]=next[j]+1 k++; //此前有next[j]=k j++; //指针后移 next[j] = k; &#125; else &#123; // k=next[k] k = next[k]; &#125; &#125;&#125; 【MP 算法的匹配】在求得 next 数组后，MP 算法的匹配就十分简单了，其在形式上与 BP 算法十分相似，不同之处仅在于匹配过程失配时的处理 在 MP 算法中，当出现 T[i]!=P[j] 时，文本指针 $i$ 不变，模式指针 $j$ 回退到 next[j] 的位置并重新比较 可以发现，MP 算法分为求 next 数组时间复杂度为 $O(m)$ 的预处理部分，和利用 next 数组时间复杂度为 $O(n)$ 的匹配部分，因此，其总时间复杂度为 $O(n+m)$ MP 算法的匹配过程的实现如下： 12345678910111213141516171819202122int MP(char T[], char P[]) &#123; // MP算法 int tLen = strlen(T); //文本串长度 int pLen = strlen(P); //模式串长度 int i = 0; //文本串指针 int j = 0; //模式串指针 getNext(P); //获取MP版本的next数组 while (i &lt; tLen &amp;&amp; j &lt; pLen) &#123; if (j == -1 || T[i] == P[j]) &#123; //当j=-1时，要移动的是i，同样j也要归零 i++; j++; &#125; else &#123; j = next[j]; //j回到指定位置 &#125; &#125; if (j == pLen) //匹配成功 return i - j; return -1;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"字符串","slug":"oi-acm/string","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/"},{"name":"单模式匹配","slug":"oi-acm/string/single-pattern-matching","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/single-pattern-matching/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"字符串","slug":"string","permalink":"https://alex-mcavoy.github.io/tags/string/"},{"name":"单模式匹配","slug":"single-pattern-matching","permalink":"https://alex-mcavoy.github.io/tags/single-pattern-matching/"}],"author":"Alex_McAvoy"},{"title":"SQL 删除数据","slug":"database/27.SQL删除数据","date":"2018-10-08T06:53:00.000Z","updated":"2021-08-23T13:56:41.340Z","comments":true,"path":"notes/database/f11bff41.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/f11bff41.html","excerpt":"【DELETE 语句】在 SQL 中，删除语句是 DELETE 语句，其语法如下 123DELETEFROM &lt;表名&gt;[WHERE &lt;条件表达式&gt;];","text":"【DELETE 语句】在 SQL 中，删除语句是 DELETE 语句，其语法如下 123DELETEFROM &lt;表名&gt;[WHERE &lt;条件表达式&gt;]; 该语句的功能是从指定表中删除满足 WHERE 子句条件的所有元组，如果省略了 WHERE 子句，将会删除表中的全部元组，但表的定义仍存在于数据字典中 也就是说，DELETE 语句仅删除了数据，未删除表的定义，要想删除表的定义，应使用 DROP TABLE 语句，详见 SQL 基本表的数据定义 【实例】1.删除某一个元组的值 例如，删除学号为 5 的学生记录 123DELETEFROM studentWHERE Sno = 5; 2.删除多个元组的值 当不指定 WHERE 子句时，将删除指定表的所有元组，使表成为空表 例如，删除所有学生的选课记录 12DELETEFROM sc; 3.带子查询的删除语句 子查询同样可以嵌套在 DELETE 语句中，一般与 IN 谓词结合使用，以构造执行删除操作的条件 例如，删除 CS 系所有学生的选课记录 1234567DELETEFROM scWHERE Sno IN( SELECT Sno FROM student WHERE Sdept = 'CS');","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 修改数据","slug":"database/26.SQL修改数据","date":"2018-10-08T06:32:00.000Z","updated":"2021-08-23T13:56:46.198Z","comments":true,"path":"notes/database/3793fa0c.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/3793fa0c.html","excerpt":"【UPDATE 语句】修改操作又称为更新操作，在 SQL 中，使用 UPDATE 语句执行修改操作，该语句的语法如下 123UPDATE &lt;表名&gt;SET &lt;列名1&gt; = &lt;表达式1&gt; [,&lt;列名2&gt; = &lt;表达式2&gt;,...,&lt;列名n&gt; = &lt;表达式n&gt;][WHERE &lt;条件&gt;];","text":"【UPDATE 语句】修改操作又称为更新操作，在 SQL 中，使用 UPDATE 语句执行修改操作，该语句的语法如下 123UPDATE &lt;表名&gt;SET &lt;列名1&gt; = &lt;表达式1&gt; [,&lt;列名2&gt; = &lt;表达式2&gt;,...,&lt;列名n&gt; = &lt;表达式n&gt;][WHERE &lt;条件&gt;]; 其功能是修改指定表中满足 WHERE 子句条件的元组，其中由 SET 子句给出 &lt;表达式&gt; 的值，以取代相应的属性列的值，如果省略 WHERE 子句，则代表要修改表中的所有元组 【实例】1.修改某一元组值 例如，将学号为 1 的学生的年龄改为 20 岁 123UPDATE studentSET Sage = 20WHERE Sno = 1; 2.修改多个元组值 例如，将所有学生的年龄增加一岁 12UPDATE studentSET Sgae = Sage + 1; 3.带子查询的修改语句 子查询也可以嵌套在 UPDATE 语句中，通常与 IN 谓词结合使用，以构造修改的条件 例如，将 CS 系的全体学生的成绩设为 0 1234567UPDATE scSET Grade = 0WHERE Sno IN ( SELECT Sno FROM student WHERE Sdept = 'CS');","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"BP 算法","slug":"string/01.single-pattern-matching/02.BP算法","date":"2018-10-08T05:11:00.000Z","updated":"2021-09-02T13:41:32.891Z","comments":true,"path":"oi-acm/string/single-pattern-matching/8ad51007.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/string/single-pattern-matching/8ad51007.html","excerpt":"【概述】暴力（Brute Force，BF）算法，是最简单的一种模式匹配算法，没有预处理阶段 其本质是暴力枚举，通过一个大小为 $1$ 的滑动窗口，循环来检查从 $n-m+1$ 到 $m$ 的范围中是否存在满足条件 T[s+i]=P[i] 的有效位移 $s$","text":"【概述】暴力（Brute Force，BF）算法，是最简单的一种模式匹配算法，没有预处理阶段 其本质是暴力枚举，通过一个大小为 $1$ 的滑动窗口，循环来检查从 $n-m+1$ 到 $m$ 的范围中是否存在满足条件 T[s+i]=P[i] 的有效位移 $s$ 在最坏的情况下，BF 算法会进行 $n-m+1$ 轮匹配，每轮匹配都会进行 $m$ 次匹配，由于在一般的应用场景中 $n&gt;&gt;m$，因此 BF 算法的最坏时间复杂度为： O((n-m+1)*m)=O(nm)【基本思想】BF 算法的基本思想如下： 1）用两个计数指针 i、j 指示文本串 T 和模式串 P 中当前正待比较的字符位置 2）从文本串 T 的第一个字符开始，与模式串 P 的第一个字符开始比较 若相等：继续逐个比较两者的后续字符 若不等：终止本轮匹配，令文本串 T 的指针 i 从上一开始的匹配点后移一位，令模式串 P 的指针 j 归零，重新开始一轮匹配 3）待匹配完毕后，若模式串 P 中的每一字符依次与 T 中的一个连续子串序列相等，则匹配成功 【实现】12345678910111213141516171819202122int BF(char *T, char *P) &#123; //BF算法 int tLen = strlen(T); //文本串长度 int pLen = strlen(P); //模式串长度 int i = 0; //文本串的当前位置 int j = 0; //模式串的当前位置 while (i &lt; tLen &amp;&amp; j &lt; pLen) &#123; if (i &gt; tLen - pLen + 1) break; if (T[i] == P[j]) &#123; //T的第i个与P的第j个字符相等时 i++; j++; &#125; else &#123; //T的第i个与P的第j个字符不等时 i = i - j + 1; //i从上一开始的匹配点后移一位 j = 0; &#125; &#125; if (j == pLen) //模式串位置与模式串长度相同说明匹配成功 return i - j; //返回匹配位置 return -1; //匹配失败&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"字符串","slug":"oi-acm/string","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/"},{"name":"单模式匹配","slug":"oi-acm/string/single-pattern-matching","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/single-pattern-matching/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"字符串","slug":"string","permalink":"https://alex-mcavoy.github.io/tags/string/"},{"name":"单模式匹配","slug":"single-pattern-matching","permalink":"https://alex-mcavoy.github.io/tags/single-pattern-matching/"}],"author":"Alex_McAvoy"},{"title":"SQL 插入数据","slug":"database/25.SQL插入数据","date":"2018-10-08T02:16:00.000Z","updated":"2021-08-23T13:56:48.951Z","comments":true,"path":"notes/database/a8efb6f3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/a8efb6f3.html","excerpt":"【INSERT 语句】在 SQL 中，插入元组使用的是 INSERT 语句，其基本语法如下 123INSERTINTO &lt;表名&gt; [(&lt;属性列1&gt; [,&lt;属性列2&gt;,...,&lt;属性列n&gt;])]VALUES (&lt;常量1&gt; [,&lt;常量2&gt;,...,&lt;常量n&gt;]);","text":"【INSERT 语句】在 SQL 中，插入元组使用的是 INSERT 语句，其基本语法如下 123INSERTINTO &lt;表名&gt; [(&lt;属性列1&gt; [,&lt;属性列2&gt;,...,&lt;属性列n&gt;])]VALUES (&lt;常量1&gt; [,&lt;常量2&gt;,...,&lt;常量n&gt;]); 该语句是将新元组插入到指定表中，其中新元组的属性列 1 的值为常量 1，属性列 2 的值为常量 2，以此类推，属性列 n 的值为常量 n INTO 子句中没有出现的属性列，新元组将在这些列上取空值 NULL，但要注意的是，如果在表定义时，有的列声明了非空 NOT NULL ，则不能取空值，否则会出错 【实例】1.插入元组 例如，将一个新学生元组 （学号：5，姓名：孙七，性别：男，所在系：IS，年龄：18）插入到 student 表中 123INSERTINTO student(Sno, Sname, Ssex, Sdept, Sage)VALUES(5, '陈东', '男', 'IS', 18); 2.插入子查询结果 子查询也可以嵌套在 INSERT 语句中生成要插入的批量数据 例如，对每一个系，求学生的平均年龄，并将结果存入数据库 对于该例，首先要建一张新表，其中一列存系名，另一列存放相应的平均年龄 1234CREATE TABLE dept_age( Sdept CHAR(40), Avg_age SMALLINT); 之后，对 student 表按系分组来求平均年龄并插入到新表 dept_age 中 12345INSERTINTO dept_age(Sdept, Avg_age) SELECT Sdept, AVG(Sage) FROM student GROUP BY Sdept;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 视图查询","slug":"database/24.SQL视图查询","date":"2018-10-08T01:22:00.000Z","updated":"2021-08-23T13:56:51.162Z","comments":true,"path":"notes/database/d6c159cd.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/d6c159cd.html","excerpt":"在 SQL 视图的数据定义 中，介绍了视图的数据定义，视图定义后，用户即可像对基本表一样进行查询 例如，在建立了 CS 系学生视图 is_student 后，查找年龄小于等于 20 岁的学生","text":"在 SQL 视图的数据定义 中，介绍了视图的数据定义，视图定义后，用户即可像对基本表一样进行查询 例如，在建立了 CS 系学生视图 is_student 后，查找年龄小于等于 20 岁的学生 RDBMS 执行对视图的查询时，会先进行有效性检查，检查查询中涉及的视图是否存在，若存在，则会在数据字典中取出视图的定义，将定义中的子查询与用户的查询结合起来，转换成等价的对基本表的查询，再执行修正后的查询，这个过程被称为视图消解 如上例中对视图的查询，其等价于下列查询 123SELECT Sno, Sname, SageFROM studentWHERE Sdept = 'IS' AND Sage &lt;=20","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 嵌套查询","slug":"database/23.SQL嵌套查询","date":"2018-10-07T07:15:00.000Z","updated":"2021-08-23T13:56:53.283Z","comments":true,"path":"notes/database/63b488e0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/63b488e0.html","excerpt":"【概述】一个 SELECT-WHERE 语句称为一个查询块，将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中，称为嵌套查询 在嵌套查询这种，上层的查询块称为外层查询或父查询，下层的查询块称为内层查询或子查询","text":"【概述】一个 SELECT-WHERE 语句称为一个查询块，将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中，称为嵌套查询 在嵌套查询这种，上层的查询块称为外层查询或父查询，下层的查询块称为内层查询或子查询 如下例，就是一个嵌套查询 1234567SELECT Sname /*父查询*/FROM studentWHERE Sno IN( /*子查询*/ SELECT Sno FROM SC WHERE Cno='1'); SQL 允许多层嵌套查询，即一个子查询中可以嵌套其他子查询，使得通过使用多个简单的查询构成复杂的查询，从而加强了 SQL 的查询能力，这种层层嵌套的方式，反映了 SQL 语言的结构化 要注意的是，有些嵌套查询可以通过连接运算替代，同时子查询不能使用 ORDER BY 子句，ORDER BY 子句只能对最终的结果排序 【带有 IN 的子查询】在嵌套查询中，子查询的结果往往是一个集合，所以谓词 IN 是嵌套查询中最常用的谓词 例如，查询与张三在一个系的学生 该要求可以分步来完成，第一步确定张三所在的系名 第二步根据所查的系名来查找所有在 CS 系的学生 将第一步嵌入第二步中，即可构造嵌套查询 该例中，子查询的查询条件不依赖父查询，该类查询称为不相关子查询，一般处理的方法是根据要求从里向外逐层处理，用子查询的结果用于建立其父查询的查询条件 除上述两种方法外，该例还可以使用自身连接来完成 可见，对于嵌套查询来说，有些可以使用连接查询来替代，只是 SQL 语言的书写和执行效率不同 如果是嵌套查询：首先会在内层中筛选得到一张满足条件的小表，再到外面的一层表进行查找，运算量较少 如果是连接查询：首先会进行笛卡尔积运算，生成一张大表后再去进行选择，运算量较大 对于成千上万行的大型数据库，使用上述两种不同的方法运算效率差别极大，也就是说，使用嵌套查询可以大幅度提高查询效率，此外，嵌套查询逐步求解层次清楚、易于构造，具有结构化程序设计的优点 【带有比较运算符的子查询】带有比较运算符的子查询是指父查询与子查询间用比较运算符连接，当用户确切知道子查询返回的是单值时，可以使用 &gt;、&lt;、&gt;=、&lt;=、=、!=、&lt;&gt; 等比较运算符 例如，找出每个学生超过其选修课程平均成绩的课程号 该例中，子查询的查询条件依赖父查询，该类查询称为相关子查询，一般处理的方法是： 取父查询中表的第一个元组，根据与子查询相关的属性值处理子查询，若 WHERE 子句返回为真，则将该元组放入结果表中 取父查询中表中的下一个元组，重复过程 1，直到父查询全部检查完为止 【带有 ANY、ALL 的子查询】语义子查询返回单值时可以用比较运算符，当返回多值时要用 ANY 谓词(有的系统使用 SOME)或 ALL 谓词 ANY 代表任意一个值，ALL 代表所有值，当使用 ANY 或 ALL 时，必须同时使用比较运算符，其语义如下表所示： 谓词与修饰符 语义 >ANY 大于子查询结果中的某个值 >ALL 大于子查询结果中的所有值 &lt;ANY 小于子查询结果中的某个值 &lt;ALL 小于子查询结果中的所有值 >=ANY 大于等于子查询结果中的某个值 >=ALL 大于等于子查询结果中的所有值 &lt;=ANY 小于等于子查询结果中的某个值 &lt;=ALL 小于等于子查询结果中的所有值 =ANY 等于子查询结果中的某个值 =ALL 等于子查询结果中的所有值 !=(或&lt;&gt;)ANY 不等于子查询结果中的某个值 !=(或&lt;&gt;)ALL 不等于子查询结果中的任何一个值 例如，查询其他系中比 CS 系所有学生年龄都小或相等的学生姓名、年龄 聚集函数实际上，用聚集函数实现子查询通常比直接用 ANY 或 ALL 的查询效率高，ANY、ALL 与聚集函数的对应关系如下表 = != 或 &lt;&gt; &lt; &lt;= &gt; &gt;= ANY IN &lt;MAX &lt;=MAX >MIN >=MIN ALL NOT IN &lt;MIN &lt;=MIN >MAX >=MAX 【带有 EXISTS 的子查询】EXISTS 谓词EXISTS 谓词即数理逻辑中的存在量词 $\\exists$，所有带 IN、比较运算符、ANY、ALL 谓词的子查询都能用带 EXISTS 谓词的子查询等价替换 带有 EXISTS 谓词的子查询不返回任何数，只产生逻辑真值 true 或 false 若子查询结果非空，则外层的 WHERE 子句返回 true 若子查询结果为空，则外层的 WHERE 子句返回 false 由于 EXISTS 返回逻辑真值，给出的列名无实际意义，因此尤其引出的子查询，其目标列表表达式通常都用 * 例如，查询选修 1 号课程的学生姓名 EXISTS 谓词通常也会与 NOT 搭配使用 若子查询结果非空，则外层的 WHERE 子句返回 false 若子查询结果为空，则外层的 WHERE 子句返回 true 例如，查询没有选修 1 号课程的学生姓名 全称量词的实现SQL 中没有全称量词 $\\forall$，但是利用谓词演算的方法，可以将带有全称量词的谓词转换为等价的带有存在量词的谓词，即： (\\forall x)P\\equiv \\neg (\\exists(\\neg P))例如，查询选修了全部课程的学生的学号、姓名 由于没有全称量词，转换为等价的用存在量词的形式，即查询没有一门课程是他不选修的学生的学号、姓名 123456789101112SELECT SnameFROM studentWHERE NOT EXISTS( SELECT * FROM course WHERE NOT EXISTS( SELECT * FROM sc WHERE Sno = student.Sno AND Cno = course.Cno )); 逻辑蕴含的实现SQL 中同样没有逻辑蕴含 $\\rightarrow$，利用谓词演算，可以将逻辑蕴含进行等价转换，即 p\\rightarrow q \\equiv \\neg p\\bigvee q例如，查询至少选修了学号为 1 号的学生选修的全部课程的学生号 该查询用逻辑蕴含表达为：查询学号为 x 的学生，对所有课程 y，只要学号为 1 的学生选修了课程 y，则 x 也选修了 y 其中，形式化表达如下： 用 $p$ 表示谓词 “学号为 1 的学生选修了课程 y” 用 $q$ 表示谓词 “学生 x 选修了课程 y” 则上述查询为：$(\\forall y)p \\rightarrow q$ 可以发现是一个蕴含式，将其进行等价变换： \\begin{matrix} (\\forall y)p \\rightarrow q & \\equiv \\neg (\\exists(\\neg(p\\rightarrow q))) \\\\ & \\equiv \\neg (\\exists (\\neg (\\neg p \\bigvee q))) \\\\ & \\equiv \\neg \\exists y (p \\wedge \\neg q) \\end{matrix}变换后的语义为：不存在这样的课程 y，学号为 1 的学生选修了 y，而 学生 x 没有选 12345678910111213SELECT DISTINCT SnoFROM sc sc_x /*代表学生x*/WHERE NOT EXISTS( SELECT * FROM sc sc_y /*代表学生y*/ WHERE sc_y.Sno = 1 AND NOT EXISTS( SELECT * FROM sc sc_z WHERE sc_z.Sno = sc_x.Sno AND sc_z.Cno = sc_y.Cno ));","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 连接查询","slug":"database/22.SQL连接查询","date":"2018-10-07T05:50:00.000Z","updated":"2021-08-23T13:56:56.633Z","comments":true,"path":"notes/database/3134918d.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/3134918d.html","excerpt":"【连接查询】前面的查询都是针对一个表进行的，当一个查询同时涉及到两个及以上的表时，称为连接查询，关于连接的关系代数的概念，在 关系代数 中介绍过 而连接查询是关系数据库中最主要的查询，包括：等值与非等值连接查询、自然连接查询、自身连接查询、外连接查询、多表连接查询、复合连接查询","text":"【连接查询】前面的查询都是针对一个表进行的，当一个查询同时涉及到两个及以上的表时，称为连接查询，关于连接的关系代数的概念，在 关系代数 中介绍过 而连接查询是关系数据库中最主要的查询，包括：等值与非等值连接查询、自然连接查询、自身连接查询、外连接查询、多表连接查询、复合连接查询 当 WHERE 子句用于连接两个表的条件称为连接条件或连接谓词，其一般格式为 1[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt; 其中，&lt;比较运算符&gt; 即连接谓词，主要有：=、&gt;、&lt;、&gt;=、&lt;=、!=、&lt;&gt; 除上述形式外，也可以使用 BETWEEN...AND... 作为连接谓词 1[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt; 连接谓词中的列名称为连接字段，连接条件中的各连接字段类型必须是可比的，但名称不必相同 【连接操作执行过程】嵌套循环法嵌套循环法是最常用的一种方法，其执行过程如下 首先在表 1 中找到第一个元组，然后从头开始扫描表 2，逐一查找满足连接条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中的一个元组 当表 2 全部查找完后，再找表 1 中的第二个元组，然后再从头开始扫描表 2，逐一查找满足连接条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中的一个元组 重复上述操作，直到表 1 中的全部元组都处理完毕 排序合并法排序合并法常用于等值连接，其执行过程如下 首先按照连接属性对表 1 和表 2 进行排序，然后再开始扫描 对表 1 的第一个元组，从头开始扫描表 2，顺序查找满足连接条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中的一个元组，当遇到表 2 中第一条大于表 1 连接字段值的元组时，对表 2 的查询就不再继续 再找到表 1 的第二条元组，然后从刚才的中断点处继续顺序扫描表 2，查找满足连接条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中的一个元组，当遇到表 2 中大于表 1 连接字段值的元组时，对表 2 的查询就不再继续 重复上述操作，直到表 1 或表 2 中的全部元组都处理完毕为止 索引连接法索引连接法一般需要建立索引，其执行过程如下 首先对表 2 按连接字段建立索引 然后对表 1 中的每个元组，依次根据其连接字段值查询表 2 的索引，从中找到满足条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中一个元组 【等值与非等值连接查询】当连接谓词为 = 时，称为等值连接，使用其他运算符称为非等值连接 例如，使用等值连接查询每个学生及其选修课程的情况 【自然连接查询】若在等值连接中，将目标列中重复的属性去掉，则称为自然连接 例如，使用自然连接查询每个学生及其选修课程的情况 【自身连接查询】自身连接是一个表与其自己进行连接，由于所有属性名都是同名属性，因此必须需要给表起别名作为前缀以示区别 例如，查询每一门课的先修课的先修课 【外连接查询】在常规的连接查询中，只有满足连接条件的元组才会被输出 外连接以指定表为连接主体，将主体表中不满足连接条件的元组一并输出，对于这些不满足连接条件的元组，将会根据需要填充上空值 NULL 作为悬浮元组，进行外连接（列出关系中的所有元组）、左外连接（列出左边关系中的所有元组）、右外连接（列出右边关系中的所有元组） 其语法如下 12345678/*外连接*/&lt;表名1&gt; JOIN &lt;表名2&gt; ON([&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2.]&lt;列名2&gt;)/*左外连接*/&lt;表名1&gt; LEFT JOIN &lt;表名2&gt; ON([&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2.]&lt;列名2&gt;)/*右外连接*/&lt;表名1&gt; RIGHT JOIN &lt;表名2&gt; ON([&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2.]&lt;列名2&gt;) 例如，分别使用外连接、左外连接、右外连接查询每个课程与选修关系的情况 外连接 左外连接 右外连接 【复合条件连接查询】复合条件连接查询是指 WHERE 子句中含有多个利用 AND、OR 短语连接的连接条件 例如，查询选修 1 号课程且成绩在 60 分以上的学生学号、姓名、成绩 【多表连接查询】连接操作一般是两表连接，但可以将两个以上的表进行连接，后者称为多表连接 例如，查询每个学生的学号、姓名、选修课程名、成绩","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 集合查询","slug":"database/21.SQL集合查询","date":"2018-10-07T02:09:00.000Z","updated":"2021-08-23T13:55:25.570Z","comments":true,"path":"notes/database/af70a1c0.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/af70a1c0.html","excerpt":"【集合查询】SELECT 语句的查询结果是元组的集合，因此多个 SELECT 语句的结果可进行集合操作 集合操作主要包括并操作 UNION、交操作 INTERSECT、差操作 EXCEPT","text":"【集合查询】SELECT 语句的查询结果是元组的集合，因此多个 SELECT 语句的结果可进行集合操作 集合操作主要包括并操作 UNION、交操作 INTERSECT、差操作 EXCEPT 需要注意的是，参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同 从本质上来讲，UNION 操作就是多个条件进行 OR，INTERSECT 操作就是多个条件进行 AND 由于并、交、差操作是二元运算，因此在 SQL 中默认从左到右顺序运算，此外，当涉及到三个及以上的元组集合操作时，并、差操作交换操作顺序不改变最后的结果，但差操作交换操作顺序会改变最终结果 考虑到集合操作的运算顺序，在实际应用中，大多数数据库并不支持 INTERSECT 操作和 EXCEPT 操作，一般利用 AND、OR、NOT 操作来对条件进行操作，变相的完成集合运算 【并操作】UNION 短语将多个查询结果取并集，同时，系统会自动去掉重复元组 例如，查询 CS 系的学生与年龄不大于 20 岁的学生的全部信息 1234567SELECT *FROM studentWHERE Sdept = 'CS'UNIONSELECT *FROM studentWHERE Sage &lt;= 20; 实际上相当如下语句 123SELECT *FROM studentWHERE Sdept = 'CS' OR Sage &lt;= 20; 如果想要在合并时保留重复元组，则需要加上 ALL 短语 例如，查询 CS 系的学生与年龄不大于 20 岁的学生的全部信息，要求保留重复元组 1234567SELECT *FROM studentWHERE Sdept = 'CS'UNION ALLSELECT *FROM studentWHERE Sage &lt;= 20; 【交操作】INTERSECT 短语将多个查询结果取交集 例如，查询 CS 系的年龄不大于 20 岁的学生的全部信息 1234567SELECT *FROM studentWHERE Sdept = 'CS'INTERSECTSELECT *FROM studentWHERE Sage &lt;= 20; 实际上相当如下语句 123SELECT *FROM studentWHERE Sdept = 'CS' AND Sage &lt;=20; 【差操作】EXCEPT 短语将多个查询结果起来取差集 例如，查询 CS 系的年龄大于 20 岁的学生的全部信息 1234567SELECT *FROM studentWHERE Sdept = 'CS'EXCEPTSELECTFROM studentWHERE Sage &lt;= 20; 实际上相当于以下语句 123SELECT *FROM studentWHERE Sdept = 'CS' AND Sage &gt; 20;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 的 ORDER 子句与 GROUP 子句","slug":"database/20.SQL的ORDER子句与GROUP子句","date":"2018-10-06T06:58:00.000Z","updated":"2021-08-23T13:55:29.647Z","comments":true,"path":"notes/database/31d03f50.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/31d03f50.html","excerpt":"【ORDER BY 子句】基本使用ORDER BY 子句用于对查询结果按照一个或多个属性列进行升序 ASC 或降序 DESC 排序，默认为升序","text":"【ORDER BY 子句】基本使用ORDER BY 子句用于对查询结果按照一个或多个属性列进行升序 ASC 或降序 DESC 排序，默认为升序 例如，查询选修了 1 号课程的学生的学号及其成绩，查询结果按照分数降序排列 空值处理当排序列出现空值 NULL 时，显示的次序将由具体的 RDBMS 决定，一般来说，若按升序 ASC 排序，空值元组最后显示，若按降序 DESC 排序，空值元组最先显示 例如，查询所有课程情况，查询结果按先修课程号降序排列 【聚集函数】常见聚集函数为方便用户，增强检索功能，SQL 提供了许多聚集函数，常用的有： 将字母转为小写：LOWER(&lt;列名&gt;) 将字母转为大写：UPPER(&lt;列名&gt;) 统计元组个数：COUNT(*) 统计一列中值的个数：COUNT([DISTINCT|ALL] &lt;列名&gt;) 计算一列值的和：SUM([DISTINCT|ALL] &lt;列名&gt;) 计算一列值的平均值：AVG([DISTINCT|ALL] &lt;列名&gt;) 求一列值中的最大值：MAX([DISTINCT|ALL] &lt;列名&gt;) 求一列值中的最小值：MIN([DISTINCT|ALL] &lt;列名&gt;) 需要说明的是，在 WHERE 子句中，聚集函数不能作为条件表达式，其只能作用于 SELECT 子句和 GROUP BY 中的 HAVING 短语里 基本使用如果指定了 DISTINCT 短语，则在计算时会取消指定列中的重复值；如果不指定 DISTINCT 短语，将默认采用 ALL 短语，在计算时会不取消重复列值 例如，查询选修 1 号课程的学生的最高分数 空值处理当聚集函数遇到空值时，除 COUNT(*) 外，其他的聚集函数一般都跳过空值 例如，查询所有不需要先修课的课程个数 【GROUP BY 子句】基本使用GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的分为一组 对查询结果分组的目的是为了细化聚集函数的作用对象，分组后的聚集函数将作用于每一个组，即每一组都有一个函数值 例如，查询各个课程号及相应的选课人数 如果未使用 GROUP BY 子句，聚集函数将作用于整个查询结果，显示将不完整 HAVING 短语如果分组后还要求按照一定的条件对这些组进行筛选，最终只输出满足条件的组，此时需要使用 HAVING 短语进行指定 WHERE 子句与 HAVING 短语的区别在于两者的作用对象不同，WHERE 子句作用于基本表或视图，从中选择满足条件的元组，HAVING 短语作用于组，从中选择满足条件的组 当选用了 HAVING 短语后，其执行顺序是，先用 GROUP BY 子句按指定列进行分组，再将分组结果作为一个中间表，执行 HAVING 短语后的聚集函数 例如，查询平均成绩大于等于 70 分的学生学号和平均成绩","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 的 WHERE 子句","slug":"database/19.SQL的WHERE子句","date":"2018-10-06T03:28:00.000Z","updated":"2021-08-23T13:55:38.395Z","comments":true,"path":"notes/database/b89eeb8e.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/b89eeb8e.html","excerpt":"【常用查询条件】查询满足指定条件的元组一般通过 WHERE 子句来实现，常用的查询条件如下表","text":"【常用查询条件】查询满足指定条件的元组一般通过 WHERE 子句来实现，常用的查询条件如下表 【比较大小】用于进行比较的运算符一般包括等于 =、不等于 != 或 &lt;&gt;、大于 &gt;、小于&lt;、大于等于&gt;=、小于等于&lt;=、不大于!&gt;、不小于!&lt; 例如，查询 CS 系全体学生的名单 【确定范围】谓词 BETWEEN...AND... 与 NOT BETWEEN...AND... 用于查找属性值在/不在指定范围内的元组，其中 BETWEEN 后是范围的下限（低值），AND 后是范围的上限（高值） 例如，查询成绩在 80 到 90 间的学生学号 【指定集合】谓词 IN 和 NOT IN用于查询属性值属于/不属于指定集合的元组 例如，查询 CS、IS 系的学生学号、姓名、所属系 【字符匹配】谓词 LIKE 和 NOT LIKE 用于进行字符串匹配，其一般语法格式如下 1[NOT] LIKE '&lt;匹配串&gt;' [ESCAPE '&lt;换码字符&gt;'] 其含义是查找指定属性列值与 &lt;匹配串&gt; 相匹配的元组，当加上 NOT 短语后，则查找不匹配的元组 &lt;匹配串&gt; 可以是一个完整的字符串，也可以含有通配符百分号 % 与下划线 _ % 代表任意长度的字符串 例如，查询所有姓张的学生的学号、姓名、性别 _ 代表任意单个字符 例如，查询名字中第二个字为四的学生的学号、姓名、性别 ESCAPE 短语用于换码字符，这样使得匹配串中换码字符后的通配符不再具有通配符含义，转义为普通的 %、_ 字符， 例如，查询 DB_Design 课程的课程号、学分 123SELECT Cno, CcreditFROM courseWHERE Cname LIKE 'DB+_Design' ESCAPE '+'; /*换码字符为+*/ 一般默认换码字符为反斜杠 \\，此时无需使用 ESCAPE 短语 123SELECT Cno, CcreditFROM courseWHERE Cname LIKE 'DB\\_Design'; 【涉及空值的查询】当查询涉及到空值 NULL 时，一般用谓词 IS NULL 或 IS NOT NULL 来判断是否为空值（不能用 =、!=来判断是否为空值） 例如，查询不需先修课的课程的课程号、课程名 【多重条件查询】逻辑运算符 AND 和 OR 用来连接多个查询条件，需要注意的是AND 的优先级高于 OR 的优先级，但可以使用圆括号 () 来改变优先级 例如，查询 CS 系年龄在 22 岁下的学生的学号、姓名 实际上，对于使用谓词 IN 的指定集合的查询，其本质是多个 OR 的缩写 例如，查询 CS、IS 系的学生学号、姓名、所属系","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 列的选定","slug":"database/18.SQL列的选定","date":"2018-10-06T02:24:00.000Z","updated":"2021-08-23T13:55:42.187Z","comments":true,"path":"notes/database/ae3e53e1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/ae3e53e1.html","excerpt":"【查询指定列】在多数情况下，用户只需要表中的部分属性列，此时通过 SELECT 子句的 &lt;目标列表表达式&gt; 中指定要查询的属性列即可 例如，查询全体学生的学号、姓名","text":"【查询指定列】在多数情况下，用户只需要表中的部分属性列，此时通过 SELECT 子句的 &lt;目标列表表达式&gt; 中指定要查询的属性列即可 例如，查询全体学生的学号、姓名 需要注意的是，&lt;目标列表表达式&gt; 中各列的先后顺序可以与表中的顺序不一致，用户可以根据实际需要改变列的显示顺序 例如，查询全体学生的姓名、学号、所在系 【查询全部列】当需要查询所有的属性列时，有两种方法 一种是在 &lt;目标列表表达式&gt; 中显式的指出所有列名，该种方法可以改变列的显示顺序 例如，查询全体学生的全体属性，包括学号、姓名、性别、年龄、所在系，要求显示顺序为学号、姓名、年龄、性别、所在系 另一种是在 &lt;目标列表表达式&gt; 中直接使用 *，该方法查询出的列的显示顺序与基表中的顺序相同 例如，查询全体学生的全体属性，要求显示顺序与基表一致 【查询表达式】SELECT 子句的 &lt;目标列表表达式&gt; 不仅可以是表中的属性列，也可以直接使用表达式，包括：字符串常量、算术表达式、函数、列别名 例如，查询全体学生的姓名、出生年份、所在系，已知所有学生入学年份均为 2017 年，要求用小写表示系名 可以发现，查询出的列标题并不易于阅读，用户可以通过指定别名的方法来改变列标题 【消除重复行】当两个不完全相同的元组在投影到指定的某些列后，可能会变成相同的行，此时可以使用 DISTINCT 短语来消除重复的行，如果没有指定该短语，默认为 ALL 短语，即保留结果表中所有的行 例如，在选修关系表中查询学生学号 该查询结果中包含了重复的行，使用 DISTINCT 短语即可去除重复行","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 索引的数据定义","slug":"database/17.SQL索引的数据定义","date":"2018-10-05T11:40:00.000Z","updated":"2021-08-23T13:55:45.358Z","comments":true,"path":"notes/database/7d301194.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/7d301194.html","excerpt":"【索引】当表的数据量较大时，查询操作会比较耗时，而建立索引就是为了加快查询速度，可以根据需要在基本表上建立一个或多个索引，以加快查找速度 建立与删除索引一般由数据库管理员或建表的人来完成，此外 DBMS 一般会自动建立主键 PRIMARY KEY 和取唯一值 UNIQUE 列的索引","text":"【索引】当表的数据量较大时，查询操作会比较耗时，而建立索引就是为了加快查询速度，可以根据需要在基本表上建立一个或多个索引，以加快查找速度 建立与删除索引一般由数据库管理员或建表的人来完成，此外 DBMS 一般会自动建立主键 PRIMARY KEY 和取唯一值 UNIQUE 列的索引 索引是 RDBMS 的内部实现技术，属于内模式的范畴，RDBMS 会在执行查询时，自动选择合适的索引，用户不必显式地选择索引 索引虽然能够加速数据库查询，但需要占用一定的存储空间，而且当基本表更新时，DBMS 会对索引进行自动维护，这些都会增加数据库的负担，因此要根据实际需要来有选择地创建索引 目前 SQL 标准中没有涉及索引，但商用数据库管理系统一般都支持索引，只是不同的 RDBMS 支持的索引类型不同 【索引定义】在 SQL 中，建立索引的语法如下： 12CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;ON &lt;表名&gt;(&lt;列名1&gt; [&lt;次序1&gt;] [,&lt;列名2&gt; [&lt;次序2&gt;]] ... [,&lt;列名n&gt; [&lt;次序n&gt;]]); 其中，&lt;表名&gt; 是要建立索引的基本表的名字，&lt;列名&gt; 代表索引要建立在该表的哪些列上，&lt;次序&gt; 用于指定索引值的排列次序，默认值为升序 ASC，可选值为降序 DESC 而 UNIQUE 代表要建立的索引是唯一索引，该索引的每一个索引值对应唯一的数据记录；CLUSTER 代表要建立的索引是聚簇索引，该索引一般建立在需要经常查询的列上，经常更新的列不宜建立该索引，且一个基本表上最多只能建立一个聚簇索引 例如，为学生-课程数据库中的学生表 Student、课程表 Course、选课表 SC 建立索引，其中 Student 按学号 Sno 升序建立唯一索引 Stusno，Course 按课程号 Cno 升序建立唯一索引 Coucno，SC 按学号 Sno 升序、课程号 Cno 降序建立唯一索引 SCno 123CREATE UNIQUE INDEX Stusno ON Student(Sno); /*Student按Sno升序*/CREATE UNIQUE INDEX Coucno ON Course(Cno); /*Course按Cno升序*/CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); /*SC按Sno升序按Cno降序*/ 【索引修改】对于已建立的索引，可以使用 ALTER INDEX 语句进行修改，但不能用于修改索引的定义（添加列、删除列、更改列的顺序） 最常用的索引修改是重新命名索引，其语法如下 1ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt; 例如，将 SC 表的 SCno 索引名改为 SCSno 1ALTER INDEX SCno RENAME TO SCSno; 【索引删除】索引一经建立，就由系统使用、维护，不需要用户干预，若数据增删改频繁，系统会花费大量时来维护索引，变相的降低了查询效率，因此可以删除一些不必要的索引 在 SQL 中，删除索引的语法如下 1DROP INDEX &lt;索引名&gt; 例如，删除 Student 表的 Stusname 索引 1DROP INDEX Stusname","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 视图的数据定义","slug":"database/16.SQL视图的数据定义","date":"2018-10-05T08:23:00.000Z","updated":"2021-08-23T13:55:47.627Z","comments":true,"path":"notes/database/da97f9a1.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/da97f9a1.html","excerpt":"【视图】视图是从一个或几个基本表导出的表，其是一个虚表 数据库中仅存放视图定义，不存放其具体数据，这些具体数据仍在原来的基本表中，因此基本表中的数据一旦发生变化，从视图中查询出的数据也就随之改变了","text":"【视图】视图是从一个或几个基本表导出的表，其是一个虚表 数据库中仅存放视图定义，不存放其具体数据，这些具体数据仍在原来的基本表中，因此基本表中的数据一旦发生变化，从视图中查询出的数据也就随之改变了 视图一经定义，就可以与基本表一样被查询、删除，但对其更新有一定的限制，此外，还可以定义基于视图的视图 视图机制使用户可以将注意力集中在他所关心的数据上，如果这些数据不是直接来自基本表，则可以通过定义视图，使用户眼中的数据库结构简单、清晰，以简化用户的数据查询操作 同时，视图使用户以多种角度看待同一数据，当许多不同种类的用户使用同一个数据库时，这种灵活性是非常重要的 而在设计数据库应用系统时，对不同用户定义不同的视图，使机密数据不出现在不应看到这些数据的用户视图上，这样就由视图的机制自动提供了对机密数据的安全保护功能 此外，视图对重构数据库提供了一定程度的逻辑独立性 【视图定义】基本语法在 SQL 中，建立视图的语法如下 123CREATE VIEW &lt;视图名&gt; [(&lt;列名1&gt; [,&lt;列名2&gt;]...[,&lt;列名n&gt;])]AS &lt;子查询&gt;[WITH CHECK OPTION]; &lt;子查询&gt; 可以是任意的 SELECT 查询语句，RDBMS 执行建立视图的语句时，只是将视图定义存入数据字典，没有执行其中的 SELECT 语句，仅当对数据查询时，才按视图的定义从基本表中将数据查出 列名&lt;列名&gt; 是要组成视图的列的新名，如果全部省略，则该视图的列名将默认使用 SELECT 子句目标列的列名 如下例，通过基本表 student 建立 CS 系学生的视图 is_student，要求视图中包含学号 Sno、姓名 Sname、年龄 Sage 12345CREATE VIEW is_studentAS SELECT Sno, Sname, Sage FROM student WHERE Sdept='CS'; 该例中省略了组成视图的列，此时视图由子查询中 SELECT 子句中的三个列名组成 如果不省略，则 &lt;列名&gt; 的与 SELECT 子句目标列的一一对应，要求 &lt;列名&gt; 个数与 SELECT 子句目标列的个数相同 如下例，通过基本表 student 建立 CS 系学生的视图 is_student，要求视图中包含基本表中的学号 Sno、姓名 Sname、年龄 Sage，同时要求视图中的列名依次为 number、name、age 12345CREATE VIEW is_student(number, name, age)AS SELECT Sno, Sname, Sage FROM student WHERE Sdept='CS'; 此外，若视图由 SELECT * 建立，则必须要指定 &lt;列名&gt;，使用该种方法建立的视图可扩充性差，一旦基本表的结构改变，则基本表与视图的映射将被破坏，只能重新建立视图，因此应尽量避免使用该方法创建视图 例如，通过基本表 student 建立包含所有男生记录的视图 f_student 12345CREATE VIEW f_student(f_sno, name, sex, age, dept)AS SELECT * FROM Student WHERE Ssex='男'; 保证谓词条件WITH CHECK OPTION 代表对视图进行修改、删除、插入操作时，行要满足视图定义的谓词条件（子查询中的条件表达式） 如下例，通过基本表 student 建立 CS 系学生的视图 is_student，要求进行修改和插入操作时仍需保证该视图只有信息系学生 123456CREATE VIEW is_studentAS SELECT Sno, Sname, Sage FROM student WHERE Sdept='CS'WITH CHECK OPTION; 该例中加上了 WITH CHECK OPTION 子句，这样以后对该视图进行修改、删除、插入操作时，RDBMS 会自动加上 Sdept=&#39;IS&#39; 的条件： 修改：自动加上 Sdept=&#39;IS&#39; 的条件 删除：自动加上 Sdept=&#39;IS&#39; 的条件 插入：自动检查 Sdept=&#39;IS&#39; 的条件，若不是，则拒绝该插入操作；若未提供 Sdept 属性值，则自动设为 &#39;IS&#39; 视图类型若视图是从单个基本表导出的，且仅是去除了基本表的某些行列，但保留了主码，则称这类视图为行列子集视图 例如，通过基本表 student 建立 CS 系学生的视图 is_student，要求视图中包含学号 Sno、姓名 Sname、年龄 Sage 12345CREATE VIEW is_studentAS SELECT Sno, Sname, Sage FROM student WHERE Sdept='CS'; 若视图是从多个基本表导出的，则称这类视图为基于多个基表的视图 例如，通过基本表 student 和 sc 来建立 CS 系选修了 1 号课程的学生的视图 cs1，要求视图中包含学号 Sno、姓名 Sname、成绩 Grade 1234567CREATE VIEW cs1 (Sno, Sname, Grade)AS SELECT student.Sno, student.Sname, SC.Grade FROM student, sc WHERE student.Sdept='CS' AND Student.Sno=SC.Sno AND SC.Cno='1'; 视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个已定义好的视图上，这类视图称为基于视图的视图 例如，通过视图 cs1 来建立成绩在 90 分以上 的学生的视图 cs2 12345CREATE VIEW cs2AS SELECT Sno, Sname, Grade FROM cs1 WHERE Grade&gt;=90; 由于视图中的数据并不实际存储，因此定义视图时可以根据应用的需要设置一些派生属性列，这些派生属性由于在基本表中并不实际存在，因此被称为虚拟列，这些带虚拟列的视图被称为带表达式的视图 例如，通过基本表 student 建立一个反映学生出生年份的视图 birth，已知该表中所有学生的入学时间都是 2017 年 1234CREATE VIEW birth(Sno, Sname, Sbrith)AS SELECT Sno, Sname, 2017-Sage FROM student; 当使用聚集函数和 GROUP BY 子句的查询来定义视图时，这种视图称为分组视图 例如，通过基本表 sc 建立一个视图 avg_grade，包括学生学号和平均成绩 12345CREATE VIEW avg_grade(Sno, Gavg)ASSELECT Sno, AVG(Grade)FROM SCGROUP BY Sno; 【视图删除】若基本表删除被删除，那么由该基本表导出的所有视图均无法使用，但是视图的定义还没有从数据字典中删除，此时就需要调用视图删除语句，将视图删除 在 SQL 中，删除视图的语法为 1DROP VIEW &lt;视图名&gt; [CASCADE]; 执行该语句后，视图的定义将从数据字典中删除，如果该视图上还导出了其他视图，那么可以使用级联短语 CASCADE 将该视图及其导出的视图一并删除","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 基本表的数据定义","slug":"database/15.SQL基本表的数据定义","date":"2018-10-05T05:48:00.000Z","updated":"2021-08-23T14:00:57.306Z","comments":true,"path":"notes/database/807b7632.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/807b7632.html","excerpt":"【基本表定义】基本语法创建了一个模式，就创建了一个数据库的命名空间，在这个命名空间中，首先要做的就是创建该模式所包含的数据库基本表","text":"【基本表定义】基本语法创建了一个模式，就创建了一个数据库的命名空间，在这个命名空间中，首先要做的就是创建该模式所包含的数据库基本表 在 SQL 中，创建基本表的语法如下： 12345CREATE TABLE &lt;表名&gt; (&lt;列名1&gt; &lt;数据类型1&gt; [列级完整性约束条件1] [,&lt;列名2&gt; &lt;数据类型2&gt; [列级完整性约束条件2]] ... [,&lt;列名n&gt; &lt;数据类型n&gt; [列级完整性约束条件n]] [,&lt;表级完整性约束条件&gt;]); 建表的同时可以定义与该表有关的完整性约束条件，这些完整性约束条件会被存入系统的数据字典中，当用户操作表中数据时，RDBMS 会自动检查该操作是否违背完整性约束条件 需要注意的是，如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则，既可以定义在列级也可以定义在表级 数据类型在关系模型中，每一个属性来自一个域，其取值必须是域中的值 而在 SQL 中，域的概念用数据类型来实现，因此在定义表的各属性时，要指明数据类型及长度，一个属性选用何种数据类型要根据实际情况来决定，一般从取值范围、要做的运算两个方向来进行考虑 基本的数据类型如下表，要注意的是，不同的 RDBMS 中，支持的数据类型不完全相同 实例建立学生表 student，表中包含学号 Sno、姓名 Sname、性别 Ssex、年龄 Sage、专业 Sdept 五个属性，要求 Sno 是主码（列级完整性约束条件为 PRIMARY KEY），Sname 取值唯一（列级完整性约束条件为 UNIQUE） 1234567CREATE TABLE student ( Sno CHAR(9) PRIMARY KEY, /*列级完整性约束条件，主码*/ Sname CHAR(20) UNIQUE, /*列级完整性约束条件，取唯一值*/ Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20)); 建立课程表 course，表中包含课程号 Cno、课程名 Cname、先修课号 Cpno、学分 Ccredit 四个属性，要求 Cno 是主码（列级完整性约束条件为 PRIMARY KEY），Cname 不能为空（列级完整性约束条件为 NOT NULL），同时要求将 Cpno 设为外码，被参照表是 Course 表，被参照列是 Cno（表级完整性约束条件为 FOREING KEY(外码) REFERENCES 被参照表(被参照列)） 1234567CREATE TABLE course ( Cno CHAR(4) PRIMARY KEY, /*列级完整性约束条件，主码*/ Cname CHAR(40) NOT NULL, /*列级完整性约束条件，非空*/ Cpno CHAR(4), Ccredit SMALLINT, FOREIGN KEY(Cpno) REFERENCES Course(Cno) /*表级完整性约束条件*/); 建立学生选课表 sc，表中包含学生学号 Sno、课程号 Cno、成绩 SMALLINT，要求 Sno 与 Cno 共同作为主码，同时将 Sno、Cno 设为外码，被参照表分别为 Student 和 Course 12345678CREATE TABLE sc ( Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY(Sno, Cno), /*表级完整性约束条件*/ FOREIGN KEY(Sno) REFERENCES Student(Sno), /*表级完整性约束条件*/ FOREIGN KEY(Cno) REFERENCES Course(Cno) /*表级完整性约束条件*/); 模式与表每一个基本表都属于某一个模式，一个模式中包含多个基本表，在定义基本表时，有以下三种方法来定义其所属的模式 在创建模式时同时创建表名：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; &lt;表定义子句&gt;; 在表名中显示给出模式名：CREATE TABLE &lt;模式名&gt;.&lt;表名&gt;(...); 设置所属模式，在创建表时不必给出模式名 对于第一种方法，在 SQL 模式的定义与删除 中，介绍了模型定义的子句支持，可以在定义模式的同时创建基本表 对于第二种方法，其具体使用详见如下实例 1CREATE TABLE S-T.Student(...); /*Student所属的模式是S-T*/ 对于第三种方法，系统根据搜索路径来确定该对象所属的模式，RDBMS 会使用模式列表中第一个存在的模式作为数据库对象的模式名，如果搜索路径中的模式名都不存在，系统会报异常错误 使用 SHOW search_path; 语句可以显示当前的搜索路径，其默认值是 $user, PUBLIC，含义是先搜索与用户名相同的模式名，如果该模式名不存在，则使用 PUBLIC 模式 数据库管理员可以使用 SET search_path TO &lt;路径&gt;, PUBLIC 命令来设置搜索路径 【基本表修改】在 SQL 中，修改基本表的语法如下 123456ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]][ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE|RESTRICT]][DROP CONSTRAINT &lt;完整性约束名&gt; [CASCADE|RESTRICT]][ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]; 其中，&lt;表名&gt; 是要修改的基本表，ADD 子句用于增加新列、新的列级完整性约束条件、新的表级完整性约束条件，DROP 子句用于删除表中的列，DROP CONSTRAINT 子句用于删除指定的完整性约束条件，ALTER COLUMN 用于修改原有的列定义（列名与数据类型） 在 DROP 子句和 DROP CONSTRAINT 子句中，如果指定了级联短语 CASCADE，则自动删除引用了该列的其他对象；如果指定了约束短语 RESTRICT，则若该列被其他对象引用，RDBMS 将拒绝删除该列 例如，向学生表 student 中增加入学时间 S_entrance 列，其数据类型为日期型 1ALTER TABLE stuendt ADD S_entrance DATA; 此时，无论基本表中原来是否有数据，新增加的列一律为空值 【基本表删除】在 SQL 中，删除基本表的语法如下 1DROP TABLE &lt;表名&gt; [CASCADE|RESTRICT]; 如果指定了级联短语 CASCADE，则删除该表时，会将相关的依赖对象一起删除 例如，student 表上建有视图 IS_Student，删除该表时，指定级联短语 CASCADE 此时，基本表定义与数据会被删除，同时表上建立的视图也会被删除 12DROP TABLE student CASCADE;--NOTICE: drop cascades to view IS_Student 如果指定了约束短语 RESTRICT，则被删除的表不能被其他表的约束所引用，同时如果存在依赖该表的对象，RDBMS 也将拒绝删除该表，同时报出错误 例如，删除 student 表，指定级联短语 RESTRICT 此时，系统将返回错误信息，存在依赖该表的对象，此表不能被删除 12DROP TABLE student RESTRICT;--ERROR: cannot drop table Student because other object depend on it","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"SQL 模式的数据定义","slug":"database/14.SQL模式的数据定义","date":"2018-10-05T04:56:00.000Z","updated":"2021-08-23T13:55:52.017Z","comments":true,"path":"notes/database/6a894b26.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/6a894b26.html","excerpt":"【模式定义】基本语法在 SQL 中，要创建模式，需要调用该命令的用户拥有数据库管理员权限，或者取得了数据库管理员所授予的 CREATE SCHEMA 权限","text":"【模式定义】基本语法在 SQL 中，要创建模式，需要调用该命令的用户拥有数据库管理员权限，或者取得了数据库管理员所授予的 CREATE SCHEMA 权限 定义模式的 SQL 语法为： 1CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;; 例如，为用户 TOM 定义一个学生-课程模式 S-T 1CREATE SCHEMA \"S-T\" AUTHORIZATION TOM; 隐含模式名如果没有指定 &lt;模式名&gt;，那么 &lt;模式名&gt; 将隐含为 &lt;用户名&gt; 例如，为用户 TOM 定义一个学生-课程模式 S-T 时，没有指定模式名 S-T，此时模式名即用户名 TOM 1CREATE SCHEMA AUTHORIZATION TOM; 子句支持定义模式实质上是定义了一个命名空间，在这个空间中可以进一步定义该模式包含的数据库对象 目前，用户可以在创建模式的同时，在该模式中进一步创建基本表、创建视图、定义授权，即在 CREATE SCHEMA 语句中接受 CREATE TABLE、CREATE VIEW、GRANT 子句 语法为： 12CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt; | &lt;视图定义子句&gt; | &lt;授权定义子句&gt;]; 例如，为用户 TOM 定义一个学生-课程模式 S-T，同时在其中定义一个表 TAB1，该表一共两列，均为 INT 型 12CREATE SCHEMA \"S-T\" AUTHORIZATION TOMCREATE TABLE TAB1(COL1 INT, COL2 INT); 【模式删除】在 SQL 中，删除模式的 SQL 语法为： 1DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;; 其中 CASCADE 和 RESTRICT 二者必选其一，选择了级联（CASCADE），表示在删除模式的同时将该模式中所有的数据库对象全部删除；选择了限制（RESTRICT），表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行，仅在该模式中没有任何下属对象时，才执行该语句 例如，删除学生-课程模式 S-T，同时将该模式中定义的表 TAB1 也删除 1DROP SCHEMA \"S-T\" CASCADE;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"单模式匹配","slug":"string/01.single-pattern-matching/01.单模式匹配","date":"2018-10-04T11:35:00.000Z","updated":"2021-09-02T13:40:47.377Z","comments":true,"path":"oi-acm/string/single-pattern-matching/761134bf.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/string/single-pattern-matching/761134bf.html","excerpt":"【问题描述】在字符串的单模式匹配中，对于待匹配的长度为 $n$ 的数组 T[n]称为文本（Text），对于匹配的满足 $m\\leq n$ 的长度为 $m$ 的数组 P[m] 称为模式（Pattern） 当 $0\\leq s \\leq n-m$ 时，若对于 $1\\leq i\\leq m$，有 T[s+i]=P[i] 成立，则称 $s$ 为模式 P 在文本 T 中的有效位移（Valid Shift），又称匹配点","text":"【问题描述】在字符串的单模式匹配中，对于待匹配的长度为 $n$ 的数组 T[n]称为文本（Text），对于匹配的满足 $m\\leq n$ 的长度为 $m$ 的数组 P[m] 称为模式（Pattern） 当 $0\\leq s \\leq n-m$ 时，若对于 $1\\leq i\\leq m$，有 T[s+i]=P[i] 成立，则称 $s$ 为模式 P 在文本 T 中的有效位移（Valid Shift），又称匹配点 如下图所示，要在文本 T=abcabaabcabac 中找出模式 P=abaa 的所有匹配 可以发现，模式 P 在文本 T 中，仅在位移 $s=3$ 处出现一次，即 $s=3$ 为一个匹配点 综上，字符串模式匹配，本质上就是对字符串子串的定位操作，其求的是子串在主串中的位置 在字符串模式匹配中，常用的算法有 BF 算法、MP 算法、KMP 算法等，这些算法通常都分为两个步骤：预处理（Preprocessing）、匹配（Matching），所以算法的总时间复杂度为预处理和匹配的时间复杂度的总和 常见的字符串匹配算法有：BP 算法、KMP 算法等 【PM 表】对于一个字符串，在进行匹配时，有如下基本概念： 字符串前缀：除最后一个字符外字符串的头部子串集，当字符串为单个字符时，前缀为空集 字符串后缀：除第一个字符外字符串的尾部子串集，当字符串为单个字符时，后缀为空集 相等前后缀：字符串前缀与后缀的交集 部分匹配值：字符串前缀与后缀的最长的相等前后缀的长度 以 ababa 为例，有： 子串 前缀 后缀 相等前后缀 部分匹配值 a ∅ ∅ ∅ $0$ ab {a} {b} ∅ $0$ aba {a,ab} {a,ba} {a} $1$ abab {a,ab,aba} {a,ab,bab} {a,ab} $2$ ababa {a,ab,aba,abab} {a,ba,aba,baba} {a,aba} $3$ 将一个字符串的全部子串的部分匹配值写成数组形式，即可得到部分匹配值（Partial Match）的表，即 PM 表 在上例中，ababa 的 PM 表为： 编号 0 1 2 3 4 字符 a b a b a PM 值 0 0 1 2 3","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"字符串","slug":"oi-acm/string","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/"},{"name":"单模式匹配","slug":"oi-acm/string/single-pattern-matching","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/string/single-pattern-matching/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"字符串","slug":"string","permalink":"https://alex-mcavoy.github.io/tags/string/"},{"name":"单模式匹配","slug":"single-pattern-matching","permalink":"https://alex-mcavoy.github.io/tags/single-pattern-matching/"}],"author":"Alex_McAvoy"},{"title":"字符串的定义与存储结构","slug":"basic/01.theory/03.字符串的定义与存储结构","date":"2018-10-04T07:33:00.000Z","updated":"2021-09-25T08:39:05.818Z","comments":true,"path":"oi-acm/basic/theory/cd4644a3.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/cd4644a3.html","excerpt":"【字符串的定义】1.字符集 一个字符集 $\\Sigma$ 是一个建立了全序关系的集合，也就是说，$\\Sigma$ 中的任意两个不同的元素 $\\alpha$ 和 $\\beta$ 都可以比较大小，要么 $\\alpha&lt;\\beta$，要么 $\\alpha&gt;\\beta$","text":"【字符串的定义】1.字符集 一个字符集 $\\Sigma$ 是一个建立了全序关系的集合，也就是说，$\\Sigma$ 中的任意两个不同的元素 $\\alpha$ 和 $\\beta$ 都可以比较大小，要么 $\\alpha&lt;\\beta$，要么 $\\alpha&gt;\\beta$ 字符集 $\\Sigma$ 中的元素称为字符 2.字符串 一个字符串 $S$ 是将 $n$ 个字符顺次排列形成的序列，$n=|S|$ 称为字符串的长度 当 $i$ 从 $0$ 开始，$S$ 的第 $i$ 个字符记为 $S[i-1]$；当 $i$ 从 $1$ 开始，则 $S$ 的第 $i$ 个字符记为 $S[i]$ 当 $n=0$ 时，$S$ 称为空串，而当两字符串长度相等且对应位置字符相同时，称两个字符串相等 3.子序列 字符串 $S$ 的子序列是从 $S$ 中将若干元素提取出来并不改变相对位置形成的序列，即： S[p_1],S[p_2],...,S[p_k],1\\leq p_1 \\leq p_2 \\leq ... \\leq p_k\\leq n4.子串 字符串 $S$ 的子串 $S[i..j],i\\leq j$，表示 $S$ 中从 $i$ 到 $j$ 的位置 即字符串中任意个连续的字符组成的子序列被称为子串，同时，包含子串的字符串被称为主串 5.回文串 回文串是正着写与倒着写都相同的字符串，即： S[i]=S[n+1-i], 1\\leq i\\leq n6.字典序 以第 $i$ 个字符作为第 $i$ 关键字进行大小比较，空字符小于字符集内任何字符 例如，有：$a&lt;aa$ 【字符串的逻辑结构】字符串的逻辑结构与线性表相似，区别仅在于字符串的数据对象限定为字符集 在基本操作上，线性表主要以单个元素为操作对象，如查找、插入、删除某个元素等；字符串的基本操作则是以子串为操作对象，如查找、插入一个子串等 字符串的基本操作，被称为最小操作子集，分别为：串赋值、串比较、求串长、串联接、求子串，这些操作不可能利用其它串操作来实现，但其他串操作可以在最小操作子集上实现 【字符串的存储结构】定长顺序存储定长顺序存储类似于线性表的顺序存储结构，其用一组连续的存储单元存储字符序列 在字符串的定长顺序存储中，会为每个串分配一个固定长度的存储区，这个存储区被称为定长数组，而这个固定长度是预定义的最大串长 MAX_LEN ，对于超过预定义长度的串值将会被舍去，这个过程被称为截断 在 C/C++ 中，字符数组的尾部会默认加入一个不计入串长的标记字符 \\0，此时串长为隐含值，但有时希望能够将串长在字符串中显示的表示出来，常见的方法有以下两种： 使用额外的变量 len 来记录串长 用字符数组的 ch[0] 来记录串长，使得字符位序与数组下标相同 12345#define MAX_LEN 255typedef struct &#123; //使用len记录串长 char ch[MAX_LEN]; int len;&#125; Str; 堆分配存储堆分配存储，同样是以一组地址连续的存储单元来存放字符序列，但其存储空间是通过在程序执行时动态分配得到的 在 C/C++ 中，存在一个被称为堆的自由存储区，其通过 malloc()/free() 或 new/delete 来完成动态存储管理 堆分配存储一般会利用 malloc() 为每个新产生的串分配一块实际串长所需的存储空间，并返回一个指向起始地址的指针，以作为串的基地址 1234typedef struct &#123; char *ch; //串的基地址 int len;&#125; Str; 块链分配存储块链分配存储，是类似于线性表的链式存储结构 由于串的特殊性，每个元素只有一个字符，即每个字符 1B，而每个指针占 4B，存储密度极低 为解决这种问题，令每个结点存储多个字符，称为块，同时，进行串尾块填充，即当最后一块存不满时，使用 \\0 进行填充 块链分配存储的存储结构如下 12345#define PIECE 4typedef struct SNode &#123; char ch[PIECE]; struct SNode *next;&#125; SNode,* LinkString;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"},{"name":"字符串","slug":"string","permalink":"https://alex-mcavoy.github.io/tags/string/"}],"author":"Alex_McAvoy"},{"title":"SQL 概述","slug":"database/13.SQL概述","date":"2018-10-04T05:18:00.000Z","updated":"2021-08-23T13:54:48.073Z","comments":true,"path":"notes/database/83294e22.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/83294e22.html","excerpt":"【概述】目前，结构化查询语言 SQL 是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言，其功能不仅仅是查询，还包括数据库模式创建、数据库数据更新、数据库安全性完整性定义与控制等功能 在 关系操作 中，简单介绍了关系数据语言，本篇将对 SQL 进行简单的介绍","text":"【概述】目前，结构化查询语言 SQL 是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言，其功能不仅仅是查询，还包括数据库模式创建、数据库数据更新、数据库安全性完整性定义与控制等功能 在 关系操作 中，简单介绍了关系数据语言，本篇将对 SQL 进行简单的介绍 【特点】综合统一数据库系统的主要功能是通过数据库支持的数据语言来实现的，对于非关系模型的数据语言，分为以下四类： 模式数据定义语言（模式 DDL）：用于定义模式 外模式数据定义语言（外模式 DDL）：用于定义外模式 数据存储描述语言（DSDL）：用于定义内模式 数据操纵语言（DML）：进行数据的存取与处置 当非关系模型的用户数据库投入运行后，如果要修改模式，必须停止现有数据库的运行，转储数据，修改模式编译后再重装数据库，十分繁琐 而 SQL 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动： 数据定义（DDL）： 定义、修改、删除关系模式（基本表） 定义、删除视图 定义、删除索引 数据操纵（DML）： 数据查询 数据插入、删除、更新 数据控制（DCL）： 用户访问权限的授予、收回 这为数据库应用系统的开发提供了良好的环境，尤其是在关系模型的用户数据库投入运行后，当修改模式时，可根据需要随时修改模式，不影响数据库的运行，使数据库具有良好的可扩展性 此外，由于关系模型中，实体与实体间的联系均用关系来表示，这种数据结构的单一性使得 SQL 中的数据操作符具有统一性 高度非过程化在非关系模型中，数据操纵语言（DML）是面向过程的语言，在完成某些请求时必须指定存取路径 而用 SQL 进行数据操纵时，用户只要提出要做什么，无须了解存储路径，由系统自动完成存取路径的选择和 SQL 具体的操作过程 SQL 的这种设计，不仅减轻了用户的负担，还利于提高数据独立性 集合操作方式在非关系模型中，采用的是面向记录的操作方式，操作对象是一条记录，在操作时通常要说明具体处理过程，即按照哪条路径、如何循环等 而 SQL 采用集合操作方式，不仅操作对象、查找结果是元组的集合，每次插入、删除、更新操作的对象也是元组的集合 多种使用方式SQL 既是独立语言，又是嵌入式语言，在这两种不同的使用方式下，语法结构基本上是一致的，这种统一的语法结构提供多种不同使用方式的做法，提供了极大的灵活性与方便性 作为独立语言，其能独立交互使用，一般由 DBMS 提供联机交互工具，用户可以在终端上直接键入 SQL 命令对数据库进行操作，由 DBMS 来进行解释 作为嵌入式语言，SQL 语句能够嵌入到高级语言程序（宿主语言）中，供程序员设计程序时使用，使得应用程序能够充分利用 SQL 访问数据库的能力与宿主语言的过程处理能力，此外，一般需要进行预编译，将嵌入的 SQL 语句转化为宿主语言编译器能处理的语句 语言简洁SQL 功能极强，语言十分简洁，核心功能只有 9 个动词，接近英语口语，易于学习和使用 SQL 功能 动词 数据查询 SELECT 数据定义 CREATE、DROP、ALTER 数据操纵 INSERT、UPDATE、DELETE 数据控制 GRANT、REVOKE 【对三级模式结构的支持】支持 SQL 的关系数据库管理系统同样支持数据库三级模式结构 基本表是本身独立存在的表，在关系型数据库中，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，此外，一个表也可以携带若干索引，索引也存放在存储文件中 视图是从一个或几个基本表导出的表，其是一个虚表，本身不独立存储在数据库中，在数据库中仅存放其定义而不存放其对应的数据，其在概念上与基本表等同，用户可以在视图上再定义视图 存储文件的逻辑结构组成了关系数据库的内模式，物理结构对用户是透明的 【数据定义】定义语句由于支持 SQL 的关系数据库系统支持三级模式结构，其模式、外模式、内模式中的基本对象有：模式、表、视图、索引，因此 SQL 的数据定义功能包括模式定义、表定义、视图定义、索引定义 相关的定义语句如下表 可以看到，SQL 标准不提供修改模式定义和修改视图定义的操作，用户如果想修改这些对象，只能先删除后重建，实际上，SQL 标准也没有提供索引相关的语句，但为提高查询效率，商用关系数据库管理系统通常都提供了索引及其相关的语句 层次结构在早期的数据库系统中，所有数据库对象都属于一个数据库，即只有一个命名空间，而现代的数据库管理系统提供了一个层次化的数据库对象命名机制，即对于一个关系管理数据库系统的实例，可以建立多个数据库；在一个数据库中，可以建立多个模式；在一个模式下，可以多个数据库对象（表、视图、索引） 关于数据定义的详细介绍见下 模式的数据定义：点击这里 基本表的数据定义：点击这里 视图的数据定义：点击这里 索引的数据定义：点击这里 数据字典在 RDBMS 中，系统内部有一组系统表，被称为数据字典，其记录了数据巨亏中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等，RDBMS 在执行 SQL 的数据定义语句时，实际上就是在更新数据字典中的相应信息 【数据查询】查询语句数据查询是数据库的核心操作，SQL 提供了 SELECT 语句进行数据查询，该语句具有灵活的使用方式和丰富的功能，其一般格式为： 12345SELECT [ALL|DISTINCT] &lt;目标列表表达式1&gt; [,&lt;目标列表表达式2&gt; ... &lt;目标列表表达式n&gt;]FROM &lt;表名或视图名1&gt; [,&lt;表名或视图名2&gt;...&lt;表名或视图名n&gt;] | (SELECT 语句) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]]; 语句含义整个 SELECT 语句的含义是： 从 FROM 子句指定的基本表、视图、派生表作笛卡尔积 根据 WHERE 子句的条件表达式，进行选择运算，找出符合条件的元组 根据 SELECT 子句中的目标列表表达式，对上述结果作投影运算，形成结果表 如果有 GROUP BY 子句，则将结果按 &lt;列名1&gt; 的值进行分组，该属性列值相等的元组为一组，通常会在每组中作用聚集函数，如果带有 HAVING 短语，则按照其 &lt;条件表达式&gt;，满足其指定条件的组才予以输出 如果有 ORDER BY 子句，则结果表还要按照 &lt;列名2&gt; 的值，进行升序 ASC 或降序 DESC 排序 具体用法SELECT 语句既可以完成简单的单表查询，也可以完成复杂的连接查询，关于数据查询的基本用法详细介绍见下： 列的选定：点击这里 WHERE 子句：点击这里 ORDER 子句与 GROUP 子句：点击这里 集合查询：点击这里 连接查询：点击这里 嵌套查询：点击这里 视图查询：点击这里 数据库为更好的进行演示，演示数据库采用学生课程数据库 S-T，包含三张表： 学生表 student：学号 Sno、姓名 Sname、性别 Ssex、年龄 Sage、系 Sdept 课程表 course：课程号 Cno、课程名 Cname、先修课课程号 Cpno、学分 Ccreadit 选课关系表 sc：学号 Sno、课程号 Cno、成绩 Grade 各表中的数据如下： 学生表：student(Sno, Sname, Ssex, Sage, Sdept) 课程表：course(Cno, Cname, Cpno, Ccredit) 选课关系表：sc(Sno, Cno, Grade) SQL 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `course`-- ----------------------------DROP TABLE IF EXISTS `course`;CREATE TABLE `course` ( `Cno` char(4) NOT NULL, `Cname` char(40) NOT NULL, `Cpno` char(4) DEFAULT NULL, `Ccredit` smallint(6) DEFAULT NULL, PRIMARY KEY (`Cno`), KEY `Cpno` (`Cpno`), CONSTRAINT `course_ibfk_1` FOREIGN KEY (`Cpno`) REFERENCES `course` (`cno`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of course-- ----------------------------INSERT INTO `course` VALUES ('1', '英语', null, '5');INSERT INTO `course` VALUES ('2', '数学', null, '5');INSERT INTO `course` VALUES ('3', '离散数学', '2', '3');INSERT INTO `course` VALUES ('4', 'C语言', '3', '4');INSERT INTO `course` VALUES ('5', '数据结构', '4', '4');INSERT INTO `course` VALUES ('6', '算法导论', '5', '3');INSERT INTO `course` VALUES ('7', '操作系统', '3', '4');-- ------------------------------ Table structure for `sc`-- ----------------------------DROP TABLE IF EXISTS `sc`;CREATE TABLE `sc` ( `Sno` char(9) NOT NULL, `Cno` char(4) NOT NULL, `Grade` smallint(6) DEFAULT NULL, PRIMARY KEY (`Sno`,`Cno`), KEY `Cno` (`Cno`), CONSTRAINT `sc_ibfk_1` FOREIGN KEY (`Sno`) REFERENCES `student` (`sno`), CONSTRAINT `sc_ibfk_2` FOREIGN KEY (`Cno`) REFERENCES `course` (`cno`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of sc-- ----------------------------INSERT INTO `sc` VALUES ('1', '1', '90');INSERT INTO `sc` VALUES ('1', '2', '55');INSERT INTO `sc` VALUES ('2', '3', '87');INSERT INTO `sc` VALUES ('3', '1', '69');INSERT INTO `sc` VALUES ('4', '5', '88');-- ------------------------------ Table structure for `student`-- ----------------------------DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `Sno` char(9) NOT NULL, `Sname` char(20) DEFAULT NULL, `Ssex` char(2) DEFAULT NULL, `Sage` smallint(6) DEFAULT NULL, `Sdept` char(20) DEFAULT NULL, PRIMARY KEY (`Sno`), UNIQUE KEY `Sname` (`Sname`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of student-- ----------------------------INSERT INTO `student` VALUES ('1', '张三', '男', '21', 'CS');INSERT INTO `student` VALUES ('2', '李四', '女', '20', 'CS');INSERT INTO `student` VALUES ('3', '王五', '男', '20', 'MA');INSERT INTO `student` VALUES ('4', '赵六', '女', '21', 'IS'); 【数据更新】数据更新操作有三种：插入数据、修改数据、删除数据 详细介绍见下： 插入数据：点击这里 修改数据：点击这里 删除数据：点击这里 对于视图的更新：点击这里 【空值的处理】所谓空值 NULL 就是不知道、无意义、不存在的值，SQL 语言中允许某些元组的某些属性在一定情况下取空值，一般有以下几种情况： 该属性有一个值，但目前不知道它的具体值 该属性不应该有值 由于某种原因不便填写 综上所述，空值是一个很特殊的值，含有不确定性，对关系运算带来特殊的问题，因此需要进行特殊处理 关于空值的处理详见：SQL 的空值处理","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"},{"name":"SQL","slug":"sql","permalink":"https://alex-mcavoy.github.io/tags/sql/"}],"author":"Alex_McAvoy"},{"title":"数组与矩阵的压缩存储","slug":"basic/01.theory/04.数组与矩阵的压缩存储","date":"2018-10-04T03:31:00.000Z","updated":"2021-09-25T08:39:43.736Z","comments":true,"path":"oi-acm/basic/theory/233df825.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/233df825.html","excerpt":"【数组】概念数组，是由 $n(n \\geq1 )$ 个相同类型的数据元素构成的有限序列，每个数据元素被称为一个数组元素，每个元素在数组中的序号称为数组的下标，下标的取值范围被称为维界","text":"【数组】概念数组，是由 $n(n \\geq1 )$ 个相同类型的数据元素构成的有限序列，每个数据元素被称为一个数组元素，每个元素在数组中的序号称为数组的下标，下标的取值范围被称为维界 其是数组是线性表的推广，但与线性表不同是，数组一旦被定义，维数和维界都不会再改变，因此数组除初始化和销毁外，只有存取和修改操作 也就是说，对于一维数组来说，可视为定长线性表，对于二维数组来说，可视为元素定长线性表的定长线性表 存储结构一个数组的所有元素在内存中占据一段连续的存储空间 对于一维数组 $a[0,1,…,n-1]$ 来说，设每个数组元素所占的存储空间为 $L$ 则第 $i$ 个元素 $a_i$ 的地址为： LOC(a_i)=LOC(a_0)+i*L,\\quad 0 \\leq i","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"}],"author":"Alex_McAvoy"},{"title":"关系的完整性约束","slug":"database/12.关系的完整性约束","date":"2018-10-03T11:58:00.000Z","updated":"2021-08-23T13:41:38.994Z","comments":true,"path":"notes/database/d5e329c3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/d5e329c3.html","excerpt":"【概述】关系模型的完整性规则是对关系的某种约束条件，关系的值随着时间变化应满足一定的约束，这些约束条件实际上是对现实世界的要求 在 数据库关系模型 中，简单介绍了关系模型的完整性约束条件：","text":"【概述】关系模型的完整性规则是对关系的某种约束条件，关系的值随着时间变化应满足一定的约束，这些约束条件实际上是对现实世界的要求 在 数据库关系模型 中，简单介绍了关系模型的完整性约束条件： 实体完整性：关系中的主属性不能取空值 参照完整性：关系中不允许引用不存在的实体 用户定义的完整性：用户自定义的针对具体关系数据库的约束条件 其中，实体完整性、参照完整性是关系模型必须满足的完整性约束条件，被称为关系的两个不变性，由关系系统自动实现，用户定义的完整性是应用领域要遵循的约束条件，体现了具体领域中的语义约束 【实体完整性】实体完整性是指：若属性 $A$ 是基本关系 $R$ 的主属性，则属性 $A$ 不能取空值 $NULL$ 其说明如下： 实体完整性规则是针对基本关系而言的，一个基本表通常对应现实世界的一个实体集 现实世界中，实体是可区分的，即他们具有某种唯一性的标识 关系模型中，以主码作为唯一性标识 主码中的属性即主属性不能取空值，若主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与 2. 矛盾 例如：在选修关系 选修(学号, 课程号, 成绩) 中，若 学号、课程号 为主码，则这两个属性都不能取空值 【参照完整性】关系间的引用现实世界中，实体间存在某种联系，在关系模型中，实体及实体间的联系是用关系描述的，这样自然就存在关系与关系间的引用 例如，学生实体和专业实体可以用下面的关系来表示 学生(学号, 姓名, 性别, 专业号, 年龄)，其中 学号 为主码 专业(专业号, 专业名)，其中 专业号 为主码 学生关系引用了专业关系的主码 专业号，这就要求学生关系中 专业号 的值必须是确实存在的专业的专业号，也就是说，学生关系中的某个属性的取值需要参照专业关系的属性取值 此外，同一关系内部属性间也可存在引用关系 如下图，学号 是主码，班长是 外码，其引用了本关系的 学号 外码设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的码，如果 $F$ 与基本关系 $S$ 的主码 $K_s$ 相对应，则称 $F$ 是基本关系 $R$ 的外码，其中基本关系 $R$ 参照关系，基本关系 $S$ 称为被参照关系或目标关系 以主码为 学号 的学生关系 学生(学号, 姓名, 性别, 专业号, 年龄) 和主码为 专业 的专业关系 专业(专业号, 专业名) 为例 学生关系是参照关系，专业关系是被参照关系，专业关系的 专业号 属性是学生关系的外码 需要注意的是，目标关系 $S$ 与主码 $K_s$ 和参照关系的外码 $F$ 必须定义在同一个域上，此外，外码并不一定要与相应的主码同名，当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别 参照完整性规则若属性或属性组 $F$ 是基本关系 $R$ 的外码，其与基本关系 $S$ 的主码 $K_s$ 相对应（$S$ 与 $R$ 不一定是不同的关系），则对于 $R$ 中每个元组在 $F$ 上的值必须满足： 或为空值 或等于 $S$ 中某个元组的主码值 以主码为 学号 的学生关系 学生(学号, 姓名, 性别, 专业号, 年龄) 为例，每个元组的 专业号 属性只取两类值： 空值：表示尚未给该学生分配专业 非空值：此时该值必须是专业关系中某个元组的 专业号 值，表示该学生不可能分配一个不存在的专业 【用户定义的完整性】用户定义的完整性是针对某一具体关系数据库的约束条件，反映了某一具体应用所涉及的数据必须满足的语义要求 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能 例如，对于课程关系 课程(课程号, 课程名, 学分)，根据实体完整性，主属性 课程号 必须取唯一值，定义如下完整性规则： 课程名 不能取空值 学分 只能取值 {1, 2, 3, 4}","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"关系代数","slug":"database/11.关系代数","date":"2018-10-03T06:12:00.000Z","updated":"2021-08-23T13:52:06.014Z","comments":true,"path":"notes/database/61c34bcf.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/61c34bcf.html","excerpt":"【概述】在 关系操作 中，简单介绍了关系模型中的常用操作和关系查询语言，目前，在关系数据库领域，SQL 是最常用的关系数据语言，其是以关系代数为核心的，本篇将对关系代数进行简单介绍 关系代数是一种抽象的关系数据语言，其通过代数运算方式表示关系查询，所谓代数运算，是将一定的运算符作用于一定的运算对象上，通过形成表达式以得到预期的运算结果，所以运算对象、运算符、运算结果是代数运算的三大要素","text":"【概述】在 关系操作 中，简单介绍了关系模型中的常用操作和关系查询语言，目前，在关系数据库领域，SQL 是最常用的关系数据语言，其是以关系代数为核心的，本篇将对关系代数进行简单介绍 关系代数是一种抽象的关系数据语言，其通过代数运算方式表示关系查询，所谓代数运算，是将一定的运算符作用于一定的运算对象上，通过形成表达式以得到预期的运算结果，所以运算对象、运算符、运算结果是代数运算的三大要素 关系代数的运算对象、运算结果都是关系，运算符分为集合运算符、专门的关系运算符两类，关系代数运算符如下表所示 依据运算符的不同，关系代数的运算分为传统的集合运算、专门的关系运算 传统的集合运算将关系看成元组的集合，其运算是从关系的水平方向（以行的角度）进行；专门的关系运算不仅涉及到行，还涉及到列，在进行运算时，常涉及到比较运算符、逻辑运算符来辅助运算 【传统的集合运算】传统的集合运算是二目运算，包括：并（Union）、差（Except）、交（Intersection）、笛卡尔积（Cartesian Product）四种运算 设关系 $R$ 和关系 $S$ 具有相同的目 $n$（两个关系都有 $n$ 个属性），且相应属性取自同一域，$t$ 是元组变量，$t \\in R$ 表示 $t$ 是 $R$ 的一个元组，据此可以定义并、差、交三种运算 关系 $R$ 与 $S$ 的并仍是 $n$ 目关系，由属于 $R$ 或属于 $S$ 的元组组成，记作： R \\cup S=\\{t|t \\in R \\vee t \\in S\\} 关系 $R$ 与 $S$ 的差仍是 $n$ 目关系，由属于 $R$ 但不属于 $S$ 的元组组成，记作： R - S=\\{t|t \\in R \\wedge t \\notin S\\} 关系 $R$ 与 $S$ 的交仍是 $n$ 目关系，由既属于 $R$ 又不属于 $S$ 的元组组成，记作： R \\cap S=\\{t|t \\in R \\wedge t \\in S\\} 此外，关系的交可以用关系的差来表示，即：$R \\cap S=R-(R-S)$ 而关系的笛卡尔积的元素是元组，因此严格来讲其实是广义的笛卡尔积（Extended Cartesian Product），关于笛卡尔积详见：点击这里 设 $R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系，有 $t_r \\in R，t_s \\in S$，关系 $R$ 与关系 $S$ 的笛卡尔积是一个 $n+m$ 列的元组的集合，记作： R \\times S=\\{\\overset{\\frown }{t_r t_s} | t_r \\in R \\wedge t_s \\in S\\}其中，$\\overset{\\frown }{t_r t_s}$ 被称为元组的连接（concatenatoin），是一个 $n+m$ 列的元组，该元组的前 $n$ 列是关系 $R$ 的一个 $n$ 元组，后 $m$ 列是关系 $S$ 的一个 $m$ 元组 同时，在上例中可以看出，若 $R$ 有 $k_1$ 个元组，$S$ 有 $k_2$ 个元组，则关系 $R$ 和 $S$ 的笛卡尔积有 $k_1*k_2$ 个元组 【专门的关系运算】引入专门的关系运算包括选择、投影、连接、除运算等，为了叙述上的方便，引入以下记号： 设关系模式为 $R(A_1,A_2,…,A_n)$，其中的某个关系为 $R$，用 $t \\in R$ 表示 $t$ 是 $R$ 的一个元组，$t[A_i]$ 表示元组 $t$ 中相应属性 $A_i$ 的一个分量 若 $A=\\{A_{i1},A_{i2},…,A_{ik}\\}$ 其中的 $A_{i1},A_{i2},…,A_{ik}$ 是 $A_1,A_2,…,A_n$ 中的一部分，则称 $A$ 为属性列或属性组，用 $\\overline{A}$ 表示 $\\{A_1,A_2,…,A_n\\}$ 中去掉属性组 $A$ 后剩余的属性组，用 $t[A]=(t[A_{i1}],t[A_{i2}],…,t[A_{ik}])$ 表示元组 $t$ 在属性组 $A$ 上诸分量的集合 同时，以下图的学生-课程数据库为例，包括学生关系 Student、课程关系 Course、选修关系 SC，以便对专门的关系运算进行举例 选择选择（Selection）又称限制，其是在关系 $R$ 中选择满足给定条件的元组组成新的关系，记作： \\sigma_F(R)=\\{t| t \\in R \\wedge F(t)=true\\}其中，$F$ 表示选择条件，是一个逻辑表达式，取逻辑值 true 或 false，同时，在基本的选择条件上可以进一步的进行逻辑运算（与 $\\wedge$、或 $\\vee$、非 $\\neg$） 逻辑表达式 $F$ 的基本形式为 $X_1 \\theta Y_1$，其中 $\\theta$ 代表比较运算符（$&gt;,&lt;, \\geq ,\\leq ,\\neq ,=$），$X_1$ 和 $Y_1$ 可代表属性名（也可用其序号代替）、常量、简单函数 综上所述，选择运算实际上是从关系 $R$ 中选取使逻辑表达式 $F$ 为 true 的元组，是从行角度进行的运算 例如，查询信息系（IS 系）全体学生：$\\sigma_{Sdept=’IS\\:’}(Student)$，结果如下 再例如，查询年龄大于等于 20 岁的男学生：$\\sigma_{Sage\\geq 20 \\wedge Ssex=’男\\:’}(Student)$，结果如下 投影投影（Projection）是在关系 $R$ 上选择若干属性列组成新的关系，记作： \\Pi_A(R)=\\{t[A] | t \\in R\\}其中，$A$ 为 $R$ 中的属性列 投影操作是对列进行运算的，但值得注意的是，投影后不仅取消了原关系中的某些列，而且可能取消某些元组，因为取消了某些列后，可能会出现重复的行，此时应该对完全相同行去重 例如，查询所有学生的姓名和年龄：$\\Pi_{Sname,Sage}(Student)$，结果如下 再例如，查询学号为 95001 号学生所选修的课程号：$\\Pi_{Cno}(\\sigma_{Sno=95001(SC)})$，结果如下 连接定义连接（Join）也称 $\\theta$ 连接，是从两个关系 $R$ 与 $S$ 的笛卡尔积中选取属性间满足一定条件的元组组成新的关系，记作： R \\underset{A\\theta B}{\\bowtie} S=\\{\\overset{\\frown }{t_r t_s} | t_r \\in R \\wedge t_s \\in S \\wedge t_r[A] \\: \\theta \\: t_s[B]\\}其中，$A$ 和 $B$ 分别为关系 $R$ 和 $S$ 上目（列数）相等且可比的属性组，$\\theta$ 为比较运算符 该运算式实质为：在 $R$ 和 $S$ 的笛卡尔积 $R \\times S$ 中选取 $R$ 关系在 $A$ 属性组上的值与 $S$ 关系在 $B$ 属性组上的值满足比较关系 $\\theta$ 的元组 等值连接与自然连接连接运算中最常用的连接有两种，一种是等值连接（Equijion），另一种是自然连接（Natural join），除这两种连接外的所有连接，都称为非等值连接 等值连接是指当比较运算符 $\\theta$ 为 $=$ 时的连接运算，其是从关系 $R$ 和 $S$ 的笛卡尔积中选取 $A$、$B$ 属性组的属性值相等的元组组成新的关系，即： R \\underset{A=B}{\\bowtie} S=\\{\\overset{\\frown }{t_r t_s} | t_r \\in R \\wedge t_s \\in S \\wedge t_r[A] = t_s[B]\\}例如，学生关系 Student 和选修关系 SC 的学号属性 Sno 的等值连接 $Student \\underset{Student.Sno=Sc.Sno}{\\bowtie} SC$，结果如下 自然连接是一种特殊的等值连接，其要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中将重复的属性列去掉，即： R \\bowtie S=\\{\\overset{\\frown }{t_r t_s} [U-A] | t_r \\in R \\wedge t_s \\in S \\wedge t_r[A] = t_s[A]\\}其中，$U$ 为关系 $R$ 和 $S$ 的全体属性的集合 可以发现，一般的连接操作是从行的角度进行运算，而自然连接由于要取消重复列，其是同时从行和列的角度进行运算 此外，值得注意的是，当 $R$ 与 $S$ 无相同属性时，$R\\bowtie S=R\\times S$ 例如，学生关系 Student 和选修关系 SC 作自然连接 $Student \\bowtie SC$，结果如下 悬浮元组与外连接当两个关系 $R$ 与 $S$ 作自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系，此时，关系 $R$ 中某些元组可能在 $S$ 中不存在公共属性值相等的元组，使得 $R$ 中这些元组在操作时被舍弃了，同样，$S$ 中的某些元组也可能被舍弃，这些被舍弃的元组称为悬浮元组（Dangling tuple） 例如，对学生关系 Student 和选修关系 SC 的自然连接 $Student \\bowtie SC$ 中，学生关系 Student 的第 3 个、第 4 个元组，选修关系的第 5 个元组，就是悬浮元组 如果把悬浮元组也保存在结果关系中，在其他属性上填上空值（NULL），那么这种连接就叫外连接（Outer join），记作：$R \\Join S$ 例如，学生关系 Student 和选修关系 SC 的外连接 $Student \\bowtie SC$，结果如下 如果只保留左边关系 $R$ 中的悬浮元组，那么这种连接就叫左外连接（Left join），记作：$R \\rtimes S$ 例如，学生关系 Student 和选修关系 SC 的左外连接 $Student \\bowtie SC$，结果如下 如果只保留左边关系 $R$ 中的悬浮元组，那么这种连接就叫右外连接（Right join），记作：$R \\ltimes S$ 例如，学生关系 Student 和选修关系 SC 的右外连接 $Student \\bowtie SC$，结果如下 除运算象集对于给定一个关系 $R(X,Z)$，其中 $X$ 和 $Z$ 为属性组，当 $t[X]=x$ 时，定义 $x$ 在 $R$ 中的象集（Images set）为： Z_x=\\{t[Z] | t\\in R,t[X]=x\\}其表示在关系 $R$ 中，选出属性组 $X$ 上所有取值为 $x$ 的元组，去掉这些元组的属性组 $X$ 上的分量，只保留这些元组的属性组 $Z$ 上的分量 例如，对于如下的姓名课程关系，取 x=张军，象集 $Z_x$ 代表张军所选修的所有课程 除运算在有了象集的定义后，我们用象集来定义除运算（Division） 对于给定关系 $R(X,Y)$ 和 $S(Y,Z)$，其中 $X$、$Y$、$Z$ 为属性组，$R$ 中的 $Y$ 和 $S$ 中的 $Y$ 可以有不同属性名，但必须出自相同的域 关系 $R$ 与关系 $S$ 进行除运算，得到一个新的关系 $P(X)$，$P$ 是 $R$ 中满足下列条件的元组在 $X$ 属性列上的投影：元组在 $X$ 的分量值 $x$ 的象集 $Y_x$ 包含关系 $S$ 在 $Y$ 上的投影的集合 记作： R \\div S=\\{t_r[X]|t_r \\in R \\wedge \\Pi_Y(S) \\subseteq Y_x\\}其中，$x=t_r[X]$，$Y_x$ 为 $x$ 在关系 $R$ 中的象集 简单来说，设关系 $R$ 除以关系 $S$ 的结果为关系 $T$，则 $T$ 包含所有在 $R$ 但不在 $S$ 中的属性及其值，且 $T$ 的元组与 $S$ 的元组的所有组合都在 $R$ 中 举例来说，假设关系 $R$ 和关系 $S$ 如下 在关系 $R$ 中，属性 $A$ 可取的值为 $\\{a_1,a_2,a_3,a_4\\}$，则这 4 个可取值的象集如下 关系 $S$ 在属性组 $(B,C)$ 上的投影为 显然，只有 $a_1$ 的象集 $(B,C)_{a_1}$ 包含了 $S$ 在属性组 $(B,C)$ 上的投影，故 $R \\div S$ 的结果如下 【关系代数表达式】关系代数中，将关系代数运算经过有限次复合后形成的表达式，称为关系代数表达式 在表达式中，关系代数运算的结果没有可供引用的名字，这使得复杂的查询显得非常冗长 为解决这个问题，引入了命名运算，将一个名字赋给关系代数表达式，记作： \\rho_x(E)其中，$E$ 为给定的关系代数表达式，$x$ 表示名字 命名运算除了赋名外，还可以设置关系代数表达式各属性的名字 假设关系代数表达式 $E$ 是 $n$ 元的，则表达式：$\\rho_{x(A_1,A_2,…,A_n)}(E)$ 返回表达式 $E$ 的结果，并赋名为 $x$，同时将 $E$ 的各属性更名为 $A_1,A_2,…,A_n$","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"关系操作","slug":"database/10.关系操作","date":"2018-10-03T02:51:00.000Z","updated":"2021-08-23T13:40:24.886Z","comments":true,"path":"notes/database/f156402b.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/f156402b.html","excerpt":"【基本关系操作】关系模型给出了关系操作的能力说明，但未对关系数据库管理系统语言给出具体的语法要求，也就是说不同的关系数据库管理系统（RDBMS）可以定义、开发不同的语言来实现这些操作 关系操作的特点是集合操作，即操作的对象和结果都是集合，一次查询后全表搜索，然后一次性返回所有满足条件的元组的集合，这种操作方式也称为一次一集合（set-at-a-time）方式，相应的，非关系数据模型的操作方式是一次一记录（record-at-a-time）方式","text":"【基本关系操作】关系模型给出了关系操作的能力说明，但未对关系数据库管理系统语言给出具体的语法要求，也就是说不同的关系数据库管理系统（RDBMS）可以定义、开发不同的语言来实现这些操作 关系操作的特点是集合操作，即操作的对象和结果都是集合，一次查询后全表搜索，然后一次性返回所有满足条件的元组的集合，这种操作方式也称为一次一集合（set-at-a-time）方式，相应的，非关系数据模型的操作方式是一次一记录（record-at-a-time）方式 关系模型中的常用的两大关系操作是查询操作和插入、删除、修改操作，查询的表达能力是其中最主要的部分，查询操作可以分为选择、投影、连接、除、并、差、交、笛卡尔积等 在查询操作中，选择、投影、并、差、笛卡尔积是 5 种基本操作，其他操作都可以用这些操作来定义、导出 【关系数据语言】早期的关系操作能力通常用代数运算方式、逻辑运算方式来表示，使用代数方式来表示称为关系代数，使用逻辑方式来表示称为关系演算 关系代数通过对关系的运算来表达查询要求，关系演算用谓词来表达查询要求，关系演算又按谓词变元的基本对象的类型分为元组关系演算、域关系演算 当一个关系数据语言可以表示关系代数可以表示的查询时，称为具有完备的表达能力，即关系完备性，关系代数、元组关系演算、域关系演算三种语言在表达能力上是等价的，都具有完备的表达能力 他们都是抽象的查询语言，与具体的 RDBMS 中使用的语言并不完全相同，只是用作评估实际系统中查询语言能力的标准，实际的查询语言除了提供关系代数或关系演算的功能外，还提供了许多附加功能 此外，结构化查询语言（Structured Query Language，SQL）是一种介于关系代数和关系演算间，具有高度非过程化的语言，其不仅具有丰富的查询功能，还具有数据定义、数据控制功能，是集查询、数据定义语言（DLL）、数据操纵语言（DML）、数据控制语言（DCL）于一体的关系数据语言，是数据库的标准语言 关系数据语言 \\left\\{\\begin{matrix} 关系代数语言(例:ISBL) \\\\ 关系演算语言 \\left\\{\\begin{matrix} 域关系演算语言(例:QBE)\\\\ 元组关系演算语言(例:ALPHA)\\\\ \\end{matrix}\\right.\\\\ 结构化查询语言 SQL:具有关系代数与关系演算双重特点\\\\ \\end{matrix}\\right.目前，在关系数据库领域，关系代数与关系演算已不作为商用 RDBMS 的查询语言，常用 SQL 作为关系数据语言，在处理查询时，RDBMS 会将 SQL 查询翻译成关系代数，然后进行查询，也就是说 SQL 是以关系代数为核心的，目前关系代数仍是研究关系数据语言的数学工具 关于关系代数：点击这里 关于 SQL：点击这里","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"关系数据结构","slug":"database/09.关系数据结构","date":"2018-10-02T03:25:00.000Z","updated":"2021-08-23T13:40:37.045Z","comments":true,"path":"notes/database/549e5907.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/549e5907.html","excerpt":"【关系数据结构的形式化定义】关系模型的数据结构十分简单，在用户角度来看关系模型中数据的逻辑结构只是一张二维表，虽然简单，但却能表示现实世界中实体以及实体间的各种联系，在 数据库关系模型 中，已经介绍了关系模型与其基本概念，但关系模型实质上是建立在集合代数基础上的，这里从集合论角度，给出关系数据结构的形式化定义 域","text":"【关系数据结构的形式化定义】关系模型的数据结构十分简单，在用户角度来看关系模型中数据的逻辑结构只是一张二维表，虽然简单，但却能表示现实世界中实体以及实体间的各种联系，在 数据库关系模型 中，已经介绍了关系模型与其基本概念，但关系模型实质上是建立在集合代数基础上的，这里从集合论角度，给出关系数据结构的形式化定义 域域（Domain）是一组具有相同数据类型的值的集合，例如整数、实数、某个取值范围内的数等等，都是一个域 一个域允许的不同取值个数称为这个域的基数，对于一个域 $D$，其基数记为 $m$ 例如，某个域 D = {1, 2, 4, 8}，其基数 m = 4 笛卡尔积笛卡尔积（Cartesian Product）是域上的一种集合运算，是所有域的所有取值的不可重复的组合 其数学定义如下： 给定一组域 $D_1,D_2,…,D_n$，并允许这些域中某些域是相同的，则这些域的笛卡尔积为 D_1 \\times D_2 \\times ... \\times D_n = \\{(d_1,d_2,...,d_n) | d_i \\in D_i,i=1,2,...,n \\}其中，笛卡尔积的每一个元素 $(d_1,d_2,…,d_n)$ 称为一个 n 元组（n-tuple），元组 $(d_1,d_2,…,d_n)$ 中的每一个值 $d_i$ 称为一个分量 若 $D_i$ 为有限集，其基数为 $m_i$，则笛卡尔积的基数为 M=\\prod_{i=1}^n m_i举例来说，假如给出三个域：教师集合 THACHER={a,b}​，学生集合STUDENTS={1,2,3}，专业集合 MAJORS={P,Q} 则 THACHER, STUDENTS, MAJORS 的笛卡尔积为 THACHER \\times STUDENTS \\times MAJORS = \\begin{matrix} \\{(a,1,P), & (a,2,P), & (a,3,P), \\\\ (a,1,Q), & (a,2,Q), & (a,3,Q), \\\\ (b,1,P), & (b,2,P), & (b,3,P), \\\\ (b,1,Q), & (b,2,Q), & (b,3,Q)\\} \\end{matrix}其中，笛卡尔积 THACHER x STUDENTS x MAJORS 中的每一个元素 (a, 1, P)、(a, 2, P) 等，都是一个元组；组中的每一个值 a、3、Q 等，都是一个分量，该笛卡尔积的基数为 M = 2*3*2 = 12 笛卡尔积可表示为一个二维表，表中的每行对应一个元组，表中的每列对应一个域，上例的笛卡尔积就可表示为下表 THACHER STUDENTS MAJORS a 1 P a 1 Q a 2 P a 2 Q a 3 P a 3 Q b 1 P b 1 Q b 2 P b 2 Q b 3 P b 3 Q 关系笛卡尔积是没有实际意义的，其某个子集才有实际含义，一个子集称为一个关系（Relation），由于关系是笛卡尔积的子集，因此关系也是一张二维表，表中的每行对应一个元组，每列对应一个域，由于域可以相同，为进行区分，对每列起一个名字，称为属性（Attribute） 对于笛卡尔积 $D_1 \\times D_2 \\times … \\times D_n$ ，其子集 $R(D_1,D_2,…,D_n)$ 为该笛卡尔积的关系，其中 $R$ 为关系名，$n$ 为关系的目或度（Degree），关系中每个元素是关系中的元组（Tuple），常用 $t$ 来表示 当关系的度 $n=1$ 时，称该关系为一元关系，当 $n=2$ 时，称该关系为二元关系 根据定义，关系可以是一个无限集合，而且由于组成笛卡尔积的域不满足交换律（$(d_1,d_2) \\neq (d_2,d_1)$），因此当关系作为关系模型的数据结构时，需要给予如下的限定与扩充： 无限关系在数据库系统中无意义，限定关系模型中的关系必须是有限集合 通过位关系的每个列附加一个属性名将关系属性的有序性取消 同时，在引入关系后，有如下定义： 码（Key）：又称为键，用于确定关系表中某一元组的 候选码（Candidate key）：对于关系中的某一属性组，其值能够唯一标识一个元组，而其子集不能 主码（Primary key）：对于候选码，选定其中一个用于唯一标识一个元组（候选码唯一时该候选码即为主码） 主属性（Primary attribute）：候选码的各属性 非主属性（no-prime attribute）：不包含在任何候选码中的属性 全码（All-key）：最极端的情况下，关系模式的所有属性组是这个关系的候选码（最简单的情况下，候选码仅包含一个属性） 以上述的三个域教师集合 THACHER={a,b}，学生集合STUDENTS={1,2,3}，专业集合 MAJORS={P,Q} 产生的笛卡尔积为例 许多元组是没有实际意义的，因为在许多学校的研究生培训制度中，一个教师仅教授一门课，且一个学生只能跟着一个导师学习某个专业，故而其中的某一个子集才是有实际意义的，才能表示清楚某些导师与学生的关系 如下表所示，将该关系取名为 TSM，表示 老师a 带领 学生1 和 学生2 学习 专业P，老师b 带领 学生3 学习 专业Q THACHER STUDENTS MAJORS a 1 P a 2 P b 3 Q 如上所示，该关系可以表示为 TSM(T, S, C)，关系名 R = TSC，关系的度 n = 3，属性即为三个域的域名，假设学生姓名不会重复，那么 STUDENTS 属性的每一个值都唯一标识了一个元组，可作为 TSC 关系的候选码，同时也为主码，此外，STUDENTS 属性为主属性，THACHER 属性和 MAJORS 为非主属性 【关系类型】关系有三种类型： 基本关系（基本表）：实际存在的表，其是实际存储数据的逻辑表示 查询表：查询结果对应的表，其是根据要求对基本关系进行查询得到的结果 视图表：由基本表或其他视图导出的表，是一种虚拟的表，不对应实际存储的数据 可以发现，在三类关系中，基本关系是最基本也是最核心的关系，其具有以下性质： 列是同质的（Homogeneous）：每列中的分量是同一类型的数据，来自同一域 不同的列可出自同一域，其中每一列称为一个属性，不同的属性要给予不同的属性名 列的次序可任意交换（在实际应用中，增加新属性时往往插入到最后一列） 任意两元组的候选码不能相同，以保证可以唯一标识元组 行的次序可任意交换 分量必须取原子值：每一分量是不可再分的数据项 在 关系模型 中，已经介绍了关系模型要求规范化，规范条件最基本的一条就是关系的每一分量必须取原子值，规范化的关系称为范式（Normal Form，NF），详见：范式 【关系模式】在任何一个数据库中，都要区分型和值，对于关系数据库来说，型就是关系模式，是对关系数据库的描述，其包括若干域的定义、这些域之上定义的若干关系模式；值就是关系模式在某一时刻对应的关系的集合，简称为**关系数据库 关系模式（Relation schema）包含元组集合的结构（属性构成、属性来自的域、属性与域之间的映象关系）、元组语义及完整性约束条件、属性间的数据依赖关系集合，其可表示为：$R(U,D,DOM,F)$ 其中，$R$ 是关系名，$U$ 是组成该关系的属性名集合，$D$ 是 $U$ 中属性来自的域，$DOM$ 是属性到域的映射集合（常常直接说明为属性的类型、长度），$F$ 是属性间数据的依赖关系集合 关系模型通常简记为：$R(U)$ 或 $R(A_1,A_2,…,A_n)$，其中 $A_i$ 为第 $i$ 个属性的属性名","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"链式队列","slug":"data-structure/03.queue/04.链式队列","date":"2018-10-01T07:22:00.000Z","updated":"2021-08-31T08:05:33.061Z","comments":true,"path":"oi-acm/data-structure/queue/f6839f18.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/queue/f6839f18.html","excerpt":"【概述】链式队列是采取链式存储的队列，其不存在队列满而导致上溢的情况，通常设计为一个带头结点的单链表，其有两个指针，队头指针向队头结点，尾指针指向队尾结点 链式队列的实现类如下：","text":"【概述】链式队列是采取链式存储的队列，其不存在队列满而导致上溢的情况，通常设计为一个带头结点的单链表，其有两个指针，队头指针向队头结点，尾指针指向队尾结点 链式队列的实现类如下： 1234567891011121314151617181920template &lt;typename T&gt; struct LNode &#123; //单链表结点 T data; //数据域 LNode&lt;T&gt; *next; //指针域&#125;;template &lt;typename T&gt; class LinkQueue &#123; public: LinkQueue(); //初始化队 int getLen(); //求队长 bool empty(); //判空 bool pop(T &amp;elem); //出队 bool push(T elem); //入队 bool getTop(T &amp;elem); //取队首 void print(); //输出 private: LNode&lt;T&gt; *head; //队首指针 LNode&lt;T&gt; *tail; //队尾指针 int len; //队列长度&#125;; 【初始化】链式队列被设计为带头结点的单链表，因此其头指针 head 的初始化与带头结点的单链表相似，只是要注意令尾指针 tail 的指向与 head 相同，并给队长 len 赋 $0$ 值即可 1234567template &lt;typename T&gt; LinkQueue&lt;T&gt;::LinkQueue() &#123; //初始化队列 head = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); tail = head; head-&gt;next = NULL; len = 0;&#125; 【求队长】由于数据结构中封装了队长 len，因此在求队长时，直接输出 len 即可 1234template &lt;typename T&gt; int LinkQueue&lt;T&gt;::getLen() &#123; //求队长 return len;&#125; 【判空】由于 tail 指向队尾元素的下一位置，即接下来要插入的位置，因此在判空时，只需判断队尾指针与队头指针是否相同即可 123456template &lt;typename T&gt; bool LinkQueue&lt;T&gt;::empty() &#123; //判空 if (head == tail) return true; return false;&#125; 【出队】在出队时，首先进行下溢判断，再令队长 len-1，然后将队首结点释放，最后释放结点空间即可，要注意的是，如果要出队的是最后一个结点，要令尾指针 tail 与头指针 head 指向相同 1234567891011121314151617template &lt;typename T&gt; bool LinkQueue&lt;T&gt;::pop(T &amp;elem) &#123; //出队 if (empty()) //下溢判断 return false; //队长-1 len--; //将队首结点断链 LNode&lt;T&gt; *p = head-&gt;next; elem = p-&gt;data; head-&gt;next = p-&gt;next; //最后一个结点 if (tail == p) tail = head; //释放队首结点空间 free(p); return true;&#125; 【入队】在入队时，首先令队长 len+1，之后为新结点赋值，再连接到队尾 123456789101112131415template &lt;typename T&gt; bool LinkQueue&lt;T&gt;::push(T elem) &#123; //入队 LNode&lt;T&gt; *p = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); if (p == NULL) //空间分配失败 return false; //队长+1 len++; //为新结点赋值 p-&gt;data = elem; p-&gt;next = NULL; //连接到队尾 tail-&gt;next = p; tail = p; return true;&#125; 【取队头】在取队首元素时，先进行下溢判断，然后直接取队首指针 head 指向头结点的下一元素的值即可 1234567template &lt;typename T&gt; bool LinkQueue&lt;T&gt;::getTop(T &amp;elem) &#123; //取队首 if (empty()) //下溢判断 return false; elem = head-&gt;next-&gt;data; return true;&#125; 【输出】在输出时，从队首开始，将队列中所有元素依次出队，进行输出即可 123456789template &lt;typename T&gt; void LinkQueue&lt;T&gt;::print() &#123; //输出 int elem; while (!empty()) &#123; //将所有元素依次出队进行输出 pop(elem); cout &lt;&lt; elem &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"队列","slug":"oi-acm/data-structure/queue","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/queue/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"队列","slug":"queue","permalink":"https://alex-mcavoy.github.io/tags/queue/"}],"author":"Alex_McAvoy"},{"title":"循环队列","slug":"data-structure/03.queue/03.循环队列","date":"2018-10-01T05:19:00.000Z","updated":"2021-09-02T13:44:31.148Z","comments":true,"path":"oi-acm/data-structure/queue/b66774c1.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/queue/b66774c1.html","excerpt":"【概述】由于顺序队列中的假溢出会造成极大的空间浪费，为避免这种浪费，对可采用以下两种方法来克服： 将队列中所有元素均向低地址区移动 将存储队列的数组头尾相接，当存放到 $n$ 地址后，下一个地址就翻转为 $1$","text":"【概述】由于顺序队列中的假溢出会造成极大的空间浪费，为避免这种浪费，对可采用以下两种方法来克服： 将队列中所有元素均向低地址区移动 将存储队列的数组头尾相接，当存放到 $n$ 地址后，下一个地址就翻转为 $1$ 对于第一种方法来说，由于每个元素都需要向前移动空间，这无疑十分浪费时间，为此，常采用第二种方法，采用循环队列 循环队列，就是将顺序队列从逻辑上视为一个环，从而克服假溢出问题 循环队列的实现类如下： 1234567891011121314151617#define N 55 //申请空间个数template &lt;typename T&gt; class CirQueue &#123; public: CirQueue(); //初始化队 int getLen(); //求队长 bool empty(); //判空 bool full(); //判满 bool pop(T &amp;elem); //出队 bool push(T elem); //入队 bool getTop(T &amp;elem); //取队首 void print(); //输出 private: T data[N]; //队列空间 int head; //队首指针 int tail; //队尾指针&#125;; 【初始化】初始时，队列为空队列，此时队头指针 head 与队尾指针 tail 均设为 $0$ 12345template &lt;typename T&gt; CirQueue&lt;T&gt;::CirQueue() &#123; //初始化队列 head = 0; tail = 0;&#125; 【求队长】由于队首与队尾在逻辑上相连，因此在求队长时，要将两者的差值加上存储空间长度后再取存储空间的模，即 (tail + N - head) % N 1234template &lt;typename T&gt; int CirQueue&lt;T&gt;::getLen() &#123; //求队长 return (tail + N - head) % N;&#125; 【判空】由于 tail 指向队尾元素的下一位置，即接下来要插入的位置，因此在判空时，只需判断队尾指针与队头指针是否相同即可 123456template &lt;typename T&gt; bool CirQueue&lt;T&gt;::empty() &#123; //判空 if (head == tail) return true; return false;&#125; 【判满】在判满时，考虑到队首与队尾在逻辑上相连的因素，当队首指针与队尾指针加一后取存储空间的模相等，说明队满，即 (tail + 1) % N == head 123456template &lt;typename T&gt; bool CirQueue&lt;T&gt;::full() &#123; //判满 if ((tail + 1) % N == head) return true; return false;&#125; 【出队】在出队时，取队首指针 head 指向的元素，之后令队首指针后移一位，同时，考虑到队首与队尾在逻辑上相连的因素，要对队首指针取对存储空间 N 的模，即 head = (head + 1) % N 12345678template &lt;typename T&gt; bool CirQueue&lt;T&gt;::pop(T &amp;elem) &#123; //出队 if (empty()) //下溢判断 return false; elem = data[head]; head = (head + 1) % N; return true;&#125; 【入队】在入队时，将元素存入队尾指针 tail 指向的位置，之后令队尾指针后移一位，同时，考虑到队首与队尾在逻辑上相连的因素，要对队尾指针取对存储空间 N 的模，即 tail = (tail + 1) % N 12345678template &lt;typename T&gt; bool CirQueue&lt;T&gt;::push(T elem) &#123; //入队 if (full()) //上溢判断 return false; data[tail] = elem; tail = (tail + 1) % N; return true;&#125; 【取队首】在取队首元素时，先进行下溢判断，然后直接取队首指针 head 指向的元素即可 1234567template &lt;typename T&gt; bool CirQueue&lt;T&gt;::getTop(T &amp;elem) &#123; //取队首 if (empty()) //下溢判断 return false; elem = data[head]; return true;&#125; 【输出】在输出时，从队首开始，将队列中所有元素依次出队，进行输出即可 123456789template &lt;typename T&gt; void CirQueue&lt;T&gt;::print() &#123; //输出 int elem; while (!empty()) &#123; //将所有元素依次出队进行输出 pop(elem); cout &lt;&lt; elem &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125; 【关于队空与队满】为区分队空与队满，有三种处理方式： 方式一 约定队首指针 head 在队尾指针 tail 的下一位置为队满标志，这样通过牺牲一个存储单元即可识别队空、队满，即开辟的存储空间为 $N$ 时，最大队长为 $N-1$，此时有： 队空条件：head == tail 队满条件：(tail + 1) % N == head 队长：(tail + N - head) % N 方式二 在存储结构中增设一个整型数据成员 size，用于标识元素个数，每次入队成功就令 size++，出队成功就令 size--，此时有： 队空条件：size == 0 队满条件：size == N 队长：size 方式三 由于在不牺牲存储空间时，无法确定 head == tail 时是队空开始队满 因此可以在存储类型中增设一布尔类型数据成员 tag，用于标识最近进行的是入队还是出队操作，每次入队成功令 tag=true，出队成功令 tag=false，此时有： 队空条件：由于只有出队才会导致队空，故 !tag &amp;&amp; head == tail 队满条件：由于只有入队才会导致队满，故 tag &amp;&amp; head == tail 队长：(tail + N - head) % N","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"队列","slug":"oi-acm/data-structure/queue","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/queue/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"队列","slug":"queue","permalink":"https://alex-mcavoy.github.io/tags/queue/"}],"author":"Alex_McAvoy"},{"title":"数据库关系模型","slug":"database/08.数据库关系模型","date":"2018-09-27T09:25:00.000Z","updated":"2021-08-23T13:40:31.494Z","comments":true,"path":"notes/database/f1fb41ab.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/f1fb41ab.html","excerpt":"【概述】关系模型是最重要的一种逻辑模型，在数据库领域上，当前的研究工作都是以关系方法为基础，目前常见的数据库系统基本都是采用关系模型作为数据的组织方式，即关系型数据库 关系模型建立在严格的数学概念的基础上，可以描述一对一、一对多、多对多的联系，同时概念单一，实体、各类联系、对数据的检索结果都用关系来表示，具有更高的数据独立性、更好的安全保密性，此外存取路径对用户透明，用户只要指出干什么，不必详细说明怎么干，简化了数据库建立的过程，也精简了程序员的工作","text":"【概述】关系模型是最重要的一种逻辑模型，在数据库领域上，当前的研究工作都是以关系方法为基础，目前常见的数据库系统基本都是采用关系模型作为数据的组织方式，即关系型数据库 关系模型建立在严格的数学概念的基础上，可以描述一对一、一对多、多对多的联系，同时概念单一，实体、各类联系、对数据的检索结果都用关系来表示，具有更高的数据独立性、更好的安全保密性，此外存取路径对用户透明，用户只要指出干什么，不必详细说明怎么干，简化了数据库建立的过程，也精简了程序员的工作 但关系模型的存取路径对用户透明，导致了查询效率不如非关系数据模型，为提高性能，必须对用户的查询请求进行优化，增加了开发 DBMS 的难度 关系模型建立在严格的数学概念的基础上，这里仅简单介绍从用户角度来看的关系模型与其基本术语 关于关系数据库系统的具体内容详见： 关系数据结构：点击这里 关系操作：点击这里 关系的完整性约束：点击这里 【数据结构】基本术语在用户角度来看，关系模型由一组关系组成，每个关系的数据结构是一张由若干行列组成的二维表，其基本术语如下： 关系（Relation）：一个关系对应一张表 元组（Tuple）：表中的一行为一个元组 属性（Attribute）：表中的一列为一个属性，每个属性的名称为属性名 分量：元组中的某个属性值为一个分量 码（Key）：亦称码键，表中的某个属性组为一个码，可以唯一确定一个元组 域（Domain）：一组具有相同数据类型的值的集合，某个属性的取值范围是某个域 关系模式：对关系的描述，表示为 关系名(属性1,属性2,...,属性n) 如下图，整个学生登记表为一个关系，其中的一行为一个元组；其中的一列为一个属性；某个元组中的某个属性值为一个分量；学号可以唯一确定一个学生，成为本关系的码；对于性别这个属性，其取值范围是 (男,女)，即该属性的域；关系模式为 学生(学号,姓名,年龄,性别,系名,年级) 与表格的对比将关系模型的术语与现实中的一般表格的术语做一个对比，有： 关系术语 一般表格术语 关系名 表名 关系模式 表头（表格的描述） 关系 二维表 元组 记录/行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中嵌套另一个表 规范化要求关系模型要求关系必须是规范化的，即关系要满足一定的规范条件，最基本的就是关系中的每一分量是不可分的数据项，简单来说，就是不允许表中还有表 如下图，工资是一个可分的数据项，不符合关系模型的要求 【数据操纵与完整性约束】关系模型的数据操作是集合操作，操作对象与操作结果都是关系，基础的操作有：插入、更新、查询、删除 这些操作要求满足完整性约束条件，关系模型的完整性约束条件分为三类： 实体完整性：关系中的主属性不能取空值 参照完整性：关系中不允许引用不存在的实体 用户定义的完整性：用户自定义的针对具体关系数据库的约束条件 【存储结构】由于关系模型的实体及实体间的联系都用二维表来表示，这使得在物理存储时，只要将二维表以文件形式存储即可 不同的 DBMS 的存储结构不同，有的 DBMS 一个表存储为一个文件，有的 DBMS 一个表存储为多个文件，还有的 DBMS 根据需要自己设计文件结构","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库逻辑模型","slug":"database/07.数据库逻辑模型","date":"2018-09-27T05:25:00.000Z","updated":"2021-08-23T13:40:15.621Z","comments":true,"path":"notes/database/525ace90.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/525ace90.html","excerpt":"【概述】数据库领域主流的逻辑模型随着时代的发展不断在变化，格式化模型（层次模型、网状模型）在 20 世纪 70 年代到 80 年代初期十分流行，占据主导地位，但现在已逐渐被关系模型的数据库系统取代 同时，自 80 年代面向对象技术在计算机各领域广泛应用后，数据库领域针对于面向对象方法也进行了研究，这就有了面向对象模型，之后为进一步支持面向对象模型，许多数据库厂商对关系模型进行了扩展，这就产生了对象关系数据模型","text":"【概述】数据库领域主流的逻辑模型随着时代的发展不断在变化，格式化模型（层次模型、网状模型）在 20 世纪 70 年代到 80 年代初期十分流行，占据主导地位，但现在已逐渐被关系模型的数据库系统取代 同时，自 80 年代面向对象技术在计算机各领域广泛应用后，数据库领域针对于面向对象方法也进行了研究，这就有了面向对象模型，之后为进一步支持面向对象模型，许多数据库厂商对关系模型进行了扩展，这就产生了对象关系数据模型 随着 Internet 的发展，Web 上各种半结构化、结构化数据源成为了重要的信息来源，这又促进产生了半结构化数据模型和非结构数据模型 限于篇幅，本篇仅简单介绍基本已被淘汰的格式化模型 【层次模型】介绍层次模型是最早出现的逻辑模型，其和概念模型最接近，用树形结构来表示各类实体以及实体间的关系，典型代表是 IBM 公司的 IMS 数据库管理系统 层次模型的数据结构简单清晰，查询效率高，性能优于关系模型，不低于网状模型，还提供了良好的完整性支持，但多对多联系表示不自然，对插入和删除操作的限制多，应用程序的编写比较复杂，查询子结点必须通过父结点，结构严密，层次命令趋于程序化 数据模型组成要素层次模型的数据结构满足以下两个基本条件： 有且仅有一个结点没有父结点，这个结点称为根结点 根结点以外的结点有且仅有一个父结点 在层次模型进行表示时，采取如下方法： 实体型：用记录类型描述，每个结点表示一个记录类型（实体） 属性：用字段描述，每个记录类型包含若干字段 联系：用结点间的连线表示实体间的一对多的父子联系 如下图，是一个教员学生层次模型，该模型有 4 个记录类型，代表着 4 个不同的实体，每个类型根据实际需要划分为若干字段，每个字段代表一个属性，每个实体之间的连线代表着彼此间的关系 下图是教员学生层次模型对应的一个值 层次模型的数据操纵主要有：查询、插入、删除、更新 在进行插入、删除、查询操作时，要满足层次模型的完整性约束条件，即： 插入：没有父结点值，就不能插入子结点值 删除：删除父结点值，要删除相应子结点值 查询：查询子结点值，必须通过父结点值查询 通过上述介绍可以发现，层次模型只能处理一对多的实体联系，同时，任何记录值只有按路径查看时，才能显示其全部意义，此外，任何一个子结点记录值都不可脱离父结点记录值独立存在 多对多联系的表示如果想要用层次模型表示多对多的实体联系，那么就要将多对多联系分解成一对多联系，间接来表示多对多联系，常见的方法有冗余结点法、虚拟结点法 如下图所示，是一个学生选课的多对多联系 当采用冗余结点法转换为一对多联系时，有： 当采用虚拟结点法转换为一对多联系时，有： 存储结构层次模型的存储需要存储数据本身和数据间的联系，有邻接法、链接法（孩子-兄弟链接法、层次序列链接法）两种方法 邻接法是按照层次树前序遍历的顺序将所有记录值依次邻接存放，即通过物理空间的位置相邻来实现层次顺序 孩子-兄弟链接法是将每个记录设两类指针，分别指向最左边的孩子和最近的兄弟 层次序列链接法是按层次树的前序穿越顺序链接各记录值 【网状模型】介绍网状数据库系统采用网状模型作为数据的组织方式，典型代表是 DBTG 系统（CODASYL 系统），其是数据系统语言研究会（CODASYL）下属的数据库任务组（Database Task Group，DBTG）提出的一个系统方案，其并不是一个实际的数据库系统软件，其基本概念、方法、技术具有普遍意义，后续不少系统均采用 DBTG 模型作为实际的网状模型 网状模型能够更为直接地描述现实世界，其具有良好的性能，存取效率较高，但结构比较复杂，且随着应用环境的扩大，数据库的结构越来越复杂，不利于用户掌握，同时，DDL、DML 语言复杂，不容易使用，此外，记录类型联系变动后涉及链接指针的调整，扩充和维护都比较复杂 数据模型组成要素网状模型的数据结构满足以下两个基本条件： 允许一个以上的结点没有父结点 一个节点可以有多个父结点 在网状模型进行表示时，采取如下方法： 实体型：用记录类型描述，每个结点表示一个记录类型（实体） 属性：用字段描述，每个记录类型包含若干字段 联系：用结点间的连线表示实体间的一对多的父子联系 网状模型中子结点与父结点的联系可以不唯一（层次模型中的联系必须唯一），这就要求为每个联系进行命名，并指出与该联系有关的父亲记录和孩子记录 如下图，是一个学生选课数据库的网状模型 网状模型的数据操纵主要有：查询、插入、删除、更新 但网状模型的完整性约束条件不像层次模型那么严格，具体的数据库系统有着不同的限制，以 DBTG 来说，其在模式数据定义语言中提供了定义 DBTG 数据库完整性的若干概念和语句，主要有： 记录码：唯一标识记录的数据项的集合 一个联系中父记录与子记录间是一对多联系 支持父记录与子记录间的某些约束条件（子记录插入时要求父记录存在、父记录删除时连同子记录一起删除等） 多对多联系的表示如果想要用网状模型表示多对多的实体联系，那么就要将多对多联系分解成一对多联系，间接来表示多对多联系 例如：一个学生可以选修若干门课程，某一课程可以被多个学生选修，学生与课程之间是多对多联系 为在网状模型中表示这种多对多联系，可以引进一个学生选课的联结记录，其由 3 个数据项组成：学号、课程号、成绩，从而表示某个学生选修某一门课程及其成绩 存储结构网状模型的存储需要存储数据本身和数据间的联系，常用的方法有：单向链接、双向链接、环状链接、向首链接 如下图，是一个学生选课系统的网状数据库实例，其中，左侧为学生记录，右侧为课程记录，中间为选课记录 【关于格式化模型】实质上，层次模型可以认为是网状模型的一种特例，因此两者被统称为格式化模型 两者有许多共同的缺点： 使用了许多与数据操作任务无关的概念，如：DBTG 系统中的系 记录之间的联系是通过存取路径实现的，在访问数据时必须选择适当的存取路径，这要求必须了解系统结构的细节，加重了编写应用程序的负担 不支持集合处理，即未提供一次处理多个记录的功能 没有充分认识端点用户直接与数据库对话的需求，缺乏为适应非预期查询而增加系统设施的能力","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"顺序队列","slug":"data-structure/03.queue/02.顺序队列","date":"2018-09-27T04:19:00.000Z","updated":"2021-09-02T13:44:44.237Z","comments":true,"path":"oi-acm/data-structure/queue/4901c438.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/queue/4901c438.html","excerpt":"【概述】顺序队列是采取顺序方式存储的队列，利用一组地址连续的存储单元自队首到队尾存放数据元素，并通过队首指针来指示当前队首元素位置，通过队尾指针来指示当前队尾元素的下一位置 对于存储空间的分配，若采用静态分配方式，一经分配不可修改，若采用动态分配方式，分配后在 $O(n)$ 的时间复杂度内可以更改","text":"【概述】顺序队列是采取顺序方式存储的队列，利用一组地址连续的存储单元自队首到队尾存放数据元素，并通过队首指针来指示当前队首元素位置，通过队尾指针来指示当前队尾元素的下一位置 对于存储空间的分配，若采用静态分配方式，一经分配不可修改，若采用动态分配方式，分配后在 $O(n)$ 的时间复杂度内可以更改 顺序队列的实现类如下： 1234567891011121314151617#define N 50 + 5 //申请空间个数template &lt;typename T&gt; class SeqQueue &#123; public: SeqQueue(); //初始化队 int getLen(); //求队长 bool empty(); //判空 bool full(); //判满 bool pop(T &amp;elem); //出队 bool push(T elem); //入队 bool getTop(T &amp;elem); //取队首 void print(); //输出 private: T data[N]; //队列空间 int head; //队首指针 int tail; //队尾指针&#125;; 【初始化】初始时，队列为空队列，此时队头指针 head 与队尾指针 tail 均设为 $0$ 12345template &lt;typename T&gt; SeqQueue&lt;T&gt;::SeqQueue() &#123; //初始化队列 head = 0; tail = 0;&#125; 【求队长】队列的队尾指针 tail 与队首指针 head 的差值，即为队列的队长 1234template &lt;typename T&gt; int SeqQueue&lt;T&gt;::getLen() &#123; //求队长 return tail-head;&#125; 【判空】由于 tail 指向队尾元素的下一位置，即接下来要插入的位置，因此在判空时，只需判断队尾指针与队头指针是否相同即可 123456template &lt;typename T&gt; bool SeqQueue&lt;T&gt;::empty() &#123; //判空 if (head == tail) return true; return false;&#125; 【判满】当队尾指针 tail 的值为申请空间个数时，说明空间已满 123456template &lt;typename T&gt; bool SeqQueue&lt;T&gt;::full() &#123; //判满 if (tail == N) return true; return false;&#125; 顺序队列中存在假溢出问题，即当队列经过一定的入队出队操作后，队列的低端存在一部分的空闲空间，而队列的高端空间已被用尽，此时尽管数组中还有空间，但由于队列的入队操作只会插入到数组尾部，此时继续入队会发生假溢出 【出队】在出队时，取队首指针 head 指向的元素，之后令队首指针后移一位，即 head++ 1234567template &lt;typename T&gt; bool SeqQueue&lt;T&gt;::pop(T &amp;elem) &#123; //出队 if (empty()) //下溢判断 return false; elem = data[head++]; return true;&#125; 【入队】在入队时，将元素存入队尾指针 tail 指向的位置，之后令队尾指针后移一位，即 tail++ 1234567template &lt;typename T&gt; bool SeqQueue&lt;T&gt;::push(T elem) &#123; //入队 if (full()) //上溢判断 return false; data[tail++] = elem; return true;&#125; 【取队首】在取队首元素时，先进行下溢判断，然后直接取队首指针 head 指向的元素即可 1234567template &lt;typename T&gt; bool SeqQueue&lt;T&gt;::getTop(T &amp;elem) &#123; //取队首 if (empty()) //下溢判断 return false; elem = data[head]; return true;&#125; 【输出】在输出时，从队首开始，将队列中所有元素依次出队，进行输出即可 123456789template &lt;typename T&gt; void SeqQueue&lt;T&gt;::print() &#123; //输出 int elem; while (!empty()) &#123; //将所有元素依次出队进行输出 pop(elem); cout &lt;&lt; elem &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"队列","slug":"oi-acm/data-structure/queue","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/queue/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"队列","slug":"queue","permalink":"https://alex-mcavoy.github.io/tags/queue/"}],"author":"Alex_McAvoy"},{"title":"栈与括号匹配","slug":"data-structure/02.stack/05.栈与括号匹配","date":"2018-09-27T03:17:00.000Z","updated":"2021-08-31T11:58:00.771Z","comments":true,"path":"oi-acm/data-structure/stack/bcd57b6.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/stack/bcd57b6.html","excerpt":"括号匹配问题是指，在给出一个包含 (、{、[、)、}、] 的序列，问这个序列的括号是否匹配 解决括号匹配问题的基本思想是： 扫描整个序列，遇到左括号时，令左括号入栈，遇到右括号时，令左括号出栈，进行匹配操作 若出栈的左括号与当前右括号不匹配，则整个序列不匹配 若栈为空，且扫描到右括号，则整个序列不匹配 若扫描完序列后，栈中仍有左括号（判断栈是否为空即可），则整个序列不匹配","text":"括号匹配问题是指，在给出一个包含 (、{、[、)、}、] 的序列，问这个序列的括号是否匹配 解决括号匹配问题的基本思想是： 扫描整个序列，遇到左括号时，令左括号入栈，遇到右括号时，令左括号出栈，进行匹配操作 若出栈的左括号与当前右括号不匹配，则整个序列不匹配 若栈为空，且扫描到右括号，则整个序列不匹配 若扫描完序列后，栈中仍有左括号（判断栈是否为空即可），则整个序列不匹配 1234567891011121314151617181920212223242526272829303132333435363738394041void parenthesisMatch() &#123; //括号匹配 char str[N]; stack&lt;char&gt; S; while (scanf(\"%s\", str) != EOF) &#123; int len = strlen(str); bool flag = true; for (int i = 0; i &lt; len; i++) &#123; if (str[i] == '(' || str[i] == '[' || str[i] == '&#123;') S.push(str[i]); else &#123; if (S.empty()) &#123; flag = false; break; &#125; char top = S.top(); S.pop(); if (str[i] == ')' &amp;&amp; top != '(') &#123; flag = false; break; &#125; if (str[i] == ']' &amp;&amp; top != '[') &#123; flag = false; break; &#125; if (str[i] == '&#125;' &amp;&amp; top != '&#123;') &#123; flag = false; break; &#125; &#125; &#125; stack&lt;char&gt;().swap(S); if (flag) printf(\"sucessful\\n\"); else printf(\"fail\\n\"); &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"栈","slug":"oi-acm/data-structure/stack","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/stack/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"栈","slug":"stack","permalink":"https://alex-mcavoy.github.io/tags/stack/"}],"author":"Alex_McAvoy"},{"title":"栈与表达式的计算","slug":"data-structure/02.stack/06.栈与表达式的计算","date":"2018-09-27T01:54:00.000Z","updated":"2021-08-31T11:58:05.285Z","comments":true,"path":"oi-acm/data-structure/stack/caf4d79.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/stack/caf4d79.html","excerpt":"【表达式类型】一个表达式一般由操作数、运算符、界限符三个部分组成，根据运算符的位置，表达式可分为以下三类： 中缀表达式（算术表达式）：运算符在两运算数中间，界限符反映了计算的先后顺序 前缀表达式（波兰式）：无界限符，运算符在前，操作数在后 后缀表达式（逆波兰式）：无界限符，运算符在后，操作数在前","text":"【表达式类型】一个表达式一般由操作数、运算符、界限符三个部分组成，根据运算符的位置，表达式可分为以下三类： 中缀表达式（算术表达式）：运算符在两运算数中间，界限符反映了计算的先后顺序 前缀表达式（波兰式）：无界限符，运算符在前，操作数在后 后缀表达式（逆波兰式）：无界限符，运算符在后，操作数在前 中缀 前缀 后缀 a + b + a b a b + a + b - c - + a b c a b + c - a + b - c * d - + a b *c d a b + c d * - 注：缀指的是运算符的位置 【后缀表达式的计算】在计算后缀表达式时，从前向后扫描，遇到运算符时，让运算符前的两个操作数执行相应运算，合并为一个操作数，并将运算符与其前的两个操作数替换为这个新得到的操作数，继续扫描，重复上述步骤，直到处理完成 根据上述处理步骤，可以发现其运算规则符合栈后入先出的特性，故而可采用以下算法： 从前向后扫描表达式的下一元素，直到所有元素处理完成，栈中最后剩余的元素即为结果 若扫描到操作数，令操作数入栈，转向步骤 1 若扫描到运算符，连续出栈两次，此时先出栈的是右操作数，执行相应运算，运算结果入栈，转向步骤 1 1234567891011121314151617181920212223242526272829303132333435363738394041void postfix_of_cal() &#123; //后缀表达式计算 char postfix[N]; stack&lt;int&gt; S; cin.get(postfix,N); int len = strlen(postfix); int left_op, right_op; for (int i = 0; i &lt; len; i++) &#123; //从前向后遍历 if (postfix[i] == '+') &#123; right_op = S.top(); S.pop(); //右操作数先出栈 left_op = S.top(); S.pop(); S.push(left_op + right_op); &#125; else if (postfix[i] == '-') &#123; right_op = S.top(); S.pop(); //右操作数先出栈 left_op = S.top(); S.pop(); S.push(left_op - right_op); &#125; else if (postfix[i] == '*') &#123; right_op = S.top(); S.pop(); //右操作数先出栈 left_op = S.top(); S.pop(); S.push(left_op * right_op); &#125; else if (postfix[i] == '/') &#123; right_op = S.top(); S.pop(); //右操作数先出栈 left_op = S.top(); S.pop(); S.push(left_op / right_op); &#125; else &#123; if (postfix[i] != ' ') &#123; int temp = 0; while (postfix[i] != ' ') &#123; temp = temp * 10 + postfix[i] - '0'; i++; &#125; S.push(temp); &#125; &#125; &#125; printf(\"%d\\n\", S.top());&#125; 【前缀表达式的计算】在计算前缀表达式时，从后向前扫描，遇到运算符时，让运算符后的两个操作数执行相应运算，合并为一个操作数，并将运算符与其后的两个操作数体会为这个新得到的操作数，继续扫描，重复上述步骤，直到处理完成 根据上述处理步骤，可以发现其运算规则符合栈后入先出的特性，故而可采用以下算法： 从后向前扫描表达式的下一元素，直到所有元素处理完成，栈中最后剩余的元素即为结果 若扫描到操作数，令操作数入栈，转向步骤 1 若扫描到运算符，连续出栈两次，此时先出栈的是左操作数，执行相应运算，运算结果入栈，转向步骤 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445void prefix_of_cal() &#123; //前缀表达式计算 char prefix[N]; stack&lt;int&gt; S; cin.get(prefix,N); int len = strlen(prefix); int left_op, right_op; for (int i = len - 1; i &gt;= 0; i--) &#123; //从后向前遍历 if (prefix[i] == '+') &#123; left_op = S.top(); S.pop(); //左操作数先出栈 right_op = S.top(); S.pop(); S.push(left_op + right_op); &#125; else if (prefix[i] == '-') &#123; left_op = S.top(); S.pop(); //左操作数先出栈 right_op = S.top(); S.pop(); S.push(left_op - right_op); &#125; else if (prefix[i] == '*') &#123; left_op = S.top(); S.pop(); //左操作数先出栈 right_op = S.top(); S.pop(); S.push(left_op * right_op); &#125; else if (prefix[i] == '/') &#123; left_op = S.top(); S.pop(); //左操作数先出栈 right_op = S.top(); S.pop(); S.push(left_op / right_op); &#125; else &#123; if (prefix[i] != ' ') &#123; int num = 0; int pos = 0; while (prefix[i] != ' ') &#123; int temp = prefix[i] - '0'; temp *= pow(10, pos); num += temp; i--; pos++; &#125; S.push(num); &#125; &#125; &#125; printf(\"%d\\n\", S.top());&#125; 【中缀表达式转后缀表达式】由于中缀表达式的运算顺序难以界定，因此在遇到中缀表达式时，可将中缀表达式转换为后缀表达式，之后进行后缀计算 在将中缀表达式转换为后缀表达式时，由于运算顺序不唯一，因此对应的后缀表达式也不唯一，一般采取左优先原则，即左边的运算符只要能先计算，就先转换左边的 在转换时，采取如下算法： 初始化一个栈，用于保存暂时无法确定运算顺序的运算符 从前向后扫描，逐个处理字符，根据遇到的字符决定处理方式 遇到操作数：直接加入后缀表达式 遇到界限符：遇到 ( 直接入栈，遇到 ) 将栈中的操作符依次弹出加入后缀表达式，直到弹出 ( 为止 遇到运算符：依次弹出栈中大于等于当前运算符优先级的所有运算符，加入后缀表达式，直到弹出 ( 为止，之后再将当前运算符入栈 扫描完毕后，将栈中剩余运算符依次弹出，加入后缀表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int getLevel(char x) &#123; //算符优先级 if (x == '+' || x == '-') return 1; if (x == '*' || x == '/') return 2; if (x == '^') return 3; return 0; // ( 与 ) 的优先级&#125;void infix_to_postfix() &#123; //中缀转后缀 char infix[N]; char postfix[N]; stack&lt;char&gt; S; cin.get(infix,N); int len = strlen(infix); memset(postfix, '\\0', sizeof(postfix)); int pos = 0; for (int i = 0; i &lt; len; i++) &#123; if(infix[i] == ' ') continue; if (infix[i] == '(') // ( 入栈 S.push(infix[i]); else if (infix[i] == ')') &#123; while (!S.empty() &amp;&amp; S.top() != '(') &#123; //遇到 ( 为止 postfix[pos++] = S.top(); postfix[pos++] = ' '; S.pop(); &#125; S.pop(); // ( 出栈 &#125; else if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/' || infix[i] == '^') &#123; //当前算符优先级小于等于栈中运算符优先级 while (!S.empty() &amp;&amp; getLevel(infix[i]) &lt;= getLevel(S.top())) &#123; char op = S.top(); postfix[pos++] = op; postfix[pos++] = ' '; S.pop(); &#125; S.push(infix[i]); //当前操作符入栈 &#125; else &#123; //数字 postfix[pos++] = infix[i]; if (i + 1 == len || infix[i + 1] == ' ') postfix[pos++] = ' '; &#125; &#125; while (!S.empty()) &#123; //栈中剩余算符出栈 postfix[pos++] = S.top(); postfix[pos++] = ' '; S.pop(); &#125; printf(\"%s\\n\", postfix);&#125; 【中缀表达式转前缀表达式】由于中缀表达式的运算顺序难以界定，因此在遇到中缀表达式时，可将中缀表达式转换为前缀表达式，之后进行前缀计算 在将中缀表达式转换为前缀表达式时，由于运算顺序不唯一，因此对应的前缀表达式也不唯一，一般采取右优先原则，即右边的运算符只要能先计算，就先转换右边的 在转换时，采取如下算法： 初始化一个栈，用于保存暂时无法确定运算顺序的运算符 从前向后扫描，逐个处理字符，根据遇到的字符决定处理方式 遇到操作数：直接加入表达式 遇到界限符：遇到 ) 直接入栈，遇到 ( 将栈中的操作符依次弹出加入表达式，直到弹出 ) 为止 遇到运算符：依次弹出栈中大于等于当前运算符优先级的所有运算符，加入表达式，直到弹出 ) 为止，之后再将当前运算符入栈 扫描完毕后，将栈中剩余运算符依次弹出，加入表达式 将表达式进行翻转，即得到前缀表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int getLevel(char x) &#123; //算符优先级 if (x == '+' || x == '-') return 1; if (x == '*' || x == '/') return 2; if (x == '^') return 3; return 0; // ( 与 ) 的优先级&#125;void infix_to_prefix() &#123; //中缀转前缀 char infix[N]; char prefix[N]; stack&lt;char&gt; S; cin.get(infix,N); int len = strlen(infix); memset(prefix, '\\0', sizeof(prefix)); int pos = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; if (infix[i] == ' ') continue; if (infix[i] == ')') // ) 入栈 S.push(infix[i]); else if (infix[i] == '(') &#123; while (!S.empty() &amp;&amp; S.top() != ')') &#123; //遇到 ) 为止 prefix[pos++] = S.top(); prefix[pos++] = ' '; S.pop(); &#125; S.pop(); // ) 出栈 &#125; else if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/' || infix[i] == '^') &#123; //当前算符优先级小于等于栈中运算符优先级 while (!S.empty() &amp;&amp; getLevel(infix[i]) &lt;= getLevel(S.top())) &#123; char op = S.top(); prefix[pos++] = op; prefix[pos++] = ' '; S.pop(); &#125; S.push(infix[i]); //当前操作符入栈 &#125; else &#123; //数字 prefix[pos++] = infix[i]; if (i == 0 || infix[i - 1] == ' ') prefix[pos++] = ' '; &#125; &#125; while (!S.empty()) &#123; prefix[pos++] = S.top(); prefix[pos++] = ' '; S.pop(); &#125; reverse(prefix, prefix + pos); printf(\"%s\\n\", prefix + 1);&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"栈","slug":"oi-acm/data-structure/stack","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/stack/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"栈","slug":"stack","permalink":"https://alex-mcavoy.github.io/tags/stack/"}],"author":"Alex_McAvoy"},{"title":"数据库概念模型","slug":"database/06.数据库概念模型","date":"2018-09-24T15:26:00.000Z","updated":"2021-08-23T13:40:42.576Z","comments":true,"path":"notes/database/2dc1fdc3.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/2dc1fdc3.html","excerpt":"【信息世界中的基本概念 】实体（Entity）是客观存在并且可以相互区别的事物，可以是具体的人、事、物，也可以是抽象的概念或联系 实体集（Entity set）是同一类型实体的集合","text":"【信息世界中的基本概念 】实体（Entity）是客观存在并且可以相互区别的事物，可以是具体的人、事、物，也可以是抽象的概念或联系 实体集（Entity set）是同一类型实体的集合 属性（Attribute）是实体所具有的某一特性，一个实体可以通过若干属性来进行刻画，属性的取值范围称为域（Domain），具有相同属性的实体必然具有共同的特征、性质 实体型（Entity type）是用实体名及其属性名集合，来进行抽象、刻画同一类实体 码（Key）是唯一标识实体的属性集 联系（Relationship）：现实世界中事物内部以及事物之间的联系，在信息世界中反映为实体内部的联系和实体之间的联系 实体内部的联系：指组成实体的各属性之间的联系 实体之间的联系：指不同实体集之间的联系 例如，对于如下的表，有： 每个学生是一个实体，整张学生表是一个实体集 学号、姓名、年龄、性别、专业是学生这个实体的属性，其中 性别 这个属性的域是 (男,女) 学生(学号,姓名,年龄,性别,专业) 是实体型 学号 是学生实体的码 学号 姓名 年龄 性别 专业 17001 张三 19 男 通信工程 17002 李四 18 女 网络工程 17003 王五 20 女 计算机科学 17004 赵六 18 男 物联网工程 … … … … … 【实体之间的联系】若对于实体集 A 中的每一个实体，实体集 B 中最多有一个实体与其联系，反之亦然，则称实体集 A 和实体集 B 存在一对一关系（1：1） 若对于实体集 A 中的每一个实体，实体集 B 中有 m 个实体与其联系，反之，对于实体集 B 中的每一个实体，实体集 A 中最多有一个实体与其联系，则称实体集 A 和实体集 B 存在一对多关系（1：m） 若对于实体集 A 中的每一个实体，实体集 B 中有 n 个实体与其联系，反之，对于实体集 B 中的每一个实体，实体集 A 中有 m 个实体与其联系，则称实体集 A 和实体集 B 存在多对多关系（n：m） 【概念模型】概念模型是对信息世界的建模，能够方便准确地表示上述信息世界中的基本概念和实体间的联系 概念模型的主要特点有： 真实、充分地反映现实世界 易于理解 易于更改 易于向关系、网状、层次等各种数据模型转换 目前通常使用实体-联系方法用 E-R 图来描述现实世界的概念模型，关于 E-R 模型的具体介绍，详见：数据库概念结构设计","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"链栈","slug":"data-structure/02.stack/04.链栈","date":"2018-09-24T15:16:00.000Z","updated":"2021-08-31T08:03:22.774Z","comments":true,"path":"oi-acm/data-structure/stack/b899469.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/stack/b899469.html","excerpt":"【概述】链栈是采取链式存储的栈，其不存在栈满上溢的情况，通常采用不带头结点的单链表来实现，且一般规定所有的操作都在单链表表头进行，以保证出栈、入栈、取栈顶操作的时间复杂度为 $O(1)$ 链栈的实现类如下：","text":"【概述】链栈是采取链式存储的栈，其不存在栈满上溢的情况，通常采用不带头结点的单链表来实现，且一般规定所有的操作都在单链表表头进行，以保证出栈、入栈、取栈顶操作的时间复杂度为 $O(1)$ 链栈的实现类如下： 123456789101112131415161718template &lt;typename T&gt; struct LNode &#123; //单链表结点 T data; //数据域 LNode&lt;T&gt; *next; //指针域&#125;;template &lt;typename T&gt; class LinkStack &#123; public: LinkStack(); //初始化栈 int getLen(); //求栈长 bool empty(); //判空 bool pop(T &amp;elem); //出栈 bool push(T elem); //入栈 bool getTop(T &amp;elem); //取栈顶 void print(); //输出 private: LNode&lt;T&gt; *first; //头指针&#125;; 【初始化】由于采用不带头结点的单链表，因此在初始化时直接令头指针指向为 NULL 即可 1234template &lt;typename T&gt; LinkStack&lt;T&gt;::LinkStack() &#123; //初始化栈 first = NULL;&#125; 【求栈长】由于采用的是链式存储结构，因此在求栈长时，要从头指针开始枚举，枚举到链表尾部，时间复杂度为 $O(n)$ 12345678910template &lt;typename T&gt; int LinkStack&lt;T&gt;::getLen() &#123; //求栈长 LNode&lt;T&gt; *p = first; int len = 0; while (p != NULL) &#123; len++; p = p-&gt;next; &#125; return len;&#125; 【判空】判空时，只需判断头指针 first 是否为 NULL 即可 123456template &lt;typename T&gt;bool LinkStack&lt;T&gt;::empty() &#123; //判空 if (first == NULL) return true; return false;&#125; 【出栈】在出栈时，首先进行下溢判断，之后令头指针指向的结点出栈，释放空间，再令头指针后移 12345678910template &lt;typename T&gt; bool LinkStack&lt;T&gt;::pop(T &amp;elem) &#123; //出栈 if (empty()) //下溢判断 return false; LNode&lt;T&gt; *p = first; elem = p-&gt;data; first = first-&gt;next; free(p); return true;&#125; 【入栈】在入栈时，首先进行申请空间，之后采用头插法将新元素入栈 12345678910template &lt;typename T&gt; bool LinkStack&lt;T&gt;::push(T elem) &#123; //入栈 LNode&lt;T&gt; *p = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); if (p == NULL) //空间分配失败 return false; p-&gt;data = elem; p-&gt;next = first; first = p; return true;&#125; 【取栈顶】在取栈顶时，首先进行下溢判断，之后输出头指针指向结点的数据域即可 1234567template &lt;typename T&gt; bool LinkStack&lt;T&gt;::getTop(T &amp;elem) &#123; //取栈顶 if (empty()) //下溢判断 return false; elem = first-&gt;data; return true;&#125; 【输出】在输出时，从栈顶开始，将栈中所有元素依次出栈，进行输出即可 123456789template &lt;typename T&gt; void LinkStack&lt;T&gt;::print() &#123; //输出 int elem; while (!empty()) &#123; //将所有元素依次出栈进行输出 pop(elem); cout &lt;&lt; elem &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"栈","slug":"oi-acm/data-structure/stack","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/stack/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"栈","slug":"stack","permalink":"https://alex-mcavoy.github.io/tags/stack/"}],"author":"Alex_McAvoy"},{"title":"数据库数据模型","slug":"database/05.数据库数据模型","date":"2018-09-24T09:56:00.000Z","updated":"2021-08-23T13:40:08.721Z","comments":true,"path":"notes/database/b4a5ca38.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/b4a5ca38.html","excerpt":"【两类数据模型】数据模型是对现实世界数据特征的抽象，用于描述、组织、处理数据，其分为概念模型、逻辑模型和物理模型两类： 概念模型：也称信息模型，是按用户的观点来对数据和信息建模，用于数据库设计 逻辑模型和物理模型： 逻辑模型：主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于 DBMS 实现 物理模型：对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法","text":"【两类数据模型】数据模型是对现实世界数据特征的抽象，用于描述、组织、处理数据，其分为概念模型、逻辑模型和物理模型两类： 概念模型：也称信息模型，是按用户的观点来对数据和信息建模，用于数据库设计 逻辑模型和物理模型： 逻辑模型：主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于 DBMS 实现 物理模型：对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法 【事物抽象过程】为将现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型，人们通常将现实世界抽象为信息世界，然后将信息世界抽象为机器世界，即将现实世界中的某一客观对象变为概念模型，再变为逻辑模型和物理模型的过程 【数据模型组成要素】数据结构数据结构是对系统静态特性的描述，用于描述数据库的组成对象以及对象之间的联系，也就是说，其描述的内容分为以下两类： 与对象的类型、内容、性质有关的（例如：关系模型中的域、属性等） 与数据之间联系有关的对象（例如：网状模型中的系型等） 在数据库系统中，数据结构通常按照数据结构的类型来命名数据模型，例如：层次结构、网状结构、关系结构的数据模型，分别命名为层次模型、网状模型、关系模型 数据操作数据操作是对系统动态特性的描述，是数据库中各种对象（实体型）的实例（值）允许执行的操作及有关的操作规则 数据库的操作主要分为查询、更新（插入、修改、删除）两大类，这就要求数据模型必须定义这些操作的确切含义、操作符号、操作规则、实现操作的语言 数据的完整性约束条件数据的完整性约束条件是一组完整性规则，完整性规则是给定的数据模型中，数据及其联系所具有的制约和储存规则，用来限定符合数据模型的数据库状态、状态的变化，从而保证数据的正确、有效、相容 数据模型应该反映、规定其必须遵守的基本的、通用的完整性约束条件，例如：在关系模型中，任何关系必须满足实体完整性、参照完整性这两个条件 同时，数据模型还应提供定义完整性约束条件的机制，来反映具体应用所涉及的数据必须遵守的特定语义约束条件，例如：银行数据库中规定账号的余额不能为负数","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"双端栈","slug":"data-structure/02.stack/03.双端栈","date":"2018-09-24T09:14:00.000Z","updated":"2021-09-02T13:43:53.457Z","comments":true,"path":"oi-acm/data-structure/stack/aab050fd.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/stack/aab050fd.html","excerpt":"【概述】早期计算机中，为更有效的利用存储空间，在顺序栈的基础上引入了双端栈，其又被称共享栈 双端栈令两个顺序栈共享一个数组空间，将栈底分别设为数组的两端，栈顶从两端向中间延伸，以达到利用同一个数组空间的目的","text":"【概述】早期计算机中，为更有效的利用存储空间，在顺序栈的基础上引入了双端栈，其又被称共享栈 双端栈令两个顺序栈共享一个数组空间，将栈底分别设为数组的两端，栈顶从两端向中间延伸，以达到利用同一个数组空间的目的 双端栈的两个栈的共享空间相互调节，只有在整个数组存满后才会发生上溢，有效地利用了存储空间 双端栈的实现类如下： 1234567891011121314151617#define N 50 + 5 //申请空间个数template &lt;typename T&gt; class ShStack &#123; public: ShStack(); //初始化栈 int getLen(int i); //求栈长 bool empty(int i); //判空 bool full(); //判满 bool pop(int i, T &amp;elem); //出栈 bool push(int i, T elem); //入栈 bool getTop(int i, T &amp;elem); //取栈顶 void print(int i); //输出 private: T data[N]; //栈空间 int top1; //1号栈指针 int top2; //2号栈指针&#125;; 【初始化】在初始化时，栈为空栈，栈中无元素，对于 $1$ 号栈，栈指针设为存储空间顶部 -1，对于 $2$ 号栈，栈指针设为存储空间尾部 N 12345template &lt;typename T&gt; ShStack&lt;T&gt;::ShStack() &#123; //初始化栈 top1 = -1; //1号栈栈底为头部 top2 = N; //2号栈栈底为尾部&#125; 【求栈长】对于双端栈来说，其通过指定的栈号 i 来求对应栈的长度 若求 $1$ 号栈的栈长，与顺序栈相同，直接返回对应栈指针 +1 的位置 top1+1 即可 若求 $2$ 号栈的栈长，则需要从存储空间的尾部 N 开始计算，减去该栈栈指针 top2 的位置即可 1234567template &lt;typename T&gt;int ShStack&lt;T&gt;::getLen(int i) &#123; //求栈长 if (i == 1) //判断1号栈 return top1 + 1; else //判断2号栈 return N - top2;&#125; 【判空】对于双端栈来说，其通过指定的栈号 i 来判断对应栈是否为空 在判断时，只需判断对应栈的栈指针 top1、top2 是否为对应初始值即可 12345678910111213template &lt;typename T&gt;bool ShStack&lt;T&gt;::empty(int i) &#123; //判空 if (i == 1) &#123; //判断1号栈 if (top1 == -1) return true; return false; &#125; else &#123; //判断2号栈 if (top2 == N) return true; return false; &#125;&#125; 【判满】对于双端栈来说，其两个栈空间是共享的，不存在一个栈满另一个栈不满的情况，只可能两个栈所占用的空间占满了整个存储空间 因此，在判满时，只需要判断两个栈指针的位置 top1 与 top2 是否相邻即可 123456template &lt;typename T&gt; bool ShStack&lt;T&gt;::full() &#123; //判满 if (top1 == top2 - 1) return true; return false;&#125; 【出栈】对于双端栈来说，其通过指定的栈号 i 来对指定栈进行出栈操作，但在出栈前，要对对应栈进行下溢判断 之后，若是 $1$ 号栈出栈，其栈顶元素出栈后令栈指针 top1 后移一位；若是 $2$ 号栈出栈，其栈顶元素出栈后令栈指针 top2 前移一位 12345678910template &lt;typename T&gt; bool ShStack&lt;T&gt;::pop(int i, T &amp;elem) &#123; //出栈 if (empty(i)) //下溢判断 return false; if (i == 1) //1号栈入栈 elem = data[top1--]; else //2号栈入栈 elem = data[top2++]; return true;&#125; 【入栈】对于双端栈来说，其通过指定的栈号 i 来对指定栈进行出栈操作，但在入栈前，要对整个栈进行上溢判断 之后，若是 $1$ 号栈入栈，其先令栈指针 top1 前移一位，再将元素放入栈中；若是 $2$ 号栈入栈，其先令栈指针 top2 后移一位，再将元素放入栈中 12345678910template &lt;typename T&gt; bool ShStack&lt;T&gt;::push(int i, T elem) &#123; //入栈 if (full()) //上溢判断 return false; if (i == 1) //1号栈入栈 data[++top1] = elem; else //2号栈入栈 data[--top2] = elem; return true;&#125; 【取栈顶】对于双端栈来说，其通过指定的栈号 i 来对指定栈进行取栈顶操作，但在取栈顶元素前，要对对应栈进行下溢判断 之后，根据要取的栈号 i，取对应栈指针的元素即可 12345678910template &lt;typename T&gt; bool ShStack&lt;T&gt;::getTop(int i, T &amp;elem) &#123; //取栈顶 if (empty(i)) //下溢判断 return false; if (i == 1) //取1号栈栈顶 elem = data[top1]; else //取2号栈栈顶 elem = data[top2]; return true;&#125; 【输出】对于双端栈来说，其通过指定的栈号 i 来对指定栈进行输出操作 在输出时，从指定栈的栈顶开始，将栈中所有元素依次出栈，进行输出即可 123456789template &lt;typename T&gt; void ShStack&lt;T&gt;::print(int i) &#123; //输出 int elem; while (!empty(i)) &#123; //将所有元素依次出栈进行输出 pop(i, elem); cout &lt;&lt; elem &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"栈","slug":"oi-acm/data-structure/stack","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/stack/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"栈","slug":"stack","permalink":"https://alex-mcavoy.github.io/tags/stack/"}],"author":"Alex_McAvoy"},{"title":"查找的基本概念","slug":"basic/01.theory/07.查找的基本概念","date":"2018-09-23T09:25:51.000Z","updated":"2021-09-25T08:37:03.921Z","comments":true,"path":"oi-acm/basic/theory/ff587363.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/ff587363.html","excerpt":"【查找的基本概念】查找（search），又称搜索，是在数据集合中，寻找满足某种条件的数据的过程 用于查找的数据集合被称为查找表，其由同一类型的数据元素或记录组成，数据元素中唯一标识该元素的某个数据项的值，被称为关键字，通过关键字的查找，结果应当是唯一的","text":"【查找的基本概念】查找（search），又称搜索，是在数据集合中，寻找满足某种条件的数据的过程 用于查找的数据集合被称为查找表，其由同一类型的数据元素或记录组成，数据元素中唯一标识该元素的某个数据项的值，被称为关键字，通过关键字的查找，结果应当是唯一的 在查找过程中，一次查找的长度是指这一次查找中关键字的比较次数，平均查找长度是指所有查找过程中关键字的比较次数的平均值，其是衡量查找算法最主要的指标 平均查找长度被定义为： ASL=\\sum_{i=1}^nP_iC_i其中，$n$ 为查找表的长度，$P_i$ 为查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_i=\\frac{1}{n}$，$C_i$ 是找到第 $i$ 个数据元素所要进行的比较次数 【查找表】用于查找的数据集合被称为查找表，其由同一类型的数据元素或记录组成 对于查找表的操作一般有四种： 查询某特定的数据元素是否在查找表中 检索满足条件的某个特定的数据元素的各种属性 在查找表中插入一个数据元素 在查找表中删除一个数据元素 如果一个查找表的操作，仅涉及到上述的 1、2，那么该查找表无需动态修改查找表，此时查找表被称为静态查找表，与此对应，需要动态插入或删除的查找表被称为动态查找表","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"}],"author":"Alex_McAvoy"},{"title":"数据库系统的内体系结构","slug":"database/04.数据库系统的内体系结构","date":"2018-09-23T07:53:00.000Z","updated":"2021-08-23T13:36:53.516Z","comments":true,"path":"notes/database/9115cc91.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/9115cc91.html","excerpt":"【概述】对于数据库系统的体系结构，其分为内部体系结构、外部体系结构两个角度 从数据库管理系统角度来看，通常采用外模式、模式、内模式三级模式结构，这是数据库系统的内体系结构，又被称为数据库系统的模式结构","text":"【概述】对于数据库系统的体系结构，其分为内部体系结构、外部体系结构两个角度 从数据库管理系统角度来看，通常采用外模式、模式、内模式三级模式结构，这是数据库系统的内体系结构，又被称为数据库系统的模式结构 从数据库最终用户角度来看，数据库系统结构分为单用户结构、主从式结构、分布式结构、客户-服务器结构、浏览器-应用服务器-数据库服务器多层结构等，这是数据库系统的外体系结构 本篇仅介绍数据库系统的内体系结构，关于数据库系统的外体系结构：点击这里 【模式的概念】在数据模型中，有型和值的概念： 型（Type）：对某一类数据的结构和属性的说明 值（Value）：型的一个具体赋值 例如：在学生数据库中，学生记录定义为 (学号,姓名,性别,系别,年龄) ，这就是一个记录型，而对应的 (97001,张三,男,计算机,19) 是该记录型的一个记录值 对于模式，有如下概念： 模式（Schema）：数据库中全体数据的逻辑结构和特征的描述，是型的描述，反映的是数据的结构及其联系，相对稳定 实例（Instance）：模式的一个具体值，反映数据库某一时刻的状态，随数据库中的数据的更新而变动，同一个模式可以有很多实例 例如：在学生数据库模式中，包含学生记录、课程记录、学生选课记录，这是一个模式，而在 2018 年度学生数据库实例中，包含了 2018 年学校中所有学生的记录、学校开设的所有课程的记录、所有学生选课的记录，同时 2017 年度学生数据库模式对应的实例与 2018 年度学生数据库模式对应的实例是不同的 【三级模式结构】概述数据库系统的三级模式结构是指数据库系统由外模式、模式、内模式三级构成 简单来说，外模式是用户世界，模式是程序员世界，内模式是机器世界，对于某个学生课程数据库，三者的视角如下图 模式模式（Schema）也称逻辑模式，是数据库中全体数据的逻辑结构与特征的描述，是所有用户的公共数据视图，综合了所有用户的需求 模式是数据库系统模式结构的中间层，与数据的物理存储细节和硬件环境无关，也与具体的应用程序、开发工具、高级程序设计语言无关 模式实际上是数据库数据在逻辑上的视图，一个数据库只有一个模式，DBMS 提供模式数据定义语言（模式 DDL）来定义模式，在定义时，要考虑数据的逻辑结构（数据项名字、类型、取值范围等）、数据之间的联系、数据有关的安全性、完整性要求 外模式外模式（External Schema）也称子模式、用户模式，其是数据库用户能够看见、使用的局部数据的逻辑结构与特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 外模式介于模式与应用之间，对于模式与外模式来说，一个模式可以对应多个外模式（一对多关系），是模式的子集，不同的外模式反映了不同用户的需求；对于外模式与应用来说，一个外模式可以对应多个应用（一对多关系），但一个应用只能使用一个外模式 外模式是保证数据库安全性的一个强有力的措施，每个用户只能访问对应外模式的数据，数据库中其他数据是不可见的，DBMS 提供外模式数据定义语言（外模式 DDL）来定义外模式 内模式内模式（Internal Schema）也称存储模式，其是数据库中的数据物理结构和存储方式的描述 内模式是数据在数据库内部的表示方式，例如记录的存储方式、索引的组织方式、数据是否加密、数据是否压缩存储等，都是数据库的内模式 一个数据库只有一个内模式，对应着唯一一个模式 【二级映像】概述数据库系统的三级模式是对数据的三个抽象级别，其将数据的具体组织交由 DBMS 管理，是用户能够有逻辑地抽象地处理数据，不必关心计算机中数据的具体表示方式与存储方式，为能够在系统内部实现这三个抽象层次的联系和转换，DBMS 在这三级模式之间提供了两层映像（外模式/模式映像、模式/内模式映像），来保证数据库系统的数据独立性（逻辑独立性、物理独立性） 外模式/模式映像模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构 一个模式可以有任意个外模式，对于每一个外模式，都有一个外模式/模式映像，定义了该外模式与模式间的对应关系，这些映像通常包含在各自外模式的描述中 当模式改变时，数据库管理员修改有关的外模式/模式映像，使外模式不变，而应用程序是依据外模式编写的，这就使得应用程序不必修改，从而保证数据与程序的逻辑独立性 模式/内模式映像模式描述的是数据的全局逻辑结构，内模式描述的是数据的物理结构 一个模式对应一个内模式，因此模式/内模式映像是唯一的，其定义了数据全局逻辑结构与存储结构间的对应关系，该映像包含在模式的描述中 当数据库的存储结构改变时，数据库管理员修改模式/内模式映像，使模式不变，加之外模式/模式映像，这就使得应用程序不必修改，从而保证数据与程序的物理独立性 【数据独立性】数据库模式是数据库的中心与关键，它独立于数据库的其他层次，因此在设计数据库模式结构时，应该首先确定数据库的逻辑模式（模式） 内模式依赖于全局逻辑结构，独立于数据库的用户视图（外模式），也独立于具体的存储设备，其是将全局逻辑结构中定义的数据结构及其联系，依照一定的物理存储策略进行组织，以达到较好的时间与空间效率 外模式面向具体的应用程序，定义于逻辑模式之上，独立于存储模式（内模式）与存储设备，当应用需求发生较大变化，相应外模式不能满足其视图需求时，该外模式要做相应该多，因此在设计外模式时，要充分考虑应用的扩展性 二级映像保证了数据库外模式的稳定性，从而从底层保证了应用程序的稳定性，除非应用需求发生变化，否则应用程序一般不需要修改 数据与程序间的独立性使数据的定义与描述可以从应用程序中分离出去，此外，由于数据的存取由 DBMS 管理，简化了应用程序的编制，这大大减少了应用程序的维护与修改","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库系统的外体系结构","slug":"database/03.数据库系统的外体系结构","date":"2018-09-23T02:25:00.000Z","updated":"2021-08-23T13:39:13.599Z","comments":true,"path":"notes/database/71d8e303.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/71d8e303.html","excerpt":"【概述】对于数据库系统的体系结构，其分为内部体系结构、外部体系结构两个角度 从数据库管理系统角度来看，通常采用外模式、模式、内模式三级模式结构，这是数据库系统的内体系结构，又被称为数据库系统的模式结构","text":"【概述】对于数据库系统的体系结构，其分为内部体系结构、外部体系结构两个角度 从数据库管理系统角度来看，通常采用外模式、模式、内模式三级模式结构，这是数据库系统的内体系结构，又被称为数据库系统的模式结构 从数据库最终用户角度来看，数据库系统结构分为单用户结构、主从式结构、分布式结构、C/S 结构、B/S 结构，这是数据库系统的外体系结构 本篇仅介绍数据库系统的外体系结构，关于数据库系统的内体系结构：点击这里 【单用户结构】单用户结构是最早的数据库系统，也是最简单的数据库系统，整个数据库系统（数据、DBMS、应用程序）集中存放在一台计算机上，为一个用户独占，不同机器间不能共享数据 例如：一个企业的各个部门都使用本部门的机器来管理本部门的数据，各个部门的机器是独立的，由于不同部门之间不能共享数据，因此企业内部存在大量的冗余数据，每个部门必须重复存放每一名职工的一些基本信息 【主从式结构】主从式结构是一个主机带多个终端的多用户结构，数据库系统（数据、DBMS、应用程序）集中存放在主机上，所有处理任务都由主机来完成，各个用户通过主机的终端并发存取数据库，共享数据资源 该结构易于管理、控制与维护，但当终端用户数目增加到一定程度后，主机的任务会过分繁重，从而使系统性能下降，此外系统的可靠性依赖主机，当主机出现故障时，整个系统都不能使用 【分布式结构】采取分布式结构的数据库中的数据在逻辑上是一个整体，但物理上分布在不同结点，网络中的每个结点都可以独立处理本地数据库中的数据，执行局部应用，同时也可以同时处理多个异地数据库中的数据，执行全局应用 最典型的例子就是各大银行的数据库，以中国银行为例，其在全国各地有多个营业网点，每个网点都可以进行个人存取款的服务，在开户局取钱时，本地机就可以处理，不需要去总机那里调用个人信息，这是局部应用；如果是在上海开户建卡，在北京出差时要取钱，那么本地机是不能自己处理的，它必须去总行那里得到你的帐户信息，然后才能完成异地取款的任务，这就是全局应用 分布式数据库是为了满足那些地理跨越范围比较大的业务的需要而产生的，例如像是微软、IBM 等跨国公司，他们的业务和生产线分布在多个国家，但是需要一个统一的数据库来存储他们的产品信息，物流信息，版本信息等，所以产生了分布式数据库 分布式结构适应了地理上分散的公司、团体和组织对于数据库应用的需求，但数据的分布存放给数据的处理、管理与维护带来困难，同时，当用户需要经常访问远程数据时，系统效率会明显地受到网络传输的制约 【 C/S 结构】C/S 结构即客户/服务器结构，其将 DBMS 功能与应用分开，网络中某些结点上的计算机专门用于执行 DBMS 功能，称为数据库服务器，其他结点上的计算机安装 DBMS 的外围应用开发工具，称为客户机，最典型的例子就是票务系统 C/S 结构的数据库更加开放，客户与服务器一般都能在多种不同的硬件和软件平台上运行，可以使用不同厂商的数据库应用开发工具，易于扩展和共享 但 C/S 结构存在胖客户问题，即系统安装复杂、工作量大，且应用维护困难，难于保密，安全性差，相同的应用程序要重复安装在每一台客户机上，从系统总体来看，大大浪费了系统资源 C/S 结构与主从式结构和分布式结构相比，主从式的主机、分布式的每个结点机，既执行 DBMS 功能又执行应用程序，而 C/S 结构的服务器仅执行 DBMS 功能，客户机仅执行应用程序 C/S 结构分为集中式服务器结构、分布式服务器结构两类 集中式服务器结构由一台服务器、多台客户机构成 分布式服务器结构由多台服务器、多台客户机构成，其是 C/S 结构与分布式结构的结合 【 B/S 结构】B/S 结构即浏览器/应用服务器/数据库结构，客户端采用浏览器，界面统一，易于用户掌握，减少了培训时间和费用，服务器端分为应用服务器、数据库服务器两个部分，减少了系统开发和维护代价，能够支持数万甚至更多的用户","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"顺序栈","slug":"data-structure/02.stack/02.顺序栈","date":"2018-09-20T07:14:00.000Z","updated":"2021-08-31T08:03:04.014Z","comments":true,"path":"oi-acm/data-structure/stack/dbb1f3e2.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/stack/dbb1f3e2.html","excerpt":"【概述】顺序栈是采取顺序方式存储的栈，利用一组地址连续的存储单元自栈底到栈顶存放数据元素，并通过栈指针来指示当前栈顶元素位置 对于存储空间的分配，若采用静态分配方式，一经分配不可修改，若采用动态分配方式，分配后在 $O(n)$ 的时间复杂度内可以更改","text":"【概述】顺序栈是采取顺序方式存储的栈，利用一组地址连续的存储单元自栈底到栈顶存放数据元素，并通过栈指针来指示当前栈顶元素位置 对于存储空间的分配，若采用静态分配方式，一经分配不可修改，若采用动态分配方式，分配后在 $O(n)$ 的时间复杂度内可以更改 顺序栈的实现类如下： 12345678910111213141516#define N 50 + 5 //申请空间个数template &lt;typename T&gt; class SeqStack &#123; public: SeqStack(); //初始化栈 int getLen(); //求栈长 bool empty(); //判空 bool full(); //判满 bool pop(T &amp;elem); //出栈 bool push(T elem); //入栈 bool getTop(T &amp;elem); //取栈顶 void print(); //输出 private: T data[N]; //栈空间 int top; //栈指针&#125;; 【初始化】初始化时，栈为空栈，栈中无元素，此时栈指针 top 一般设为 -1，有时也可令 top=0，以表明 top 指向栈顶元素的下一存储单元 1234template &lt;typename T&gt; SeqStack&lt;T&gt;::SeqStack() &#123; //初始化栈 top = -1;&#125; 【求栈长】由于栈指针指示了栈顶元素位置，因此栈的长度即为栈指针的大小，需要注意的是，当栈指针初始化为 -1 时，最终的栈长要 +1 1234template &lt;typename T&gt; int SeqStack&lt;T&gt;::getLen() &#123; //求栈长 return top + 1;&#125; 【判空】判空时，只需判断栈指针 top 是否为初始值即可 123456template &lt;typename T&gt; bool SeqStack&lt;T&gt;::empty() &#123; //判空 if (top == -1) return true; return false;&#125; 【判满】判满时，只需要判断栈指针 top 是否达到最大栈空间即可 123456template &lt;typename T&gt; bool SeqStack&lt;T&gt;::full() &#123; //判满 if (top == N - 1) return true; return false;&#125; 【出栈】在出栈时，要进行下溢判断，即在栈已空的情况下，再进行出栈操作，会发生溢出 1234567template &lt;typename T&gt; bool SeqStack&lt;T&gt;::pop(T &amp;elem) &#123; //出栈 if (empty()) //下溢判断 return false; elem = data[top--]; return true;&#125; 【入栈】由于顺序栈的存储空间有限，因此在入栈时，要进行上溢判断，即在栈已满的情况下，再进行入栈操作时，会发生溢出 1234567template &lt;typename T&gt; bool SeqStack&lt;T&gt;::push(T elem) &#123; //入栈 if (full()) //上溢判断 return false; data[++top] = elem; return true;&#125; 【取栈顶】在取栈顶时，要进行下溢判断，以确保不会在栈已空的情况下取到元素 1234567template &lt;typename T&gt; bool SeqStack&lt;T&gt;::getTop(T &amp;elem) &#123; //取栈顶 if (empty()) //下溢判断 return false; elem = data[top]; return true;&#125; 【输出】在输出时，从栈顶开始，将栈中所有元素依次出栈，进行输出即可 123456789template &lt;typename T&gt; void SeqStack&lt;T&gt;::print() &#123; //输出 int elem; while (!empty()) &#123; //将所有元素依次出栈进行输出 pop(elem); cout &lt;&lt; elem &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"栈","slug":"oi-acm/data-structure/stack","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/stack/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"栈","slug":"stack","permalink":"https://alex-mcavoy.github.io/tags/stack/"}],"author":"Alex_McAvoy"},{"title":"队列","slug":"data-structure/03.queue/01.队列","date":"2018-09-20T05:12:00.000Z","updated":"2021-09-02T13:44:57.267Z","comments":true,"path":"oi-acm/data-structure/queue/6534ce06.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/queue/6534ce06.html","excerpt":"【队列的定义】队列（Queue），也是一种操作受限的线性表，只允许在表的一端插入，在表的另一端删除，其中，只允许删除的那一端称为队首，只允许插入的那一端称为队尾，当线性表中不含元素时，称为空队列 队列具有先进先出（First In First Out，FIFO）的操作性质，如下图所示，假设某个队列 $Q=(a_1,a_2,a_3,a_4,a_5)$ ，其中 $a_1$ 为队首元素，$a_5$ 为队尾元素，进队顺序为：$a_1,a_2,a_3,a_4,a_5$，出队顺序为：$a_1,a_2,a_3,a_4,a_5$","text":"【队列的定义】队列（Queue），也是一种操作受限的线性表，只允许在表的一端插入，在表的另一端删除，其中，只允许删除的那一端称为队首，只允许插入的那一端称为队尾，当线性表中不含元素时，称为空队列 队列具有先进先出（First In First Out，FIFO）的操作性质，如下图所示，假设某个队列 $Q=(a_1,a_2,a_3,a_4,a_5)$ ，其中 $a_1$ 为队首元素，$a_5$ 为队尾元素，进队顺序为：$a_1,a_2,a_3,a_4,a_5$，出队顺序为：$a_1,a_2,a_3,a_4,a_5$ 【双端队列】双端队列是指两端均可以进入队和出队的队列，其元素的逻辑结构仍为线性结构 双端队列分为前端、后端两端，均可以进行出队与入队，在双端队列进队时，前端进的元素排列在后端进的元素之前；在双端队列出队时，无论前端还是后端出队，先出的元素排列在后出的元素之前 只允许在一端进行插入、删除，在另一端只允许插入的双端队列被称为输出受限的双端队列 只允许在一端进行插入、删除，在另一端只允许删除的双端队列被称为输入受限的双端队列 【队列的存储结构】队列也是一种受限的线性表，类似于线性表，其有顺序存储方式和链式存储方式两种 采用顺序存储方式的队列称为顺序队列，其利用一组地址连续的存储单元存放从队首到队尾的数据元素，并设置一个头指针来指示当前队首元素位置，设置一个尾指针来指示当前队尾元素位置或队尾元素的下一个位置 由于顺序队列假溢出的问题，可以令顺序队列在逻辑上视为一个环，当队首指针到达线性表最大长度时，再令其返回线性表的初始位置，以解决假溢出问题，这种逻辑上为环装的顺序队列称为循环队列 采用链式存储方式的队列称为链式队列，通常采用带有一个队首指针和一个队尾指针的带头单链表实现，其中，队首指针指向单链表头结点，队尾指针指向单链表的最后一个结点","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"队列","slug":"oi-acm/data-structure/queue","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/queue/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"队列","slug":"queue","permalink":"https://alex-mcavoy.github.io/tags/queue/"}],"author":"Alex_McAvoy"},{"title":"栈","slug":"data-structure/02.stack/01.栈","date":"2018-09-20T05:10:00.000Z","updated":"2021-09-02T13:43:57.927Z","comments":true,"path":"oi-acm/data-structure/stack/1f4ac2fb.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/stack/1f4ac2fb.html","excerpt":"【栈的定义】栈（Stack），是只允许在一端进行插入或删除操作的线性表，其中，允许插入、删除的那一端称为栈顶，不允许插入、删除的那一端称为栈底，当线性表中不含元素时，称为空栈 栈具有后进先出（Last In First Out，LIFO）的操作性质，如下图所示，假设某个栈 $S=(a_1,a_2,a_3,a_4,a_5)$ ，其中 $a_1$ 为栈底元素，$a_5$ 为栈顶元素，由于栈只能在栈顶进行插入、删除，故而进栈顺序为：$a_1,a_2,a_3,a_4,a_5$，出栈顺序为：$a_5,a_4,a_3,a_2,a_1$","text":"【栈的定义】栈（Stack），是只允许在一端进行插入或删除操作的线性表，其中，允许插入、删除的那一端称为栈顶，不允许插入、删除的那一端称为栈底，当线性表中不含元素时，称为空栈 栈具有后进先出（Last In First Out，LIFO）的操作性质，如下图所示，假设某个栈 $S=(a_1,a_2,a_3,a_4,a_5)$ ，其中 $a_1$ 为栈底元素，$a_5$ 为栈顶元素，由于栈只能在栈顶进行插入、删除，故而进栈顺序为：$a_1,a_2,a_3,a_4,a_5$，出栈顺序为：$a_5,a_4,a_3,a_2,a_1$ 对于 $n$ 个不同元素，进栈、出栈元素的不同排列个数满足卡特兰（Catalan）数，即： \\frac{1}{n+1}C_{2n}^n【栈的存储结构】栈是一种受限的线性表，类似于线性表，其有顺序存储方式和链式存储方式两种 采用顺序存储方式的栈称为顺序栈，其利用一组地址连续的存储单元存放从栈底到栈顶的数据元素，同时设置一个指针来指示当前栈顶元素位置 利用栈顶位置不变的特性，可以令两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间中间延伸，这样的结构能够更有效地利用存储空间，被称为双端栈 采用链式存储方式的栈称为链栈，通常采用不带头结点的单链表实现，并规定所有的操作都是在单链表表头进行的","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"栈","slug":"oi-acm/data-structure/stack","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/stack/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"栈","slug":"stack","permalink":"https://alex-mcavoy.github.io/tags/stack/"}],"author":"Alex_McAvoy"},{"title":"数据管理技术的发展","slug":"database/02.数据管理技术的发展","date":"2018-09-18T09:05:00.000Z","updated":"2021-08-23T13:38:19.359Z","comments":true,"path":"notes/database/2d52e881.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/2d52e881.html","excerpt":"【数据管理技术】数据管理是数据处理的中心问题，即对数据进行分类、组织、编码、存储、检索和维护 随着应用需求的扩大以及计算机软件硬件的发展，数据管理技术也不断的在发展，数据管理技术的发展过程经历了以下三个阶段：","text":"【数据管理技术】数据管理是数据处理的中心问题，即对数据进行分类、组织、编码、存储、检索和维护 随着应用需求的扩大以及计算机软件硬件的发展，数据管理技术也不断的在发展，数据管理技术的发展过程经历了以下三个阶段： 人工管理阶段： 20 世纪 50 年代末 —— 60 年代中 文件系统阶段：20 世纪 40 年代中 —— 50 年代中 数据库系统阶段：20 世纪 60 年代末 —— 至今 【发展背景】三个阶段的背景对比如下表： 背景 人工管理阶段 文件系统阶段 数据库系统阶段 应用需求 科学计算 科学计算、数据管理 大规模数据管理 硬件水平 无直接存取存储设备 磁盘、磁鼓 大容量磁盘、磁盘阵列 软件水平 没有操作系统 有文件系统 有数据库管理系统 处理方式 批处理 联机实时处理、批处理 联机实时处理、分布处理、批处理 【特点】特点对比三个阶段的特点对比如下表： 特点 人工管理阶段 文件系统阶段 数据库系统阶段 数据管理者 程序员 文件系统 数据库管理系统 数据面向对象 某一应用程序 某一应用程序 现实世界 数据共享程度 数据不共享，冗余度极大 共享性差，冗余度大 共享性高，冗余度小 数据独立性 不独立，完全依赖于程序 独立性差 高度物理独立性，一定逻辑独立性 数据结构化 无结构 记录内有结构，整体无结构 整体结构化，用数据模型描述 数据控制能力 应用程序自己控制 应用程序自己控制 DBMS 提供 数据库系统的特点解释对于数据库系统阶段的特点解释： 物理独立性：用户的应用程序与存储在磁盘上的数据库中数据是相互独立的，当数据的物理存储改变了，应用程序不用改变 逻辑结构性：用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变 由 DBMS 提供的数据控制功能： 数据安全性保护：保护数据，以防止不合法的使用造成的数据的泄密和破坏 数据完整性检查：将数据控制在有效的范围内，或保证数据之间满足一定的关系 并发控制：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果 数据库恢复：将数据库从错误状态恢复到某一已知的正确状态 数据结构化在文件系统中，每个文件的记录是有结构的，但记录之间没有联系 在关系数据库系统中，不仅数据内部结构化，整体也是结构化的，数据之间具有联系 【对应关系】在人工管理阶段，应用程序与数据间的一一对应关系可用下图表示： 在文件系统阶段，应用程序与数据间的对应关系可用下图表示： 在数据库系统阶段，应用程序与数据间的对应关系可用下图表示：","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"数据库的基本概念","slug":"database/01.数据库的基本概念","date":"2018-09-18T07:56:00.000Z","updated":"2021-08-23T13:36:57.649Z","comments":true,"path":"notes/database/42116fac.html","link":"","permalink":"https://alex-mcavoy.github.io/notes/database/42116fac.html","excerpt":"【数据】数据（Data）是数据库中存储的基本对象，是描述事物的符号记录，描述事物的符号可以是数字，也可以是文字、图形、图象、声音 数据记录是计算机中表示和存储数据的一种格式，是有结构的数据，例如：(张三，男，25，北京)","text":"【数据】数据（Data）是数据库中存储的基本对象，是描述事物的符号记录，描述事物的符号可以是数字，也可以是文字、图形、图象、声音 数据记录是计算机中表示和存储数据的一种格式，是有结构的数据，例如：(张三，男，25，北京) 数据的表现形式无法完全表达其内容，需要经过解释，数据解释是对数据含义的说明，数据的含义被称为数据语义，数据与数据语义是不可分的 例如，93 是一个数据，在不给出解释的情况下，其含义有多种，可以代表某个学生某门课的成绩，也可以代表某人的体重，还可以代表某本书的价格 对于上述的数据记录 (张三，男，25，北京)，在给出语义 姓名、性别、年龄、籍贯 后，可以作出如下解释：张三是一个男性，其今年 25 岁，北京人 【数据库】数据库（Database，DB）是长期存储在计算机内、有组织、可共享的大量数据的集合 其中的数据按一定的数据模型进行组织、描述、存储，具有较小的冗余度、较高的数据独立性和易扩展性，可为各种用户共享，概括来说，数据库数据具有永久存储、有组织、可共享三个基本特点 如下的学生登记表，即可视为一个数据库 学号 姓名 年龄 性别 专业 17001 张三 19 男 通信工程 17002 李四 18 女 网络工程 17003 王五 20 女 计算机科学 17004 赵六 18 男 物联网工程 … … … … … 【数据库管理系统】数据库管理系统（Database Management System，DBMS）是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据，同时可以高效地获取和维护数据，各数据库公司的软件产品就是 DBMS DBMS 主要提供以下功能： 数据定义：提供数据定义语言（DDL）及其翻译处理程序，以便用户定义数据库中的数据对象 数据操纵：提供数据操纵语言（DML）及其编译程序，以便用户思想对数据的基本操作（查询、插入、删除、修改） 数据组织、存储与管理 分类组织、存储和管理各种数据（数据字典、用户数据、数据存取路径等） 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法（顺序查找、索引查找、Hash 查找等）提高存取效率 数据库的运行管理：保证数据的安全性、完整性，提供多用户对数据的并发使用，以及发生故障后的系统恢复 数据库的建立和维护：数据库数据批量装载、数据库转储、介质故障恢复、数据库重组织、性能监视等 【数据库系统】数据库系统（Database System，DBS）是在计算机系统中引入数据库后的系统，用于存储、管理、处理和维护数据，由数据库、数据库管理系统及应用开发工具、应用程序、数据库管理员（DBA）组成 数据库应用系统（DBAS）是在 DBMS 支持下的一类计算机应用系统，由数据库系统和各种用户应用程序结合而成的，每个数据库公司会以自己的数据库管理系统为平台，针对不同的应用来开发相应的应用程序 数据库管理员（DBA）负责全面管理数据库系统，主要职责有： 决定数据库中的信息内容和结构 决定数据库的存储结构和存取策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 数据库的改进和重组 数据字典中存放着数据的信息（索引、完整性约束等），当给出一个索引，可以指出要查询数据的长度、存放起始位置等，以便于找到要寻找的数据","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/categories/notes/"},{"name":"数据库系统","slug":"notes/database","permalink":"https://alex-mcavoy.github.io/categories/notes/database/"}],"tags":[{"name":"学习笔记","slug":"notes","permalink":"https://alex-mcavoy.github.io/tags/notes/"},{"name":"数据库系统","slug":"database","permalink":"https://alex-mcavoy.github.io/tags/database/"}],"author":"Alex_McAvoy"},{"title":"静态链表","slug":"data-structure/01.linear-list/06.静态链表","date":"2018-09-17T09:54:00.000Z","updated":"2021-09-02T13:43:24.831Z","comments":true,"path":"oi-acm/data-structure/linear-list/270275d2.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/linear-list/270275d2.html","excerpt":"【静态链表】静态链表是借助数组实现的链表，与顺序表相比，其在进行增删操作时不需要移动大量元素，同时，其具有不能随机存取，固定容量不变的特点 可见，静态链表适用于不支持指针的编程语言（如：Lisp）和数据元素固定不变的场景（如：文件分配表FAT）","text":"【静态链表】静态链表是借助数组实现的链表，与顺序表相比，其在进行增删操作时不需要移动大量元素，同时，其具有不能随机存取，固定容量不变的特点 可见，静态链表适用于不支持指针的编程语言（如：Lisp）和数据元素固定不变的场景（如：文件分配表FAT） 【结点】静态链表的每个结点与链表相似，同样分为数据域和指针域，其中： 数据域：存储数据 指针域：称为游标，利用数组的下标来充当指针 12345template &lt;typename T&gt; struct LNode &#123; //静态链表结点 T data; //数据域 int next; //指针域&#125;; 【结点地址】如下图所示，静态链表通常会将数组下标为 $0$ 的位置作为头结点，其数据域为空，指针域设置为存放的第一个数据元素的数组下标，对于链表最末端的数据元素，静态链表会将其指针域设置为 $-1$ 同时，对于每个结点来说，其地址为：起始地址+（数据元素大小+游标大小）* 数组下标 以上图为例，假设每个数据元素大小为 $4B$，游标大小为 $4B$，起始地址为 $0x0100$ 则对于数组下标为 $3$ 的结点来说，其地址为： 0x0100+(4+4)*3=0x0118","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线性表","slug":"oi-acm/data-structure/linear-list","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/linear-list/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线性表","slug":"linear-list","permalink":"https://alex-mcavoy.github.io/tags/linear-list/"}],"author":"Alex_McAvoy"},{"title":"循环链表","slug":"data-structure/01.linear-list/05.循环链表","date":"2018-09-17T03:54:00.000Z","updated":"2021-08-31T09:26:22.482Z","comments":true,"path":"oi-acm/data-structure/linear-list/23c1ac0e.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/linear-list/23c1ac0e.html","excerpt":"【概述】循环链表分为循环单链表和循环双链表，两者分别是在单链表和双链表的基础上进行的改进，其最大的特点就是在遍历时，从一个结点出发总能到达链表的任一结点 对于循环单链表来说，其结点类型与单链表类型相同，只是表尾结点 p 的指针 next 指向头结点，此外，基本操作与单链表相似","text":"【概述】循环链表分为循环单链表和循环双链表，两者分别是在单链表和双链表的基础上进行的改进，其最大的特点就是在遍历时，从一个结点出发总能到达链表的任一结点 对于循环单链表来说，其结点类型与单链表类型相同，只是表尾结点 p 的指针 next 指向头结点，此外，基本操作与单链表相似 对于循环双链表来说，其结点类型与双链表类型相同，只是表尾结点 p 的后继指针 next 指向头结点，头结点的前驱指针 prior 指向表尾结点 p，此外，基本操作与双链表相似 为便于实现，两者均采用带头结点的方式，此外，由于对链表的操作很多都在头部或尾部进行，而从头结点找到尾结点时间复杂度为 $O(n)$，为便于操作，可以令头指针 L 指向表尾元素，这样无论对头部还是尾部进行操作时，时间复杂度都为 $O(1)$ 【循环单链表】初始化表在初始化时，令头结点 first 的后继指针 next 指向其自身 12345678910111213template &lt;typename T&gt; CirSingleLinkList&lt;T&gt;::CirSingleLinkList() &#123; //无参构造函数，初始化 first = (CNode&lt;T&gt; *)malloc(sizeof(CNode&lt;T&gt;)); //分配一头结点 first-&gt;next = first; //空表&#125;template &lt;typename T&gt;CirSingleLinkList&lt;T&gt;::CirSingleLinkList(T data[], int len) &#123; //有参构造函数，链表建立 first = (CNode&lt;T&gt; *)malloc(sizeof(CNode&lt;T&gt;)); //分配一头结点 first-&gt;next = first; //空表 this-&gt;headInsert(data, len); //头插法 // this-&gt;tailInsert(data, len); //尾插法&#125; 销毁表由于循环链表的尾结点的后继结点指向头结点，在逐个销毁结点空间时，会导致指向错误 因此，对于循环单链表来说，要一开始对表进行遍历，寻找到尾结点，然后将其与头结点的连接断开 1234567891011121314151617template &lt;typename T&gt; CirSingleLinkList&lt;T&gt;::~CirSingleLinkList() &#123; //析构函数，链表销毁 CNode&lt;T&gt; *p = first; while (p-&gt;next != first) &#123; //遍历循环单链表 p = p-&gt;next; if (p-&gt;next = first) &#123; //寻找尾结点 p-&gt;next = NULL; //断开与头结点的链接 break; &#125; &#125; while (first != NULL) &#123; CNode&lt;T&gt; *p = first; //暂存要被释放的结点 first = first-&gt;next; //头指针指向要被释放的结点的下一个结点 free(p); //释放空间 &#125;&#125; 基本操作求表长在求表长时，只要头指针 first 所指向的结点不为其自身，就继续枚举，统计表长 12345678910template &lt;typename T&gt; int CirSingleLinkList&lt;T&gt;::getLen() &#123; //求表长 int len = 0; CNode&lt;T&gt; *p = first; while (p-&gt;next != first) &#123; //判断下一结点是否为头结点 p = p-&gt;next; len++; &#125; return len;&#125; 判空在判空时，只需判断头指针 first 是否指向他自己 123456template &lt;typename T&gt; bool CirSingleLinkList&lt;T&gt;::empty() &#123; //判空 if (first-&gt;next == first) return true; return false;&#125; 输出在输出时，只要头指针 first 所指向的结点不为其自身，就循环输出 123456789template &lt;typename T&gt; void CirSingleLinkList&lt;T&gt;::print() &#123; //输出 CNode&lt;T&gt; *p = first-&gt;next; //指向第1个结点 while (p != first) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 查找按值查找在按值查找时，只要工作指针 p 不为头结点，就循环查找 1234567template &lt;typename T&gt;CNode&lt;T&gt; *CirSingleLinkList&lt;T&gt;::getNodeByValue(T elem) &#123; //按值查找 CNode&lt;T&gt; *p = first-&gt;next; //从头结点开始 while (p != first &amp;&amp; p-&gt;data != elem) p = p-&gt;next; return p;&#125; 按位查找在按位查找时，从头结点指向的结点开始计数，同时，只要工作指针 p 不为头结点，就循环查找 1234567891011121314151617template &lt;typename T&gt;CNode&lt;T&gt; *CirSingleLinkList&lt;T&gt;::getNodeByLocate(int pos) &#123; //按位查找 if (pos &lt; 0) //越界判断 return NULL; if (pos == 0) //返回头结点 return first; CNode&lt;T&gt; *p; //扫描器，当前扫描到的工作结点 p = first-&gt;next; //扫描器从头结点指向的结点开始 int now_pos = 1; //累加器，记录p指向的第几个结点 while (p != first &amp;&amp; now_pos &lt; pos) &#123; //查找第pos个结点 p = p-&gt;next; now_pos++; &#125; return p;&#125; 删除与单链表不同，循环单链表在任意一个位置上的删除是等价的，无须判断是否为表尾元素 123456789101112template &lt;typename T&gt;bool CirSingleLinkList&lt;T&gt;::deleteNodeByLocate(CNode&lt;T&gt; *p, T &amp;elem) &#123; //删除指定结点p if (p == NULL) return false; CNode&lt;T&gt; *s = p-&gt;next; //指向结点p的下一结点s elem = p-&gt;data; //记录数据域 p-&gt;data = s-&gt;data; //将结点p的下一结点s中的数据存到结点p中 p-&gt;next = s-&gt;next; //断开结点p与其下一结点s的链接关系 free(s); //释放p的下一结点的空间 return true;&#125; 【循环双链表】初始化表在初始化时，令头结点 first 的后继指针 next 指向其自身，同时令头结点的前驱指针 prior 也指向其自身 123456789101112131415template &lt;typename T&gt;CirDoubleLinkList&lt;T&gt;::CirDoubleLinkList() &#123; //无参构造函数，初始化 first = (CDNode&lt;T&gt; *)malloc(sizeof(CDNode&lt;T&gt;)); //分配一头结点 first-&gt;prior = first; //指向自己 first-&gt;next = first; //指向自己&#125;template &lt;typename T&gt;CirDoubleLinkList&lt;T&gt;::CirDoubleLinkList(T data[], int len) &#123; //有参构造函数，链表建立 first = (CDNode&lt;T&gt; *)malloc(sizeof(CDNode&lt;T&gt;)); //分配一头结点 first-&gt;prior = first; //头结点的前驱永远指向NULL first-&gt;next = first; //空表 this-&gt;headInsert(data, len); //头插法 // this-&gt;tailInsert(data, len); //尾插法&#125; 销毁表由于循环链表的尾结点的后继结点指向头结点，在逐个销毁结点空间时，会导致指向错误 因此对于循环双链表来说，要在一开始将尾结点与头结点的连接断开 123456789template &lt;typename T&gt;CirDoubleLinkList&lt;T&gt;::~CirDoubleLinkList() &#123; //析构函数，链表销毁 first-&gt;prior-&gt;next = NULL; //断开尾结点与头结点的连接 while (first != NULL) &#123; CDNode&lt;T&gt; *p = first; //暂存要被释放的结点 first = first-&gt;next; //头指针指向要被释放的结点的下一个结点 free(p); //释放空间 &#125;&#125; 基本操作求表长在求表长时，只要头指针 first 所指向的结点不为其自身，就继续枚举，统计表长 12345678910template &lt;typename T&gt; int CirDoubleLinkList&lt;T&gt;::getLen() &#123; //求表长 int len = 0; CDNode&lt;T&gt; *p = first; //为保证头指针指向不变，建立临时指针变量进行枚举 while (p-&gt;next != first) &#123; //判断下一结点是否为头结点 p = p-&gt;next; len++; &#125; return len;&#125; 判空在判空时，只需判断头指针 first 是否指向他自己 123456template &lt;typename T&gt; bool CirDoubleLinkList&lt;T&gt;::empty() &#123; //判空 if (first-&gt;next == first) //判断头结点下一结点是否为自身 return true; return false;&#125; 输出在输出时，只要头指针 first 所指向的结点不为其自身，就循环输出 123456789template &lt;typename T&gt; void CirDoubleLinkList&lt;T&gt;::print() &#123; //输出 CDNode&lt;T&gt; *p = first-&gt;next; //指向第1个结点 while (p != first) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 查找按值查找在按值查找时，只要工作指针 p 不为头结点，就循环查找 1234567template &lt;typename T&gt;CDNode&lt;T&gt; *CirDoubleLinkList&lt;T&gt;::getNodeByValue(T elem) &#123; //按值查找 CDNode&lt;T&gt; *p = first-&gt;next; //从头结点开始 while (p != first &amp;&amp; p-&gt;data != elem) p = p-&gt;next; return p;&#125; 按位查找在按位查找时，从头结点指向的结点开始计数，同时，只要工作指针 p 不为头结点，就循环查找 1234567891011121314151617template &lt;typename T&gt;CDNode&lt;T&gt; *CirDoubleLinkList&lt;T&gt;::getNodeByLocate(int pos) &#123; //按位查找 if (pos &lt; 0) //越界判断 return NULL; if (pos == 0) //返回头结点 return first; CDNode&lt;T&gt; *p; //扫描器，当前扫描到的工作结点 p = first-&gt;next; //扫描器从头结点指向的结点开始 int now_pos = 1; //累加器，记录p指向的第几个结点 while (p != first &amp;&amp; now_pos &lt; pos) &#123; //查找第pos个结点 p = p-&gt;next; now_pos++; &#125; return p;&#125; 删除对于循环双链表来说，在删除指定结点时，无需考虑结点位置，直接断开连接进行删除即可 12345678910template &lt;typename T&gt;bool CirDoubleLinkList&lt;T&gt;::deleteNodeByLocate(CDNode&lt;T&gt; *p, T &amp;elem) &#123; //删除指定结点p if (p == NULL) return false; elem = p-&gt;data; //存储数据 p-&gt;next-&gt;prior = p-&gt;prior; //p的后继结点的前驱指针指向p的前驱结点 p-&gt;prior-&gt;next = p-&gt;next; //p的前驱结点的后继指针指向p的后继结点 free(p); return true;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线性表","slug":"oi-acm/data-structure/linear-list","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/linear-list/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线性表","slug":"linear-list","permalink":"https://alex-mcavoy.github.io/tags/linear-list/"}],"author":"Alex_McAvoy"},{"title":"双链表","slug":"data-structure/01.linear-list/04.双链表","date":"2018-09-13T03:52:00.000Z","updated":"2021-08-31T09:26:36.248Z","comments":true,"path":"oi-acm/data-structure/linear-list/c1a5ceb3.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/linear-list/c1a5ceb3.html","excerpt":"【双链表】双链表是在单链表的基础上在每个结点中多加入了前驱指针 prior，其指向当前结点的前驱结点 123456template &lt;typename T&gt; struct DNode &#123; //双链表结点 T data; //数据域 DNode&lt;T&gt; *prior; //前驱指针 DNode&lt;T&gt; *next; //后继指针&#125;;","text":"【双链表】双链表是在单链表的基础上在每个结点中多加入了前驱指针 prior，其指向当前结点的前驱结点 123456template &lt;typename T&gt; struct DNode &#123; //双链表结点 T data; //数据域 DNode&lt;T&gt; *prior; //前驱指针 DNode&lt;T&gt; *next; //后继指针&#125;; 在单链表中，在进行插入与删除时，若仅知道待操作结点，是无法取得其前驱结点的，而由于双链表引入了前驱指针，这就使得双链表在插入与删除时，当仅知道待操作结点时，能够快速得知其前驱结点 此外，对于最基本的 CRUD 操作，除非已经给出待操作结点（此时双链表插入与删除为 $O(1)$ ），否则单链表与双链表都需要从头到尾按序遍历，时间复杂度都是 $O(n)$ 双链表的结构优势在于可以在 $O(1)$ 的时间内找到前驱结点，若算法需要对待操作结点的前驱结点大量处理，则双链表比单链表更有优势，但若从工程角度考量，双链表的维护性和可读性都更低 为提高维护性与可读性，双链表一般采取带头结点的实现，其实现类如下： 1234567891011121314151617181920template &lt;typename T&gt; class DoubleLinkList &#123; public: DoubleLinkList(); //无参构造函数，初始化表 DoubleLinkList(T data[], int len); //有参构造函数，链表建立 ~DoubleLinkList(); //析构函数，链表销毁 int getLen(); //求表长 bool empty(); //判空 void print(); //输出 DNode&lt;T&gt; *getNodeByValue(T elem); //按值查找 DNode&lt;T&gt; *getNodeByLocate(int pos); //按位查找 bool insertNextNode(DNode&lt;T&gt; *p, T elem); //后插，用于按位插入 bool insertPreNode(DNode&lt;T&gt; *p, T elem); //前插，用于按位插入 bool insertNode(int pos, T elem); //按位插入 bool deleteNodeByLocate(DNode&lt;T&gt; *p, T &amp;elem); //删除指定结点p void headInsert(T data[], int len); //头插法 void tailInsert(T data[], int len); //尾插法 private: DNode&lt;T&gt; *first; //头指针&#125;; 需要说明的是，对于单链表和双链表来说，除了两者的插入与删除操作不同外，其余操作均相同 【初始化表与销毁表】初始化与双链表的建立对于双链表来说，其与单链表相似，在初始化完毕后，即可对于给定的数据序列 data[] 来建立双链表，建立双链表的两种方式与单链表的类似，同样一种是头插法，另一种是尾插法 在进行初始化时，需要为头指针 first 建立一个头结点，并使头结点的前驱指针 prior 永远指向 NULL，代表无前驱；令头结点的后继指针 next 暂时指向 NULL，代表目前是空表 123456789101112131415template &lt;typename T&gt;DoubleLinkList&lt;T&gt;::DoubleLinkList() &#123; //无参构造函数，初始化 first = (DNode&lt;T&gt; *)malloc(sizeof(DNode&lt;T&gt;)); //分配一头结点 first-&gt;prior = NULL; //头结点的前驱永远指向NULL first-&gt;next = NULL; //空表&#125;template &lt;typename T&gt;DoubleLinkList&lt;T&gt;::DoubleLinkList(T data[], int len) &#123; //有参构造函数，链表建立 first = (DNode&lt;T&gt; *)malloc(sizeof(DNode&lt;T&gt;)); //分配一头结点 first-&gt;prior = NULL; //头结点的前驱永远指向NULL first-&gt;next = NULL; //空表 this-&gt;headInsert(data, len); //头插法 // this-&gt;tailInsert(data, len); //尾插法&#125; 双链表的销毁12345678template &lt;typename T&gt;DoubleLinkList&lt;T&gt;::~DoubleLinkList() &#123; //析构函数，链表销毁 while (first != NULL) &#123; DNode&lt;T&gt; *p = first; //暂存要被释放的结点 first = first-&gt;next; //头指针指向要被释放的结点的下一个结点 free(p); //释放空间 &#125;&#125; 【基本操作】求表长12345678910template &lt;typename T&gt; int DoubleLinkList&lt;T&gt;::getLen() &#123; //求表长 int len = 0; DNode&lt;T&gt; *p = first; //为保证头指针指向不变，建立临时指针变量进行枚举 while (p-&gt;next != NULL) &#123; //判断下一结点是否为 NULL p = p-&gt;next; len++; &#125; return len;&#125; 判空123456template &lt;typename T&gt; bool DoubleLinkList&lt;T&gt;::empty() &#123; //判空 if (first-&gt;next == NULL) return true; return false;&#125; 输出123456789template &lt;typename T&gt; void DoubleLinkList&lt;T&gt;::print() &#123; //输出 DNode&lt;T&gt; *p = first-&gt;next; //指向第1个结点 while (p != NULL) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 【查找】按值查找1234567template &lt;typename T&gt;DNode&lt;T&gt; *DoubleLinkList&lt;T&gt;::getNodeByValue(T elem) &#123; //按值查找 DNode&lt;T&gt; *p = first-&gt;next; //从头结点开始 while (p != NULL &amp;&amp; p-&gt;data != elem) p = p-&gt;next; return p;&#125; 按位查找1234567891011121314151617template &lt;typename T&gt;DNode&lt;T&gt; *DoubleLinkList&lt;T&gt;::getNodeByLocate(int pos) &#123; //按位查找 if (pos &lt; 0) //越界判断 return NULL; if (pos == 0) //返回头结点 return first; DNode&lt;T&gt; *p; //扫描器，当前扫描到的工作结点 p = first; //扫描器从头结点开始，头结点是第0个结点 int now_pos = 0; //累加器，记录p指向的第几个结点 while (p != NULL &amp;&amp; now_pos &lt; pos) &#123; //查找第pos个结点 p = p-&gt;next; now_pos++; &#125; return p;&#125; 【插入】后插后插，是指在给定 p 结点后插入元素 elem，一般用于按位插入，不单独使用 由于对指针的操作顺序有很多，但由于双向链表实质上可看作两条反向的单链表，所以插入操作的核心是：先处理每个方向的远端指针，再处理近端指针 原则上，插入一个结点需要连接 4 个指针，但考虑插入时的特殊情况，即在空表或表尾插入一个结点时，新结点的右指针指向为空，此时只需连接 3 个指针 123456789101112131415161718192021template &lt;typename T&gt;bool DoubleLinkList&lt;T&gt;::insertNextNode(DNode&lt;T&gt; *p, T elem) &#123; //后插，用于按位插入 if (p == NULL) return false; DNode&lt;T&gt; *s = (DNode&lt;T&gt; *)malloc(sizeof(DNode&lt;T&gt;)); //申请新结点 //对新结点s操作 s-&gt;data = elem; //存数据 s-&gt;next = p-&gt;next; //新结点s的后继指针指向p的后继 s-&gt;prior = p; //新结点s的前驱指针指向p //对工作结点p操作 p-&gt;next = s; //工作结点p的后继指针指向新结点 //对新结点s的后继结点操作 if (s-&gt;next != NULL) //如果新结点s的后继结点存在 s-&gt;next-&gt;prior = s; //新节点s的后继结点的前驱指针指向新结点s return true;&#125; 前插前插与后插一样，一般用于按位插入，不单独使用 由于对指针的操作顺序有很多，但由于双向链表实质上可看作两条反向的单链表，所以插入操作的核心是：先处理每个方向的远端指针，再处理近端指针 原则上，插入一个结点需要连接 4 个指针，但考虑插入时的特殊情况，即在空表或表尾插入一个结点时，新结点的右指针指向为空，此时只需连接 3 个指针 1234567891011121314151617181920template &lt;typename T&gt;bool DoubleLinkList&lt;T&gt;::insertPreNode(DNode&lt;T&gt; *p, T elem) &#123; //前插，用于按位插入 if (p == NULL) return false; DNode&lt;T&gt; *s = (DNode&lt;T&gt; *)malloc(sizeof(DNode&lt;T&gt;)); //申请新结点 //对新结点s操作 s-&gt;data = elem; //存数据 s-&gt;prior = p-&gt;prior; //新结点s的前驱指向p的前驱 s-&gt;next = p; //新结点s的后继指针指向p //对新结点s的前驱结点操作 s-&gt;prior-&gt;next = s; //新节点s的前驱结点的后继指针指向新结点s //对工作结点p操作 p-&gt;prior = s; //工作结点p的后继指针指向新结点 return true;&#125; 按位插入1234567891011121314151617template &lt;typename T&gt; bool DoubleLinkList&lt;T&gt;::insertNode(int pos, T elem) &#123; //按位插入 if (pos &lt; 1) //越界判断 return false; //后插 DNode&lt;T&gt; *p = getNodeByLocate(pos - 1); //找到第pos-1个位置 if (p == NULL) //插入位置异常 return false; return insertNextNode(p, elem); //在pos-1个位置后插入元素 //前插 // DNode&lt;T&gt; *p = getNodeByLocate(pos); //找到第pos个位置 // if (p == NULL) //插入位置异常 // return false; // return insertPreNode(p, elem); //在pos个位置前插入元素&#125; 【删除】1234567891011121314template &lt;typename T&gt;bool DoubleLinkList&lt;T&gt;::deleteNodeByLocate(DNode&lt;T&gt; *p, T &amp;elem) &#123; //删除指定结点p if (p == NULL) return false; elem = p-&gt;data; //存储数据 if (p-&gt;next == NULL) //p为表尾元素 p-&gt;prior-&gt;next = NULL; //p的前驱结点的后继指针指向NULL else &#123; //p为非表尾元素 p-&gt;next-&gt;prior = p-&gt;prior; //p的后继结点的前驱指针指向p的前驱结点 p-&gt;prior-&gt;next = p-&gt;next; //p的前驱结点的后继指针指向p的后继结点 &#125; free(p); return true;&#125; 【头插法与尾插法】头插法对于双链表的头插法，每次插入都是对头结点进行后插操作 12345template &lt;typename T&gt; void DoubleLinkList&lt;T&gt;::headInsert(T data[], int len) &#123; //头插法 for (int i = 0; i &lt; len; i++) //每一次对头结点进行后插操作 insertNextNode(first, data[i]);&#125; 尾插法对于双链表的尾插法，不断地申请新结点，填充数据域，并通过尾指针 tail 来建立后继关系与前驱关系 123456789101112template &lt;typename T&gt; void DoubleLinkList&lt;T&gt;::tailInsert(T data[], int len) &#123; //尾插法 DNode&lt;T&gt; *tail = first; //尾指针 for (int i = 0; i &lt; len; i++) &#123; DNode&lt;T&gt; *p = (DNode&lt;T&gt; *)malloc(sizeof(DNode&lt;T&gt;)); //申请新结点 p-&gt;data = data[i]; //填充数据域 tail-&gt;next = p; //建立后继关系 p-&gt;prior = tail; //建立前驱关系 tail = p; //更改尾指针为新结点p地址 &#125; tail-&gt;next = NULL; //建立完毕，尾指针指针域置空&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线性表","slug":"oi-acm/data-structure/linear-list","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/linear-list/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线性表","slug":"linear-list","permalink":"https://alex-mcavoy.github.io/tags/linear-list/"}],"author":"Alex_McAvoy"},{"title":"单链表","slug":"data-structure/01.linear-list/03.单链表","date":"2018-09-10T03:52:00.000Z","updated":"2021-12-14T14:30:43.389Z","comments":true,"path":"oi-acm/data-structure/linear-list/71c610d3.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/linear-list/71c610d3.html","excerpt":"【单链表】概述线性表的链式存储方式称为链表，其通过一组任意存储单元来存储线性表中的数据元素，最基本一种链接方式构成的链表称为单链表","text":"【单链表】概述线性表的链式存储方式称为链表，其通过一组任意存储单元来存储线性表中的数据元素，最基本一种链接方式构成的链表称为单链表 为了建立数据元素间的线性关系，对于每个链表结点，除了存放数据元素（数据域）外，还要存储指向下一结点的指针（指针域） 这就使得不再要求大片连续的空间来存储数据，可以利用指针来将不连续的空间建立链接关系，进一步可以对空间进行扩充 此外，由于指针的特性，在单链表中查找某个元素时，要从表头开始遍历，这被称为非随机存取 头指针与头结点为了标识单链表，引入头指针的概念，其始终指向单链表的第一个结点 同时，在单链表第一个结点前附加一个结点，其数据域一般存储表长等信息，指针域指向单链表第一个结点，这个附加的结点被称为头结点 头结点引用的目的是为了方便编程，将空表与非空表的操作统一，无须特殊处理： 头结点指针域指向单链表第一个结点，使得第一个结点的操作与其他结点操作一致 无论单链表是否为空，头指针都指向头结点的指针 在带有头结点时，头指针会指向头结点（第 $0$ 个结点），头结点指向链表第 $1$ 个结点；在不带头结点时，头指针直接指向单链表的第 $1$ 个结点 单链表的实现类如下： 1234567891011121314151617181920212223242526template &lt;typename T&gt; struct LNode &#123; //单链表结点 T data; //数据域 LNode&lt;T&gt; *next; //指针域&#125;;template &lt;typename T&gt; class LinkList &#123; public: LinkList(); //无参构造函数，初始化表 LinkList(T data[], int len); //有参构造函数，链表建立 ~LinkList(); //析构函数，链表销毁 int getLen(); //求表长 bool empty(); //判空 void print(); //输出 LNode&lt;T&gt; *getNodeByValue(T elem); //按值查找 LNode&lt;T&gt; *getNodeByLocate(int pos); //按位查找 bool insertNextNode(LNode&lt;T&gt; *p, T elem); //后插，用于按位插入 bool insertPreNode(LNode&lt;T&gt; *p, T elem); //前插，用于按位插入 bool insertNode(int pos, T elem); //按位插入 bool deleteNodeByLocate(LNode&lt;T&gt; *p, T &amp;elem); //删除指定结点p bool deleteNodeByElem(T elem); //删除所有值为elem的结点 void headInsert(T data[], int len); //头插法 void tailInsert(T data[], int len); //尾插法 private: LNode&lt;T&gt; *first; //头指针&#125;; 【初始化表与销毁表】初始化与单链表的建立对于单链表 L 来说，在初始化完毕后，即可对于给定的数据序列 data[] 来建立单链表，建立单链表有两种方式，一种是头插法，另一种是尾插法 对于带头结点的单链表 L，在进行初始化时，需要为头指针 first 建立一个头结点，并使头结点的指向为 NULL 12345678910111213template &lt;typename T&gt; LinkList&lt;T&gt;::LinkList() &#123; //无参构造函数，初始化 first = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); //分配一头结点 first-&gt;next = NULL; //空表&#125;template &lt;typename T&gt;LinkList&lt;T&gt;::LinkList(T data[], int len) &#123; //有参构造函数，链表建立 first = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); //分配一头结点 first-&gt;next = NULL; //空表 this-&gt;headInsert(data, len); //头插法 // this-&gt;tailInsert(data, len); //尾插法&#125; 对于不带头结点的单链表 L，在进行初始化时，令头指针 first 指向为 NULL 即可 1234567891011template &lt;typename T&gt; LinkList&lt;T&gt;::LinkList() &#123; //无参构造函数，初始化 first = NULL; //空表&#125;template &lt;typename T&gt;LinkList&lt;T&gt;::LinkList(T data[], int len) &#123; //有参构造函数，链表建立 first = NULL; //空表 this-&gt;headInsert(data, len); //头插法 // this-&gt;tailInsert(data, len); //尾插法&#125; 单链表的销毁对于单链表 L 来说，若要将其销毁，需要从头指针 first 指向的结点开始，逐个将链表中结点的存储空间释放 12345678template &lt;typename T&gt; LinkList&lt;T&gt;::~LinkList() &#123; //析构函数，链表销毁 while (first != NULL) &#123; LNode&lt;T&gt; *p = first; //暂存要被释放的结点 first = first-&gt;next; //头指针指向要被释放的结点的下一个结点 free(p); //释放空间 &#125;&#125; 【基本操作】求表长对于带头结点的单链表 L，若想求其长度，只需从头结点开始枚举，依次判断下一结点是否为 NULL，同时，每枚举一个结点令长度加一，直到当前结点所指向的下一个结点为 NULL 为止 12345678910template &lt;typename T&gt; int LinkList&lt;T&gt;::getLen() &#123; //求表长 int len = 0; LNode&lt;T&gt; *p = first; //为保证头指针指向不变，建立临时指针变量进行枚举 while (p-&gt;next != NULL) &#123; //判断下一结点是否为 NULL p = p-&gt;next; len++; &#125; return len;&#125; 对于不带头结点的单链表 L，若想求其长度，只需从头指针指向的第一个结点开始枚举，依次判断当前结点是否为 NULL，同时，每枚举一个结点令长度加一，直到当前结点所指向的下一个结点为 NULL 为止 12345678910template &lt;typename T&gt; int LinkList&lt;T&gt;::getLen() &#123; //求表长 int len = 0; LNode&lt;T&gt; *p = first; //为保证头指针指向不变，建立临时指针变量进行枚举 while (p != NULL) &#123; //判断当前结点是否为 NULL p = p-&gt;next; len++; &#125; return len;&#125; 判空对于带头结点的单链表 L，若想判断其是否为空，只需判断 L 的头指针指向的头结点是否指向 NULL 即可 123456template &lt;typename T&gt; bool LinkList&lt;T&gt;::empty() &#123; //判空 if (first-&gt;next == NULL) return true; return false;&#125; 对于不带头结点的单链表 L，若想判断其是否为空，只需判断 L 的头指针的指向是否为 NULL 即可 123456template &lt;typename T&gt; bool LinkList&lt;T&gt;::empty() &#123; //判空 if (first == NULL) return true; return false;&#125; 输出对于带头结点的单链表 L，若将其输出，只需从头结点指向的第一个节点开始遍历，只要结点不为空，就输出结点的数据域 123456789template &lt;typename T&gt; void LinkList&lt;T&gt;::print() &#123; //输出 LNode&lt;T&gt; *p = first-&gt;next; //指向第1个结点 while (p != NULL) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 对于不带头结点的单链表 L，若将其输出，只需从头指针指向的第一个节点开始遍历，只要结点不为空，就输出结点的数据域 123456789template &lt;typename T&gt; void LinkList&lt;T&gt;::print() &#123; //输出 LNode&lt;T&gt; *p = first; //指向第1个结点 while (p != NULL) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 【查找】按值查找按值查找，即获取 L 中与给定参数值 elem 相同的结点，若查找失败，则返回 NULL，若查找成功，则返回该结点，因此，在调用该方法时，需要进行判断是否返回值为 NULL 对于带头结点的单链表 L，只需从头结点开始遍历，判断当前数据域是否为 elem 1234567template &lt;typename T&gt;LNode&lt;T&gt; *LinkList&lt;T&gt;::getNodeByValue(T elem) &#123; //按值查找 LNode&lt;T&gt; *p = first-&gt;next; //从头结点开始 while (p != NULL &amp;&amp; p-&gt;data != elem) p = p-&gt;next; return p;&#125; 对于不带头结点的单链表 L，只需从头指针开始遍历，判断当前数据域是否为 elem 1234567template &lt;typename T&gt;LNode&lt;T&gt; *LinkList&lt;T&gt;::getNodeByValue(T elem) &#123; //按值查找 LNode&lt;T&gt; *p = first; //从头指针开始 while (p != NULL &amp;&amp; p-&gt;data != elem) p = p-&gt;next; return p;&#125; 按位查找按位置查找，即获取 L 中第 pos 个结点，在查找前需要进行越界判断，若查找位置异常，则返回 NULL，若查找位置正常，则返回该结点，因此，在调用该方法时，需要进行判断是否返回值为 NULL 对于带头结点的单链表 L，之后建立一个从 $0$ 开始的累加器，记录当前指针指向的是第几个结点，当遍历到第 pos 个结点时，返回指针所指向的当前结点即可 1234567891011121314151617template &lt;typename T&gt;LNode&lt;T&gt; *LinkList&lt;T&gt;::getNodeByLocate(int pos) &#123; //按位查找 if (pos &lt; 0) //越界判断 return NULL; if (pos == 0) //返回头结点 return first; LNode&lt;T&gt; *p; //扫描器，当前扫描到的工作结点 p = first; //扫描器从头结点开始，头结点是第0个结点 int now_pos = 0; //累加器，记录p指向的第几个结点 while (p != NULL &amp;&amp; now_pos &lt; pos) &#123; //查找第pos个结点 p = p-&gt;next; now_pos++; &#125; return p;&#125; 对于不带头结点的单链表 L，之后建立一个从 $1$ 开始的累加器，记录当前指针指向的是第几个结点，当遍历到第 pos 个结点时，返回指针所指向的当前结点即可 123456789101112131415template &lt;typename T&gt;LNode&lt;T&gt; *LinkList&lt;T&gt;::getNodeByLocate(int pos) &#123; //按位查找 if (pos &lt;= 0) //越界判断 return NULL; LNode&lt;T&gt; *p; //扫描器，当前扫描到的工作结点 p = first; //扫描器从头指针开始，头指针指向的是第0个结点 int now_pos = 1; //累加器，记录p指向的第几个结点 while (p != NULL &amp;&amp; now_pos &lt; pos) &#123; //查找第pos个结点 p = p-&gt;next; now_pos++; &#125; return p;&#125; 【插入】后插后插，是指在给定 p 结点后插入元素 elem，一般用于按位插入，不单独使用 12345678910111213template &lt;typename T&gt;bool LinkList&lt;T&gt;::insertNextNode(LNode&lt;T&gt; *p, T elem) &#123; //后插，用于按位插入 if (p == NULL) return false; LNode&lt;T&gt; *s = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); //申请新结点 s-&gt;data = elem; s-&gt;next = p-&gt;next; //将s链接至p后 p-&gt;next = s; return true;&#125; 前插前插，是指在给定 p 结点前插入元素 elem，由于指针机制是后向机制，若采用循环遍历的方式找到前驱结点进行前插，时间复杂度为 $O(n)$，而采用以下交换数据的方式，时间复杂度仅为 $O(1)$ 前插与后插一样，一般用于按位插入，不单独使用 1234567891011121314151617template &lt;typename T&gt;bool LinkList&lt;T&gt;::insertPreNode(LNode&lt;T&gt; *p, T elem) &#123; //前插，用于按位插入 if (p == NULL) return false; LNode&lt;T&gt; *s = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); //申请新结点 //将新结点s链接到工作结点p后 s-&gt;next = p-&gt;next; p-&gt;next = s; //交换数据 s-&gt;data = p-&gt;data; //将p结点的数据存入s结点 p-&gt;data = elem; //将元素elem存入p结点 return true;&#125; 按位插入按位置插入，即在 L 中第 pos 个结点插入元素 elem，在插入前需要进行越界判断，在插入时，可以找到第 pos-1 个结点进行后插，也可以找到第 i 个结点进行前插，但无论使用后插还是前插，都需要注意判断插入位置是否异常 对于带头结点的单链表 L，由于头结点的存在，使得操作统一，因此直接进行插入即可 1234567891011121314151617template &lt;typename T&gt; bool LinkList&lt;T&gt;::insertNode(int pos, T elem) &#123; //按位插入 if (pos &lt; 1) //越界判断 return false; //后插 LNode&lt;T&gt; *p = getNodeByLocate(pos - 1); //找到第pos-1个位置 if (p == NULL) //插入位置异常 return false; return insertNextNode(p, elem); //在pos-1个位置后插入元素 //前插 // LNode&lt;T&gt; *p = getNodeByLocate(pos); //找到第pos个位置 // if (p == NULL) //插入位置异常 // return false; // return insertPreNode(p, elem); //在pos个位置前插入元素&#125; 对于不带头结点的单链表 L，在插入第一个位置时，需要改变头指针 ，令其指向新的结点，其余位置则与带头结点的单链表操作相同 1234567891011121314151617181920212223242526template &lt;typename T&gt;bool LinkList&lt;T&gt;::insertNode(int pos, T elem) &#123; //按位插入 if (pos &lt; 1) //越界判断 return false; //第1个结点 if (i == 1) &#123; LNode&lt;T&gt; *s = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); s-&gt;data = elem; s-&gt;next = first; //新结点指向头指针所指向的第一个结点 first = s; //头指针指向新结点 return true; &#125; //后插 LNode&lt;T&gt; *p = getNodeByLocate(pos - 1); //找到第pos-1个位置 if (p == NULL) //插入位置异常 return false; return insertNextNode(p, elem); //在pos-1个位置后插入元素 //前插 // LNode&lt;T&gt; *p = getNodeByLocate(pos); //找到第pos个位置 // if (p == NULL) //插入位置异常 // return false; // return insertPreNode(p, elem); //在pos个位置前插入元素&#125; 【删除】删除指定结点在按值查找、按位查找寻找到某一指定结点 p 后，要删除该结点并返回该结点的数据域 elem，方法如下： 若删除的是非最后结点，只需将要删除的结点 p 之后的结点 s 的数据存入 p，然后再断开 p 与 s 的链接，令 p 指向 s 之后的结点，再释放空间即可 若删除的是最后结点，由于其没有后继结点，无法采用上述方法，只能从头到尾开始遍历，在单链表中匹配与 p 地址相同的结点，然后将该结点前的结点指向 NULL，再释放空间 可见，若删除的是非最后结点，时间复杂度为 $O(1)$；若删除的是最后结点，时间复杂度为 $O(n)$ 无论是带头结点的单链表，还是不带头结点的单链表，在该删除指定结点方法中，操作是一致的，唯一的区别仅是：当删除的是最后结点时，需要从头到尾开始遍历，带头结点的单链表，从头结点的下一结点开始，不带头结点的单链表，从头指针指向的结点开始 对于带头结点的单链表 L，在删除指定结点时，若删除的是非最后结点，直接进行删除即可，若删除的是最后一个结点，则从头结点的下一结点开始遍历 123456789101112131415161718192021222324252627282930template &lt;typename T&gt;bool LinkList&lt;T&gt;::deleteNodeByLocate(LNode&lt;T&gt; *p, T &amp;elem) &#123; //删除指定结点p if (p == NULL) return false; //删除非最后一个结点 if (p-&gt;next != NULL) &#123; LNode&lt;T&gt; *s = p-&gt;next; //指向结点p的下一结点s elem = p-&gt;data; //记录数据域，通过引用的方式返回 p-&gt;data = s-&gt;data; //将结点p的下一结点s中的数据存到结点p中 p-&gt;next = s-&gt;next; //断开结点p与其下一结点s的链接关系 free(s); //释放p的下一结点的空间 return true; &#125; //删除最后一个结点 if (p-&gt;next == NULL) &#123; LNode&lt;T&gt; *s = first-&gt;next; //指向头结点的临时指针 while (s-&gt;next != NULL) &#123; //从头结点所指向的结点开始遍历 if (s-&gt;next == p) &#123; //地址相同，即找到链表的最后一个结点 elem = p-&gt;data; //记录数据域，通过引用的方式返回 s-&gt;next = NULL; //断开链接关系 free(p); //释放p的空间 return true; &#125; s = s-&gt;next; &#125; &#125;&#125; 对于不带头结点的单链表 L，在删除指定结点时，若删除的是非最后结点，直接进行删除即可，若删除的是最后一个结点，则从头指针所指向的结点开始遍历 123456789101112131415161718192021222324252627282930template &lt;typename T&gt;bool LinkList&lt;T&gt;::deleteNodeByLocate(LNode&lt;T&gt; *p, T &amp;elem) &#123; //删除指定结点p if (p == NULL) return false; //删除非最后一个结点 if (p-&gt;next != NULL) &#123; LNode&lt;T&gt; *s = p-&gt;next; //指向结点p的下一结点s elem = p-&gt;data; //记录数据域，通过引用的方式返回 p-&gt;data = s-&gt;data; //将结点p的下一结点s中的数据存到结点p中 p-&gt;next = s-&gt;next; //断开结点p与其下一结点s的链接关系 free(s); //释放p的下一结点的空间 return true; &#125; //删除最后一个结点 if (p-&gt;next == NULL) &#123; LNode&lt;T&gt; *s = first; //指向头指针所指向的结点的临时指针 while (s-&gt;next != NULL) &#123; //从头指针所指向的结点开始遍历 if (s-&gt;next == p) &#123; //地址相同，即找到链表的最后一个结点 elem = p-&gt;data; //记录数据域，通过引用的方式返回 s-&gt;next = NULL; //断开链接关系 free(p); //释放p的空间 return true; &#125; s = s-&gt;next; &#125; &#125;&#125; 删除给定值的所有结点对于给定值 elem，要在单链表中删除所有数据域为 elem 的结点，删除方法如下： 设置一个指向工作结点 p 的前驱结点的指针 pre 用工作结点 p 从头到尾扫描单链表：若 p 所指结点值为 elem，则将其删除，并让 p 指向下一结点，否则令 pre 与 p 后移一个结点 对于带头结点的单链表 L，前驱指针一开始设为头结点 first，工作指针设为头指针指向的下一结点 first-&gt;next，在删除给定值的所有结点时，从头结点的下一结点开始遍历 123456789101112131415161718template &lt;typename T&gt;bool LinkList&lt;T&gt;::deleteNodeByElem(T elem) &#123; //删除所有值为elem的结点 LNode&lt;T&gt; *pre = first; //前驱指针 LNode&lt;T&gt; *p = first-&gt;next; //从头结点的下一结点开始 if (p == NULL) return false; while (p != NULL) &#123; if (p-&gt;data == elem) &#123; //值相同 LNode&lt;T&gt; *s = p; //暂存工作指针p所指向的结点 p = p-&gt;next; //工作指针p指向下一结点 pre-&gt;next = p; // p的前驱结点指向p free(s); //释放要删除的结点 &#125; else &#123; //值不同 pre = p; //前驱指针pre后移 p = p-&gt;next; //工作指针p后移 &#125; &#125;&#125; 对于不带头结点的单链表 L，在删除给定值的所有结点时，前驱指针一开始设为 NULL，工作指针设为头指针指向的结点 first，在删除给定值的所有结点时，从头指针指向的结点开始遍历 123456789101112131415161718template &lt;typename T&gt;bool LinkList&lt;T&gt;::deleteNodeByElem(T elem) &#123; //删除所有值为elem的结点 LNode&lt;T&gt; *pre = NULL; //前驱指针 LNode&lt;T&gt; *p = first; //从头指针指向的结点开始 if (p == NULL) return false; while (p != NULL) &#123; if (p-&gt;data == elem) &#123; //值相同 LNode&lt;T&gt; *s = p; //暂存工作指针p所指向的结点 p = p-&gt;next; //工作指针p指向下一结点 pre-&gt;next = p; //p的前驱结点指向p free(s); //释放要删除的结点 &#125; else &#123; //值不同 pre = p; //前驱指针pre后移 p = p-&gt;next; //工作指针p后移 &#125; &#125;&#125; 【头插法与尾插法】头插法头插法，是每次将新申请的结点插入到链表最开始的位置，举例来说，对于一个序列 $\\{1,2,3,4,5\\}$，在使用头插法建立单链表后，单链表从头到尾每个结点的数据域依次为 $\\{5,4,3,2,1\\}$，因此，其常用于链表的建立、链表的逆置 可以发现，对于带头结点的单链表来说，每次插入都是对头结点进行后插操作 12345template &lt;typename T&gt; void LinkList&lt;T&gt;::headInsert(T data[], int len) &#123; //头插法 for (int i = 0; i &lt; len; i++) //每一次对头结点进行后插操作 insertNextNode(first, data[i]);&#125; 对于不带头结点的单链表来说，其实质是建立后继关系，通过不断交换头指针与新结点的地址来实现头插 123456789template &lt;typename T&gt; void LinkList&lt;T&gt;::headInsert(T data[], int len) &#123; //头插法 for (int i = 0; i &lt; len; i++) &#123; LNode&lt;T&gt; *p = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); p-&gt;data = data[i]; //填充数据域 p-&gt;next = first; //将新结点指向头指针所指向的地址 first = p; //更改头指针地址为新结点地址 &#125;&#125; 尾插法尾插法，是每次将新申请的结点插到链表的最后面，由于指针机制是后向机制，每次插入都需要从头指针开始遍历到表尾，为减少时间复杂度，尾插法引入了尾指针 tail，其指向单链表的表尾结点，使得每次插入都能让新结点处于最后的位置 对于带头结点的单链表来说，只需要利用尾指针 tail，不断地申请新结点，填充数据域后建立后继关系即可 123456789101112template &lt;typename T&gt; void LinkList&lt;T&gt;::tailInsert(T data[], int len) &#123; //尾插法 LNode&lt;T&gt; *tail = first; //尾指针 for (int i = 0; i &lt; len; i++) &#123; LNode&lt;T&gt; *p = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); //申请新结点 p-&gt;data = data[i]; //填充数据域 tail-&gt;next = p; //建立后继关系 tail = p; //更改尾指针为新结点p地址 &#125; tail-&gt;next = NULL; //建立完毕，尾指针指针域置空&#125; 对于不带头结点的单链表来说，由于初始头指针指向为空，因此要先建立一个初始结点，将头指针指向该结点，再对剩下的 n-1 个元素建立结点，填充数据域建立后继关系 123456789101112131415161718192021template &lt;typename T&gt; void LinkList&lt;T&gt;::tailInsert(T data[], int len) &#123; //尾插法 LNode&lt;T&gt; *tail = first; //尾指针 //初始结点 LNode&lt;T&gt; *p = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); p-&gt;data = data[0]; //初始结点数据域 p-&gt;next = first; //初始结点指向头指针 first = p; //更改头指针地址为初始结点地址 tail = first; //更改尾指针地址为头指针地址，即初始结点地址 //初始结点后的len-1个结点 for (int i = 1; i &lt; len; i++) &#123; LNode&lt;T&gt; *p = (LNode&lt;T&gt; *)malloc(sizeof(LNode&lt;T&gt;)); //申请新结点 p-&gt;data = data[i]; //填充数据域 tail-&gt;next = p; //建立后继关系 tail = p; //更改尾指针为新结点p地址 &#125; tail-&gt;next = NULL; //建立完毕，尾指针指针域置空&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线性表","slug":"oi-acm/data-structure/linear-list","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/linear-list/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线性表","slug":"linear-list","permalink":"https://alex-mcavoy.github.io/tags/linear-list/"}],"author":"Alex_McAvoy"},{"title":"顺序表","slug":"data-structure/01.linear-list/02.顺序表","date":"2018-09-06T03:44:00.000Z","updated":"2021-08-31T09:24:13.147Z","comments":true,"path":"oi-acm/data-structure/linear-list/f35acf61.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/linear-list/f35acf61.html","excerpt":"【顺序表】线性表的顺序存储又称顺序表，其使用一组地址空间连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两元素在物理存储空间上也相邻 顺序表具有以下特点：","text":"【顺序表】线性表的顺序存储又称顺序表，其使用一组地址空间连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两元素在物理存储空间上也相邻 顺序表具有以下特点： 1.支持随机访问：通过 data[i-1] 即可访问第 i 个元素，在 $O(1)$ 的时间复杂度内即可完成 2.存储密度高：只存储数据元素 3.扩展容量不方便：静态分配方式无法扩展，动态分配方式扩展要消耗大量的时间 4.插入、删除数据元素不方便 实现类如下： 1234567891011121314151617181920#define N 50 + 5 //最大表长template &lt;typename T&gt; class SeqList &#123; public: SeqList(); //无参构造函数，初始化表 SeqList(T m_data[], int m_len); //有参构造函数，对表赋初值 ~SeqList(); //析构函数，销毁表 void increaseList(int increaseLen); //扩充线性表长度 int getLen(); //求表长 bool empty(); //判空 bool full(); //判满 bool print(); //输出 bool insertElement(int pos, T elem); //第pos个位置插入元素elem bool deleteElement(int pos, T &amp;elem); //删除第pos个元素，通过引用返回元素值 int getNodeByValue(T elem); //查找与elem相同的第一个元素位置，不存在返回-1 bool getNodeByPosition(int pos, T &amp;elem); //查找第pos个元素，通过引用返回元素值 private: T *data; int len; //当前表长 int maxLen; //最大表长&#125;; 【初始化表与销毁表】在 C 语言中，连续的地址空间有两种分配方式：静态分配、动态分配 静态分配静态分配事先规定好表长，表长声明后无法更改，之后根据表长的大小申请数组空间，一旦空间占满，再加入新的数据将会发生溢出 123456789101112#define maxLen 50 + 5 //最大表长class SeqList &#123; public: SeqList(); //构造函数，初始化表 private: int data[maxLen]; int len; //当前表长&#125;;SeqList::SeqList() &#123; //构造函数，初始化表 len = 0; //初始长度为0，空表&#125; 动态分配动态分配时，顺序表的存储空间是通过动态存储分配语句分配的，当存储空间占满，可以另外开辟一块更大的存储空间，以替换原来的存储空间，从而达到扩充顺序表空间的目的 也就是说，在动态分配中，顺序表表长声明后可更改 在 C 语言中，使用 malloc() 函数与 free() 函数来进行空间的动态分配与回收；在 C++ 语言中，除了继承自 C 语言标准库的 malloc() 函数与 free() 函数，还引入了 new 操作符与 delete 操作符 相较于 malloc() 要手动计算类型大小，同时要强制转换成所需的返回类型（malloc()默认返回类型为 void*），new 操作符会自动计算类型大小，并返回对应类型指针 但从系统层面来说，真正开辟和回收空间的是 malloc() 函数与 free() 函数，new 操作符与 delete 操作符的实现依赖于内存管理接口 12345678910111213141516171819202122232425262728293031323334353637#define N 50+5 //最大表长template &lt;typename T&gt; class SeqList &#123; public: SeqList(); //无参构造函数，初始化表 SeqList(T m_data[], int m_len); //有参构造函数，对表赋初值 ~SeqList(); //析构函数，销毁表 void increaseList(int increaseLen); //扩充线性表长度 private: T *data; int len; //当前表长 int maxLen; //最大表长&#125;;template &lt;typename T&gt; SeqList&lt;T&gt;::SeqList() &#123; //无参构造函数，初始化表 len = 0; //初始长度为0，空表 maxLen = N; //最大表长为N // 使用malloc开辟空间 data = (T *)malloc(maxLen * sizeof(T)); //申请连续的maxLen个存储单元 // 使用new开辟空间 // data = new int(maxLen);&#125;template &lt;typename T&gt;SeqList&lt;T&gt;::SeqList(T data[], int len) &#123; //有参构造函数，对表赋初值 maxLen = N; //最大表长为N this-&gt;len = len; this-&gt;data = (T *)malloc(maxLen * sizeof(T)); //申请连续的maxLen个存储单元 for (int i = 0; i &lt; len; i++) this-&gt;data[i] = data[i];&#125;template &lt;typename T&gt; SeqList&lt;T&gt;::~SeqList() &#123; //析构函数，销毁表 free(data); //使用free回收malloc分配的空间 // delete data; //使用delete回收new分配的空间&#125; 在动态分配顺序表空间时，若需要对顺序表进行扩充，则可先使用 malloc() 重新分配空间，然后再将原有数据复制到新空间，最后再将原空间释放即可 此外，也可使用 realloc() 重新分配空间 1234567891011121314template &lt;typename T&gt;void SeqList&lt;T&gt;::increaseList(int increaseLen) &#123; //扩充线性表长度 maxLen = maxLen + increaseLen; //表长增加increaseLen //使用malloc重新分配空间 T *p = data; data = (T *)malloc(maxLen * sizeof(T)); //重新开辟空间 for (int i = 0; i &lt; len; i++) //将原有数据复制到新开辟空间 data[i] = p[i]; free(p); //释放原空间 //使用realloc重新分配空间 // data = (T *)realloc(data, maxLen * sizeof(T));&#125; 【基本操作】求表长为避免使用顺序表 L 的表长时操作失误导致线性表表长更改，借助 OOP 中的 getter 思想，将获取顺序表表长封装成函数 1234template &lt;typename T&gt; int SeqList&lt;T&gt;::getLen() &#123; //求表长 return len;&#125; 判空当顺序表 L 表长为 $0$ 时，表为空表 123456template &lt;typename T&gt; bool SeqList&lt;T&gt;::empty() &#123; //判空 if (len == 0) return true; return false;&#125; 判满当顺序表 L 表长为最大长度 maxLen 时，表为满表 123456template &lt;typename T&gt; bool SeqList&lt;T&gt;::full() &#123; //判满 if (len == maxLen) return true; return false;&#125; 输出对于顺序表 L，按序输出其元素，首先为防止脏读的出现，应先判断表是否为空表，之后，从表头枚举到表尾即可 1234567891011template &lt;typename T&gt; bool SeqList&lt;T&gt;::print() &#123; //输出 if (empty()) //判表空，防脏读 return false; int len = getLen(); //表长 for (int i = 0; i &lt; len - 1; i++) cout &lt;&lt; data[i] &lt;&lt; \" \"; cout &lt;&lt; data[len - 1] &lt;&lt; endl; return true;&#125; 关于脏读 在分配内存空间后，内存空间中可能存在数据，若不使用表长来制约循环，可能会出现脏读的情况 假设顺序表 L 表长为 $2$，其中仅有两个数据，分别为 $1$、$3$，且顺序表允许的最大表长为 $5$ 当采用以下输出方式时，输出可能为：1,3,0,318,0，其中 $318$ 即为原有内存空间的脏数据 123for (int i = 0; i &lt; 4 ;i++) printf(\"%d,\",L.data[i]);printf(\"%d\\n\",L.data[4]); 【插入】在顺序表 L 上的 pos 位置插入新元素 elem 时，首先要进行越界判断与表满判断，防止溢出 之后将最后一个元素到原 pos 个元素间的所有元素后移一位，最后，将新元素 elem 插入到 pos 位置上，再将表长 len 加 $1$ 需要注意的是，数组索引从 $0$ 开始，线性表索引从 $1$ 开始，因此 pos-1 为对应的数组位置 12345678910111213141516template &lt;typename T&gt;bool SeqList&lt;T&gt;::insertElement(int pos, T elem) &#123; //第pos个位置插入元素elem if (pos &lt; 1 || pos &gt; len + 1) //越界判断 return false; if (full()) //判表满，防溢出 return false; //从最后一个元素到第pos个元素的所有元素后移 for (int i = len; i &gt;= pos; i--) data[i] = data[i - 1]; data[pos - 1] = elem; len++; return true;&#125; 时间复杂度分析 1.最好时间复杂度 最好的情况是在表尾 i=n+1 插入，此时后移语句不需要执行，时间复杂度为：$O(1)$ 2.最坏时间复杂度 最坏的情况是在表头 i=1 插入，此时后移语句执行 $n$ 次，时间复杂度为：$O(n)$ 3.平均时间复杂度 对于平均情况而言，在第 i 个位置插入概率为： p_i=\\frac{1}{n+1}那么，在各位置上需要执行后移语句 $n-i+1$ 次，平均移动次数为： \\sum_{i=1}^{n+1}p_i*(n-i+1)=\\frac{n}{2}此时，时间复杂度为：$O(n)$ 【删除】删除顺序表 L 上的 pos 位置的元素时，首先要进行越界判断与表空判断，防止溢出 之后将要删除的元素值赋给引用变量以最终返回元素值，最后，将要删除的元素 elem 到最后的元素间的所有元素前移一位，再将表长 len 减 $1$ 1234567891011121314template &lt;typename T&gt;bool SeqList&lt;T&gt;::deleteElement(int pos, T &amp;elem) &#123; //删除第pos个元素，通过引用返回元素值 if (pos &lt; 1 || pos &gt; len) //越界判断 return false; if (empty()) //判表空 return false; elem = data[pos - 1]; //要删除元素 for (int i = pos; i &lt; len; i++) //要删除元素之后元素前移 data[i - 1] = data[i]; len--; return true;&#125; 时间复杂度分析 1.最好时间复杂度 最好的情况是在表尾 i=n 删除，此时后移语句不执行，时间复杂度为：$O(1)$ 2.最坏时间复杂度 最坏的情况是在表头 i=1 删除，此时后移语句执行 $n$ 次，时间复杂度为：$O(n)$ 3.平均时间复杂度 对于平均情况而言，在第 i 个位置删除概率为： p_i=\\frac{1}{n}那么，在各位置上需要执行后移语句 $n-i$ 次，平均移动次数为： \\sum_{i=1}^{n+1}p_i*(n-i)=\\frac{n-1}{2}此时，时间复杂度为：$O(n)$ 【查找】按值查找在顺序表 L 中寻找与给定元素值 elem 相同的第一个元素的位置时，需要进行表空判断，防止溢出 之后，从前向后对顺序表的元素进行枚举，若匹配成功，则直接返回对应位置 若对顺序表扫描完毕，没有匹配，说明匹配不成功，返回 -1 1234567891011template &lt;typename T&gt;int SeqList&lt;T&gt;::getNodeByValue(T elem) &#123; //查找与elem相同的第一个元素位置，不存在返回-1 if (empty()) //判表空 return -1; for (int i = 0; i &lt; len; i++) if (data[i] == elem) return i + 1; return -1;&#125; 时间复杂度分析 1.最好时间复杂度 最好的情况是在表头 i=1 查找，此时仅需比较 $1$ 次，时间复杂度为：$O(1)$ 2.最坏时间复杂度 最好的情况是在表尾 i=n 查找，此时需要比较 $n$ 次，时间复杂度为：$O(n)$ 3.平均时间复杂度 对于平均情况而言，查找元素在第 i 个位置的概率为： p_i=\\frac{1}{n}那么，要在各位置上执行后移语句 $i$ 次，平均移动次数为： \\sum_{i=1}^{n+1}p_i*i=\\frac{n+1}{2}此时，时间复杂度为：$O(n)$ 按位查找在顺序表 L 中查找第 pos 个位置的元素时，需要进行越界判断与表空判断，防止溢出 由于顺序表支持随机访问，因此直接读取 data[pos-1] 的值即可 123456789template &lt;typename T&gt;bool SeqList&lt;T&gt;::getNodeByPosition(int pos, T &amp;elem) &#123; //查找第pos个元素，通过引用返回元素值 if (pos &lt; 1 || pos &gt; len) //越界判断 return false; if (empty()) //判表空，防脏读 return false; elem = data[pos - 1]; return true;&#125; 时间复杂度分析 由于顺序表支持随机访问，因此，时间复杂度为：$O(1)$","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线性表","slug":"oi-acm/data-structure/linear-list","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/linear-list/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线性表","slug":"linear-list","permalink":"https://alex-mcavoy.github.io/tags/linear-list/"}],"author":"Alex_McAvoy"},{"title":"线性表","slug":"data-structure/01.linear-list/01.线性表","date":"2018-09-03T03:16:00.000Z","updated":"2021-09-02T13:43:34.898Z","comments":true,"path":"oi-acm/data-structure/linear-list/40f24371.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/linear-list/40f24371.html","excerpt":"【逻辑结构】线性表是具相同数据类型的 $n$ 个数据元素的有限序列，其中，相同数据类型意味着每个数据元素所占的存储空间相同，数据元素个数 $n$ 为线性表的长度，当 $n=0$ 时称为空表，反之 $n\\neq 0$ 时称为非空表 一个非空表常记为：","text":"【逻辑结构】线性表是具相同数据类型的 $n$ 个数据元素的有限序列，其中，相同数据类型意味着每个数据元素所占的存储空间相同，数据元素个数 $n$ 为线性表的长度，当 $n=0$ 时称为空表，反之 $n\\neq 0$ 时称为非空表 一个非空表常记为： L=(a_1,a_2,...a_{i-1},a_i,a_{i+1},...,a_n)其中 $a_i$ 是表中的第 $i$ 个数据元素，表中的 $a_{i-1}$ 领先于 $a_{i}$，$a_{i}$ 领先于 $a_{i+1}$，称 $a_{i-1}$ 是 $a_{i}$ 的直接前驱元素，$a_{i+1}$ 是 $a_{i}$ 的直接后继元素 对于 $i=1,2,…,n-1$ 来说，$a_{i}$ 有且只有一个直接后继，$a_n$ 为表尾元素；对于 $i=2,3,…,n$ 来说，$a_{i}$ 有且只有一个直接前驱，$a_1$ 为表头元素； 【顺序存储结构】线性表的顺序存储结构称为顺序表，常用一维数组来实现，其通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，其支持对数据元素的随机访问，因此属于随机存取结构 设顺序表的每个元素占用 $c$ 个存储单元，则第 $i$ 个元素的存储地址为： LOC ( a_ i ) = LOC ( a_1 )+ ( i - 1 ) *c 【链式存储结构】线性表的链式存储结构称为链表，其使用一组任意的存储单元来存放线性表的元素，这组存储单元在存储空间中，可以连续也可以不连续，即逻辑顺序与物理顺序可以不一致 为能正确表示元素间的逻辑关系，每个存储单元在存储数据元素的同时，还必须存储地址信息，这两部分构成了数据元素的存储映像，称为结点（Node），之后，将数据结构按照逻辑顺序链接在一起 根据结点的不同结构与结点间的链接关系，链表可分为以下四种： 单链表：结点间关系只有后继，可分为带头结点、不带头结点 双链表：结点间关系有前驱、后继 循环链表：尾结点的指向头结点，整个链表形成一个环 静态链表：一维数组模拟链表，用于无指针类型的高级程序设计语言中使用链表","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"线性表","slug":"oi-acm/data-structure/linear-list","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/linear-list/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"线性表","slug":"linear-list","permalink":"https://alex-mcavoy.github.io/tags/linear-list/"}],"author":"Alex_McAvoy"},{"title":"算法及其时空复杂度","slug":"basic/01.theory/02.算法及其时空复杂度","date":"2018-09-03T02:55:00.000Z","updated":"2021-09-25T08:37:42.932Z","comments":true,"path":"oi-acm/basic/theory/1227c6ab.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/1227c6ab.html","excerpt":"【算法】算法是对特定问题求解步骤的描述，是指令的有限序列，每个指令表示一或多个操作，其具有以下特性： 有穷性：能在有穷步、有穷时间内执行完毕 确定性：相同输入会获得相同输出 可行性：算法是可行的 输入：具有零到多个输入 输出：具有一到多个输出","text":"【算法】算法是对特定问题求解步骤的描述，是指令的有限序列，每个指令表示一或多个操作，其具有以下特性： 有穷性：能在有穷步、有穷时间内执行完毕 确定性：相同输入会获得相同输出 可行性：算法是可行的 输入：具有零到多个输入 输出：具有一到多个输出 【时间复杂度】定义时间复杂度用于评价算法的时间开销，即在给定数据范围时，通过时间复杂度来判断选用的算法会不会 TLE 通常利用 $T(n)$ 来表示算法中所有语句的频度和，而语句的频度是该语句在算法中重复执行的次数，因此 $T(n)$ 是问题规模 $n$ 的函数；利用 $f(n)$ 来表示基本运算的频度，即最深层循环内的语句频度 由此，算法的时间复杂度被定义为： T(n)=O(f(n))其中，$O$ 为 $T(n)$ 的数量级 运算规则时间复杂度的运算满足以下规则： 加法规则：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$ 乘法规则：$T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))$ 去常规则：当存在常数 $k$ 时，省略掉常数，只关注数量级 $O$，例如：$O(3n^3+8)-&gt;O(n^3)$ 根据上述规则，可以总结出如下常见时间复杂度关系： O(1)","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"}],"author":"Alex_McAvoy"},{"title":"数据结构的基本概念","slug":"basic/01.theory/01.数据结构的基本概念","date":"2018-09-03T02:50:00.000Z","updated":"2021-12-14T14:26:13.281Z","comments":true,"path":"oi-acm/basic/theory/35ca0ba5.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/theory/35ca0ba5.html","excerpt":"【基本概念】数据结构的基本概念如下： 数据：信息载体，能输入到计算机且能被计算机识别处理的集合 数据元素：基本数据单位，作为一个整体考虑处理，由若干数据项组成 数据项：构成数据元素的、不可分割的最小单位 数据对象：数据的子集，具相同性质的元素的集合 数据结构：相互存在一种或多种特定关系的数据元素的集合 数据类型：一个值的集合与定义在此集合上的一组操作 原子类型：值不可再分，如 int、float、double 结构类型：值可分为若干成分，如 struct 抽象数据类型(ADT)：数学化语言定义逻辑结构与运算，与具体实现无关，用于定义完整数据结构","text":"【基本概念】数据结构的基本概念如下： 数据：信息载体，能输入到计算机且能被计算机识别处理的集合 数据元素：基本数据单位，作为一个整体考虑处理，由若干数据项组成 数据项：构成数据元素的、不可分割的最小单位 数据对象：数据的子集，具相同性质的元素的集合 数据结构：相互存在一种或多种特定关系的数据元素的集合 数据类型：一个值的集合与定义在此集合上的一组操作 原子类型：值不可再分，如 int、float、double 结构类型：值可分为若干成分，如 struct 抽象数据类型(ADT)：数学化语言定义逻辑结构与运算，与具体实现无关，用于定义完整数据结构 【数据结构三要素】逻辑结构逻辑结构是数据元素间的逻辑关系，与存储无关，独立于计算机，逻辑结构可分为以下四种： 集合：数据元素间同属一个集合 线性结构：数据元素间一对一关系 树形结构：数据元素间一对多关系 图状结构：数据元素间多对多关系 具体划分如下图： \\left\\{\\begin{matrix} 线性结构 \\left\\{\\begin{matrix} 一般线性表\\\\ 线性表推广 \\left\\{\\begin{matrix} 数组\\\\ 广义表\\end{matrix}\\right. \\\\ 受限线性表 \\left\\{\\begin{matrix} 栈\\\\ 队列 \\\\串 \\end{matrix}\\right. \\end{matrix}\\right. \\\\ 非线性结构 \\left\\{\\begin{matrix} 集合\\\\ 树 \\left\\{\\begin{matrix} 一般树\\\\ 二叉树\\end{matrix}\\right. \\\\图 \\left\\{\\begin{matrix} 无向图\\\\ 有向图 \\end{matrix}\\right. \\end{matrix}\\right. \\end{matrix}\\right.物理结构物理结构即存储结构，是数据结构在计算机中的表示，包含数据元素及其关系的表示，物理结构可分为以下四种： 顺序存储：逻辑相邻物理上也相邻，关系由存储单元邻接关系体现 链式存储：逻辑相邻物理上不一定相邻，关系由指针体现 索引存储：建立附加的索引表，每一索引项含关键字、地址 散列存储：Hash 存储，根据关键字计算出存储地址，存在 Hash 碰撞问题 数据运算数据运算是运算的定义与实现： 运算定义：针对逻辑结构 运算实现：针对物理结构","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"基础理论","slug":"oi-acm/basic/theory","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/theory/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"基础理论","slug":"theory","permalink":"https://alex-mcavoy.github.io/tags/theory/"}],"author":"Alex_McAvoy"},{"title":"带权并查集","slug":"data-structure/07.disjoint-sets/05.带权并查集","date":"2018-08-08T12:27:58.000Z","updated":"2021-09-03T16:44:46.364Z","comments":true,"path":"oi-acm/data-structure/disjoint-sets/dbe7e802.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/disjoint-sets/dbe7e802.html","excerpt":"【带权并查集】带权并查集是结点存有权值的并查集，每个元素的权值通常描述其与并查集中祖先的关系，这种关系如何合并，路径压缩时就如何压缩 与并查集相比，带权并查集可以推算集合内点的关系，而一般并查集只能判断属于某个集合","text":"【带权并查集】带权并查集是结点存有权值的并查集，每个元素的权值通常描述其与并查集中祖先的关系，这种关系如何合并，路径压缩时就如何压缩 与并查集相比，带权并查集可以推算集合内点的关系，而一般并查集只能判断属于某个集合 当两个元素之间的关系可以量化，并且关系可以合并时，可以使用带权并查集来维护元素之间的关系 【合并操作】带权并查集只是在并查集中加入了一个 value[] 数组，与之相应，在 Union() 函数中也有改变 合并两个元素时，假设 $A$、$B$ 属于不同的树，如果合并这两棵树，把 $A$ 树合并到 $B$ 树上，就需要给 $A$ 树跟他的根结点赋值 假设于 $A$、$B$ 的权值 $Wa$、$Wb$，由于两权值代表的都是与根结点的距离，给根结点所赋的值为： Wa-Wb+x此时，对于原来的结点 $A$，只更新了 $A$ 与其根结点的权值，因此其他结点的更新在查找中实现即可 1234567891011121314int father[N];int value[N];int Union(int x, int y, int val) &#123; int fx = Find(x); int fy = Find(y); if (fx == fy) //如果当前两点与之前距离有冲突 if(dis[y] != dis[x] + val) return 1; father[fy] = fx; value[fy] = value[x] - value[y] + val; //计算两点距离 return 0;&#125; 【查找操作】带权并查集只是在并查集中加入了一个 value[] 数组，与之相应，在 Find() 函数与 Union() 函数中也有改变 123456789101112int father[N];int value[N];int Find (int x) &#123; if (father[x] == x) return x; int temp = father[x]; father[x] = Find(father[x]); value[x] += value[temp]; //结点x到根的距离 return father[x];&#125; 【常见类型】种类问题种类统计问题比普通并查集新增一属性，常用于表示它和 father[i] 的关系 例如：用 group[i] 表示和 father[i] 的关系，同类可以用 $0$ 表示，其他两种分别用 $1$ 表示该结点到父结点的单向关系，$2$ 表示该父结点到结点的单向关系 统计问题统计问题一般是对某种属性进行统计，新增一属性，在路径压缩时执行即可 例如：cnt[x] += cnt[fa] 区间问题区间问题一般是记录某区间 $[l,r]$ 的数据，此类问题需要对所有值统计设置相同的初值，但初值的大小一般没有影响 对区间 $[l, r]$ 进行记录时，实际上是对势差 $l-1$ 和 $r$ 之间 $(l-1, r]$ 的操作，即： l = l - 1","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"并查集","slug":"oi-acm/data-structure/disjoint-sets","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/disjoint-sets/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"并查集","slug":"disjoint-sets","permalink":"https://alex-mcavoy.github.io/tags/disjoint-sets/"}],"author":"Alex_McAvoy"},{"title":"并查集的删除操作","slug":"data-structure/07.disjoint-sets/04.并查集的删除操作","date":"2018-08-08T03:27:58.000Z","updated":"2021-09-03T16:21:14.525Z","comments":true,"path":"oi-acm/data-structure/disjoint-sets/bba2b22.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/disjoint-sets/bba2b22.html","excerpt":"在并查集中，删除操作是指删除掉并查集中的一个结点 在所有结点都直接连接在根结点上的完美并查集上，理论上只要把要删除的节点的上级重新指向自己就可以了 但实际情况中，并查集形成的树的形态都是不可预估的，如果一个结点非叶结点，将该结点直接删除，会将其与其子孙结点一起删除","text":"在并查集中，删除操作是指删除掉并查集中的一个结点 在所有结点都直接连接在根结点上的完美并查集上，理论上只要把要删除的节点的上级重新指向自己就可以了 但实际情况中，并查集形成的树的形态都是不可预估的，如果一个结点非叶结点，将该结点直接删除，会将其与其子孙结点一起删除 所以在一个需要删除的并查集中，可以进行如下处理： 将每一个结点都设立一个虚拟父结点，这样根结点就是我们设立的虚拟结点，类似于将每个结点放到一个盒子中 如果删除某结点，那么可以修改当前结点的父结点来导致当前结点的孤立，即删除时把这个结点从当前盒子拿出来，放到另一个盒子中 由于结点之间都是通过盒子来确定关系的，所以盒子中的元素是否存在并不影响结点之间的关系，以下图为例： 如果要删除 $2$ 号结点，那么将把 $2$ 号结点拿出来放到另一个盒子中就可以了，可以看到原来的那个树结构并没有发生变化，但是 $2$ 号结点已经不在这里面了 实现： 1234567891011121314//假设最多会有n个结点，就从n+1开始作为假结点int index; //存放盒子结点使用到哪一个int pre[N]; //盒子结点void init (int n) &#123; //初始化 index = n; for(int i = 0; i &lt; n; i++) //普通节点指向他的盒子节点 pre[i] = index++; for(int i = n; i &lt; 2*n; i++)//盒子节点指向自己就像一般的并查集一样 pre[i] = i;&#125;void del (int n) &#123; //删除结点 pre[n] = index; //将要删除的节点重新指向一个新的盒子 pre[index] = index++; //盒子节点指向自己&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"并查集","slug":"oi-acm/data-structure/disjoint-sets","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/disjoint-sets/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"并查集","slug":"disjoint-sets","permalink":"https://alex-mcavoy.github.io/tags/disjoint-sets/"}],"author":"Alex_McAvoy"},{"title":"并查集的启发式合并","slug":"data-structure/07.disjoint-sets/03.并查集的启发式合并","date":"2018-08-04T13:17:41.000Z","updated":"2021-09-03T14:39:32.961Z","comments":true,"path":"oi-acm/data-structure/disjoint-sets/3d5aa5bb.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/disjoint-sets/3d5aa5bb.html","excerpt":"【并查集的启发式合并】在并查集执行合并操作 Union()，将两个集合合并为一个时，无论将哪一个集合连接到另一集合的下面都是正确的，但不同的连接方法存在时间复杂度的差异 具体来说，如果将一棵结点数、深度都较小的集合树，连接到一棵更大的集合树下，显然相比于另一种连接方案，在接下来执行查找操作 Find() 时，时间复杂度会更小","text":"【并查集的启发式合并】在并查集执行合并操作 Union()，将两个集合合并为一个时，无论将哪一个集合连接到另一集合的下面都是正确的，但不同的连接方法存在时间复杂度的差异 具体来说，如果将一棵结点数、深度都较小的集合树，连接到一棵更大的集合树下，显然相比于另一种连接方案，在接下来执行查找操作 Find() 时，时间复杂度会更小 但不能总是恰好遇到结点数、深度都小的集合，鉴于结点数、深度这两个特征都较容易维护，常常选择其中的一个来作为估价函数，来进行合并评估 在Tarjan的论文[1]中，证明了无论选择哪一种作为估价函数，时间复杂度都是 O(m\\alpha(m,n))这就是并查集的启发式合并优化，又称为并查集的按秩合并 【实现】下面给出选择结点数作为估计函数的实现方法 123456789101112int father[N];vector&lt;int&gt; size(N, 1); //记录并初始化子树的大小为1void Union(int x, int y) &#123; //以结点数为估计函数的启发式合并 int fx = Find(x); //x的根结点 int fy = find(y); //y的根结点 if (fx == fy) //x、y属于同一集合的根结点 return; if (size[fx] &gt; size[fy]) // 保证小的集合合并到大的集合 swap(fx, fy); father[fx] = fy; //合并 size[fy] += size[fx]; //维护结点数&#125; Reference[1]Gabow, H. N., &amp; Tarjan, R. E. (1985). A Linear-Time Algorithm for a Special Case of Disjoint Set Union. JOURNAL OF COMPUTER AND SYSTEM SCIENCES, 30, 209-221.CORE PDF","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"并查集","slug":"oi-acm/data-structure/disjoint-sets","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/disjoint-sets/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"并查集","slug":"disjoint-sets","permalink":"https://alex-mcavoy.github.io/tags/disjoint-sets/"}],"author":"Alex_McAvoy"},{"title":"并查集的路径压缩","slug":"data-structure/07.disjoint-sets/02.并查集的路径压缩","date":"2018-08-04T05:17:41.000Z","updated":"2021-09-03T14:25:40.306Z","comments":true,"path":"oi-acm/data-structure/disjoint-sets/73d75a26.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/disjoint-sets/73d75a26.html","excerpt":"【概述】在并查集的寻找结点 x 的根结点的过程中，是不停的通过 father[] 数组去向上寻找其根结点 12345void Find (int x) &#123; //递归实现 if (father[x] != x) //x不是集合的代表时 return Find(father[x]); //以当前结点的父结点进一步查询 return father[x];&#125;","text":"【概述】在并查集的寻找结点 x 的根结点的过程中，是不停的通过 father[] 数组去向上寻找其根结点 12345void Find (int x) &#123; //递归实现 if (father[x] != x) //x不是集合的代表时 return Find(father[x]); //以当前结点的父结点进一步查询 return father[x];&#125; 在这个过程中，相当于把结点 x 到其根结点的这条路径上的所有结点都遍历了一遍，而之后每次要查询这条路径上某结点的根结点，都要重新进行遍历，这无疑增大了时间复杂度 为减少时间复杂度，有了并查集中最重要的优化——路径压缩 在经过路径压缩后，再次查询该条路径上的根结点时，只需要 $O(1)$ 的复杂度即可得到根结点 【基本思想】路径压缩的本质，是减少树的层数 在并查集中，对于一个结点来说，其父结点是哪个结点与其根结点是哪个结点毫无关系，每次都要一层层的找太浪费时间 因此，路径压缩，就是令路径上的每个结点，都直接连接到根结点上，这样以后在查询时，通过 father[i] 即可知道 i 号结点的根结点是谁 12345int Find (int x) &#123; //路径压缩实现 if (father[x] != x) //x不是集合的代表时 return father[x] = Find(father[x]); //查找x的祖先找到代表，并路径压缩 return father[x];&#125; 【实例】假设初始并查集如下图 此时，father[] 数组如下： father[1]=1 father[2]=1 father[3]=2 father[4]=3 father[5]=4 在未经过路径压缩前，假设要进行 Find(4) 操作，那么，根据上述的路径压缩的 Find() 过程有： 可以看出，在路径压缩完成后，有： father[1]=1 father[2]=1 father[3]=1 father[4]=1 father[5]=4 这样，当下一次 $1$ 号点到 $4$ 号点的路径时，只需要经过一次询问，即可得到相应结点的根结点","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"并查集","slug":"oi-acm/data-structure/disjoint-sets","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/disjoint-sets/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"并查集","slug":"disjoint-sets","permalink":"https://alex-mcavoy.github.io/tags/disjoint-sets/"}],"author":"Alex_McAvoy"},{"title":"并查集及其基本操作","slug":"data-structure/07.disjoint-sets/01.并查集及其基本操作","date":"2018-08-02T13:41:02.000Z","updated":"2021-09-03T14:34:54.665Z","comments":true,"path":"oi-acm/data-structure/disjoint-sets/184d6499.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/disjoint-sets/184d6499.html","excerpt":"【概述】并查集（Union-Find Set）是一种用于分离集合操作的抽象数据类型，其处理的是集合（set）之间的合并及查询问题 在并查集中，借助一个数组 father[] 来表示每个结点的父结点，即 father[i] 存储结点 i 的父结点编号","text":"【概述】并查集（Union-Find Set）是一种用于分离集合操作的抽象数据类型，其处理的是集合（set）之间的合并及查询问题 在并查集中，借助一个数组 father[] 来表示每个结点的父结点，即 father[i] 存储结点 i 的父结点编号 最主要的两种操作为： 查找（Find）：确定元素 a 的根结点 合并（Union）：将子集 a、b 合并为一个集合 当遇到有关物与物之间的关系，且这种关系是可传递的问题时，可以优先尝试用并查集解决 【基本操作】初始化在最开始时，所有的元素各自单独构成一个集合，当集合中只有一元素时，这个集合的代表结点即为该元素，即该元素的父结点（father）是其自身 因此并查集的初始化，即将每个元素作为自己的根结点 12345int father[N]; //father[i]存储结点i的父结点编号void init (int n) &#123; for (int i = 1; i &lt;= n; i++) father[i] = i;&#125; 查询根结点编号查询根结点编号，即给出一个元素编号 x 时，寻找到元素 x 的根结点的编号 以下图为例，假设我们要找 $6$ 号结点的根结点，那么过程为：首先找到 $6$ 号点的父结点为 $3$ 号，然后再找 $3$ 号的父结点为 $1$ 号，再找 $1$ 号的父结点为 $1$ 号，此时发现 $1$ 号点父结点是其自身，即满足 father[root]=root，说明找到了 $6$ 号点的根结点为 1 号点 因此，我们利用 while 循环，非递归地实现查询根结点编号的操作操作 12345void Find (int x) &#123; //非递归实现 while (father[x] != x) //未查询到根结点时 x = father[x]; //将当前结点更新为其根结点，继续向上寻找 return x;&#125; 考虑到并查集中每个集合都是一棵树，那么可以借助树的递归性来完成上述操作 12345void Find (int x) &#123; //递归实现 if (father[x] != x) //未查询到根结点时 return Find(father[x]); //以当前结点的父结点进一步查询 return father[x];&#125; 合并两集合对于两个不相交的集合，若想将这两个集合进行合并，并不需要在意祖先究竟是谁，只需要将一个集合中的祖先作为另一个集合祖先的孩子结点即可 对于分属两个集合中的元素 x、y，首先利用查找操作 Find()，找到这两个结点的根结点 fx、fy 若 fx == fy，说明两结点已经在同一个集合中，不需合并 若 fx != fy，说明两结点不再同一个集合中，将元素 y 的根结点 fy 作为 x 的根结点 fx 的儿子即可 123456void Union (int x,int y) &#123; int fx = Find(x); //x的根结点 int fy = Find(y); //y的根结点 if (fx != fy) //判断fx与fy是否为一个根结点 father[fy] = fx;&#125; 判断两元素是否属于同一集合对于两个元素 x、y 来说，若想判断这两个元素是否为一个集合，只需要利用 Find() 来寻找他们的父结点 fx、fy 若 fx == fy，说明两元素根结点相同，为同一集合 若 fx != fy，说明两元素根结点不同，不为同一集合 1234567bool judge (int x, int y) &#123; int fx = Find(x); //x的根结点 int fy = Find(y); //y的根结点 if (fx == fy) return true; return false;&#125; 统计集合数目在初始化后，每个元素都将自己作为自己的根结点 因此当需要统计并查集中的集合数目时，只需要统计有多少个元素的根结点是其自身即可 1234567int countSets (int n) &#123; int cnt = 0; for (int i = 1; i &lt;= n; i++) if (father[i] == i) cnt++; return cnt;&#125; 统计每个集合中元素个数统计每个集合中元素的个数需要两步： 对于 $n$ 个结点，先寻找他们的根结点，利用桶排的思想，来统计以 $i$ 为根结点时，该子集中的结点个数 统计根结点外的点，即对于每个元素，将其个数记为其根结点下的元素个数 123456789int num[N]; //num[i]代表以i为根结点时，该子集下的元素数目void countElements() &#123; for (int i = 1; i &lt;= n; i++) &#123; father[i] = Find(i); //寻找每个节点的根结点 num[father[i]]++; //统计根结点下的节点个数 &#125; for (int i = 1; i &lt;= n; i++) //统计根节点外的点的个数 num[i] = num[father[i]]; //对于每个元素，将其个数记为其根结点下的元素个数&#125; 【时空复杂度】阿克曼函数阿克曼函数（Ackermann），是一个非原始递归函数，其输出值增长速度很快 阿克曼函数被定义为： A(m,n)=\\left\\{\\begin{matrix} n+1, & m=0 \\\\ A(m-1,1), & m>0,n=0 \\\\ A(m-1,A(m,n-1)), & otherwise \\end{matrix}\\right.阿克曼函数的单变量反函数 $\\alpha(n)$ 被称为反阿克曼函数，其被定义为：最大的整数 $m$，使得 $A(m,m)\\leq n$ 成立 阿克曼函数 $A(m,n)$ 的增长速度极快，但反阿克曼函数 $\\alpha(n)$ 增长速度很慢，它们常出现在算法时间复杂度分析中 时间复杂度在本文中所论述的并查集，是最基础的并查集，没有进行任何优化 但在实际应用中，可以对并查集进行路径压缩和启发式合并优化，此时的并查集的时间复杂度常用反阿克曼函数 $\\alpha(n)$ 来衡量 在同时使用路径优化和启发式合并后，并查集的每个操作平均时间为： O(\\alpha(n))通常，在 OI&amp;ACM 竞赛中，即使不适用启发式合并，代码也往往能在规定时间内完成任务 在 Tarjan 的论文[1]中，证明了不使用启发式合并、只使用路径压缩的最坏时间复杂度为： O(m\\log n)在姚期智的论文[2]中，证明了不使用启发式合并、只使用路径压缩的平均时间复杂度为： O(m\\alpha(m,n))空间复杂度显然，并查集的空间复杂度为： O(n)References[1]Tarjan, R. E., &amp; Van Leeuwen, J. (1984). Worst-case analysis of set union algorithms. Journal of the ACM (JACM), 31(2), 245-281.ResearchGate PDF [2]Yao, A. C. (1985). On the expected performance of path compression algorithms.SIAM Journal on Computing, 14(1), 129-133.","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"并查集","slug":"oi-acm/data-structure/disjoint-sets","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/disjoint-sets/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"并查集","slug":"disjoint-sets","permalink":"https://alex-mcavoy.github.io/tags/disjoint-sets/"}],"author":"Alex_McAvoy"},{"title":"置换选择排序与最佳归并树","slug":"basic/02.sort/17.置换选择排序与最佳归并树","date":"2018-07-23T05:17:26.000Z","updated":"2021-09-26T09:20:00.055Z","comments":true,"path":"oi-acm/basic/sort/6492a1eb.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/6492a1eb.html","excerpt":"【引入】在 外部排序 中讨论过，增大归并路数 $k$ 或减少初始归并段个数 $r$，都可以减少归并趟数 $S$，进而减少 I/O 次数，以提高外部排序速度 若总的记录个数为 $n$，每个归并段长度为 $l$，则归并段个数 $\\left \\lceil \\frac{n}{l} \\rceil \\right.$，采用内部排序得到的各个初始归并段，除最后一个外，长度都相同，其依赖于内部排序时可用内存工作区的大小","text":"【引入】在 外部排序 中讨论过，增大归并路数 $k$ 或减少初始归并段个数 $r$，都可以减少归并趟数 $S$，进而减少 I/O 次数，以提高外部排序速度 若总的记录个数为 $n$，每个归并段长度为 $l$，则归并段个数 $\\left \\lceil \\frac{n}{l} \\rceil \\right.$，采用内部排序得到的各个初始归并段，除最后一个外，长度都相同，其依赖于内部排序时可用内存工作区的大小 因此，为产生更长的初始归并段，以减少初始归并段数 $r$，引入了置换-选择算法 【置换选择排序】设待排序文件为 F1，初始归并段输出文件为 FO，内存工作区为 WA，FO 和 WA 的初始状态为空，WA 可容纳 $w$ 个记录 那么，置换选择排序的算法步骤如下： 1）从待排文件 FI 输入 $w$ 个文件到工作区 WA 2）从工作区 WA 选出关键字最小的记录，记为miniMax 记录 3）将 miniMax 记录输出到输出文件 FO 4）若待排文件 FI 不空，则从 FI 输入下一记录到工作区 WA 中 5）从工作区 WA 所有比 miniMax 记录大的关键字中选出最小关键字记录，作为新的 miniMax 记录 6）重复 3）~ 5），直到在工作区 WA 中选不出新的 miniMax 记录为止，由此得到一个初始归并段，并输出一个归并段的结束标志到输出文件 FO 7）重复 2）~ 6），直到工作区 WA 为空，由此得到全部初始归并段 需要注意的是，在工作区 WA 中选择 miniMax 记录的过程，需要用败者树来实现 以待排文件 FI 中的数据 $\\{17,21,5,44,10,12,56,32,29\\}$ 为例，设工作区 WA 容量为 $3$，排序过程如下： 输出文件 FO​ 工作区 WA miniMax 记录 输入文件 FI $-$ $-$ $-$ $17,21,5,44,10,12,56,32,29$ $-$ $17,21,5$ $5$ $44,10,12,56,32,29$ $5$ $17,21,44$ $17$ $10,12,56,32,29$ $5,17$ $10,21,44$ $21$ $12,56,32,29$ $5,17,21$ $10,12,44$ $44$ $56,32,29$ $5,17,21,44$ $10,12,56$ $56$ $32,29$ $5,17,21,44,56$ $10,12,32$ $-$ $29$ $5,17,21,44,56,EOF$ 此时，在工作区 WA 中选不出新的 miniMax 记录，得到一个初始归并段 $\\{5,17,21,44,56\\}$，工作区 WA 非空，重新选择 miniMax 记录，以继续获得初始归并段 输出文件 FO 工作区 WA miniMax 记录 输入文件 FI $-$ $10,12,32$ $10$ $29$ $10$ $29,12,32$ $12$ $-$ $10,12$ $29,32$ $29$ $-$ $10,12,29$ $32$ $32$ $-$ $10,12,29,32$ $-$ $-$ $-$ $10,12,29,32,EOF$ $-$ $-$ $-$ 此时，得到另一个初始归并段 $\\{10,12,29,32\\}$，工作区 WA 为空，算法终止 得到全部的初始归并段 $\\{5,17,21,44,56\\}$、 $\\{10,12,29,32\\}$ 【最佳归并树】文件经过置换选择排序后，得到的是长度不等的初始归并段，为使 I/O 次数最小，那么就需要合理的组织长度不等的初始归并段的归并顺序 将霍夫曼树的思想推广到 $k$ 叉树的情形，在归并树中，让记录数最少的初始归并段先归并，记录数多的初始归并段最晚归并，即可建立总 I/O 次数最少的最佳归并树 若初始归并段不足以形成一棵严格 $k$ 叉树，需要添加长度为 $0$ 的虚段 设度为 $0$ 的结点有 $n_0$ 个，度为 $k$ 的结点有 $n_k$ 个，则对于严格 $k$ 叉树有 $n_0=(k-1)n_k+1$，由此可得： n_k=\\frac{n_0-1}{k-1}若 $(n_0-1)\\%(k-1)=0$，则说明这 $n_0$ 个叶结点(初始归并段)正好可以构成 $k$ 叉归并树，此时内结点有 $n_k$ 个 若 $(n_0-1)\\%(k-1)=u\\neq 0$，则说明这 $n_0$ 个叶结点中有 $u$ 个多余，不能包含在 $k$ 叉树中，为构造包含所有 $n_0$个初始归并段的 $k$ 叉归并树，应在原有 $n_k$ 个内结点的基础上再增加 $1$ 个内结点，代替一个叶结点的位置，被代替的叶结点再加上多出的 $u$ 个叶结点（$k-u-1 $个空归并段），即可建立归并树 如下图，用 $8$ 个归并段构造 $3$ 叉树，由于有： (n_0-1)\\%(k-1)=(8-1)\\%(3-1)=1\\neq 0说明了 $7$ 个归并段刚好构成一棵严格 $3$ 叉树，为此，将叶子 $5$ 变为一个内结点，再添加 $3-1-1=1$ 个空归并段，即可构成一棵严格 $k$ 叉树","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"Linux 的进程管理","slug":"51.Linux的进程管理","date":"2018-07-22T10:52:00.000Z","updated":"2022-06-22T17:38:22.515Z","comments":true,"path":"linux/2ccadbc4.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/2ccadbc4.html","excerpt":"【signal 信号】对于一个进程来说，通过给予该进程一个信号（signal），可以告知该进程要做什么 通过 man7 signal 可以查看 Linux 中支持的所有 signal 信号，常见的信号如下表","text":"【signal 信号】对于一个进程来说，通过给予该进程一个信号（signal），可以告知该进程要做什么 通过 man7 signal 可以查看 Linux 中支持的所有 signal 信号，常见的信号如下表 代号 名称 内容 1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置文件，类似重新启动 2 SIGINT 相当于用键盘输入 [Ctrl]+[C] 来中断进程 9 SIGKILL 强制中断进程，尚未完成的部分会有临时文件产生 15 SIGTERM 以正常的结束进程来终止该进程 17 SIGSTOP 相当于用键盘输入 [Ctrl]+[Z] 来暂停进程 【kill 命令】在 Linux 的工作管理 中，介绍过使用 kill 命令进行工作管理，实际上，kill 命令也可用于进程管理，其语法格式为：kill -signal PID 如下图所示，使用 ps 命令找出 syslog 这个进程的 PID 后，再用 kill 传送信号，使得 syslog 重新读取配置文件，之后使用 tail 命令查看日志文件，可以发现其重新启动过 【killall 命令】kill 命令每次都需要加上 PID 或者 job number，因此 kill 命令通常要搭配 ps、grep 等命令使用 为简化操作，有了 killall 命令，其可以利用执行命令的名称来给予信号，命令格式为：killall [选项] -signal 命令名 常见的选项有： -i：交互式的，例如若需要删除时会给予用户提示 -I：命令名可忽略大小写","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 的工作管理","slug":"50.Linux的工作管理","date":"2018-07-22T08:20:00.000Z","updated":"2022-06-21T11:15:48.770Z","comments":true,"path":"linux/d133282e.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/d133282e.html","excerpt":"【工作管理的概念】工作管理（Job Control）是在登录系统取得 Bash Shell 后，在单一终端机下同时进行多个工作的行为管理 在进行工作管理的行为中，其实每个工作都是目前 Bash 的子进程，即彼此之间存在相关系，也就是说，无法以工作管理的方式由 tty1 的环境去管理 tty2 的 Bash","text":"【工作管理的概念】工作管理（Job Control）是在登录系统取得 Bash Shell 后，在单一终端机下同时进行多个工作的行为管理 在进行工作管理的行为中，其实每个工作都是目前 Bash 的子进程，即彼此之间存在相关系，也就是说，无法以工作管理的方式由 tty1 的环境去管理 tty2 的 Bash 假设只存在一个终端，那么称可以出现提示符并允许操作的环境就称为前台（Foreground），其他的工作就放入后台（Background）去暂停（Stop）或运行（Running），且运行过程中无法使用 [Ctrl]+[C] 来终止，此外，放入后台的工作在运行时必须不能与用户互动 【工作后台执行】在只有一个 Bash 的环境下，若想同时进行多个工作，那么可以将某些不用与用户互动的工作于后台运行，让我们可以继续操作前台的工作 在输入一个命令后，只需要在命令最后加上一个 &amp;，此时 Bash 会给予该命令一个工作号码（job number），然后就会将整个工作丢到后台运行，用户可以继续进行前台操作 如下图所示，[1] 是给予的 job number，6160 是该命令所触发的 PID 当后台的某项工作完成后，此时在前台输入任何命令，都会弹出工作完成的提示 如下图所示，当后台工作完成后，会说明已完成，同时还会显示所执行的命令串 需要注意的是，对于后台运行的工作，当其有标准输出 stdout 和标准错误输出 stderr 时，其数据依然会输出到屏幕上，而后台工作又无法使用 [Ctrl]+[C] 来停止，这就使得屏幕不可避免的出现显示混乱，因此，常使用数据流重定向来将输出数据传到某个文件中 【暂停当前工作】当某项工作正在进行时，由于某种原因需要暂停该工作，此时可以使用 [Ctrl]+[Z] 来将工作暂停，并放于后台中 【查看后台工作状态】使用 jobs 命令可以查看当前后台有多少工作在运行，其命令格式为：jobs [选项] 常见选项有： -l：除列出 job number 与命令串外，同时列出 PID -r：仅列出正在后台运行的工作 -s：仅列出正在后台暂停的工作 需要注意的是，对于 job number 来说，其后跟的 + 代表最近被放入后台的 job number，- 代表最近最后第二个放入到后台的 job number，当超过最后第三个及以后的工作时，就不会有 +/- 的存在 【后台工作提前】使用 fg 命令可将后台正在处理的工作提前，其命令格式为：fg %job_number，当直接使用 fg 命令时，会默认提前最近被放入后台的工作 【暂停工作改为运行】对于在后台中暂停的工作，可以使用 bg 命令改为运行中，其命令格式为：bg %job_number，当直接使用 bg 命令时，会默认提前最近被放入后台的工作 【删除后台工作】使用 kill 命令可以删除后台的工作，其命令格式为：kill -signal %job_number 其中，-signal 为给予该工作的一个信号，可以使用 kill -l 来查看当前可使用的信号，常见的信号有： -1：重新读取一次参数的配置文件 -2：与键盘输入 [Ctrl]+[C] 进行一样的操作 -9：强制删除一个工作 -15：以正常的程序方式终止一项工作","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 的进程查看","slug":"49.Linux的进程查看","date":"2018-07-21T07:18:00.000Z","updated":"2022-11-07T14:39:14.663Z","comments":true,"path":"linux/852cfab6.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/852cfab6.html","excerpt":"【ps 命令】命令格式ps 命令可用于查看当前系统正在运行的进程，其命令格式为：ps [选项]","text":"【ps 命令】命令格式ps 命令可用于查看当前系统正在运行的进程，其命令格式为：ps [选项] 常见的选项有： -A：列出当前终端上的所有进程，包括其他用户的进程 -a：列出不与当前终端有关的所有进程 -u：显示面向用户的格式，包括用户名、CPU、内存使用情况等 -x：常与 -a 选项一起使用，列出后台进程的信息 -l：将 PID 的信息较为详细的列出 -j：以工作的格式列出 -f：显示进程的所有信息 查看与当前环境相关的进程使用 ps -l 仅会列出与当前操作环境有关的进程，即最上层的父进程是当前的 Shell，而没有扩展到 init 这个进程中 使用 ps -l 显示出来的数据有： F：进程标志，说明进程的权限，为 4 说明进程权限为 root，为 1 说明该子进程可复制（fork）而无法实际执行（exec） S：进程状态 R：运行态（Running），进程正在运行 S：休眠态（Sleep），可以被唤醒（signal） D：不可唤醒的休眠态，通常进程在等待 I/O T：终止态（Stop），处于工作控制或除错状态 Z：僵尸态（Zombie），已被终止，但无法被删除至内存外 UID、PID、PPID：进程的 UID 号、PID 号、PPID 号 C：CPU 使用率，单位为百分比 PRI、NI：进程被 CPU 所执行的优先级 ADDR：指出进程在内存的哪个部分，若是在运行的进程会显示 - SZ：该进程用掉多少内存 WCHAN：该进程是否处于运行中，若是在运行的进程会显示 - TTY：该进程在哪个终端机上运行，若与终端机无关则显示 ?，若是本机上的程序会显示 tty1~tty6，若是由网络连接进主机的进程会显示 pts/0 等 TIME：该进程实际花费 CPU 运行的时间 CMD：造成该进程的触发命令 查看所有进程数据使用 ps -lA 可以列出所有的进程，其显示的每个字段与 ps -l 的输出情况相同 此外，还可以使用 ps aux 来列出所有的进程，其显示会依照进程的 PID 排序来显示，且其输出字段与 ps -l 的输出情况有所不同 ps aux 显示出来的数据有： USER：该进程所属的用户 PID：该进程的 PID 号 %CPU：该进程所占用的 CPU 资源百分比 %MEM：该进程所占用的物理内存百分比 VSZ：该进程使用掉的虚拟内存量，单位为 KB RSS：该进程占用的固定内存量，单位为 KB TTY：该进程在哪个终端机上运行，若与终端机无关则显示 ?，若是本机上的程序会显示 tty1~tty6，若是由网络连接进主机的进程会显示 pts/0 等 STAT：该进程目前的状态，状态显示与 ps -l 的 S 标识相同（R/S/T/Z） START：该进程被触发启动的时间 TIME：该进程实际花费 CPU 运行的时间 COMMAND：造成该进程的触发命令 【top 命令】相较于 ps 命令是选取一个时间点的进程状态来进行展示，top 命令则是持续监测进程的运行状态，其命令格式为：top [选项] 常见选项有： -d：后接秒数，即整个进程界面更新的秒数，默认为 5 秒 -b：以批次的方式执行 top，通常搭配数据流重定向来将批处理结果输出为文件 -n：后接数字，与 -b 搭配，即需要几次 top 的输出结果 -p：后接 PID 号，指定查看该 PID 所对应的进程运行状态 在 top 的执行过程中，可以使用如下的按键命令： ?：显示在 top 可以输入的按键命令 P：按进程的 CPU 使用资源排序 M：按进程的内存使用资源排序 N：按进程的 PID 号排序 T：按进程使用的 CPU 时间累积 TIME+ 来排序 k：给予某个 PID 一个 signal 信号 r：给予某个 PID 重新制定一个 nice 值 q：离开 top 【pstree 命令】pstree 命令用于显示当前系统的进程树，其命令格式为：pstree [选项] 常见的选项有： -A：各进程树之间的连接以 ASCII 字符连接 -U：各进程树之间的连接以 UTF-8 字符连接 -p：同时列出各进程的 PID -u：同时列出各进程的所属账号 【pidof】pidof 命令用于找出某个正在执行的进程的 PID，其命令格式为：pidof [选项] 进程名 常见的选项有： -s：仅列出一个 PID -x：同时列出该进程可能的 PPID 那个进程的 PID","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 中的进程","slug":"48.Linux中的进程","date":"2018-07-21T05:57:00.000Z","updated":"2022-06-16T14:17:17.387Z","comments":true,"path":"linux/cbc4b5af.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/cbc4b5af.html","excerpt":"【程序与进程】在 Linux 中，程序一般放置于磁盘中，然后通过用户的执行来触发，触发后会加载到内存中称为一个个体，这个个体即被称为进程 为了让系统可对进程进行管理，系统会给予这个进程的触发者的权限与属性，并包括进程所需要的脚本、文件数据等，最后再给予一个 PID，系统会根据 PID 来判断该进程是否具有权限进行工作","text":"【程序与进程】在 Linux 中，程序一般放置于磁盘中，然后通过用户的执行来触发，触发后会加载到内存中称为一个个体，这个个体即被称为进程 为了让系统可对进程进行管理，系统会给予这个进程的触发者的权限与属性，并包括进程所需要的脚本、文件数据等，最后再给予一个 PID，系统会根据 PID 来判断该进程是否具有权限进行工作 需要注意的是，由进程衍生出来的其他进程在一般状态下，也会沿用该进程的相关权限 【父进程与子进程调用流程】在 Shell 脚本的编写原则与执行 中，简单的介绍过 Linux 中的父进程与子进程，他们之间最大的复杂点在于进程间的调用 Linux 中进程调用被称为 fork-and-exec 流程，进程会通过父进程以 fork 的方式产生一个一模一样的子进程，然后被复制出来的子进程会以 exec 的方式来加载实际要进行的进程，最终形成一个子进程 如下图所示，系统先以 fork 的方式复制一个与父进程相同的暂存进程，这个进程与父进程的唯一区别是 PID 不同，同时多一个 PPID 的参数，即父进程的 PID，之后暂存进程以 exec 的方式加载实际要执行的程序","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 例行性工作调度","slug":"47.Linux例行性工作调度","date":"2018-07-18T07:24:00.000Z","updated":"2022-06-16T09:41:03.455Z","comments":true,"path":"linux/91b1d33b.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/91b1d33b.html","excerpt":"【例行性工作调度】在 Linux 中，存在两种工作调度方式，一种是例行性的，即每隔一定周期执行的工作，另一种是突发性的，即这次工作完成后就结束调度 在 Linux 中，例行性工作调度依靠 Crond 服务的支持，通过 crontab 命令来实现","text":"【例行性工作调度】在 Linux 中，存在两种工作调度方式，一种是例行性的，即每隔一定周期执行的工作，另一种是突发性的，即这次工作完成后就结束调度 在 Linux 中，例行性工作调度依靠 Crond 服务的支持，通过 crontab 命令来实现 与 at 命令类似，考虑到安全性的问题，crontab 命令也进行了限制 /etc/cron.allow：可以使用 crontab 的账号写入其中 /etc/cron.deny：不可以使用 crontab 的账号写入其中 同样，以优先级来说，/etc/cron.allow 的优先级要高于 /etc/cron.deny，一般来说，从判断上来考虑，这两个文件只需要保留一个即可，以免影响在设置上的判断 当用户使用 crontab 命令新建工作调度后，该项工作就会记录在 /var/spool/cron/ 中，且是以账号作为判别依据的 【crontab 命令】crontab 命令为：crontab [选项]，常见选项如下 -u：后接 username，只有 root 用户才可进行该任务，即帮助账号名为 username 的用户新建、删除 Crontab 工作调度 -e：编辑 Crontab 的工作内容 -l：查阅 Crontab 的工作内容 -r：删除所有的 Crontab 的工作内容，若要仅删除一项，使用 -e 选项编辑即可 在 Crontab 中，每行都代表一项工作，如下例，前五个字段分别代表分钟、小时、日期、月份、周，后续的字段为要执行的工作命令 12# 以 alex_mcavoy 的身份每天在 12:00 发信给自己0 12 * * * mail alex_mcavoy -s \"at 12:00\" &lt; /home/alex_mcavoy/.bashrc 对于前五个时间字段来说，其数字范围如下表 意义 范围 分钟 0 ~ 59 小时 0 ~ 23 日期 1 ~ 31 月份 1 ~ 12 周几 0 ~ 7（0、7 均代表周天） 此外，还有一些辅助字符 字符 代表意义 实例 实例含义 * 任何时刻均接受 0 12 * * * command 每天的 12:00都执行后续命令 , 分隔时段 0 3,6 * * * command 每天的 3:00 和 6:00都执行后续命令 - 时间范围 20 8-12 * * * command 每天的 8 点到 12 点每隔 20 分钟都执行一次后续命令 /num 每隔 num 单位间隔 */5 * * * * command 每隔 5 分钟执行一次后续命令 【/etc/crontab 配置文件】crontab -e 是针对用户的 Cron 来设计的，其实质上是对 /usr/bin/crontab 这个文件进行修改 若是系统的例行性工作，则需要对 /etc/crontab 进行修改，Cron 服务会每分钟读取一次该文件的数据内容，从而进行系统的例行性工作调度 【anacron 服务】若 Linux 主机是 24 小时全天午休运行的服务器，那么仅需要 atd、crond 这两个服务即可管理工作调度 若 Linux 主机并非是 24 小时无间断开机，那么就需要 anacron 服务了 anacron 服务并不能指定何时执行某项任务，而是以天为单位，或开机后立刻进行 anacron 的操作，去检测停机期间应该进行但是没有进行的 Crontab 任务，并将该任务执行 anacron 服务会去分析当前时间与时间记录文件所记载的上次执行 anacron 的时间，若比较两者后发现有区别，那就是在某些时刻没有进行 Crontab 任务，此时 anacron 就会开始执行未进行的 Crontab 任务","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 单一工作调度","slug":"46.Linux单一工作调度","date":"2018-07-18T05:46:00.000Z","updated":"2022-06-16T09:40:57.326Z","comments":true,"path":"linux/72678716.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/72678716.html","excerpt":"【单一工作调度】在 Linux 中，存在两种工作调度方式，一种是例行性的，即每隔一定周期执行的工作，另一种是突发性的，即这次工作完成后就结束调度 在 Linux 中，单一工作调度依靠 atd 服务的支持，通过 at 命令来实现","text":"【单一工作调度】在 Linux 中，存在两种工作调度方式，一种是例行性的，即每隔一定周期执行的工作，另一种是突发性的，即这次工作完成后就结束调度 在 Linux 中，单一工作调度依靠 atd 服务的支持，通过 at 命令来实现 at 命令用于生成要运行的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，之后该工作便等待 atd 这个服务的取用与执行 考虑安全性的问题，并非所有用户都可以使用 at 工作调度，可以利用 /etc/at.allow 和 /etc/at.deny 这两个文件来对 at 进行使用限制 寻找 /etc/at.allow 这个文件，写在这个文件内的用户才能使用 at 命令 若 /etc/at.allow 不存在，就寻找 /etc/at.deny 文件，没有在该文件中声明的用户均可以使用 at 命令 若两个文件均不存在，则只有 root 用户可以使用 at 命令 【at 命令】at 命令的运行十分简单，其命令格式为：at [选项] TIME 其中，TIME 为时间格式，定义什么时候要执行 at 这项工作的时间，格式如下表： 格式 含义 实例 HH:MM 在今日的 HH:MM 时刻执行，若已超过该时刻，则明日该时刻执行 04:00 HH:MM YYYY-MM-DD 在 YYYY 年 MM 月 DD 日 HH:MM 执行 04:00 2018-07-18 HH:MM[am&#124;pm] [Month] [Date] 在 Month 月 Date 日的 HH:MM 执行 04pm March 17 HH:MM[am&#124;pm] + number [minutes&#124;hours&#124;days&#124;weeks] 在某个时间点再加 number 分钟/小时/天/周后执行，时间点为 now 时，表示当前时刻 04pm + 3 days 常见选项如下： -m：当工作完成后，即使没有输出信息，也以 email 通知用户该工作已经完成 -l：列出目前系统上所有该用户的 at 调度信息 -d：取消一个在 at 调度中的工作 -v：使用较为明显的时间格式列出 at 调度的任务列表 -c：后接一个号码，可以列出该号码对应工作的实际命令内容 当输入完 at 命令后，会进入一个 At Shell 环境让用户输入要执行的工作命令，在输入完成后，键入 [Ctrl]+[d] 即可退出该环境 需要注意的是，在这个 At Shell 环境中，其执行与终端机无关，所有的标准输出 stdout 和标准错误输出 stderr 都会被传送到执行者的 mailbox 中，若想在终端中看到信息，可以使用数据流重定向的方式来查看","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 中的 PAM 模块","slug":"45.Linux中的PAM模块","date":"2018-07-17T14:02:00.000Z","updated":"2022-06-15T16:16:09.557Z","comments":true,"path":"linux/618dce37.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/618dce37.html","excerpt":"【PAM 模块】在过去，当想要对用户进行验证时，需要用户输入用户名、密码，然后通过自行编写的程序来判断账号密码是否匹配 因此，经常要使用不同的机制来判断账号密码，这使得一台主机上有多个不同的认证系统，可能造成账号密码不同步的验证问题","text":"【PAM 模块】在过去，当想要对用户进行验证时，需要用户输入用户名、密码，然后通过自行编写的程序来判断账号密码是否匹配 因此，经常要使用不同的机制来判断账号密码，这使得一台主机上有多个不同的认证系统，可能造成账号密码不同步的验证问题 为解决这个问题，有了嵌入式模块（Pluggable Authentication Modules，PAM）机制，其是一套提供一连串验证机制的 API，只需要用户将验证阶段的需求告知 PAM 后，PAM 就能回报用户验证的结果 【PAM 调用流程】在 Linux 中，PAM 通过一个与程序相同文件名的配置文件夹来进行一连串的认证分析需求 以 passwd 命令为例，当执行该命令后，其调用 PAM 的流程如下： 用户开始执行 /usr/bin/passwd 这个程序，并输入密码 passwd 调用 PAM 模块进行验证 PAM 模块会到 /etc/pam.d/ 中寻找与 passwd 同名的程序的配置文件 根据 /etc/pam.d/passwd 内的设置，引用相关的 PAM 模块逐步进行验证分析 将验证结果回传给 passwd 这个命令 passwd 命令会根据 PAM 回传结果决定下一个操作，即通过验证或重新输入密码 【PAM 模块的配置文件】文件信息在 Linux 中，与 PAM 模块相关的文件信息如下表： 模块 功能 /etc/pam.d/* 每个命令的 PAM 配置文件 /lib/security/* PAM 文件的实际存放目录 /etc/security/* 其他 PAM 环境的配置文件 /usr/share/doc/pam-* 详细的 PAM 说明文件 配置信息下面以 /etc/pam.d/passwd 为例，说明 PAM 配置文件中的内容 在 PAM 配置文件中，除第一行声明 PAM 版本外，其他任何以 # 开头的都是批注，同时，每一行都是一个独立的验证流程，可分为验证类别（type）、控制标志（flag）、PAM 模块与参数这三个字段 1.验证类别 验证类别主要分为四种： auth：认证，主要用来检验用户的身份验证，该类通常需要密码来进行校验，后接的模块一般用来检验用户身份 account：账号，主要用来在授权时检验用户是否具有正确的权限 session：会话，管理用户在本次登录期间 PAM 所给予的环境设置，通常用于记录用户登录与注销信息 password：密码，主要用于修改密码时提供验证 2.控制标志 控制标志，简单来说是验证通过的标准，这个字段用于管控该验证的放行方式，主要分为四种： required：验证若成功，则带有 success 的标志；若失败，则带有 failure 的标志，但无论成功与失败，都会继续后续的验证流程，有利于数据的日志写入 requisite：验证若成功，则带有 success 的标志，并继续后续验证流程；若失败，则立刻回报原程序带有 failure 的标志，并终止后续验证流程 sufficient：验证若成功，则立刻回报原程序带有 success 的标志，并终止后续验证流程；若失败，则带有 failure 的标志，并继续后续验证流程 optional：带有该控制标志的模块，大多用于显示信息 PAM 控制标志所造成的回报流程如下图： 3.PAM 模块与参数 该行验证过程中，所采用的 PAM 模块与参数，具体的 PAM 模块位于 /lib/security/* 中","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 的用户身份切换","slug":"44.Linux的用户身份切换","date":"2018-07-17T07:56:00.000Z","updated":"2022-06-15T09:12:42.970Z","comments":true,"path":"linux/5184fa7e.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/5184fa7e.html","excerpt":"【用户身份切换】在 Linux 中，一般都是使用普通用户来登录系统的，当需要进行系统维护或软件更新时，才会转为 root 用户来操作 将普通用户转为 root 用户主要有两种方式：","text":"【用户身份切换】在 Linux 中，一般都是使用普通用户来登录系统的，当需要进行系统维护或软件更新时，才会转为 root 用户来操作 将普通用户转为 root 用户主要有两种方式： 使用 su 命令，直接将身份变为 root，但该命令需要使用 root 密码 使用 sudo 命令，执行 root 的命令串，但 sudo 需要提前设置且需要用户输入自己的密码 【su 命令】su 命令可以实现任何用户身份间的切换，命令格式为：su [选项] [username] 常见选项有： -l：后跟 username，即要切换的用户账号 -m：表示使用目前的环境设置，不读取新用户的配置文件 -c：后接命令串，仅执行一次命令 需要注意的是，单纯输入 su 并输入 root 密码后，虽然切换到了 root 身份，但由于读取变量设置方式为 non-login shell 方式，此时如 PATH 等环境变量并没有被改变 因此，在使用 su 命令切换 root 身份时，一般常采用 su - 以 login shell 的方式切换成 root 用户 此外，在使用 root 用户切换成任何用户时，均不需要输入用户密码，若想退出 su 环境，输入 exit 命令即可 【sudo 命令】当主机是多人管理的环境时，若大家都需要使用 su 命令来切换 root 身份，那么就需要这些人都知道 root 密码，密码太多可能会流传出去，存在安全隐患 sudo 命令，可以以普通用户的身份去执行使用 root 身份来执行的命令，但该命令并非所有用户都可执行，默认情况下，系统仅限 root 用户来执行 sudo，因此，若想让某些用户能够执行 sudo 的话，需要使用 root 用户来对 /etc/sudoers 文件进行更改，将可以使用 sudo 命令的用户添加进该文件中 sudo 命令格式为：sudo [-b] [-u username] 命令，其中各选项含义如下 -b：后续的命令让系统自动执行，不与当前 Shell 产生影响 -u：后接欲切换的用户，若无该项则代表切换身份为 root 用户","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 中 ACL 的使用","slug":"43.Linux中ACL的使用","date":"2018-07-17T07:33:00.000Z","updated":"2022-06-15T07:53:32.820Z","comments":true,"path":"linux/19b4c988.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/19b4c988.html","excerpt":"【访问控制列表 ACL】访问控制列表（Accesss Control List，ACL）在 Linux 中用于设定用户针对文件的权限设置 在传统的权限设置中，用户对文件只有三种身份，属主 owner、属组 group、其他 othres，每种用户身份拥有读 read、写 write、执行 execute 三种权限，但在实际应用中，需要对文件或目录进行具体的设置，此时就需要使用 ACL 来进行设置","text":"【访问控制列表 ACL】访问控制列表（Accesss Control List，ACL）在 Linux 中用于设定用户针对文件的权限设置 在传统的权限设置中，用户对文件只有三种身份，属主 owner、属组 group、其他 othres，每种用户身份拥有读 read、写 write、执行 execute 三种权限，但在实际应用中，需要对文件或目录进行具体的设置，此时就需要使用 ACL 来进行设置 ACL 可以提供以下支持： 用户 user：针对用户来设置权限 用户组 group：针对用户组来设置权限 默认属性 mask：在某目录下新建文件或目录时设置默认权限 【setfacl 命令】setfacl 命令用于设置某个文件或目录的 ACL 设置项，其命令格式为：setfacl [选项] filename 常见选项有： -m：后跟 ACL 参数，用于设置 ACL 参数，不可与 -x 选项合用 -x：后跟 ACL 参数，用于删除 ACL 参数，不可与 -m 选项合用 -R：递归设置 ACL 参数，即子目录及文件同样会被设置 ACL 参数 -d：设置默认 ACL 参数，只对目录有效，在该目录新建的数据都会引用该默认值 -b：删除所有 ACL 参数 -k：删除默认 ACL 参数 在设置 ACL 参数时，一般采用 u:用户:权限、g:用户组:权限、o:其他:权限 的形式设置，当一个文件或目录设置 ACL 参数后，其权限部分会多一个 + 号，代表该文件或目录经过了 ACL 设置，此时看到的权限与实际权限可能存在误差 【getfacl 命令】在通过 setfacl 命令设置 ACL 参数后，看到的权限与实际权限可能存在误差，此时若想查看文件或目录的实际权限，可以通过 getfacl 命令来取得其具体的 ACL 设置项，命令格式为：getfacl filename","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"败者树","slug":"basic/02.sort/16.败者树","date":"2018-07-17T05:17:26.000Z","updated":"2021-09-26T09:07:03.679Z","comments":true,"path":"oi-acm/basic/sort/35decf94.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/35decf94.html","excerpt":"【引入】在进行外部排序时，当其进行内部归并时，要在 $k$ 个元素中选择关键字最小的记录需要比较 $k-1$ 次，每趟归并 $n$ 个元素需要做 $(n-1)(k-1)$ 次比较，$S$ 趟归并总共需要比较的次数为： S(n-1)(k-1)=\\left \\lceil log_kr \\rceil \\right.(n-1)(k-1)= \\frac{\\left \\lceil log_2r \\rceil \\right.(n-1)(k-1)} {\\left \\lceil log_2k \\rceil \\right.}在 外部排序 中讨论过，增大归并路数 $k$ 或减少初始归并段个数 $r$，都可以减少归并趟数 $S$，进而减少 I/O 次数，以提高外部排序速度","text":"【引入】在进行外部排序时，当其进行内部归并时，要在 $k$ 个元素中选择关键字最小的记录需要比较 $k-1$ 次，每趟归并 $n$ 个元素需要做 $(n-1)(k-1)$ 次比较，$S$ 趟归并总共需要比较的次数为： S(n-1)(k-1)=\\left \\lceil log_kr \\rceil \\right.(n-1)(k-1)= \\frac{\\left \\lceil log_2r \\rceil \\right.(n-1)(k-1)} {\\left \\lceil log_2k \\rceil \\right.}在 外部排序 中讨论过，增大归并路数 $k$ 或减少初始归并段个数 $r$，都可以减少归并趟数 $S$，进而减少 I/O 次数，以提高外部排序速度 对于增加归并路数 $k$ 来说，$\\frac{k-1}{\\left \\lceil log_2k \\rceil \\right.}$ 随着 $k$ 增长而增长，因此内部归并时间随着 $k$ 的增长而增长，这抵消了由于增大 $k$ 而减少外存访问次数所得到的效益，故而不能使用普通的内部归并排序算法 为使内部归并不受 $k$ 增大的影响，引入了败者树 【败者树】败者树是树形选择排序的一种变体，可视为一棵完全二叉树 $k$ 个叶结点分别存放 $k$ 个归并段在归并过程中当前参加比较的记录，内部结点用于记录左右子树中的失败者，而让胜者继续向上进行比较，直到根结点 对于比较的两个数，大者为失败者，小者为胜利者，根结点指向的数为最小数 如下图所示，初始时，叶结点 $b_3$ 与 $b_4$ 比较，$b_4$ 是败者，段号 $4$ 写入父结点 $ls[4]$，叶结点 $b_1$ 与 $b_2$ 比较，$b_2$ 是败者，段号 $2$ 写入父结点 $ls[3]$ 之后，$b_3$ 与 $b_4$ 的胜者 $b_3$ 与叶结点 $b_0$ 比较，$b_0$ 是败者，段号 $0$ 写入父结点 $ls[2]$ 最后两个胜者 $b_3$ 与 $b_1$ 比较，$b_1$ 是败者，段号 $1$ 写入父结点 $ls[1]$，$b_3$ 是胜者，段号 $3$ 写入根结点 $ls[0]$ 此时，根结点 $ls[0]$ 所指的段的关键字最小，将 $b_3$ 中的 $6$ 输出后，将下一关键字 $15$ 填入 $b_3$，继续进行上述过程 【性能分析】$k$ 路归并的败者树深度为 $\\left \\lceil log_2k \\rceil \\right.$，因此 $k$ 个记录中选择最小关键字，最多需要 $\\left \\lceil log_2k \\rceil \\right.$ 次比较，因此总的比较次数为： S(n-1)\\left \\lceil log_2k \\rceil \\right.=\\left \\lceil log_kr \\rceil \\right.(n-1)\\left \\lceil log_2k \\rceil \\right.= (n-1)\\left \\lceil log_2r \\rceil \\right.可见，使用败者树后，内部归并的比较次数与 $k$ 无关，因此，只要内存空间允许，增大归并路数 $k$ 将有效地减少归并树的高度，从而减少 I/O 次数，提高外部排序的速度 值得说明的是，归并路数 $k$ 并非越大越好，归并路数 $k$ 增大时，相应地需要增加输入缓冲区的个数，若可供使用的内存空间不变，势必要减少输入缓冲区的容量，使得内存、外存交换数据的次数增大，当 $k$ 值过大时，虽然归并趟数会减少，但读写外存的次数仍会增大","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"外部排序","slug":"basic/02.sort/15.外部排序","date":"2018-07-15T05:17:26.000Z","updated":"2021-09-26T09:12:35.745Z","comments":true,"path":"oi-acm/basic/sort/c11bef8.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/c11bef8.html","excerpt":"【概述】当对大文件进行排序时，由于文件中的记录很多，信息量庞大，无法将整个文件复制进内存中进行排序，因此需要将待排序记录存储在外存上，排序时再将记录一部分一部分的调入内存进行排序，在排序过程中需要多次进行内存和外存的交换 在 OS 中，是按块对磁盘信息进行读写的，由于磁盘读写的时间远超过内存运算时间，因此在外存排序过程中，时间代价主要考虑访问磁盘的次数，即 I/O 次数","text":"【概述】当对大文件进行排序时，由于文件中的记录很多，信息量庞大，无法将整个文件复制进内存中进行排序，因此需要将待排序记录存储在外存上，排序时再将记录一部分一部分的调入内存进行排序，在排序过程中需要多次进行内存和外存的交换 在 OS 中，是按块对磁盘信息进行读写的，由于磁盘读写的时间远超过内存运算时间，因此在外存排序过程中，时间代价主要考虑访问磁盘的次数，即 I/O 次数 【方法】外部排序通常采用归并排序法，其包括两个相对独立的阶段： 根据内存缓冲区大小，将外存上的文件分为若干长度为 $l$ 的子文件，依次读入内存按照内部排序方法进行排序，排序完成后再写回内存，这些有序子文件称为归并段 对归并段逐趟进行归并，使归并段逐小到大，直到得到整个有序文件为止 在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果段同时放入内存，因此要不停的将数据读出写入磁盘，一般情况下有： 外部排序时间 = 内部排序时间 + 外存信息读写时间 + 内部归并时间显然，外存读写时间远大于内部排序时间与内部归并时间，因此应着力减少 I/O 次数 【优化方法】一般来说，对于 $r$ 个初始归并段，做 $k$ 路平衡归并，归并树可用严格 $k$ 叉树(只有度为 $0$ 和度为 $k$ 的 $k$ 叉树)来表示 第一趟将 $r$ 个初始归并段归并为 $\\left \\lceil \\frac{r}{k} \\rceil \\right.$ 个归并段，之后每趟归并将 $m$ 个归并段归并为 $\\left \\lceil \\frac{m}{k} \\rceil \\right.$ 个归并段，直到形成一个大的归并段为止 而 由于树的高度满足： 树的高度 = \\left \\lceil log_kr \\rceil \\right. = 归并趟数 S因此，只要增大归并路数 $k$ 或减少初始归并段个数 $r$，都能减少归并趟数 $S$，进而减少读写磁盘次数，以提高外部排序速度","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"B+ 树与 B* 树","slug":"data-structure/09.index-method/07.B+树与Bstar树","date":"2018-07-15T03:21:13.000Z","updated":"2021-09-24T14:02:38.105Z","comments":true,"path":"oi-acm/data-structure/index-method/19292343.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/19292343.html","excerpt":"【B+ 树】结构B+ 树是 B 树的变形树，严格意义上来讲，其已经不是一棵树了，其常用于数据库中","text":"【B+ 树】结构B+ 树是 B 树的变形树，严格意义上来讲，其已经不是一棵树了，其常用于数据库中 在 B 树中，每一元素在该树中只出现一次，有可能在终端结点上，也有可能在分支结点上，而在 B+ 树中，出现在分支结点中的元素会被当作他们在该分支结点位置的中序后继者中再次列出，此外，每一叶结点都会保存一个指向后一叶结点的指针 一棵 $m$ 阶的 B+ 树满足以下条件： 每个分支结点最多有 $m$ 棵子树 非叶根结点至少有 $2$ 棵子树，其他每个分支结点至少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil$ 棵子树 结点的子树个数与关键字相等 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排序，且相邻叶结点按大小顺序相互链接 所有分支结点中仅包含其各个子结点中关键字的最大值及指向其子结点的指针 如下图，是一个 $3$ 阶 B+ 树，可以看出，分支结点的某个关键字是其子树中最大关键字的副本，且整个 B+ 树具有两个指针： 指向根结点：从根结点开始进行多路查找 指向关键字最小的叶结点：可以进行顺序查找 值得注意的是，只要是随机查找，就从根结点出发，但在分支结点中找到了待查找的关键字，其也只是用于索引，不能提供实际记录的访问，仍需到达包含此关键字的终端结点 与 B 树的区别一棵 $m$ 阶的具有 $n$ 个关键字的 B 与 B+​ 树的差异在于： B 树 B+ 树 子树个数 $n+1 $棵 $n$ 棵 根结点关键字个数范围 $1\\leq n\\leq m-1$ $1\\leq n\\leq m$ 非根结点关键字个数范围 $\\left \\lceil \\frac{m}{2} \\right \\rceil -1 \\leq n\\leq m-1$ $\\left \\lceil \\frac{m}{2} \\right \\rceil\\leq n\\leq m$ 终端结点 终端结点关键字与其他结点关键字不重复 终端结点关键字与其他结点关键字重复（包含所有关键字） 叶结点 为空，表示查找失败 包含信息，非叶结点仅起索引作用 操作 在非叶结点上进行 在叶结点上进行 【B* 树】B* 树是 B+ 树的变形树，其也非严格意义上的树 B* 树是在 B+ 树的基础上进行了改进，即在 B+​ 树的非根和非叶子结点上增加了指向兄弟的指针，且规定非叶结点关键字个数至少为 $\\frac{2}{3}m$，即块的最低使用率为 $\\frac{2}{3}$（B+ 树只有 $\\frac{1}{2}$） 可以看出，B*​ 树分配结点的概率要比 B+ 树低，空间利用率更高","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"Linux 新增与删除用户组","slug":"42.Linux新增与删除用户组","date":"2018-07-14T14:37:00.000Z","updated":"2022-06-13T16:12:39.174Z","comments":true,"path":"linux/63c1fffc.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/63c1fffc.html","excerpt":"【groupadd 命令】groupadd 命令用于新建和给予用户组 GID，其命令格式为：groupadd [选项] 用户组名 常见选项有：","text":"【groupadd 命令】groupadd 命令用于新建和给予用户组 GID，其命令格式为：groupadd [选项] 用户组名 常见选项有： -g：后接 GID，用来将 GID 给予用户组 -r：新建用户组 【groupmod 命令】groupmod 命令用于修改用户组相关参数， 命令格式为：groupmod [选项] 用户组名 常见的选项有： -g：修改用户组的 GID -n：修改用户组的用户组名 【groupdel 命令】groupdel 命令用于删除用户组，命令格式为：groupdel 用户组名 【gpasswd 命令】在 Linux 中，最高权限用户是 root 用户，但在大型系统中，仅有 root 用户来进行管理的话，当某些账号想要加入某个项目时，找不到管理员，会浪费大量的时间 为此，在每个用户组中有一个用户组管理员，这个管理员可以管理哪些账号可以加入、移出用户组，gpasswd 命令就是用于新建用户组管理员的，该命令格式为：gpasswd [选项] 用户组名 常见的选项有： -A：后接用户名，将用户组的主控权交由该组的管理员执行，即设置用户组管理员 -a：后接用户名，将某个账号加入该组中 -d：后接用户名，将某个账号移出该组 -M：后接用 , 分隔的多个用户名，将这些账号都加入该组中 -r：将用户组的密码删除 -R：令用户组的密码失效","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 一般用户的账号数据更改","slug":"41.Linux一般用户的账号数据更改","date":"2018-07-14T11:19:00.000Z","updated":"2022-06-13T14:36:56.596Z","comments":true,"path":"linux/f19514eb.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/f19514eb.html","excerpt":"【用户的账号数据更改】在 Linux 新增与删除用户 中，介绍了使用 useradd、usermod、userdel 等命令，但这些命令都是管理员才能使用的 如果是一般用户，除了使用 passwd 命令修改密码外，还可以使用 finger、chfn、chsh、id 等命令对账号数据进行更改与查询","text":"【用户的账号数据更改】在 Linux 新增与删除用户 中，介绍了使用 useradd、usermod、userdel 等命令，但这些命令都是管理员才能使用的 如果是一般用户，除了使用 passwd 命令修改密码外，还可以使用 finger、chfn、chsh、id 等命令对账号数据进行更改与查询 【finer 命令】finer 命令常用于查询用户相关信息，大多数都是 /etc/passwd 中的数据，其命令格式为：finger [选项] 用户账号名 常见选项有： -s：仅列出用户的账号、全名、终端机代号、登录时间等 -m：禁止对用户账号名进行匹配 -p：省略 .plan、.project、.pgpkey 文件中的内容 可以发现，在 finger 命令给出的信息中，存在 Mail 和 Plan，这两行是用户的邮箱和计划文档，分别对应 /var/spool/mail 中的信箱数据，和 ~/.plan 计划文件数据 若想新建自己的计划文档，使用 echo 命令将计划写入 ~/.plan 中即可 【chfn 命令】chfn 命令可以改变用户账号的一些基本信息，类似于 change finger 的意思，命令格式为：chfn [选项] 用户账号名 常见的选项有： -f：后接用户名 -o：后接办公室房间号 -p：后接办公室电话 -h：后接住宅电话 当不带有任何选项时，将会对用户名、办公室房间号、办公室电话、住宅电话依次进行修改 【chsh 命令】chsh 命令是 change shell 的简写，用于修改当前用户所使用的 Shell，命令格式为：chsh [-ls] 选项含义为： -l：列出目前系统中可用的 Shell，即 /etc/shells 中的内容 -s：后接 Shell 路径，用于修改当前所使用的 Shell 【id 命令】id 命令可以查询某用户或自己的相关 UID、GID 的信息，当省略用户账号名时，会查询当前账户的信息","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 新增与删除用户","slug":"40.Linux新增与删除用户","date":"2018-07-14T10:40:00.000Z","updated":"2022-06-12T17:28:13.500Z","comments":true,"path":"linux/d5d16af5.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/d5d16af5.html","excerpt":"【useradd 命令】在 Linux 中，想要新建一个用户可以使用 useradd 命令，其命令格式为：useradd [选项] 用户账号名 其中，各选项含义如下：","text":"【useradd 命令】在 Linux 中，想要新建一个用户可以使用 useradd 命令，其命令格式为：useradd [选项] 用户账号名 其中，各选项含义如下： -u：后接 UID，直接指定一特定 UID 给新建的账号 -g：后接用户组名，该用户组为账号的初始用户组，会放在 /etc/passwd 的第四个字段中 -G：后接用户组名，该用户组为新建账号还可加入的用户组，会修改 /etc/group 中相应的字段 -M：系统账号默认值，强制执行，不创建用户主文件夹 -m：一般账号默认值，强制执行，创建用户主文件夹 -d：指定某个目录成为主文件夹，而不使用默认值，要求使用绝对路径 -s：后接一个 Shell，默认为 /bin/bash，即 /etc/passwd 的第八个字段 -f：后接密码过期宽限的天数，即 /etc/shadow 的第七个字段，0 为立即失效，-1 为永不失效 -e：后接格式为 YYYY-MM-DD 的日期，会写入 /etc/shadow 的第八个字段，即账号失效日期 可以发现，新建的账户的默认的用户组与账号名相同，这是因为 Linux 系统的私有用户组机制，即系统会创建一个与账号一样的用户组作为初始用户组，且主文件夹权限会设置为 700 实际上，系统已经规定好诸多默认值，可以简单的使用 useradd 用户账号名 来创建用户，这些规定好的默认值可以使用 useradd -D 来进行查看，这个命令实际上是去调用 /etc/defualt/useradd 的数据 各行含义如下： GROUP：新建账号的初始用户组的 GID HOME：用户文件夹的基准目录 INACTIVE：密码过期后是否会失效 EXPIRE：账号失效的日期 SHELL：默认使用的 Shell SKEL：用户主文件夹参考基准目录 CREATE_MAIL_SPOOL：是否创建用户的 mailbox 【passwd 命令】在使用 useradd 命令创建账号后，默认情况下，该账号是被封锁的，需要在设置好密码后才可登录 passwd 命令用于设置账号的密码，该命令格式为：passwd [选项] 账号名，当不加账号名时，修改的是当前用户的密码 常见选项有： -l：lock，会在 /etc/shadow 第二个字段加上 !，使得密码失效 -u：unlock，与 -l 选项相对，使密码解锁 -S：列出密码相关参数，即 /etc/shadow 中的大部分信息 -n：后接多久不可修改密码天数，即 /etc/shadow 的第四个字段 -x：后接多久内必须修改密码天数，即 /etc/shadow 的第五个字段 -w：后接密码过期前警告天数，即 /etc/shadow 的第六个字段 -i：后接密码失效日期，即 /etc/shadow 的第七个字段 —stdin：通过前一个管道数据作为密码输入 需要注意的是，Linux 使用 PAM 模块来管理密码，管理机制写在 /etc/pam.d/passwd 中，而该文件与密码相关的测试模块使用的是 pam_cracklib.so，这个模块会检验密码相关的信息，如果太过简单将不会被采纳 【chage 命令】chage 命令可以修改密码的详细参数，相较于 passwd 命令来说更为简便，命令格式为：chage [选项] 用户账号名 常见选项如下： -l：列出账号的详细密码参数并进行更改 -d：后接最近一次更改密码的日期，即 /etc/shadow 的第三个字段 -m：后接密码最短保留天数，即 /etc/shadow 的第四个字段 -M：后接密码多久必须修改天数，即 /etc/shadow 的第五个字段 -W：后接密码过期前警告天数，即 /etc/shadow 的第六个字段 -I：后接密码失效天数，即 /etc/shadow 的第七个字段 -E：后接账号失效日期，即 /etc/shadow 的第八个字段 【usermod 命令】当使用 useradd 命令时加入了错误的参数，最直接的方式是修改 /etc/passwd 和 /etc/shadow 文件，但 Linux 中提供了 usermod 命令来直接对账号相关数据进行微调，命令格式为：usermod [选项] 账号用户名 常见的选项有： -l：后接账号名，修改账户名，即修改 /etc/passwd 的第一个字段 -u：后接 UID，修改 UID，即修改 /etc/passwd 的第三个字段 -g：后接初始用户组，修改初始用户组，即修改 /etc/passwd 的第四个字段 -c：后接账号说明，修改账号说明，即修改 /etc/passwd 的第五个字段 -d：后接账号主文件夹，修改账号主文件夹，即修改 /etc/passwd 的第六个字段 -s：后接 Shell，修改默认 Shell，即修改 /etc/passwd 的第八个字段 -L：将用户密码冻结，会在 /etc/shadow 第二个字段加上 !，使得密码失效 -U：与 -L 选项相对，使密码解锁 -f：后接密码失效天数，修改密码失效天数，即修改 /etc/shadow 的第七个字段 -e：后接账号失效日期，修改账号失效日期，即修改 /etc/shadow 的第八个字段 -G：后接次要用户组，修改次要用户组，会修改 /etc/group 中的相关数据 -a：与 -G 合用来增加次要用户组 【userdel 命令】userdel 命令用于删除用户相关数据，包括： 用户账号/密码相关参数：/etc/passwd、/etc/shadow 用户组相关参数：/etc/group、/etc/gshadow 用户个人文件数据：/home/用户账号名、/var/spool/mail/用户账号名 该命令格式为：userdel [-r] 用户账号名，其中 -r 选项是连同用户的主文件夹也删除","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 的初始用户组与有效用户组","slug":"39.Linux的初始用户组与有效用户组","date":"2018-07-13T14:51:00.000Z","updated":"2022-06-11T11:40:33.846Z","comments":true,"path":"linux/3a4b8be0.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/3a4b8be0.html","excerpt":"【初始用户组】在 /etc/passwd 文件中，第四列的 GID 就是初始用户组，即用户登录系统时，立刻就拥有该 GID 对应的用户组的相关权限","text":"【初始用户组】在 /etc/passwd 文件中，第四列的 GID 就是初始用户组，即用户登录系统时，立刻就拥有该 GID 对应的用户组的相关权限 【有效用户组】groups 命令当使用 usermod 命令，将某个账号添加到某个用户组后，此时该账号同时支持多个用户组，那么当该账号新建一个文件或目录时，要想知道新文件的用户组是初始用户组还是新添加的用户组，就需要检查有效用户组 groups 命令，可以查看当前用户所支持的所有用户组，其输出的第一个用户组即为有效用户组 newgrp 命令newgrp 命令用于实现有效命令组的切换，其命令格式为：newgrp 用户组名，其中，要求用户组名必须为当前账户中所支持的用户组","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 的账号与用户组","slug":"38.Linux的账号与用户组","date":"2018-07-13T13:33:00.000Z","updated":"2022-06-10T14:50:28.728Z","comments":true,"path":"linux/29296dcc.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/29296dcc.html","excerpt":"【用户标识符】在登录 Linux 时，输入的是账号，但 Linux 主机并不会直接识别账号名称，而是识别一个 ID 号，账号只是为了方便让用户容易记住而已 每个登录的用户至少会获得两个 ID，一个是用户 ID（UserID，简称 UID），一个是用户组 ID（Group ID，简称 GID），账号与 UID、GID 的对应关系，就分别保存在 /etc/passwd 和 /etc/group 中","text":"【用户标识符】在登录 Linux 时，输入的是账号，但 Linux 主机并不会直接识别账号名称，而是识别一个 ID 号，账号只是为了方便让用户容易记住而已 每个登录的用户至少会获得两个 ID，一个是用户 ID（UserID，简称 UID），一个是用户组 ID（Group ID，简称 GID），账号与 UID、GID 的对应关系，就分别保存在 /etc/passwd 和 /etc/group 中 【登录流程】在 Linux 用户输入账号密码后，系统会进行如下处理： 寻找 /etc/passwd 中是否有输入的账号，若没有则跳出，若有则将该账号对应的 UID 读出，同时会读出 /etc/group 中所对应的 GID，此外，该账号的主文件夹与 Shell 配置也一并读出 进入 /etc/shadow 中找到对应的账号与 UID，核对输入的密码是否相同 若上述步骤执行顺利，则进入 Shell 控管阶段 【用户账号】/etc/passwd 文件结构在 /etc/passwd 中，每一行都代表一个账号，字段之间用 : 分隔 各字段具体含义如下： 字段 含义 账号名称 用户账号名 密码 早期的 UNIX 系统密码即位于该字段上，但由于安全性问题，后将这个字段的密码数据改放到 /etc/shadow 中 UID 通过字段范围来表示不同用户权限0 为系统管理员，1~499 为系统账号，500~65535 为可登录账号 GID 该字段与 /etc/group 有关 用户信息说明列 解释该账号的意义 主文件夹 用户主文件夹 Shell 用户指定的 Shell 需要说明的是，对于 UID 字段来说，除了 0 以外，其他的 UID 权限与特性并没有不同，默认 500 以下的数字让给系统作为保留账号只是一个习惯 但由于系统上启动的某些服务不希望使用 root 来执行，而希望使用较小的权限来执行，所以需要提供运行这些程序的所有者账号，这些系统账号通常是不可登录的，因此也才会有 /sbin/nologin 这个特殊的存在 根据系统账号的由来，通常系统账号分为两种： 1~99：由 distributions 自动创建的系统账号 100~499：若用户有系统账号需求时，可以使用的账号的 UID /etc/shadow 文件结构在 /etc/shadow 中，每一行同样都代表一个账号，字段之间也用 : 分隔 各字段具体含义如下： 字段 含义 账号名称 用户账号名，与 /etc/passwd 对应 密码 用户账号对应的密码，目前常采用 MD5 进行加密 最近变动密码的日期 以 1970 年 1 月 1 日作为 1 来累加 密码不可被变更的天数 该账号密码在最近一次更改后，需要几天才可更改若为 0 则表示随时可更改 密码需要重新更改的天数 指定最近一次更改密码后，在多少天需要更改密码若未在这个天数内更改，账号密码会变为过期特性即系统会强制要求重新设置密码才能登陆若为 99999 则表示没有强制更改要求 密码更改期限前的警告天数 用户主文件夹 密码过期后的宽限时间 密码过期多少天后，该账号密码才会失效 账号失效日期 以 1970 年 1 月 1 日作为 1 来累加，到达设定日期后账号会失效 保留字段 保留以待日后有新功能加入时使用 对于最近变动密码的日期和账号失效日期来说，假设若想知道 2008-09-04 的累计日数，可通过如下代码进行计算： 1echo $( ($(date --date==\"2008/09/04\" + %s) / 86400 + 1 ) ) 需要说明的是，如果一般用户的密码忘记了，可以联系系统管理员使用 root 用户来重设密码；如果 root 用户的密码忘记了，一般可通过重启系统进入用户维护模式，在系统给予 root 权限的 bash 接口中使用 passwd 命令修改密码即可 【用户组】/etc/group 文件结构/etc/group 记录了 GID 与组名的对应关系，每一行都代表一个用户组，字段之间用 : 分隔 各字段具体含义如下： 字段 含义 用户组名称 用户组名 用户组密码 与 /etc/passwd 类似，目前密码已移至 /etc/gshadow 中 GID 用户组的 ID/etc/passwd 中 GID 字段对应的用户组名 该用户组支持的账号名称 一个账号可加入多个用户组，若想将某个账号加入该用户组将账号填入该字段即可，账号间使用 , 分隔 关于账号相关文件之间的 UID 和 GID 的对应，以及密码相关性，如下所示 /etc/gshadow 文件结构/etc/gshadow 记录了用户组以及其对应的密码，每一行都代表一个用户组，字段之间用 : 分隔 各字段具体含义如下： 字段 含义 用户组名称 用户组名 用户组密码 用户组的密码，若该字段值为 ！说明该用户组无用户组管理员 GID 与 /etc/group 内容相同 该用户组支持的账号名称 与 /etc/group 内容相同","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"B 树","slug":"data-structure/09.index-method/06.B树","date":"2018-07-13T13:15:01.000Z","updated":"2021-09-24T13:42:09.448Z","comments":true,"path":"oi-acm/data-structure/index-method/c043e023.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/c043e023.html","excerpt":"【B 树的结构】定义B 树（B-Tree），是一种多路平衡查找树，其所有结点的平衡因子为 $0$，主要面向于动态查找，常用于文件系统中","text":"【B 树的结构】定义B 树（B-Tree），是一种多路平衡查找树，其所有结点的平衡因子为 $0$，主要面向于动态查找，常用于文件系统中 B 树中，结点最大的孩子数目称为 B 树的阶，一棵 $m$ 阶的 B 树或为空树，或为满足以下性质的 $m$ 叉树： 叶结点的父结点称为终端结点，若根结点不是终端结点，则至少有 $2$ 棵子树 每个结点，最多含有 $m-1$ 个关键字，同时最多有 $m$ 棵子树 除根结点外的所有非终端结点，至少含有 $\\left \\lceil \\frac{m}{2} \\right \\rceil-1$ 个关键字，同时最少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil$ 棵子树 所有的非终端结点都包括数据：$\\{n,P_0,K_1,P_1,K_2,…,K_n,P_n\\}$，其中，$n$ 为结点中关键码个数，且满足 $\\left \\lceil \\frac{m}{2} \\right \\rceil-1\\leq n\\leq m-1$ ，$K_i$ 为关键码，$P_i$ 为指向子树根结点的指针，且指针 $P_i$ 所指子树中所有结点的关键码均小于 $K_{i+1}$ 大于 $K_i$ 所有的叶结点均在同一层，且不带任何信息，这些结点实质上并不存在，指向这些结点的指针为空 可见，2-3 树，就是一棵 $3$ 阶 B 树 性质$B$ 树具有如下性质： 结点的孩子个数为关键字个数加 $1$ 若根结点没有关键字，则没有子树，此时 $B$ 树为空 若根结点有关键字，则子树必然大于等于 $2$ 棵，即子树个数为关键字个数加 $1$ 除根结点外的所有非终端结点，最少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil-1$ 个关键字 ，最多有 $m-1$ 个关键字 除根结点外的所有非终端结点，最少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil$ 棵子树，最多有 $ m $ 棵子树， 结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的关键字均大于该关键字 下层结点关键字总是落在由上层结点关键字所划分的区间内 所有叶结点均在最后一层，代表查询失败的位置 实例如下图，是一个 $3$ 阶 B 树，除根结点外的非终端结点，最少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil=\\left \\lceil \\frac{3}{2} \\right \\rceil=2$ 棵子树，最多有 $3$ 棵子树，同时，最少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil-1=2-1=1$ 个关键字，最多有 $2$ 个关键字 由于下层结点关键字总是落在由上层结点关键字所划分的区间内，以第二层最左结点为例，其关键字为 $\\{8,12\\}$，划分为 $3$ 个区间 $(- \\infty,8)$、$(8,12)$、$(12,17)$，该结点的 $3$ 个指针 $\\{p_1,p_2,p_3\\}$ 所指子树的关键字，均落在这 $3$ 个区间内 【B 树的高度】对于任意一棵包含 $n$ 个关键字，高度为 $h$，阶数为 $m$ 的 B 树，其高度满足如下约束： 1） $h$ 的下界 每个结点最多有 $m$ 棵子树时，有 $m-1$ 个关键字 假设在一棵 $m$ 阶 B 树在高度为 $h$ 时高度最小，那么关键字个数应满足： n\\leq (m-1)(1+m+m^2+...+m^{h-1})=m^h-1故可得高度 $h$ 的下界为： h\\geq log_m(n+1)2）$h$ 的上界 每个结点中的关键字个数达到最少时，容纳同样多的关键字的 B​ 树高度最大 根据 B​ 树的定义：第一层至少有 $1$ 个结点，除根结点外的每个非终端结点至少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil$ 棵子树 故而，第二层至少有 $2$ 个结点，第三层至少有 $2\\left \\lceil \\frac{m}{2} \\right \\rceil$ 个结点，以此类推，第 $h+1$ 层至少有 $2(\\left \\lceil \\frac{m}{2} \\right \\rceil)^{h-1}$ 个结点 由于 $B$ 树的高度不包含最后一层不带任何信息的叶结点层，即不包含第 $h+1$ 层，那么对于关键字为 $n$ 的 $B$ 树，叶结点即查找不成功的结点数为 $n+1$，那么有： n+1 \\geq 2(\\left \\lceil \\frac{m}{2} \\right \\rceil)^{h-1}故可得高度 $h$ 的上界为： h\\leq log_{\\left \\lceil \\frac{m}{2} \\right \\rceil}(\\frac{n+1}{2}+1)3）$h$ 的范围 综上所述，高度 $h$ 满足： log_m(n+1)\\leq h \\leq log_{\\left \\lceil \\frac{m}{2} \\right \\rceil}(\\frac{n+1}{2})+1假设一棵 $3$ 阶 B​ 树有 $8$ 个关键字，那么高度范围为： log_3(8+1)\\leq h\\leq log_{\\left \\lceil \\frac{3}{2} \\right \\rceil}(\\frac{8+1}{2})+1即：$2\\leq h \\leq 3.17$ 4）关键字与结点 对于一个高度为 $h$ 的 $m$ 阶 B 树，根结点外的所有非终端结点至少有 $\\left \\lceil \\frac{m}{2} \\right \\rceil$ 棵子树，最多有 $m$ 棵子树 记 $k=\\left \\lceil \\frac{m}{2} \\right \\rceil$，那么在最少的情况时，有： 第 $1$ 层：最少有 $1$ 个结点，最少有 $1$ 个关键字 第 $i$ 层：最少有 $2k^{h-2}$ 个结点，最少有 $2k^{h-i}(k-1)$ 个关键字 故而，$h$ 层的 $m$ 阶 B 树，最少包含 $1+2(k^{h-1}-1)$ 个关键字，最少含有 $2^h-1$ 个结点 同理，在在最多的情况时，有： 第 $1$ 层：最多有 $1$ 个结点，最多有 $1$ 个关键字 第 $i$ 层，最多有 $m^{i-1}$ 个结点，最多有 $(m-1)m^{i-1}$ 个关键字 故而，$h$ 层的 $m$ 阶 B 树，最多包含 $m^h-1$ 个关键字，最多含有 $\\frac{1-m^h}{1-m}$ 个结点 【B 树的查找】B​ 树的查找与二叉查找树相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是二路分支决定，而是根据该节点的子树所做的多路分支决定 B 树的查找包含两个基本操作： 在 B 树中找结点（在磁盘中进行） 在结点中找关键字（在内存中进行） B 树一般存储于磁盘中，因此在找到目标结点后，先将结点信息读入内存，然后在结点中采用顺序查找的方法寻找关键字，查找到叶结点时，对应指针为空指针，说明树中没有对应关键字，查找失败 以下图为例，假设要查找关键字 $79$ 根结点有两个关键字 $\\{17,35\\}$，$79&gt;35$，若关键字 $79$ 存在，必在根结点的右子树里 右子树有两个关键字 $\\{65,87\\}$，$65&lt;79&lt;87$，若关键字 $79$ 存在，必在该结点的中子树里 中子树有两个关键字 $\\{75,79\\}$，查找到关键字 $79$，查找成功 【B 树的插入】过程将关键字 $key$ 插入 B​ 树的过程如下： 定位：利用 B 树查找算法，找出插入该关键字的最低层中的某个非叶结点 插入：每个非失败结点的关键字个数都在区间 $[\\left \\lceil \\frac{m}{2} \\right \\rceil-1,m-1]$ 内 若插入后的结点关键字小于 $m$，直接插入 若插入后的结点关键字大于 $m-1$，对结点进行分裂 分裂：取一个新结点，在插入 $key$ 后的原结点，从中间位置 $\\left \\lceil \\frac{m}{2} \\right \\rceil$，将关键字分为两部分 左部分包含的关键字放在原结点中 右部分包含的关键字放在新结点中 中间位置的结点插入原结点的父结点 提升：若分裂过程中，中间位置的结点插入父结点，使得父结点中关键字个数也达到上限，那么继续进行分裂操作，直到这个过程传达到根结点为止，此时，$B$ 树高度 $+1$ 实例如下图，给出一的 $3$ 阶 B 树，现要在其中依次插入 $14$、$55$ 在插入 $14$ 时，从根结点开始查找，到达存储 $15$ 的叶结点，其是一个 $2$ 结点，直接将 $14$ 插入即可 在插入 $55$ 时，从根结点开始查找，到达存储 $\\{50,52\\}$ 的结点，其是关键字个数为 $2$ ，需要进行分裂，加入 $55$ 后，三个关键码的值为 $\\{50,52,55\\}$，其中，令中值 $52$ 提升，小值 $50$ 与大值 $55$ 作为父结点的叶结点 【B 树的删除】B 树的删除要保证删除后的结点中的关键字个数大于等于 $\\left \\lceil \\frac{m}{2} \\right \\rceil-1$ 被删关键字 $key$ 可能在终端结点中，也可能不在终端结点中，由此，B 树的删除可分为以下两种情况： 1）不在终端结点 使用 $key$ 的前驱或后继 $key’$ 来代替 $key$，然后在相应结点中删除 $key’$，关键字 $key’$ 必定落在某个终端结点中，这就转换成了删除关键字在终端结点的情况 如下图的 $4$ 阶 B 树，删除关键字 $80$，用其前驱 $78$ 替代 $80$，然后在终端结点中，将 $78$ 删除 2）在终端结点 当被删结点在终端结点中，有三种情况： ①直接删除 若被删关键字所在结点的关键字个数 $\\geq \\left \\lceil \\frac{m}{2} \\right \\rceil$，直接删除该关键字后仍满足 B 树定义 ②兄弟够借 若被删关键字所在结点的关键字个数 $= \\left \\lceil \\frac{m}{2} \\right \\rceil-1$，且与该结点相邻的左兄弟或右兄弟结点的关键字个数 $\\geq \\left \\lceil \\frac{m}{2} \\right \\rceil$，将该结点、左兄弟或右兄弟结点、父结点中的关键字进行换位，以达到新的平衡 如下图的 $4$ 阶 $B$ 树，删除关键字 $65$，其结点关键字个数 $=\\left \\lceil \\frac{m}{2} \\right \\rceil-1=1$，右兄弟关键字个数为 $2 \\geq \\left \\lceil \\frac{m}{2} \\right \\rceil = 2$，需要调整结点，用 $71$ 取代原 $65$ 位置，用 $74$ 取代原 $71$ 位置 ③兄弟不够借 若被删关键字所在结点的关键字个数 $= \\left \\lceil \\frac{m}{2} \\right \\rceil-1$，且与该结点相邻的左兄弟或右兄弟结点的关键字个数 $= \\left \\lceil \\frac{m}{2} \\right \\rceil-1$，则进行合并操作 在合并过程中，父结点中的关键字个数会 $-1$ 若父结点是根结点，且关键字个数减少到 $0$，则直接删除根结点，合并后的新结点为根 若父结点不是根结点，且关键字个数减少到 $\\left \\lceil \\frac{m}{2} \\right \\rceil-2$，则要将其与其兄弟结点进行调整或合并，重复上述步骤，直到符合 $B$ 树要求为止 如下图的 $4$ 阶 $B$ 树，删除关键字 $5$，其结点关键字个数 $=\\left \\lceil \\frac{m}{2} \\right \\rceil-1=1$，右兄弟结点关键字个数 $=\\left \\lceil \\frac{m}{2} \\right \\rceil-1=1$，在将 $5$ 删除后，将 $60$ 合并到 $65$ 中 【应用】在实际应用中，B 树常用于文件系统中，且常使得 阶数与磁盘存储的页面大小匹配，即一个索引结点大小应取不超过磁盘页块的大小 假设 $B$ 树为 $m$ 阶，那么一个结点最多存放： $m-1$ 个关键字和对应记录地址（指针） $m$ 个子树指针 $1$ 个指示结点中的实际关键字个数的整数 假设磁盘页块大小为 $4000B$，指示磁盘地址的指针需要 $5B$，现有 $2*10^7$ 个记录构成的文件，每个记录为 $200B$，其中包括关键字 $5B$，若采用 $B$ 树作索引，$B$ 的阶数为多少？假定文件数据部分未按关键字排序，索引部分要占用多少磁盘页块？ 假设为 $m$ 阶 $B$ 树，那么一个结点最多存放： $m-1$ 个关键字和对应记录地址（指针） $m$ 个子树指针 $1$ 个指示结点中的实际关键字个数的整数 由题意： 一个结点最多存放 $m-1$ 个关键字，那么关键字所占空间为 $5B\\times(m-1)$，相应的对应记录地址亦为 $5B\\times(m-1)$ 总共需要 $m$ 个子树指针，那么指针所占空间为 $5B\\times m$ $1$ 个指示实际关键字个数的整数，取 $int$ 型，为 $2B$ 综上，一个结点所占空间满足： 5B\\times(m-1)\\times 2+5B\\times m+2\\leq 4000B可得：$m\\leq 267$ 那么，一个索引结点最多可以存放 $m-1=266$ 个索引项，最少可以存放 $\\left \\lceil \\frac{m}{2} \\right \\rceil-1=133$ 个索引项 共有 $2\\times 10^7$ 个记录，每记录占用 $200B$，每页块可以存放 $\\frac{4000}{200}=20$ 个记录，则共需 $\\frac{2\\times 10^7}{20}=2\\times 10^6$ 个页块 最多占用 $\\left \\lceil \\frac{2\\times 10^6}{133} \\right \\rceil=7591$ 个磁盘块作为 $B$ 树索引，最少占用 $\\left \\lceil \\frac{2\\times 10^6}{266} \\right \\rceil=3760$ 个磁盘块作为 $B$ 树索引","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"Shell 脚本的函数","slug":"37.Shell脚本的函数","date":"2018-07-10T10:35:00.000Z","updated":"2022-06-06T13:19:01.543Z","comments":true,"path":"linux/840b94e2.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/840b94e2.html","excerpt":"如同高级编程语言中的函数，在 Shell 中，同样具有函数，用于完成相对独立的、可重复的功能，语法形式如下： 123function 函数名() &#123; 命令序列&#125; 需要注意的是，由于 Shell 脚本是从上到下、从左到右逐行执行的，不会进行编译，因此在 Shell 脚本中，使用函数前一定要先声明函数","text":"如同高级编程语言中的函数，在 Shell 中，同样具有函数，用于完成相对独立的、可重复的功能，语法形式如下： 123function 函数名() &#123; 命令序列&#125; 需要注意的是，由于 Shell 脚本是从上到下、从左到右逐行执行的，不会进行编译，因此在 Shell 脚本中，使用函数前一定要先声明函数 此外，同 Shell 脚本的默认变量相似，Shell 脚本中的函数拥有内置变量：函数名称用 $0 表示，后接的变量以 $1、$2 等表示","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 脚本的循环控制语句","slug":"36.Shell脚本的循环控制语句","date":"2018-07-10T09:45:00.000Z","updated":"2022-06-06T12:54:07.396Z","comments":true,"path":"linux/4dfe2dfd.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/4dfe2dfd.html","excerpt":"【while 循环】while 循环是不定循环，当条件表达式成立时，就进行循环，直到条件表达式不成立为止，while 循环的格式如下： 1234while [条件表达式]do 命令序列done","text":"【while 循环】while 循环是不定循环，当条件表达式成立时，就进行循环，直到条件表达式不成立为止，while 循环的格式如下： 1234while [条件表达式]do 命令序列done 【until 循环】until 循环是不定循环，当条件表达式不成立时，就进行循环，直到条件表达式成立为止，until 循环的格式如下： 1234until [条件表达式]do 命令序列done 【for 循环】在 Shell 中，for 循环有两种形式 第一种形式主要用于处理参数列表，在每次循环时，变量的内容是参数列表中的值 1234for 变量 in [参数列表]do 命令序列done 第二种形式主要用于处理数值，类似于高级编程语言中的 for 循环 1234for ((初始值; 限制值; 步长))do 命令序列done","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 脚本的分支控制语句","slug":"35.Shell脚本的分支控制语句","date":"2018-07-10T07:32:00.000Z","updated":"2022-06-06T09:45:17.679Z","comments":true,"path":"linux/9c5fd825.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/9c5fd825.html","excerpt":"【if 条件语句】单分支 if 语句单分支 if 语句是最简单的条件语句，其格式如下：","text":"【if 条件语句】单分支 if 语句单分支 if 语句是最简单的条件语句，其格式如下： 123if [条件表达式]; then 命令序列fi 关于条件表达式的具体写法，见：Shell 测试命令与条件表达式 需要注意的是，当有多个条件需要判别时，除了采用条件表达式中多重条件判定外，还可以将多个条件拆分为多个 []，中括号之间用 &amp;&amp; 代替 -a，用 || 代替 -o 如下例，两种写法在 if 语句中是等价的 12[ \"$test1\"==\"hello\" -a \"$test2\"==\"world\" ][ \"$test1\"==\"hello\" ] &amp;&amp; [ \"$test2\"==\"world\" ] 下面给出单分支 if 语句的实例 双分支 if 语句双分支 if 语句格式如下： 12345if [条件表达式]; then 命令序列1else 命令序列2fi 多分支 if 语句多分支 if 语句格式如下： 12345678if [条件表达式1]; then 命令序列1elif [条件表达式2]; then 命令序列2...else 命令序列nfi 【case 语句】case 语句类似于高级编程语言中的 switch-case 语句，可以将一个变量的内容与多个选项匹配，若匹配成功则执行该条件下的匹配语句，格式如下： 1234567891011case \"$变量名\" in \"第一个变量内容\") 命令序列1 ;; \"第二个变量内容\") 命令序列2 ;; ... \"第n个变量内容\") 命令序列n ;; *) 其他 ;;esac","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 脚本的编写原则与执行","slug":"34.Shell脚本的编写原则与执行","date":"2018-07-09T03:55:00.000Z","updated":"2022-06-06T13:18:06.510Z","comments":true,"path":"linux/494af6c5.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/494af6c5.html","excerpt":"【Shell 脚本编写原则】Shell 脚本Shell 脚本（Shell scirpt），是利用 Shell 功能写的程序，是使用纯文本文件，其包含一些 Shell 的语法与命令，搭配正则表达式、管道命令、数据流重定向等","text":"【Shell 脚本编写原则】Shell 脚本Shell 脚本（Shell scirpt），是利用 Shell 功能写的程序，是使用纯文本文件，其包含一些 Shell 的语法与命令，搭配正则表达式、管道命令、数据流重定向等 简单来说，Shell 脚本可以被看作批处理文件，一次执行多个命令，不需要编译即可执行，能够帮助管理员快速管理好主机 注意事项在编写 Shell 脚本时，有以下几个注意事项： 命令从上到下、从左到右分析与执行 命令、参数间的多个空白都会被忽略掉 空白行将被忽略掉 [Tab] 所得的空白被视为空格键 读取到一个 [Enter] 符号（CR），就会尝试执行该行命令 若一行命令太多，可以使用 \\[Enter] 来将命令扩展到下一行 # 为注释符号 第一行声明该脚本所使用的 Shell 名称，对于 bash 来说，一般为 #!/bin/bash 后缀名为 .sh 文件头除第一行为加载 bash 相关环境配置文件的而写入的 #!/bin/bash 外，通常为了便于 Shell 脚本的说明与维护，会根据实际情况在每个 Shell 脚本的文件头写入如下注释： Shell 脚本的功能 Shell 脚本的版本信息 Shell 脚本的作者与联络方式 Shell 脚本的版权声明方式 Shell 脚本的 History Shell 脚本内较为特殊的命令 Shell 脚本执行时需要的环境变量预先声明与设置 【Shell 脚本的执行】对于 Shell 脚本文件 *.sh，必须要具备可读与可执行的权限（rx） 若想执行一个 Shell 脚本文件，其有两种基本的执行方式： 直接命令执行：输入 Shell 脚本的绝对路径、输入 Shell 脚本的相对路径、将 Shell 脚本写入 PATH 环境变量 以 Shell 进程执行：将 Shell 脚本文件通过 sh 命令执行，例 sh test.sh 采用上述两种方式执行 Shell 脚本时，该脚本都会使用一个新的 Shell 环境来执行脚本内的命令，也就是说，Shell 脚本其实是在子进程内执行的，此时，在 Shell 脚本内的各项变量与操作在脚本结束后并不会传回到父进程 若想令 Shell 脚本在父进程中执行，此时直接使用 source 脚本名 命令即可 【Shell 脚本的默认变量】就像命令带有参数一样，Shell 脚本同样可以带有参数 如下所示，执行的脚本文件名就是 $0 这个变量，后接的参数依次为 $1、$2、$3、$4 等 12scriptname opt1 opt2 opt3 opt4$0 $1 $2 $3 $4 此外，还有一些特殊的变量可在 Shell 脚本内来调用： $#：代表参数总数 $@：代表 &quot;$1&quot;、&quot;$2&quot;、&quot;$3&quot;、&quot;$4&quot; 等，每个变量是独立的 $*：代表 &quot;$1c$2c$3c$4&quot;，其中 c 为分隔字符，默认为 [Space] 【Shell 脚本的追踪与调试】在将 Shell 脚本文件通过 sh 命令执行时，可以附加一些选项，来对要执行的 Shell 脚本进行追踪与调试 -n：不执行该脚本，仅查询语法是否出现问题 -v：在执行该脚本前，先将脚本的内容输出到屏幕上 -x：在执行该脚本时，将使用到的内容输出到屏幕上","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 的操作环境","slug":"33.Shell的操作环境","date":"2018-07-06T14:03:00.000Z","updated":"2022-06-03T10:25:46.583Z","comments":true,"path":"linux/97aaee7.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/97aaee7.html","excerpt":"【路径与命令的执行顺序】在 Shell 中，一条命令的执行顺序为： 以相对/绝对路径执行命令，例如：/bin/ls 由 alias 找到该命令执行 由 Shell 内置命令 builtin 来执行 通过 PATH 环境变量内路径的顺序找到的第一个命令来执行","text":"【路径与命令的执行顺序】在 Shell 中，一条命令的执行顺序为： 以相对/绝对路径执行命令，例如：/bin/ls 由 alias 找到该命令执行 由 Shell 内置命令 builtin 来执行 通过 PATH 环境变量内路径的顺序找到的第一个命令来执行 【环境配置文件】环境配置文件在 Linux 系统中，存在一些环境配置文件，Shell 在启动时直接读取这些配置文件，以规划好 Shell 的操作环境 对于命令别名、自定义变量等，在注销 Shell 时就会失效，若想让他们永久生效，就需要将这些设置写入配置文件中 在通过 tty1~tty6 登录，需要输入用户名与密码进行验证，之后取得的 Shell 就被称为 login shell，也就是说在取得 Shell 时，需要完整登录流程的就是 login shell 而以 X Window 登录，再以 X 的图形界面启动终端机，此时的终端接口不需要输入用户名与密码，这样取得的 Shell 就被称为 non-login shell 对于 login shell 与 non-login shell 来说，两者读取的配置文件不一致 login shell配置文件读取流程login shell 只会读取以下两个配置文件： /etc/profile：系统整体设置，不建议进行修改 ~/.bash_profile：用户个人设置，要想让命令别名、变量等永久生效，就需要写入该文件 /etc/profile在 login shell 的 bash 环境中，该文件是每个用户登录取得 Shell 时一定会读取的配置文件，若想修改用户的整体环境，就对该文件进行修改，该文件中主要变量如下表： 变量 说明 PATH 依据 UID 决定是否包含 sbin 的系统命令目录 MAIL /var/spool/mail/账号名 USER 用户账号 HOSTNAME 主机的 hostname HISTSIZE 历史命令记录条数 除上述变量外，/etc/profile 文件还会调入下述数据： /etc/inputrc：Shell 热键、[Tab] 有无声音等数据 /etc/profile.d/*.sh：规定了现有 Shell 操作接口的颜色、语系、命令别名等 /etc/sysconfig/i18n：决定 Shell 默认使用的语系配置文件 ~/.bash_profileShell 在读完整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来会读取用户的个人配置文件 在 login shell 的 bash 环境中，所读取的用户个人配置文件其实主要是以下三个： ~/.bash_profile ~/.bash_login ~/.profile 实际上，login shell 只会读取上述三个文件中的一个，读取顺序是依照上述的顺序 也就是说，如果 ~/.bash_profile 存在的话，无论剩余两个文件是否存在，都不会读取，只有当 ~/.bash_profile 不存在时，才会读取 ~/.bash_login 之所以有这三个文件，是 bash 为了照顾从其他 Shell 环境转换过来的用户的习惯 打印 ~/.bash_profile 可以发现其分为两部分： 读取 ~/.bashrc 处理个人化设置 non-login shell当取得 non-login shell 时，只会读取 ~/.bashrc 文件 打印 ~/.bashrc 可以发现其分为两部分： 用户个人设置 整体环境设置 需要注意的是，root 用户与一般用户的 ~/.bashrc 有所不同，但同样都是分为上述的两部分 source 命令由于 /etc/profile 和 ~/.bash_profile 都是在取得 login shell 后才会读取的配置文件，因此如果将自己的偏好写入上述两个文件后，需要注销再登录后才会使得设置生效 使用 source 配置文件名 命令可以直接使得修改后的配置文件生效，避免了繁琐的注销登录流程","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 测试命令与条件表达式","slug":"32.Shell测试命令与条件表达式","date":"2018-07-06T09:32:00.000Z","updated":"2022-06-06T07:39:49.203Z","comments":true,"path":"linux/4f161c28.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/4f161c28.html","excerpt":"【test 命令】命令与结果显示当需要检测系统中某些文件或属性时，使用 test 命令可以告诉我们相关结果","text":"【test 命令】命令与结果显示当需要检测系统中某些文件或属性时，使用 test 命令可以告诉我们相关结果 例如：判断 ~/test 是否存在 可以发现，该命令执行结果并不会显示任何信息，要想获取结果信息，需要通过使用 $?、&amp;&amp;、|| 来显示 即想要进行结果显示时，其语法如下： 1234# 使用$?来获取test命令返回值test ...; echo $?# 根据test命令返回值输出测试结果test ... &amp;&amp; echo \"测试结果为true的显示信息\" || echo \"测试结果为false的显示信息\" 判断文件类型test 命令可用于某个文件或目录的文件存在与文件类型判断，其命令格式为：test [选项] filename 此时选项如下： -e：filename 是否存在 -f：filename 是否存在且为文件 -d：filename 是否存在且为目录 -b：filename 是否存在且为 block device 设备 -c：filename 是否存在且为 character device 设备 -S：filename 是否存在且为 socket 文件 -p：filename 是否存在且为 FIFO 文件 -L：filename 是否存在且为连接文件 -s：filename 是否存在且为非空白文件 文件权限检测test 命令还可用于文件权限检测，其命令格式为：test [选项] filename 此时选项如下： -r：filename 是否存在且具有可读权限 -w：filename 是否存在且具有可写权限 -x：filename 是否存在且具有可执行权限 -u：filename 是否存在且具有 SUID 属性 -g：filename 是否存在且具有 SGID 属性 -k：filename 是否存在且具有 sticky bit 属性 文件比较test 命令还可用于两个文件之间的比较，其命令格式为：test file1 [选项] file2 此时选项如下： -nt：判断 file1 是否比 file2 新（newer than） -ot：判断 file1 是否比 file2 旧（older than） -ef：判断 file1 与 file2 是否为同一文件，常用于硬连接的判断，即两个文件是否指向同一个 inode（equal file） 整数判定test 命令还可用于判定两个整数，其命令格式为：test n1 [选项] n2 此时选项如下： -eq：判断 n1 与 n2 是否相等（equal） -ne：判断 n1 与 n2 是否不等（not equal） -gt：判断 n1 是否大于 n2（greater than） -lt：判断 n1 是否小于 n2（less than） -ge：判断 n1 是否大于等于 n2（greater than or equal） -le：判断 n1 是否小于等于 n2（less than or equal） 字符串数据判定test 命令还可用于判定字符串数据，其命令格式如下： test -z str：判断 str 是否为空串 test -n str：判断 str 是否为非空串 test str1=str：判断 str1 是否等于 str2 test str1!=str2：判断 str1 是否不等于 str2 多重条件判定当需要使用 test 命令使用多重条件判定时，可采用如下选项： -a：两个条件同时成立，例如 test -r file -a -x file，当 file 同时具有 r、x 权限时返回 true -o：任何一个条件成立，例如 test -r file -o -x file，当 file 具有 r 或 x 权限时返回 true !：条件取反，例如 test ! -r file，当 file 不具有 r 权限时返回 true 【条件表达式】在 test 命令中，test 后跟的选项、文件名等统称为条件表达式 对于条件表达式来说，除了使用 test 命令进行测试外，还可以利用判断符号 [] 来进行判断 例如：判断 ~/test 是否存在且为目录 对于 [] 来说，需要注意的有： 为区分通配符、正则表达式等，[] 内的左右两端需要使用 [Space] 来分隔 [] 内每个组件都需要使用 [Space] 来分隔 [] 内的变量最好都使用 &quot;&quot; 括起来 [] 内的常量最好都使用 &#39;&#39; 括起来 判断选项与 test 命令判断选项相同","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 命令执行判断依据","slug":"31.Shell命令执行判断依据","date":"2018-07-05T15:51:00.000Z","updated":"2022-06-03T09:42:47.971Z","comments":true,"path":"linux/25b40e11.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/25b40e11.html","excerpt":"【命令回传码】在 Shell 中，$ 本身也是个变量，其代表的是目前 Shell 的线程号，即所谓的 PID 输入 echo $$ 命令，出现的数字即 PID","text":"【命令回传码】在 Shell 中，$ 本身也是个变量，其代表的是目前 Shell 的线程号，即所谓的 PID 输入 echo $$ 命令，出现的数字即 PID 同时，? 也是一个特殊的变量，其是上一执行命令所回传的值 当执行某些命令时，都会回传一个执行后的代码，一般来说，执行成功会回传 0，如果执行失败则会回传错误代码 【命令连续执行】在某些情况下，需要一次性输入然后执行，此时除了编写 Shell 脚本外，还可以使用 ; 或 &amp;&amp; 与 || 来执行 无相关性在前一个命令和后一个命令之间不存在相关性的情况下，命令与命令之间，使用分号 ; 来隔开，这样一来，分号前的命令执行完后就会立刻执行后面的命令 有相关性若两个命令之间具有相关性，即后一个命令依赖于前一命令执行正确，此时就需要用到 $$$$ 或 ||，这个过程依赖于命令回传码 命令 说明 命令1 &amp;&amp; 命令2 若命令 1 正确执行（$?=0），则执行命令 2若命令 1 执行错误（$?≠0），则命令 2 不执行 命令1 &#124;&#124; 命令2 若命令 1 正确执行（$?=0），则命令 2 不执行若命令 1 执行错误（$?≠0），则执行命令 2","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 变量内容的删除与替换","slug":"30.Shell变量内容的删除与替换","date":"2018-07-05T09:39:00.000Z","updated":"2022-05-31T19:18:17.671Z","comments":true,"path":"linux/6f3beaa0.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/6f3beaa0.html","excerpt":"【变量内容的删除与替换】变量内容的删除与替换，具体方式可参考下表 变量设置方式 说明 ${变量#关键字} 若变量内容从头开始的数据符合关键字，则将符合的最短数据删除 ${变量##关键字} 若变量内容从头开始的数据符合关键字，则将符合的最长数据删除 ${变量%关键字} 若变量内容从尾向前的数据符合关键字，则将符合的最短数据删除 ${变量%%关键字} 若变量内容从尾向前的数据符合关键字，则将符合的最长数据删除 ${变量/旧字符串/新字符串} 若变量内容符合旧字符串，则将第一个旧字符串用新字符串代替 ${变量//旧字符串/新字符串} 若变量内容符合旧字符串，则将所有旧字符串用新字符串代替","text":"【变量内容的删除与替换】变量内容的删除与替换，具体方式可参考下表 变量设置方式 说明 ${变量#关键字} 若变量内容从头开始的数据符合关键字，则将符合的最短数据删除 ${变量##关键字} 若变量内容从头开始的数据符合关键字，则将符合的最长数据删除 ${变量%关键字} 若变量内容从尾向前的数据符合关键字，则将符合的最短数据删除 ${变量%%关键字} 若变量内容从尾向前的数据符合关键字，则将符合的最长数据删除 ${变量/旧字符串/新字符串} 若变量内容符合旧字符串，则将第一个旧字符串用新字符串代替 ${变量//旧字符串/新字符串} 若变量内容符合旧字符串，则将所有旧字符串用新字符串代替 以环境变量 PATH 为例，先自定义一个变量 path，令其值等于 PATH，可以发现，在变量中，是通过 : 来分隔目录的 假设要删除第一个目录，有： 若想要删除最后一个目录，有： 若想将变量中所有的 bin 替换为大写的 BIN，有： 【变量测试与内容替换】在某些时刻，需要判断某个变量是否存在，若变量存在则使用既有的设置，若变量不存在则给一个常用的设置 对于变量 var 与 str，当想要针对 str 的具体值来决定 var 的值时，可参考下表 变量设置方式 str 未设置 str 为空字符串 str 为非空字符串 var=${str-expr} var=expr var= var=$str var=${str:-expr} var=expr var=expr var=$str var=${str+expr} var= var=expr var=expr var=${str:+expr} var= var= var=expr var=${str=expr} str=exprvar=expr str 不变var= str 不变var=$str var=${str:=expr} str=exprvar=expr str=exprvar=expr str 不变var=$str var=${str?expr} expr 输出至 stderr var= var=str var=${str}:?expr expr 输出至 stderr expr 输出至 stderr var=str 以 var=${str-expr} 为例，由于打印变量 test 后出现空白，无法确定是不存在还是空字符串，在使用 - 进行测试与内容替换后，test 的值被改为 “hello world” 而当变量 test 存在时，会使用原有的值 需要说明的是，上述的变量测试可以通过 Shell 脚本内的 if...then... 语句来进行处理","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 变量的读取与声明","slug":"29.Shell变量的读取与声明","date":"2018-07-05T03:06:00.000Z","updated":"2022-05-31T19:17:20.050Z","comments":true,"path":"linux/fb11e853.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/fb11e853.html","excerpt":"【变量键盘读取】read 命令可以读取来自键盘输入的变量，其语法为：read [选项] 变量名 常用的选项有：","text":"【变量键盘读取】read 命令可以读取来自键盘输入的变量，其语法为：read [选项] 变量名 常用的选项有： -p：后接提示输入 -t：后接等待的秒数，超时后将自动取消输入 【变量类型声明】declare 命令用于声明变量的类型，其语法为：declare [选项] 变量名 常用的选项有： -p：单独列出变量类型 -x：与 export 命令一样，将自定义变量设为环境变量 -r：将变量设为只读类型，不可修改和删除 -i：将变量定义为整数类型 -a：将变量定义为数组类型 在默认情况下，变量类型为字符串，同时数值运算仅能达到整数类型 与 export 命令相同，使用 -x 选项，会将自定义变量转为环境变量，而若想将环境变量转为非环境变量，可以将 -x 中的 - 变为 +，代表进行取消操作 对于 -r 选项，一旦变量设为只读类型，则不可修改与删除，其会在 Shell 结束后会自动删除 对于 -a 选项，可以将变量声明为数组变量，但这没有必要，因为所有变量都不必显式定义就可以用作数组，也就是说，在某种意义上，所有变量都是数组，且赋值给没有下标的变量与赋值给下标为 0 的相同","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 环境变量","slug":"28.Shell环境变量","date":"2018-07-03T14:31:00.000Z","updated":"2022-05-31T19:16:19.072Z","comments":true,"path":"linux/1f00a113.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/1f00a113.html","excerpt":"【环境变量的显示】环境变量类似于高级程序语言中的全局变量，可以在创建他们的 Shell 及其派生出的任意子程序中使用 有些环境变量是用户创建的，而大多数环境变量是专用的，属于系统变量的一部分，使用 env 命令可以打印当前 Shell 环境下所有环境变量及其内容","text":"【环境变量的显示】环境变量类似于高级程序语言中的全局变量，可以在创建他们的 Shell 及其派生出的任意子程序中使用 有些环境变量是用户创建的，而大多数环境变量是专用的，属于系统变量的一部分，使用 env 命令可以打印当前 Shell 环境下所有环境变量及其内容 除了环境变量外，还有一些与 Shell 操作接口有关的变量，以及用户自定义变量，此时可以使用 set 命令来列出当前 Shell 环境下的所有变量及其内容 常见的环境变量说明见下表 环境变量 说明 HOME 用户的主文件夹 SHELL 目前环境所使用的 Shell HISTSIZE 历史记录所记录的条数 PATH 执行文件查找的路径，目录与目录间用冒号 : 分隔 MAIL 使用 mail 命令在收信时，系统读取的邮件信箱文件 LANG 语系数据，中文编码通常是 zh_CN.gb2312 或 zh_CN.UTF-8 RANDOM 随机数变量，可通过该变量获取一个介于 0 到 32767 的随机数值 【语系相关的环境变量】目前，大多数 Linux 都支持各国及地区代码，也支持大部分的语系，使用 locale -a 可以列出当前 Linux 环境所支持的语系代码 而对于系统所支持的语系环境，可以直接使用 locale 来列出与语系相关的环境变量与其内容 这些变量的含义如下表 语系相关的环境变量 说明 LANG 主语言的环境 LC_CTYPE 字符辨识的编码 LC_NUMERIC 数字系统的显示信息 LC_TIME 时间系统的显示数据 LC_COLLATE 字符串的比较与排序 LC_MONETARY 币值显示格式 LC_MESSAGES 菜单、错误信息等信息显示内容 LC_PAPER 页面显示内容 LC_NAME 姓名书写方式 LC_ADDRESS 地址书写方式 LC_TELEPHONE 电话号码书写方式 LC_MEASUREMENT 度量衡表达方式 LC_IDENTIFICATION 对 locale 自身包含信息的概述 LC_ALL 整体语系的环境 对于上述的与语系相关的环境变量，LANG 指定了所有与 locale 有关的变量默认值，但其优先级最低，而 LC_ALL 则指定了整体语系环境，其优先级最高，当设定了 LC_ALL 时，所有的与语系相关的环境变量都将被 LC_ALL 的值所取代，即有： LANG < LC\\_* < LC\\_ALL【进程相关性】当登录 Linux 并取得一个 Shell 后，此时的 Shell 就是一个独立的进程，接下来在这个 Shell 中执行的任何命令都是由这个 Shell 所衍生出来的，此时这些被执行的命令就被称为子进程 在 Linux 中，当启动 Shell 后，操作系统会分配一个记忆块给 Shell 使用，此内存内的变量可以让子进程使用；当加载另一个 Shell，即启动子进程时，子进程会将父进程的环境变量所在的记忆块导入自己的环境变量中 因此，子进程会继承父进程的环境变量，同时子进程不会继承父进程的自定义变量 这就导致了原本的自定义变量在 Shell 进入子进程后会消失，直到离开子进程回到父进程后，才会出现 换个角度来说，如果能将自定义变量设为环境变量的话，那么就可以让该自定义变量继续存在于子进程中 使用 export 变量名 命令，即可令一个自定义变量变为环境变量，其实质是将自定义变量的内容写入环境变量所在的记忆块中，此外，若单独键入 export，则会将所有的环境变量显示出来","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 变量的显示与设置","slug":"27.Shell变量的显示与设置","date":"2018-07-03T13:04:00.000Z","updated":"2022-05-31T19:14:45.097Z","comments":true,"path":"linux/bd7a1729.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/bd7a1729.html","excerpt":"在 Shell 中，可以使用 echo 命令来进行字符串的输出，当想要显示变量时，需要加上字符 $，以 ${变量} 的方式来显示 而一个变量名尚未被设置时，默认内容为空","text":"在 Shell 中，可以使用 echo 命令来进行字符串的输出，当想要显示变量时，需要加上字符 $，以 ${变量} 的方式来显示 而一个变量名尚未被设置时，默认内容为空 变量设置可以通过变量与变量内容之间用一个等号 = 来连接，同时要求等号两边不能有空格符，变量名称只能是英文与数字的组合，且开头不能为数字，此外，为方便判断，通常系统默认变量为大写字符，用户自定义变量为小写字符 在双引号包裹的内容中，使用 $ 可以保持原有特性，会输出相应的变量值 在进行输出时，可以 -e 选项来使转义符 \\n 显示换行 在单引号包裹的内容中，会原样的输出字符串，特殊符号仅作为一般文本，不进行转义，不取变量值 当想要取消变量时，采用 unset 变量名 来进行取消","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"Shell 基本介绍","slug":"26.Shell基本介绍","date":"2018-07-03T11:43:00.000Z","updated":"2022-06-16T08:54:53.140Z","comments":true,"path":"linux/1a317006.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/1a317006.html","excerpt":"【Shell 的概念】操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动检测，如果这组软件能被用户随意操作，若使用不当，则会使得整个系统崩溃 但我们总是需要令用户去操作系统的，因此就有了在操作系统上面发展的应用程序，用户可以通过应用程序来指挥内核，让内核达成我们所需要的硬件任务","text":"【Shell 的概念】操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动检测，如果这组软件能被用户随意操作，若使用不当，则会使得整个系统崩溃 但我们总是需要令用户去操作系统的，因此就有了在操作系统上面发展的应用程序，用户可以通过应用程序来指挥内核，让内核达成我们所需要的硬件任务 Shell 就是提供用户操作系统的一个接口，狭义来说，Shell 指的是命令行方面的软件，广义的 Shell 则包括图形界面的软件 【Shell 的发展历史】第一个流行的 Shell 是由 Steven Bourne 发明的，为了纪念他就称为 Bourne Shell，简称为 sh 后来另一个广为流传的 Shell 是由柏克莱大学的 Bill Joy 设计依附于 BSD 版 UNIX 系统的 Shell，这个版本的 Shell 语法类似于 C 语言，因此被称为 C Shell，简称为 csh 在 Linux 中，使用的 Shell 版本是在 Bourne Shell 的基础上发展起来的增强版本，也是基于 GNU 架构下发展出来的，被称为 Bourne Again Shell，简称为 bash 由于 bash 是 Linus 最常用的 Shell 版本，因此，一般所说的 Shell，其实就是指 bash 常见的 Shell 可见下表： Shell 简述 sh Bourne Shell，第一个流行的 Shell bash sh 的增强版，是 Linux 默认的 Shell csh C Shell，目前已被 tcsh 所取代 tcsh csh 的增强版，在整合 csh 的同时，提供了更多的功能 ksh Korn Shell，由贝尔实验室开发，向后兼容 sh、bash、csh zsh 基于 ksh 发展而来，功能更加完善 在 /etc/shells 文件下，可以查看当前 Linux 版本可使用的所有 Shell 如下图所示，展示了 CentOS 7 中所有可用的 Shell 【用户可用 Shell】系统某些服务在运行时，会去检查当前用户能够使用的 Shell，而这些 Shell 的查询就是借助 /etc/shells 这个文件 用户登录时，系统会自动根据 /etc/passwd 文件的内容来为用户分配一个登录后可取得的默认 Shell 可以发现，除了 bash 外，还存在一个奇怪的 Shell，即 nologin，这是不想让某些用户使用主机资源而给予的 Shell 举例来说，某些 FTP 网站会去检查用户的可用 Shell，如果不想让这些用户使用 FTP 外的主机资源时，可能会给予用户一些奇怪的 Shell 以令用户无法登录主机，比如 /etc/shells 中写入的 /sbin/nologin","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"},{"name":"Shell","slug":"shell","permalink":"https://alex-mcavoy.github.io/tags/shell/"}],"author":"Alex_McAvoy"},{"title":"2-3 树","slug":"data-structure/09.index-method/05.2-3树","date":"2018-07-03T10:21:23.000Z","updated":"2021-09-24T12:56:45.321Z","comments":true,"path":"oi-acm/data-structure/index-method/db71a3ac.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/db71a3ac.html","excerpt":"【结构】2-3 树（2-3 Tree），是一种多路查找树，其是一棵具有如下特性的树： 每个结点都具有 $2$ 个孩子或 $3$ 个孩子，具有 $2$ 个孩子的结点称为 $2$ 结点，具有 $3$ 个孩子的结点称为 $3$ 结点 $2$ 结点包含 $1$ 个关键码，且其具有 $2$ 个孩子，同时，左子树包含小于 $2$ 结点的元素，右子树包含大于 $2$ 结点的元素 $3$ 结点包含一大一小 $2$ 个关键码，且其具有 $3$ 个孩子，同时，左子树包含小于 $3$ 结点两个关键码的元素，右子树包含大于 $3$ 结点两个关键码的元素，中间子树包含介于 $3$ 结点两个关键码之间的元素 所有叶结点都在同一层","text":"【结构】2-3 树（2-3 Tree），是一种多路查找树，其是一棵具有如下特性的树： 每个结点都具有 $2$ 个孩子或 $3$ 个孩子，具有 $2$ 个孩子的结点称为 $2$ 结点，具有 $3$ 个孩子的结点称为 $3$ 结点 $2$ 结点包含 $1$ 个关键码，且其具有 $2$ 个孩子，同时，左子树包含小于 $2$ 结点的元素，右子树包含大于 $2$ 结点的元素 $3$ 结点包含一大一小 $2$ 个关键码，且其具有 $3$ 个孩子，同时，左子树包含小于 $3$ 结点两个关键码的元素，右子树包含大于 $3$ 结点两个关键码的元素，中间子树包含介于 $3$ 结点两个关键码之间的元素 所有叶结点都在同一层 当所有叶结点均处于同一层时，就说这棵树是树高平衡的，可见，2-3 树是树高平衡的，其最大的优点正是能够以相对较低的代价来保持树高平衡 如下图，内部结点 $12$、$48$ 为 $2$ 结点，内部结点 $\\{18,33\\}$、$\\{23,30\\}$ 为 $3$ 结点 同时，可以发现： 对于一棵高度为 $h$ 的 2-3 树，其至少有 $2^{h-1}$ 个叶结点，此时每个分支结点都有 $2$ 个孩子，从而形成一棵满二叉树 对于一棵高度为 $h$ 的 2-3 树，其至多有 $3^{h-1}$ 个叶结点，此时每个分支结点都有 $3$ 个孩子，从而形成一棵满三叉树 【查找】在 2-3 树中，查找一个关键码的过程类似于在二叉排序树中的查找 在 2-3 树中查找给定 $k$ 值的过程是： 若 root 是空树，查找失败 若 k = root-&gt;data，查找成功 对于 $2$ 结点，若 k &lt; root-&gt;data，则在 root 的左子树进行查找；若 k &gt; root-&gt;data，则在 root 的右子树进行查找 对于 $3$ 结点，若 k &lt; root-&gt;smallData，则在 root 的左子树进行查找；若 k &gt; root-&gt;bigData，则在 root 的右子树进行查找；否则，在 root 的中间子树进行查找 上述过程一直持续到 $k$ 被找到或者待查找的子树为空，若待查找的子树为空，则查找失败 值得注意的是，当查找失败时，恰好找到了以 $k$ 为键值的新结点在 2-3 树中的插入位置 以下图为例，要如果查找 $24$，首先查找根结点，由于 $24$ 大于根结点的 smallData=18，小于 bigData=33，那么进入第二层的中间子树查找；在第二层中，由于 $24$ 大于 smallData=23，小于 bigData=30，进入第三层的中间子树查找，最终到达包含 $24$ 的结点 【插入】在 2-3 树中，插入一个关键码的过程类似于在二叉排序树中的插入 插入一个记录的过程如下： 1.找到要被插入记录应该被插入的叶结点 2.若该叶结点为一个 $2$ 结点，那么可以直接将该记录添加在该叶结点中，从而升级为 $3$ 结点 3.若该叶结点为一个 $3$ 结点，那么需要将该结点进行分裂-提升，拆分为两个 $2$ 结点，再向上提升，具体步骤如下： 1）设要插入的叶结点为 $L$，分裂一个新结点 $L’$ 2）结点 $L$ 得到 $3$ 结点中两个关键码与新插入的记录中最小的一个，结点 $L’$ 得到最大的一个 3）进行一次提升，即将剩余的一个关键码与一个指向 $L’$ 的指针传回父结点，并将被提升的关键码插入父结点 4）若父结点为 $2$ 结点，那么重复步骤 2 5）若父结点为 $3$ 结点，那么重复步骤 3 的分裂-提升过程 如下图，假设在当前 2-3 树中，依次插入记录 $14$、$55$ 在插入 $14$ 时，从根结点开始查找，到达存储 $15$ 的叶结点时，发现其是一个 $2$ 结点，直接将 $14$ 插入即可 在插入 $55$ 时，从根结点开始查找，到达存储 $\\{50,52\\}$ 的结点，其是一个 $3$ 结点，需要进行分裂-提升 此时，存储 $\\{50,52\\}$ 的结点保存 $50$、$52$、$55$ 中最小的 $50$，新分裂的结点保存最大的 $55$，剩余的 $52$ 向上提升，发现其存储 $48$ 的结点为 $2$ 结点，直接将 $52$ 插入 【删除】当从 2-3 树删除一个关键码时，有三种情况要考虑： 1.从内部结点删除记录 当所删除的关键码为内部结点时，对树进行中序遍历，将要删除的关键码的中序前驱或中序后继元素作为替代元素即可 2.从叶结点为 $3$ 结点删除记录 当所删除的关键码位于叶结点且该结点为 $3$ 结点时，直接在该结点删除该关键码即可，不会影响整棵树的结构 3.从叶结点为 $2$ 结点删除记录 当所删除的关键码位于叶结点且该结点为 $2$ 结点时，可分为四种情况进行讨论 1）$2$ 结点的父结点是 $3$ 结点 此时，将 $3$ 结点进行拆分，根据删除要删除的元素的大小，将被拆分的点与 $3$ 结点的子树进行合并 2）$2$ 结点的父结点是 $2$ 结点，且拥有一个 $3$ 结点的右孩子 此时，将父结点与右孩子一起进行左旋，令父结点的右孩子的较小值成为新的父结点，原先的父结点成为新的左孩子，原先的右孩子的较大值不做改变 3）$2$ 结点的父结点是 $2$ 结点，且拥有一个 $2$ 结点的右孩子 此时，在不破坏 2-3 树的性质的前提下，将 $2$ 结点的右孩子变为 $3$ 结点的右孩子，然后删除要删除的元素，并将剩下的三个点进行左旋调整 4）当前树是一个满二叉树 此时，删除任意一个结点都会破坏 2-3 树的性质，需要考虑在不改变 2-3 树的顺序的情况下，将 2-3 树的层次减少一层","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"Linux 数据处理工具","slug":"25.Linux数据处理工具","date":"2018-07-01T03:39:00.000Z","updated":"2022-05-31T19:00:35.073Z","comments":true,"path":"linux/c290f804.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/c290f804.html","excerpt":"【sed 工具】sed 工具具有对数据进行替换、删除、新增、选取特定行等功能，其命令格式为：sed [选项] [动作] 常见的选项有：","text":"【sed 工具】sed 工具具有对数据进行替换、删除、新增、选取特定行等功能，其命令格式为：sed [选项] [动作] 常见的选项有： -n：使用安静模式，只有经过 sed 特殊处理的一行才被显示出来 -e：在命令行模式上进行 sed 的动作编辑 -f：将 sed 的动作写在一个文件内，通过 -f file 来执行 file 内的动作 -r：使 sed 的动作支持扩展正则表达式，默认情况下仅支持基础正则表达式 -i：直接修改读取的文件内容，不经过屏幕输出 而对于 sed 命令的动作，其格式为：[n1[,n2]] function 其中，n1 与 n2 不一定会出现，一般代表选择进行动作的行数，function 代表动作行为，具有下述参数： a：新增，后接字符串，这些字符串会在当前行的下一行出现 i：插入，后接字符串，这些字符串会在当前行的上一行出现 c：替换，后接字符串，这些字符串会替换 n1 到 n2 之间的行 s：替换，通常搭配正则表达式使用，格式为 &quot;s/要被替换的字符串/新字符串/g&quot; p：打印，将某个选择的数据打印出来，通常与 sed -n 搭配使用 d：删除 【awk 工具】awk 也是一个数据处理工具，相较于 sed 工具直接对行进行处理，awk 工具偏向于将一行分为数个字段来处理 awk 工具的命令格式为：awk &quot;条件类型1{动作1} 条件类型2{动作2}...&quot; filename 简单来说，在 awk 后接上两个单引号并加上大括号 {} 即可设置对数据进行的处理动作 在 awk 中，每一行的每个字段都是有一个变量名称的，依次是 $1、$2 等，而 $0 代表的是一整行的数据，可以发现，awk 是以行为一次处理单位的，在一行中又是以一个字段为处理单位的 整个 awk 的处理流程如下： 读入第一行，并将第一行的数据依次填入 $0、$1、$2 等变量中 依据条件类型的限制，判断是否进行后续的动作 做完所有的动作与条件类型 若还有后续的行，重复上述步骤，直到所有数据处理完为止 【格式化打印】有时需要将数据进行格式化输出，此时可采用 printf 命令来进行格式化打印，该命令类似于 C 语言中的 printf() 函数 printf 命令格式为：printf &quot;打印格式&quot; 打印内容","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件切割","slug":"24.Linux文件切割","date":"2018-06-30T13:49:00.000Z","updated":"2022-05-31T17:32:54.134Z","comments":true,"path":"linux/54601e3b.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/54601e3b.html","excerpt":"若想将一个大文件依据文件大小或函数来切割成数个小文件，可采用 split 命令 split 命令格式为：split [选项] file PREFIX 常见的选项如下：","text":"若想将一个大文件依据文件大小或函数来切割成数个小文件，可采用 split 命令 split 命令格式为：split [选项] file PREFIX 常见的选项如下： -b：后接欲切割成的文件大小，可加 b、k、m 等单位 -l：以行数进行切割 file：要进行切割的文件，- 代表由管道传输的输入流 PREFIX：前导符，作为切割文件的前导文字 若想将切割而成的多个小文件合并为一个大文件，使用数据流重定向即可","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 字符转换命令","slug":"23.Linux字符转换命令","date":"2018-06-30T11:35:00.000Z","updated":"2022-05-31T16:23:58.174Z","comments":true,"path":"linux/d3f2aa5f.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/d3f2aa5f.html","excerpt":"【tr 命令】tr 命令是一个管道命令，用来删除一段数据中的字符，或是对字符进行替换 对于删除字符，命令格式为：tr -d str，其会在数据中匹配 str 中的每个字符，之后进行删除","text":"【tr 命令】tr 命令是一个管道命令，用来删除一段数据中的字符，或是对字符进行替换 对于删除字符，命令格式为：tr -d str，其会在数据中匹配 str 中的每个字符，之后进行删除 对于替换字符，命令格式为：tr -s str1 str2，其会将数据中的 str1 替换为 str2，同时，支持正则表达式 【join 命令】join 命令用于处理两个文件间的数据，其会比较两个文件的字段，对相同的行，会将两条数据连成一行，命令格式为：join [选项] file1 file2 常用的选项有： -t：指定分隔符，默认为空格 -i：忽略大小写 -1：第一个文件以第几个字段分析，默认为第一个字段 -2：第二个字段以第几个字段分析，默认为第一个字段 需要注意的是，在使用 join 命令前，需要对处理的文件进行排序，否则在进行对比时某些项会被略过 【paste 命令】paste 命令与 join 命令类似，同样会将两个文件中的数据连成一行，但与 join 不同的是，paste 不会对比两个文件的数据相关性 paste 命令格式为：paste [-d] file1 file2，其中，-d 选项后接分隔符，默认为 [Tab] 【col 命令】在 Linux 说明文件中，含有多种控制字符，当使用数据流重定向将说明文件的内容输出为纯文本时，控制字符会变成乱码，而 col 命令能够有效的滤除这些控制字符 col 命令是一个管道命令，其有以下三种基本用法： col -x：将所有的 [Tab] 替换为多个 [Space] col -f：过滤掉 RLF，仅允许 HRLF 字符显示 col -b：过滤掉所有的控制字符 【expand 命令】expand 命令用于将文件内的 [Tab] 转为 [Space]，其命令格式为：expand [-t] file，其中，-t 选项后接数字，代表一个 [Tab] 用几个 [Space] 替换","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 排序命令","slug":"22.Linux排序命令","date":"2018-06-27T05:21:00.000Z","updated":"2022-05-31T17:58:37.952Z","comments":true,"path":"linux/a652e2c4.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/a652e2c4.html","excerpt":"【sort 命令】sort 命令可以依据不同的数据特征来进行排序，其即可作为一般命令来使用，又可作为管道命令，其基本格式为：sort [选项] file/stdin 常见的选项有：","text":"【sort 命令】sort 命令可以依据不同的数据特征来进行排序，其即可作为一般命令来使用，又可作为管道命令，其基本格式为：sort [选项] file/stdin 常见的选项有： -f：忽略大小写 -b：忽略最前面的空格 -M：以月份名来排序 -n：使用纯数字排序 -r：反向排序 -u：去重，仅出现一行代表数据 -t：分隔符，默认为 [Tab] -k：以哪个区间来排序 【uniq 命令】uniq 命令是一个管道命令，用于去重和计数，其常于 sort 命令结合使用，对于其去重功能，与 sort 命令 -f 选项作用一致 uniq 命令的命令格式为：uniq [选项] 常见的选项有： -i：忽略大小写 -c：进行计数","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 选取命令","slug":"21.Linux选取命令","date":"2018-06-27T04:07:00.000Z","updated":"2022-05-31T17:45:31.687Z","comments":true,"path":"linux/6695a8a8.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/6695a8a8.html","excerpt":"【cut 命令】cut 命令通常结合管道来使用，主要是将同一行里面的数据进行分解，常在数据与文本分析中对数据进行切割 其最常用的形式是：cut -d &quot;分隔字符&quot; -f fields，其中，fields 是一个数字，代表了依照 -d 切割后，选取第几段","text":"【cut 命令】cut 命令通常结合管道来使用，主要是将同一行里面的数据进行分解，常在数据与文本分析中对数据进行切割 其最常用的形式是：cut -d &quot;分隔字符&quot; -f fields，其中，fields 是一个数字，代表了依照 -d 切割后，选取第几段 此外，还可通过 cut -c 范围 来将数据进行切割选取 【grep 命令】cut 命令是在一行数据中截取我们所需要的，而 grep 命令则是分析所有数据，若其中某行有符合需要的信息，就将这行数据取出 grep 命令的基本格式为：grep [选项] [--color=auto] &quot;str&quot; filename 常见的选项有： -a：将 binary 文件以 text 文件的方式查找数据 -c：计算该行数据中，str 所出现的次数 -i：忽略大小写 -n：输出行号 -v：反向选择，即选取没有 str 内容的行 -E：在查找字符串 str 中使用扩展正则表达式（+、?、|、()、()+） -A：后接数字 n，除列出该行外，同时列出后续的 n 行 -B：后接数字 n，除列出该行外，同时列出前面的 n 行 -C：后接数字 n，列出该行以及前后的共 n 行 —color=auto：将遭到的关键字部分加以颜色显示，默认已经将 grep --color=auto 命令的别名设置为 grep 需要注意的是，对于查找字符串 str，其默认支持基础正则表达式 【wc 命令】wc 命令是一个管道命令，其用于统计有多少行、多少字、多少字符，常搭配 grep 命令使用，命令格式为：wc [选项] 常见的选项有： -l：列出行数 -w：统计字数 -m：统计字符数 在未使用选项时，会给出三列数字，分别代表行、字数、字符数","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 重定向与管道","slug":"20.Linux重定向与管道","date":"2018-06-25T13:41:00.000Z","updated":"2022-05-31T17:37:56.798Z","comments":true,"path":"linux/1e8b4afd.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/1e8b4afd.html","excerpt":"【数据重定向】命令执行过程当执行一个命令的时候，这个命令可能会由文件读入数据，经过处理后，再将数据输出到屏幕上，输出可能是标准输出，也可能是标准错误输出","text":"【数据重定向】命令执行过程当执行一个命令的时候，这个命令可能会由文件读入数据，经过处理后，再将数据输出到屏幕上，输出可能是标准输出，也可能是标准错误输出 标准输入输出由于输入数据、标准输出、标准错误输出都是默认显示在屏幕上，这就有可能造成屏幕显示混乱，而数据流重定向功能，就是将这些分别传送到其他的文件或设备中，所用的特殊字符如下所示： 标准输入 stdin：代码为 0，使用 &lt; 或 &lt;&lt; 表示 标准输出 stdout：代码为 1，使用 &gt; 或 &gt;&gt; 表示，为命令执行成功所回传的正确信息 标准错误输出 stderr：代码为 2，使用 2&gt; 或 2&gt;&gt; 表示，为命令执行失败所回传的错误信息 而对于 &gt; 与 &gt;&gt; 来说，其区别如下： 1&gt;：以覆盖的方法将正确的数据输出到指定文件或设备上 1&gt;&gt;：以累加的方法将正确的数据输出到指定文件或设备上 2&gt;：以覆盖的方法将错误的数据输出到指定文件或设备上 2&gt;&gt;：以累加的方法将错误的数据输出到指定文件或设备上 如下例，在键入 ll &gt; ~/testFile 后，屏幕并没有任何输出信息，而是创建了一个名为 testFile 的文件，打印该文件可以发现，其内容就是键入 ll 命令后的正确输出信息 垃圾桶黑洞有时，我们知道错误信息会发生，但并不想将出现的错误信息打印或存储到文件中，这时就可以采用黑洞设备 /dev/null，这个黑洞设备可以吃掉任何导向该设备的信息 【管道】将一个命令的输出作为另一个命令的输入，一种方法是通过一个临时文件将两命令结合在一起，另一种是使用 Linux 自带的管道功能，即通过 | 来连接命令 管道可以将一系列的命令连接起来，这意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又作为第三个命令的输入，以此类推，最终显示在终端上的，是管道行中最后一个命令的输出 需要注意的是，管道命令只会处理标准输出，且必须要能够接受前一个命令的输出作为下一个命令的标准输入，对于标准错误输出会进行忽略 例如，统计系统中当前登录的用户数 此外，当某些命令需要用到文件名来进行处理时，stdin 与 stdout 可以利用 - 来代替由管道传输而来的数据流 【双向重定向】重定向会将数据流整个传送给文件或设备，因此除非去读取该文件或设备，否则无法利用这个数据流 tee 命令会将数据流输出到文件与屏幕，输出到屏幕的，就是标准输出 stdout，可以让下个命令继续处理 tee 命令的基本格式为：tee [-a] file 对于 -a 选项，其会以累加的方式，将数据加入到 file 中","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 命令别名与历史命令","slug":"19.Linux命令别名与历史命令","date":"2018-06-25T03:30:00.000Z","updated":"2022-05-30T13:41:02.088Z","comments":true,"path":"linux/9cb7f6b6.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/9cb7f6b6.html","excerpt":"【命令别名】当惯用命令特别长时，不仅输入复杂而且容易出错，此时可以利用 alias 命令来设置命令别名，其格式为：alias 别名=&quot;命令&quot;","text":"【命令别名】当惯用命令特别长时，不仅输入复杂而且容易出错，此时可以利用 alias 命令来设置命令别名，其格式为：alias 别名=&quot;命令&quot; 此外，直接执行 alias 会显示当前已有的命令别名 如果想要删除某个命令别名时，使用 unalias 别名 即可删除 【历史命令】在 Shell 中，提供了记录历史命令的功能，通过 history 命令可进行查阅 其常见的用法有以下三种： 1.列出内存中的历史命令 使用 history [n] 即可显示内存中的最近使用的 n 条数据，若省略 n 则会显示内存中所有的历史命令 使用 history 所展示的历史命令有两列，第一列为该命令在这个 Shell 中的代码，第二列则是所使用的命令 2.清空内存中的历史命令 使用 history -c 可以将目前 Shell 中的所有历史记录消除 3.写入写出历史命令 history 命令提供将内存中的历史命令写入、写出的功能，其格式为：history [-raw] histfile，若没有加 histfile，则默认为 ~/.bash_history 各选项说明如下： -w：将目前 Shell 的 history 写入到 histfile 中 -r：将 histfile 的内容读入目前 Shell 的 history 中 -a：将目前新增的 history 新增到 histfile 中","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 完整备份工具","slug":"18.Linux完整备份工具","date":"2018-06-22T14:22:00.000Z","updated":"2022-05-17T17:34:31.574Z","comments":true,"path":"linux/cfacbca4.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/cfacbca4.html","excerpt":"【dump 命令】dump 命令用于备份文件系统或备份目录，此外还可以制定备份等级 如下图所示，实时文件系统是随着时间变化的数据，第一次使用 dump 备份时是 level 0，等到第二次备份时，level 1 仅是比较目前文件系统与 level 0 的差异后备份有变化的文件，同理，level 2 仅是与 level 1 比较","text":"【dump 命令】dump 命令用于备份文件系统或备份目录，此外还可以制定备份等级 如下图所示，实时文件系统是随着时间变化的数据，第一次使用 dump 备份时是 level 0，等到第二次备份时，level 1 仅是比较目前文件系统与 level 0 的差异后备份有变化的文件，同理，level 2 仅是与 level 1 比较 当备份的数据为单一文件系统时，那么该文件系统可以完整的使用 dump 功能，包括 0~9 的数个 level 来备份，而当备份的数据为目录时，则要求所有的备份数据都必须在该目录下，且仅支持 level 0 命令格式为：dump [选项] [-level] [-f 备份文件] 待备份数据 常见的选项有： -S：仅列出后面的待备份数据需要多少磁盘空间 -u：将这次 dump 的时间记录到 /etc/dumpdateS 文件中，备份目录时不可用 -v：将 dump 的文件过程显示出来 -j：加入 bzip2 的支持，将数据进行压缩，默认压缩等级为 2 -f：类似于 tar 的 -f，后接产生的文件 -w：列出在 /etc/fstab 里面的具有 dump 设置的分区是否有备份过 -level：即备份的 level 等级，从 0~9 共 10 个级别 【restore 命令】在使用 dump 命令对文件系统或目录备份后，当出现问题想要恢复备份时，可以使用 restore 命令，该命令常用的操作有四个： 查看 dump 文件：restore -t [-f dump文件] [-h] 比较 dump 文件与实际文件：restore -C [-f dump文件] [-D 挂载点] 进入互动模式：restore -i [-f dump文件] 还原整个文件系统：restore -r [-f dump文件] 各选项说明如下： -t：查看 dump 备份文件内所包含的数据，类似 tar 的 -t 选项 -C：将 dump 备份文件与实际文件进行比较，最终会显示 dump 内有记录的但与当前文件系统或目录不同的 -i：进入互动模式，但仅可还原部分文件，用于备份目录时的还原 -r：将整个文件系统进行还原，用于备份文件系统时的还原 -h：查看完整备份数据中的 inode 与文件系统 label 等信息 -D：与 -C 搭配，可以显示后接的挂载点与 dump 内不同的文件","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件压缩","slug":"17.Linux文件压缩","date":"2018-06-22T03:12:00.000Z","updated":"2022-05-17T14:20:32.129Z","comments":true,"path":"linux/918c8ab7.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/918c8ab7.html","excerpt":"【压缩扩展名】在 Linux 环境中，支持的压缩命令很多，且不同命令所采用的压缩技术不同，彼此之间可能就无法相互压缩/解压缩文件 常见的压缩文件扩展名如下表：","text":"【压缩扩展名】在 Linux 环境中，支持的压缩命令很多，且不同命令所采用的压缩技术不同，彼此之间可能就无法相互压缩/解压缩文件 常见的压缩文件扩展名如下表： 扩展名 文件 *.Z compress 程序压缩的文件，目前已弃用 *.gz gzip 程序压缩的文件 *.bz2 bzip2 程序压缩的文件 *.tar tar 程序打包的数据，未压缩 *.tar.gz tar 程序打包的数据，经过 gzip 压缩 *.tar.bz2 tar 程序打包的数据，经过 bzip2 压缩 【gzip 与 zcat】gzip 命令是目前最常用的压缩命令，可以解开 compress、zip、gzip 等软件所压缩的文件，命令格式为：gzip [选项] 文件名 常用选项有： -c：将压缩的数据输出到屏幕上，可通过数据流重定向处理 -d：解压缩 -t：检验压缩文件的一致性 -v：显示原文件/压缩文件的压缩比等信息 -#：压缩等级，-1 最快，但压缩比最差，-9 最慢，但压缩比最好，默认为 -6 当使用 gzip 压缩时，默认状态下原本的文件会被压缩为后缀为 .gz 的文件 cat 命令可以读取纯文本文件，而 zcat 命令可以读取纯文本被压缩后的压缩文件 【bzip2 与 bzcat】gzip 是为了替代 compress 并提供更好的压缩比而创造的，bzip2 则是为了取代 gzip 而创造的，命令格式为：bzip2 [选项] 文件名 常用的选项有： -c：将压缩过程中产生的数据输出到屏幕上 -d：解压缩 -k：保留原文件，不删除原始的数据文件 -z：压缩 -v：显示原文件/压缩文件的压缩比等信息 -#：压缩等级，-1 最快，但压缩比最差，-9 最慢，但压缩比最好，默认为 -6 与 gzip 命令和 zcat 命令一样，使用 bzcat 可以读取纯文本被 bzip2 压缩后的压缩文件 【tar 命令】文件打包使用 gzip 或 zip2 只能对单个文件进行压缩，若是对目录进行操作，这两个命令会将目录内的所有文件分别进行压缩 若想将多个文件或目录压缩成一个文件，需要先使用 tar 命令进行打包，打包后再使用 gzip 或 bzip2 进行压缩 打包与压缩命令格式：tar [-z|-j] [cv] [-f 新建文件名] 要压缩的文件名或目录名 [--exclude=FILE] -z：采用 gzip 进行压缩，此时新建文件名最好为 *.tar.gz 形式 -j：采用 bzip2 进行压缩，此时新建文件名最好为 *.tar.bz2 形式 -c：新建打包文件 -v：在压缩/解压缩过程中，将正在处理的文件名显示出来 —exclude=FILE：在打包某目录时，排除该目录中的 FILE 所指示的文件 一般来说，最简单的使用 tar 进行打包压缩的命令是：tar -jcv -f 新建文件名 要压缩的文件名或目录名 查看文件要想查看使用 tar 打包并压缩后的文件中包含哪些文件，可以使用命令：tar [-z|-j] [tv] [-f 要查看的文件名] -z：采用 gzip 进行压缩，此时新建文件名最好为 *.tar.gz 形式 -j：采用 bzip2 进行压缩，此时新建文件名最好为 *.tar.bz2 形式 -t：查看打包文件的内容所包含的文件名 -v：在压缩/解压缩过程中，将正在处理的文件名显示出来 一般来说，最简单的使用 tar 进行查看文件的命令是：tar -jtv -f 要查看的文件名 解压缩命令格式：tar [-z|-j] [xv] [-f 要解压文件名] [-C 目录] -z：采用 gzip 进行压缩，此时新建文件名最好为 *.tar.gz 形式 -j：采用 bzip2 进行压缩，此时新建文件名最好为 *.tar.bz2 形式 -x：解包或解压缩，可搭配 -C 在特定目录展开 -v：在压缩/解压缩过程中，将正在处理的文件名显示出来 一般来说，最简单的使用 tar 进行解压缩文件的命令是：tar -jxv -f 要解压文件名 —C 要解压的目录","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 磁盘管理","slug":"16.Linux磁盘管理","date":"2018-06-20T07:52:00.000Z","updated":"2022-05-16T18:08:16.265Z","comments":true,"path":"linux/d015da31.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/d015da31.html","excerpt":"【磁盘分区】若想要在系统中新增一块硬盘，对磁盘进行分区是第一步 fdisk 命令是一个创建和维护分区表的程序，命令格式为：fdisk [-l] 设备名称","text":"【磁盘分区】若想要在系统中新增一块硬盘，对磁盘进行分区是第一步 fdisk 命令是一个创建和维护分区表的程序，命令格式为：fdisk [-l] 设备名称 当使用 -l 选项而不加设备名时，会将整个系统内能够找到的设备分区列出 由于每台主机的磁盘数量不同，因此在进行分区时，通常会先使用 df 命令列出可用的磁盘文件名，再用 fdisk 命令进行查阅 在进入 fdisk 工作界面后，可以输入 m 以获取帮助，可以看到如下所示的命令介绍 常用的命令有： d：删除一个分区 n：新增一个分区 p：在屏幕上显示分区表 q：不存储操作，离开 fdisk w：将操作写入分区表 如下图所示，输入 n 后，按照提示即可创建一个新的分区 在输入 p 后，会列出当前磁盘的分区表信息，相当于 fdisk -l 【磁盘格式化】分区后接着要进行的操作就是进行文件系统的格式化，一般会选用 mkfs 命令来进行该操作，命令格式为：mkfs -t 文件系统格式 设备文件名 该命令事实上是一个综合命令，例如当运行 mkfs -t ext3 ... 时，系统会去调用 mkfs.ext3 这个命令以进行格式化操作 在终端输入 mkfs 后，连续按下两次 Tab 键，会列出 mkfs 所支持的文件系统格式 【磁盘检验】在系统运行过程中，当出现死机时，文件系统可能会出现硬盘与内存数据的异步的情况，此时可使用 fsck 命令来检验并修复文件系统是否出错，使用 badblocks 命令来检验磁盘或软盘扇区是否出现坏轨 fsck 命令fsck 命令来检验并修复文件系统是否出错，其与 mkfs 命令一样，也是一个综合命令，但其会通过 Super Block 自动分辨文件系统来调用相应的程序，命令格式为：fsck [-t 文件系统] -[选项] 设备名称 常用的选项有： -t：后跟文件系统，由于 fsck 命令可自动辨别文件系统，因此该选项可省略 -A：依据 /etc/fstab 的内容，将需要的设备扫描一次，一般在开机过程中执行该命令 -C：在检验过程中，使用一个直方图来显示当前的进度 -a：自动修复检查到的有问题的扇区 -y：与 -a 作用相同，但某些文件系统仅支持 -y 这个选项 同样，在终端输入 fsck 后，连续按下两次 Tab 键，会列出 fsck 所支持的文件系统格式 需要注意的是，该命令通常只有 root 用户且文件系统有问题时使用，否则可能会对系统造成危害，一般情况下，都是系统出现极大问题，导致在 Linux 开机时不得不进入单用户模式进行维护时，才可使用 此外，在执行该命令时，被检查的分区不可挂载在系统树上，必须处于卸载状态 badblocks 命令badblocks 命令来检验磁盘或软盘扇区是否出现坏轨，命令格式为：badblocks [选项] 设备名称 常用的选项有： -s：在终端上列出检查进度 -w：使用写入的方式来测试，在待检查的设备有文件时不推荐使用 【磁盘挂载与卸载】挂载将文件系统与目录树结合的操作被称为挂载，挂载点一定是目录，该目录为进入该文件系统的入口，因此并非所有的文件系统均可使用，必须挂载到目录树的某个目录后方可使用 需要注意的是，单一文件系统不能被重复挂载到不同的挂载点中，单一目录也不能重复挂载到多个文件系统上，同时，作为挂载点的目录应当都是空目录 只有当进行挂载后，方可读取光盘、软盘、U 盘等设备上的文件 mount 命令mount 命令用于将文件系统挂载到 Linux 系统上，其有三种常用的形式： mount -a：依照配置文件 /etc/fstab 的数据将所有未挂载的磁盘都挂载上 mount [-l]：只运行 mount 会显示目前挂载的信息，加上 -l 可增加列 Label 名称 mount [-t 文件系统] [-L Label 名] [-o 额外选项] 设备文件名 挂载点：挂载文件系统 对于第三种形式，其选项说明如下： -t：与 mkfs 的 -t 选项类似，可以加上文件系统的种类来指定要挂载的类型 -L：除利用设备文件名外，可利用卷标名称 Label 来进行挂载 -o：后跟一些挂载时额外的参数，默认参数为 rw,suid,dev,exec,auto,nouser,async，具体含义见下表 参数 意义 ro/rw 挂载文件系统成为只读/只写 suid/nosuid 是否允许该分区上含有 suid/sgid 的文件格式 dev/nodev 是否允许该分区上可创建设备文件 exec/noexec 是否允许该分区上拥有可执行 binary 文件 auto/noauto 是否允许该分区可被 mount -a 自动挂载 user/nouser 是否运行该分区让任何用户执行 mount 命令（默认情况下，仅允许 root 用户执行） async/sync 挂载的文件系统是否使用异步写入/同步写入的内存机制，默认为异步方式 async remount 进行重新挂载 umount 命令umount 命令用于将设备文件卸载，只有当进行卸载后，方可退出光盘、软盘、U 盘等设备，其命令格式为：umount [选项] 设备文件名或挂载点 常用的选项有： -f：强制卸载，常用于网络文件系统 NFS 无法读取的情况下 -n：不更新 /etc/mtab 的情况下卸载 只有当进行卸载后，访客退出光盘、软盘、U 盘等设备 开机挂载手动处理挂载十分繁琐，为此，可设置让系统自动在开机时进行挂载，这样就不需要每次进入 Linux 系统后进行手动挂载 在 Linux 系统中，/etc/fstab 就是将所有利用 mount 命令进行挂载时的参数文件，也即利用 mount -a 命令进行的挂载数据文件 如图所示，该文件一共含有六个字段： 第一列：磁盘设备文件名或该设备的卷标 Label 第二列：挂载点 第三列：磁盘分区的文件系统 第四列：文件系统参数 第五列：能否被 dump 备份命令使用 第六列：是否用 fsck 命令检查扇区 【磁盘参数修改】mknod 命令在 Linux 中，所有的设备都以文件来代表，具体来说，是通过文件的 major 和 minor 数值来替代，其中 major 为主设备代码，minor 为次设备代码 常见的硬盘文件名 /dev/hda 与 /dev/sda 设备代码表如下 磁盘文件名 major minor /dev/hda 3 0~63 /dev/hdb 3 64~127 /dev/sda 8 0~15 /dev/sdb 8 16~31 mknod 命令可设置设备的 major 与 minor，命令格式为：mknod 设备文件名 [设备种类] [major] [minor] 常见的设备种类有： b：设置设备名称成为一个外部存储设备文件，例如硬盘 c：设置设备名称成为一个外部输入设备文件，例如鼠标、键盘 p：设置设备名称成为一个 FIFO 文件 e2label 命令e2label 命令用于修改格式化后的文件系统的卷标 Label，命令格式为：e2label 设备名称 新 Label","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件系统基本操作","slug":"15.Linux文件系统基本操作","date":"2018-06-18T09:02:00.000Z","updated":"2022-05-16T07:52:19.499Z","comments":true,"path":"linux/2f5f2c2a.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/2f5f2c2a.html","excerpt":"【磁盘与目录容量】df 命令df 命令用于列出文件系统的整体磁盘使用量，命令格式为：df [选项] [目录或文件名]","text":"【磁盘与目录容量】df 命令df 命令用于列出文件系统的整体磁盘使用量，命令格式为：df [选项] [目录或文件名] 其选项有： -a：列出所有的文件系统 -k：以 KB 的容量显示文件系统 -m：以 MB 的容量显示文件系统 -h：以容易阅读的 KB、MB、GB 等形式显示 -H：以 M=1000K 代替 M=1024K 的进位方式 -T：连同分区的文件系统名称一起列出 -i：不使用硬盘容量，而用 inode 数量显示 如下图，将系统内所有的文件系统列出 对于输出的结果信息，各字段含义如下： 文件系统：该文件系统是在哪个分区，所列出的设备名称 类型：该分区的文件系统名称，由 -T 选项指示 1-K 块：数字单位是 1K，可由 -h 或 -T 选项来改变容量 已用：已使用的硬盘空间 可用：剩余的磁盘空间 已用 %：磁盘的使用率 挂载点：磁盘挂载的目录所在 需要注意的是，如果使用 -a 选项，系统会出现 /proc 这个挂载点，但所有的字段均为 0，这是因为 /prop 内的文件都是系统所需要加载的系统数据，且挂载在内存中，没有占用任何硬盘空间 du 命令du 命令用于评估文件系统的磁盘使用量，常用于评估目录所占容量，命令格式为：du [选项] 目录或文件名 其选项有： -a：列出所有的文件与目录容量，默认情况下，只统计目录下的文件量 -k：以 KB 的容量显示 -m：以 MB 的容量显示 -h：以容易阅读的 KB、MB、GB 等形式显示 -s：列出总量，而不列出各目录所占容量 -S：列出不包括子目录下的总量 如下图，在未加任何选项时，du 命令会自动分析当前目录下文件与目录所占的硬盘空间，但实际显示时，仅会显示目录容量，且默认情况下，以 KB 容量显示 【连接文件】ln 命令ln 命令用于连接文件，命令格式为：ln [选项] 源文件 目标文件 其选项如下： -s：进行软连接（若不加任何参数，则进行硬连接） -f：若目标文件存在时，就主动将目标文件删除后重新创建 硬连接在 Linux 中，每个文件都会占用一个 inode，文件内容由 inode 的记录来指向，想要读取文件，必须经过目录记录的文件名来指向到正确的 inode 号才可读取 也就是说，文件名只与目录有关，但文件内容与 inode 有关，硬连接就是在某个目录下新建一条文件名连接到某 inode 号的关联记录 举例来说，假设系统存在一个文件名为 /root/crontab，其是 /etc/crontab 的实际连接，也就是说这两个文件名连接到同一个 inode，自然而然这两个文件的所有相关信息除文件名外相同 如下图所示，可以通过 1 或 2 的目录的 inode 指定 block 找到两个不同的文件名，但无论使用哪个文件名均可以指到 real 所对应的 inode 以读取文件内容 使用硬连接最大的好处就是安全，如果将任何一个文件名删除，其实 inode 与 block 都是存在的，此时可以通过另一个文件名来读取文件内容，此外，无论使用哪个文件名进行编辑，最终都会写入到相同的 inode 与 block 中 但硬连接仅能在单一文件系统中进行，无法跨文件系统，此外，其也无法连接到目录 软连接软连接又称符号连接，其类似于 Windows 系统下的快捷方式 也就是说，软连接是在建立一个独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名，由于只是利用文件来做指向操作，因此当源文件被删除后，软连接的文件会无法打开，实际上就是找不到源文件的文件名 如下图所示，由 1 号 inode 读取到连接文件的内容只有文件名，根据文件名连接到正确的目录去取得目标文件的 inode，如果目标文件被删除，那么整个读取环节就无法进行下去","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件查询","slug":"14.Linux文件查询","date":"2018-06-18T08:21:00.000Z","updated":"2022-05-14T16:49:24.329Z","comments":true,"path":"linux/b707c157.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/b707c157.html","excerpt":"【概述】在 Linux 中，当给出文件名要查找文件目录时，有 whereis、locate、find 这三条命令 Linux 系统会将系统中的所有文件都记录在一个数据库文件 /var/lib/mlocate 中，当使用 whereis 或 locate 命令时，都会以此数据库文件为准，根据数据库中的结果去查找文件所在","text":"【概述】在 Linux 中，当给出文件名要查找文件目录时，有 whereis、locate、find 这三条命令 Linux 系统会将系统中的所有文件都记录在一个数据库文件 /var/lib/mlocate 中，当使用 whereis 或 locate 命令时，都会以此数据库文件为准，根据数据库中的结果去查找文件所在 而 find 命令是直接查找硬盘，相较于 whereis 和 locate 命令，要花费更多的时间 【whereis 命令】whereis 命令格式为：whereis [选项] 文件名或目录名 其选项有： -b：只查找二进制文件 -m：只查找说明文件 manual 路径下的文件 -s：只查找 source 源文件 -u：查找不在上述三个选项中的其他特殊文件 如下图，利用 whereis 找出 ifconfig 文件 【locate 命令】locate 命令相较于 whereis 命令更加简单，其后输入文件的部分名称即可得到结果 locate 命令格式为：locate [选项] 关键字 其选项有： -i：忽略大小写 -r：后接正则表达式 如下图，利用 locate 找出 passwd 相关的文件 【mlocate 数据库】使用 whereis 或 locate 命令寻找数据时，其 /var/lib/mlocate 数据库每天默认更新一次，这就导致有时会查找不到新建的文件，或者能查找到刚删除的文件 如果想要对 /var/lib/mlocate 数据库进行手动更新，直接输入 updatedb 命令即可，该命令会根据 /etc/updatedb.conf 的设置，去查找系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件 需要注意的是，使用 updatedb 命令手动更新 mlocate 数据库时，会花费较长的时间 【find 命令】命令格式find 命令相较于 whereis 和 locate 命令来说，会耗时较长一些，但其结果更加准确，不会出现 whereis 和 loacte 命令出现的问题 其命令格式为：find [路径] [选项] 与时间有关的选项find 命令与时间有关的选项有：-atime、-ctime、-mtime 这三个，下面以 -mtime 为例进行说明： -mtime n：列出 n 天之前的一天内被更改过的文件 -mtime +n：列出 n 天之前被更改过的文件，不包括 n 天本身 -mtime -n：列出 n 天之前被更改过的文件，包括 n 天本身 newer file：列出比 file 还要新的文件名 可以发现，与时间有关的选项，其核心在于 n，有没有 +、- 号区别很大，以下图为例： 图中最右边为当前时间，越向左代表越早之前的时间轴，4、+4、-4 分别具有以下含义： 4：4~5 那一天的的文件 +4：大于等于 5 天前的文件 -4：小于等于 4 天内的文件","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件与目录的权限","slug":"13.Linux文件与目录的权限","date":"2018-06-17T15:56:00.000Z","updated":"2022-05-14T16:47:41.671Z","comments":true,"path":"linux/b8bc31b2.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/b8bc31b2.html","excerpt":"【概述】在 Linux 文件属性 中，介绍了使用 ls 命令查看文件的属主、属组、其他权限，以及使用 chmod 命令修改文件权限，下面，详细的介绍文件权限的相关内容 【默认权限】","text":"【概述】在 Linux 文件属性 中，介绍了使用 ls 命令查看文件的属主、属组、其他权限，以及使用 chmod 命令修改文件权限，下面，详细的介绍文件权限的相关内容 【默认权限】文件默认权限是指，当用户新建一个文件或目录时权限的默认值，umask 命令用于指定默认权限 查看默认权限在查看系统的默认权限时，有两种方法 umask 和 umask -S 直接使用 umask 命令，会给出 4 位数字，第一位是特殊权限用的，后面会进行详细介绍，后三位分别对应 user、group、other 的权限，其含义是该默认值需要减掉的权限（被拿掉的权限），r、w、x 分别对应了 4、2、1 在默认情况下，root 的默认权限会拿掉比较多的属性，其 umask 默认为 022，而对于一般用户，其 umask 默认为 002 如下图，输入 umask 后给出 0002，这代表了用户、组未被拿掉任何权限，其他用户被拿掉写权限 而使用 umask -S 命令，会给出系统默认权限的字符形式。 修改默认权限umask 也可用于修改默认权限，在其后跟 3 位分别对应 user、group、other 权限的数字，该数字是被拿掉的权限 如下图，将默认权限设为 222，代表 user、group、other 分别被拿掉了写权限 目录与文件的默认权限一般创建的文件，其目的是用于数据记录，不应该有执行权限，只有 r、w 两个选项，即其权限最大是 666，默认权限为：-rw-rw-rw 而目录需要进入，这就与执行权限有关，因此其所有权限均为开放，即其最大权限是 777，默认权限为：drwxrwxrwx 当 umask 为 002 时，user 和 group 未被拿走任何权限，但 other 被拿走了 w 权限，那么当用户新建文件或目录时，有不同的权限： 新建文件：(-rw-rw-rw-)-(————w-)=&gt;-rw-rw-r— 新建目录：(drwxrwxrwx)-(————w-)=&gt;drwxrwxr-x 【特殊权限】概述文件的特殊权限有三个，分别是 SUID、SGID、SBIT，这三个权限与系统账号和系统进程有关 之前介绍的权限，均为 r、w、x，而在特殊权限中，引入了另外两个标志，分别是 s 和 t SUID 与 SGIDSUID 是 Set User ID，SGID 是 Set Group ID 我们知道，在 Linux 中，系统内核是根据进程的运行用户的 ID 来确定一个进程对资源的访问权限，而这个运行用户的 ID 就包括 UID 和 GID 在 Linux 系统中，当一个文件的 user 的可执行位被设为 s，那么说明该文件被设置了 UID，即 Set UID（SUID）；如果一个文件的 group 的可执行位被设为 S，那么说明该文件被设置了 GID，即 Set GID（SGID） SUID 权限仅可作用于文件，且对二进制程序有效，当一个文件被被设置 SUID 后，其有以下特点： 一个执行者若想执行该程序，需要拥有该程序的可执行权限（x） 可执行权限（x）仅在执行该程序的过程中有效 执行者将具有程序所有者的权限。 SGID 权限除了作用于文件（二进制程序）外，还可作用于目录 当一个文件被设置 SGID 后，其有以下特点： 一个执行者若想执行该程序，需要拥有该程序的可执行权限（x） 在执行过程中，将会获得该程序用户组的支持 而当一个目录被设置 SGID 后，其有以下特点： 只有当某用户拥有该目录的 r 和 x 权限时，才能进入目录 若用户具有该目录的 w 权限（可新建文件），则用户所创建的新文件的用户组与此目录组相同 用户在此目录下的有效用户组将会变成该目录的用户组 SBITSBIT 是 Sticky Bit，其标志位为 s，目前只针对目录有效，其作用是： 当用户具有该目录的 w、x 权限时，将拥有写入权限 当用户在该目录下创建文件和目录时，仅有自己和 root 用户才有权利删除该文件 特殊权限的设置对于基础三位 r、w、x 权限，在其前再加一位数字，并进行如下规定： 4 代表 SUID 2 代表 SGID 1 代表 SBIT 这样一来，使用 chmod 命令即可进行设置特殊权限 如下图，为 test.txt 文件加入 SUID 和 SGID 权限","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"霍夫曼编码","slug":"data-structure/08.huffman-tree/02.霍夫曼编码","date":"2018-06-17T11:22:19.000Z","updated":"2021-09-06T13:40:37.815Z","comments":true,"path":"oi-acm/data-structure/huffman-tree/471b2631.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/huffman-tree/471b2631.html","excerpt":"【前缀编码】在进行程序设计时，通常给每一个字符标记一个单独的代码来表示一组字符，即编码 在进行二进制编码时，假设所有的代码都等长，那么表示 $n$ 个不同的字符需要 $\\left \\lceil log_2\\:n \\right \\rceil$ 位，称为等长编码","text":"【前缀编码】在进行程序设计时，通常给每一个字符标记一个单独的代码来表示一组字符，即编码 在进行二进制编码时，假设所有的代码都等长，那么表示 $n$ 个不同的字符需要 $\\left \\lceil log_2\\:n \\right \\rceil$ 位，称为等长编码 如果每个字符的使用频率相等，那么等长编码无疑是空间效率最高的编码方法，而如果字符出现的频率不同，则可以让频率高的字符采用尽可能短的编码，频率低的字符采用尽可能长的编码，来构造出一种不等长编码，从而获得更好的空间效率 在设计不等长编码时，要考虑解码的唯一性，如果一组编码中任一编码都不是其他任何一个编码的前缀，那么称这组编码为前缀编码，其保证了编码被解码时的唯一性 【霍夫曼编码】霍夫曼树可用于构造最短的前缀编码，即霍夫曼编码，其构造步骤如下： 1）设需要编码的字符集为：$d_1,d_2,…,d_n$，他们在字符串中出现的频率为：$w_1,w_2,…,w_n$ 2）以 $d_1,d_2,…,d_n$ 作为叶结点，$w_1,w_2,…,w_n$ 作为叶结点的权值，构造一棵霍夫曼树 3）规定哈夫曼编码树的左分支代表 $0$，右分支代表 $1$，则从根结点到每个叶结点所经过的路径组成的 $0$、$1$ 序列即为该叶结点对应字符的编码 【实现】1234567891011121314151617181920typedef struct HNode &#123; int weight; HNode *lchild, *rchild;&#125; *Htree;void huffmanCoding(Htree root, int len, int arr[]) &#123; //计算霍夫曼编码 if (root != NULL) &#123; if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) &#123; printf(\"结点为%d的字符的编码为: \", root-&gt;weight); for (int i = 0; i &lt; len; i++) printf(\"%d\", arr[i]); printf(\"\\n\"); &#125; else &#123; arr[len] = 0; huffmanCoding(root-&gt;lchild, len + 1, arr); arr[len] = 1; huffmanCoding(root-&gt;rchild, len + 1, arr); &#125; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"霍夫曼树","slug":"oi-acm/data-structure/huffman-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/huffman-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"霍夫曼树","slug":"huffman-tree","permalink":"https://alex-mcavoy.github.io/tags/huffman-tree/"}],"author":"Alex_McAvoy"},{"title":"霍夫曼树","slug":"data-structure/08.huffman-tree/01.霍夫曼树","date":"2018-06-17T07:09:19.000Z","updated":"2021-09-06T13:03:09.297Z","comments":true,"path":"oi-acm/data-structure/huffman-tree/c01a18e7.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/huffman-tree/c01a18e7.html","excerpt":"【树的带权路径长度】设二叉树具有 $n$ 个带权叶结点，从根结点到各叶结点的路径长度与相应叶节点权值的乘积之和称为树的带权路径长度（Weighted Path Length of Tree，WPL） 设 $w_i$ 为二叉树地 $i$ 个叶结点的权值，$l_i$ 为从根结点到第 $i$ 个叶结点的路径长度，则 WPL 计算公式如下：","text":"【树的带权路径长度】设二叉树具有 $n$ 个带权叶结点，从根结点到各叶结点的路径长度与相应叶节点权值的乘积之和称为树的带权路径长度（Weighted Path Length of Tree，WPL） 设 $w_i$ 为二叉树地 $i$ 个叶结点的权值，$l_i$ 为从根结点到第 $i$ 个叶结点的路径长度，则 WPL 计算公式如下： WPL=\\sum_{i=1}^nw_il_i 如上图所示，其 WPL 计算过程与结果如下： WPL=2*2+3*2+4*2+7*2=4+6+8+14=32【霍夫曼树】结构对于给定一组具有确定权值的叶结点，可以构造出不同的二叉树，其中，WPL 最小的二叉树称为霍夫曼树 对于霍夫曼树来说，其叶结点权值越小，离根越远，叶结点权值越大，离根越近，此外其仅有叶结点的度为 $0$，其他结点度均为 $2$ 霍夫曼算法霍夫曼算法用于构造一棵霍夫曼树，算法步骤如下： 1）初始化：由给定的 $n$ 个权值构造 $n$ 棵只有一个根节点的二叉树，得到一个二叉树集合 $F$ 2）选取与合并：从二叉树集合 $F$ 中选取根节点权值最小的两棵二叉树分别作为左右子树构造一棵新的二叉树，这棵新二叉树的根节点的权值为其左、右子树根结点的权值和 3）删除与加入：从 $F$ 中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到 $F$ 中 4）重复 2）、3） 步，当集合中只剩下一棵二叉树时，这棵二叉树就是霍夫曼树 【实现】霍夫曼树的构建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950typedef struct HNode &#123; int weight; HNode *lchild, *rchild;&#125; *Htree;Htree createHuffmanTree(int arr[], int n) &#123; Htree forest[N]; Htree root = NULL; for (int i = 0; i &lt; n; i++) &#123; //将所有点存入森林 Htree temp; temp = (Htree)malloc(sizeof(HNode)); temp-&gt;weight = arr[i]; temp-&gt;lchild = temp-&gt;rchild = NULL; forest[i] = temp; &#125; for (int i = 1; i &lt; n; i++) &#123; //n-1次循环建哈夫曼树 int minn = -1, minnSub; //minn为最小值树根下标,minnsub为次小值树根下标 for (int j = 0; j &lt; n; j++) &#123; if (forest[j] != NULL &amp;&amp; minn == -1) &#123; minn = j; continue; &#125; if (forest[j] != NULL) &#123; minnSub = j; break; &#125; &#125; for (int j = minnSub; j &lt; n; j++) &#123; //根据minn与minnSub赋值 if (forest[j] != NULL) &#123; if (forest[j]-&gt;weight &lt; forest[minn]-&gt;weight) &#123; minnSub = minn; minn = j; &#125; else if (forest[j]-&gt;weight &lt; forest[minnSub]-&gt;weight) &#123; minnSub = j; &#125; &#125; &#125; //建新树 root = (Htree)malloc(sizeof(HNode)); root-&gt;weight = forest[minn]-&gt;weight + forest[minnSub]-&gt;weight; root-&gt;lchild = forest[minn]; root-&gt;rchild = forest[minnSub]; forest[minn] = root; //指向新树的指针赋给minn位置 forest[minnSub] = NULL; //minnSub位置为空 &#125; return root;&#125; WPL 的计算对于给出 $n$ 个叶结点的权值，计算构成霍夫曼树的 WPL 1）递归实现 1234567891011121314151617typedef struct HNode &#123; int weight; HNode *lchild, *rchild;&#125; *Htree;int getWPL(Htree root, int len) &#123; //递归实现，对于已经建好的霍夫曼树，求WPL if (root == NULL) return 0; else &#123; if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) //叶节点 return root-&gt;weight * len; else &#123; int left = getWPL(root-&gt;lchild, len + 1); int right = getWPL(root-&gt;rchild, len + 1); return left + right; &#125; &#125;&#125; 2）非递归实现 1234567891011121314151617int getWPL(int arr[], int n) &#123; //对于未建好的霍夫曼树，直接求其WPL priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; huffman; //小根堆 for (int i = 0; i &lt; n; i++) huffman.push(arr[i]); int res = 0; for (int i = 0; i &lt; n-1 ; i++) &#123; int x = huffman.top(); huffman.pop(); int y = huffman.top(); huffman.pop(); int temp = x + y; res += temp; huffman.push(temp); &#125; return res;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"霍夫曼树","slug":"oi-acm/data-structure/huffman-tree","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/huffman-tree/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"霍夫曼树","slug":"huffman-tree","permalink":"https://alex-mcavoy.github.io/tags/huffman-tree/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件内容查阅","slug":"12.Linux文件内容查阅","date":"2018-06-16T15:56:00.000Z","updated":"2022-05-14T16:45:43.024Z","comments":true,"path":"linux/f739b1c3.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/f739b1c3.html","excerpt":"【概述】在查看文件内容时，有以下几个命令，可以根据不同的需要选取相应的命令： cat 命令：从第一行开始显示 tac 命令：从最后一行开始显示 nl 命令：显示文件内容时同时显示行号 more 命令：一页一页显示文件内容 less 命令：一页一页显示内容，可以向前翻页 head 命令：只看开头几行 tail 命令：只看结尾几行 od 命令：以二进制方式读取文件内容","text":"【概述】在查看文件内容时，有以下几个命令，可以根据不同的需要选取相应的命令： cat 命令：从第一行开始显示 tac 命令：从最后一行开始显示 nl 命令：显示文件内容时同时显示行号 more 命令：一页一页显示文件内容 less 命令：一页一页显示内容，可以向前翻页 head 命令：只看开头几行 tail 命令：只看结尾几行 od 命令：以二进制方式读取文件内容 【直接查看文件内容】cat 命令命令格式cat 命令会将文件从第一行到最后一行显示，其命令格式为：cat [选项] 文件 其选项有： -n：列出行号，含空白行 -b：列出行号，不含空白行 -T：将 Tab 以 ^I 显示出来 -E：将结尾的断行字符 $ 显示出来 -v：列出看不到的特殊字符 -A：相当于 vET 实例正向显示 /test/test.txt 中的内容，要求同时输出行号 tac 命令命令格式tac 命令则是从最后一行到第一行显示，与 cat 命令正好相反，其命令格式为：tac [选项] 文件 选项有： -b：在行前而非行尾添加分隔标志 -r：将分隔标志视作正则表达式来解析 -s：使用指定字符串代替换行作为分隔标志 实例反向显示 /test/test.txt 中的内容 nl 命令命令格式nl 命令会添加行号打印文件内容，其命令格式为：nl [选项] 文件 选项有： 指定行号指定方式： -b a：无论是否有空行，均列出行号（类似 cat -n） -b t：如果有空行，空行不列出行号（默认） 列出行号表示方法： -n ln：行号在屏幕最左方显示，且不加 0 -n rn：行号在字段最右方显示，且不加 0 -n rz：行号在字段最右方显示，且加 0（默认为 6 位） -w：行号字段占用位数 实例1.输出 /test/test.txt 的内容，同时显示行号，要求行号在字段左边 2.输出 /test/test.txt 的内容，同时显示行号，要求行号在字段右边 3.输出 /test/test.txt 的内容，同时显示行号，要求行号在字段右边，自动补0，若有空行同样显示行号，且行号位数为 3 【翻页查看】more 命令more 命令可以一页一页的对文件进行查看，当文件内容大于屏幕输出的行数时，最后一行会显示当前显示的百分比 在查看过程中，可输入一些命令，来进行操作： 空格键：下翻一页 回车键：下滚一行 /字符串：在当前页向下查询 “字符串” :f：立即显示文件名及目前行数 b：向回翻页 q：退出 more less 命令less 命令同样是用来一页一页查看文件的，但比 more 命令更有弹性 同样，在阅读过程中，可输入一些命令，来进行操作： 空格键：下翻一页 PageDown：下翻一页 PageUp：上翻一页 /字符串：在当前页向下查询 “字符串” ?字符串：在当前页向上查询 “字符串” n：重复前一个查询 N：反向重复前一个查询 q：退出 less 【数据选取】对于输出的数据，可以利用 head 命令和 tail 命令做一个简单的选取，两者以行为单位，从前向后或从后向前选取若干行 其命令格式如下： head [-n number] 文件：从前向后选取 number 行（默认 10 行） tail [-n number] 文件：从后向前选取 number 行（默认 10 行） 【非纯文本文件】对于非纯文本文件，当利用 cat 等命令读取其内容时，会产生类似乱码的数据，od 命令可以读取二进制执行文件 其命令格式为：od [选项] 文件 选项有： -t a[size]：利用默认字符输出 -t c[size]：利用 ASCII 码输出 -t d[size]：利用十进制输出，每个整数占据 size 字节 -t f[size]：利用浮点数进制输出，每个整数占据 size 字节 -t o[size]：利用八进制输出，每个整数占据 size 字节 -t x[size]：利用十六进制输出，每个整数占据 size 字节 这个命令对用户来说，帮助并不大，但对于程序员，这个命令可以将二进制文件的内容做一个大致的输出，可以近似的看出其含义 如下图，是将 /etc/issue 这个文件的内容以八进制列出存储值与 ASCII 的对照表","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件与目录管理","slug":"11.Linux文件与目录管理","date":"2018-06-16T12:56:00.000Z","updated":"2022-05-14T16:41:12.662Z","comments":true,"path":"linux/48c9f28b.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/48c9f28b.html","excerpt":"【查看】命令格式查看文件与目录的命令是 ls 命令，在 Linux 文件属性 中，介绍了 ls 基本用法，下面详细地说明一下其具体用法","text":"【查看】命令格式查看文件与目录的命令是 ls 命令，在 Linux 文件属性 中，介绍了 ls 基本用法，下面详细地说明一下其具体用法 ls 命令会列出某目录下的文件与目录，且默认会以文件名进行升序排序，其格式为：ls [-选项] [目录名称] 其选项有： -a：显示全部文件（包含以 . 开头的隐藏文件） -A：显示全部文件，但不包括 .. 和 . 这两个目录 -d：仅列出目录本身，不包含目录内的文件 -l：列出长数据串，包含文件属性与权限 -h：将文件容量以 KB、MB、GB 等形式列出 -F：根据文件、目录等信息给予附加的数据结构（* 代表可执行文件，/ 代表目录，= 代表 socket 文件，| 代表FIFO文件） -i：列出 inode 号 -n：列出 UID 与 GID -R：连同子目录一起列出 -f：直接列出结果，不进行排序 -r：将结果按文件名降序排序 -S：以文件容量大小排序 -t：以时间排序 —color=never：不依据文件特性予以颜色显示 —color=auto：依据文件特性予以颜色显示 —full-time：以完整时间模式显示（含年、月、日、时、分） —time={atime,ctime}：访问时间或改变权限属性时间（默认为内容更改时间） 说明：加粗的选项为常用选项 文件变动时间在使用 --time={atime,ctime} 命令时，涉及到访问时间、权限属性变动时间、内容变动时间 mtime：内容更改时间（modification time），当文件内容更改时，会更新该时间 ctime：权限属性变动时间（status time），当文件权限或属性更改时，会更新该时间 atime：访问时间（access time），当访问该文件时，会更新该时间 实例1.使用 ls -al ~ 命令，将主文件夹下的所有文件都列出来 如下图，以 . 开头的是隐藏文件，同时目录文件以深蓝色表示 2.使用 ls -alF --color=never ~ 命令，将主文件夹下的所有文件列出，同时不显示颜色，但在文件名末显示文件代表的类型 如下图，虽然不显示颜色，但在文件名末，目录文件以 / 表示 3.使用 ls -l --full-time ~ 完整呈现文件的修改时间 【复制】命令格式cp 命令是复制文件的命令，但除了用于复制一或多个文件外，还可以创建连接文件，对比两文件的新旧而予以更新 其命令格式有以下三种： cp [选项] 源文件 目标文件：对比两文件新旧而予以更新 cp [选项] 源文件 目录：将源文件复制到目录下 cp [选项] 源文件1 源文件2 ... 源文件n 目录：将多个源文件复制到目录下 其选项有： -u：用于对比两文件新旧，若源文件比目标文件新，则进行更新，常用于文件备份 -i：互动模式，若目标文件已存在，在覆盖前会进行询问 -f：强制，若目标文件已存在且无法开启，则删除后再尝试一次 -p：连通文件属性一起复制过去，而非使用默认属性，常用于文件备份 -r：递归持续复制，用于目录的复制 -d：若源文件为连接文件的属性，则复制连接文件属性 -s：进行软连接的连接文件创建 -l：进行硬连接的连接文件创建 -a：相当于 -pdr 说明：加粗的选项为常用选项 实例1.执行两次复制命令，第一次将 /test/test1 目录下的 test.txt 文件复制到 /test/test2 目录下，第二次同样执行上述操作，但使用 -i 选项，询问是否进行覆盖 如下图，可以看到，当已经存在了一个文件后，要进行覆盖，加上 -i 选项后，会在覆盖前询问用户是否确定，通过输入 n 或 y 来进行二次确认 2.将 /test/test1 目录下的 test1.txt 文件复制到 /test/test2 目录下，同时将其改名为 test.txt 3.将 /test/test1 目录下的 test1.txt、test2.txt、test3.txt 文件批量复制到 /test/test2 目录下 4.对比 /test/test1 目录下的 test1.txt 和 /test/test2 目录下的 test1.txt，当前者比后者新时，进行复制 5.将 test/test1/ 目录下的所有内容复制到 test/test2 下 如下图，加了 -r 参数后，可以复制目录，但是文件和目录的权限可能会被改变 【移动】命令格式mv 命令用于移动文件和目录，并且可以在移动之后进行重命名，其命令格式有三种： mv [选项] 源文件 新文件名：用于文件重命名 mv [选项] 源文件 目录：将源文件移动到目录 mv [选项] 源文件1 源文件2 ... 源文件n 目录：将多个文件移动到目录 其选项有： -f：强制移动，如果目标文件已存在，不会询问，而是直接进行覆盖 -i：互动模式，若文件已存在，会在移动或重命名前询问用户是否确定进行覆盖 -u：若文件已存在，且源文件比之前的文件要新，那么就会进行覆盖 实例1.将 /test 目录下的 test.txt 重命名为 test3.txt 2.将 /test 目录下的 test1.txt 移动到 /test/temp 目录下 2.将 /test 目录下的 test2.txt、test3.txt 全部移动到 /test/temp 目录下 【删除】命令格式rm 命令用于删除文件或目录，其命令格式为：rm [选项] 文件或目录 选项有： -f：强制删除，不会出现警告信息 -i：互动模式，在删除前询问用户是否确定进行该操作 -r：递归删除，用于目录的递归删除 需要说明的是，无论一个目录是否为空，都无法直接用 rm 目录 进行删除，需要加上 -r 参数，但由于该参数十分危险，容易造成误删，因此在实际应用中，常使用 rmdir 命令进行目录删除 实例1.删除 /test/test1 目录及其下的所有文件 可以看出，在删除目录时，不加 -r 参数无法进行删除 2.删除 /test 目录下所有以 .txt 结尾的文件，并在删除过程中进行询问 如下图，在进行删除时，可以利用通配符和 -i 选项来辅助操作，既可以进行批量删除，还可以防止误删 【文件创建】命令格式使用 touch 命令可以创建文件或修改文件时间，其命令格式为：touch [选项] 文件 当有选项时，用于修改文件时间，当无选项时，用于创建文件，选项有： -a：仅修改 atime，后接要修改的 12 位日期时间串 -m：仅修改 mtime，后接要修改的 12 位日期时间串 -d：修改 mtime 和 atime，后接要修改的日期时间串 -t：修改 mtime 和 atime，后接要修改的时间 实例1.在 /test 目录下，创建一个名为 test.txt 的文件，并检查其日期 2.将 test.txt 的 mtime 和 atime 改为 2000/01/01 00:00 3.将 test.txt 的 mtime 和 atime 改为 5 天前 4.将 test.txt 的 atime 改为 2000/01/01 00:00","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 目录的基本操作","slug":"10.Linux目录的基本操作","date":"2018-06-14T12:56:00.000Z","updated":"2022-06-03T10:31:46.308Z","comments":true,"path":"linux/6bc6282c.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/6bc6282c.html","excerpt":"【cd 命令】cd 命令是 Change Directory 的缩写，用于切换工作目录，其语法为：cd [相对路径或绝对路径] 在切换目录时，有以下比较特殊的目录：","text":"【cd 命令】cd 命令是 Change Directory 的缩写，用于切换工作目录，其语法为：cd [相对路径或绝对路径] 在切换目录时，有以下比较特殊的目录： .：本级目录 ..：上一级目录 ./：等价于 . ../：等价于 .. -：前一个工作目录 ~：当前用户身份所在的主文件夹 ~account：account 用户的主文件夹（account 为用户名） 需要说明的是，当仅给出 cd 未给出目录时，代表着返回主文件夹 【pwd 命令】pwd 命令是 Print Working Directory 的缩写，即显示当前所在的工作目录的绝对路径，其语法为：pwd [-P] -P 选项会显示出当前的路径，而非使用连接(link)的路径 12[root@localhost ~]# pwd/root 【mkdir 命令】mkdir 命令是 Make Directory 的缩写，用于创建新目录，其语法为：mkdir [-mp] 目录 当需要创建多层目录时，需要加上 -p 选项，来递归的进行创建 当要创建具有某些权限的目录时，需要加上 -m 选项，并且利用数字来说明权限，如果没有加上 -m 选项，系统会使用默认权限 【rmdir 命令】rmdir 命令是 Remove Directory 的缩写，用于删除目录，要求被删除的目录不能存在其他目录与文件，其语法为：mkdir [-p] 目录 当要删除多层目录时，需要加上 -p 选项，来递归的进行删除，要求被删除的目录中不能存在文件","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"二叉堆","slug":"data-structure/06.heap/02.二叉堆","date":"2018-06-14T11:29:51.000Z","updated":"2021-09-03T14:03:39.572Z","comments":true,"path":"oi-acm/data-structure/heap/69c852d4.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/heap/69c852d4.html","excerpt":"【二叉堆定义与存储结构】二叉堆是具备以下性质的完全二叉树： 小根堆：每个结点的值都小于等于其左右孩子结点的值，堆顶元素是堆中最大值 大根堆：每个结点的值都大于等于其左右孩子结点的值，堆顶元素是堆中最小值","text":"【二叉堆定义与存储结构】二叉堆是具备以下性质的完全二叉树： 小根堆：每个结点的值都小于等于其左右孩子结点的值，堆顶元素是堆中最大值 大根堆：每个结点的值都大于等于其左右孩子结点的值，堆顶元素是堆中最小值 若将堆按照层序顺序从根结点开始编号，根结点序号为 $1$，用 $heap[i]$ 表示第 $i$ 个结点，则 $heap[i]$ 的两个儿子为：$heap[2i]$ 与 $heap[2i+1]$ 且在小根堆中，满足： \\left\\{\\begin{matrix} heap[i] \\leq heap[2i] \\\\ heap[i] \\leq heap[2i+1] \\end{matrix}\\right.在大根堆中，满足： \\left\\{\\begin{matrix} heap[i] \\geq heap[2i] \\\\ heap[i] \\geq heap[2i+1] \\end{matrix}\\right. 【插入操作与向上调整】插入操作是指向二叉堆中插入一个元素，且要保证插入后二叉堆的结构不会改变 最简单的方式就是在最下一层最右边的叶结点后插入新的元素，若最后一层已满，就新增一层 以大根堆为例，在插入新结点后，如果这个结点的权值大于其父结点的权值，就进行向上调整操作，将其与其父结点进行交换，然后重复该过程，直到不满足或到根为止 同理，当堆为小根堆时，若这个结点的权值小于其父结点的权值，同样进行向上调整操作 向上调整操作的时间复杂度为 $O(\\log n)$ 大根堆的插入操作的实现如下： 1234567891011121314int heap[N]; //heap[1]为堆顶int size; //堆指针void up(int now) &#123; //向上调整 while (now &gt; 1 &amp;&amp; heap[now] &gt; heap[now/2]) &#123; //当前结点值小于其父结点值时终止 int next = now &gt;&gt; 1; //当前结点的父结点 break; swap(heap[now], heap[now/2]); //交换元素 now /= 2; //令now指向其父结点 &#125;&#125;void insert(int x) &#123; //插入操作 heap[++size] = x; //在堆尾加入元素 up(size); //从新加入的结点size开始向上调整&#125; 【删除操作与向下调整】插入操作是指删除二叉堆的堆顶元素，且要保证删除后二叉堆的结构不会改变 如果直接进行删除，那么堆会变为两个，难以处理 因此，可以将删除操作等价为插入操作的逆过程，即设法将根结点移动到二叉堆中的最后一个结点，然后再进行删除 通常的做法是，先将根结点与最后一个结点交换，然后删除位于最后一个结点处的根结点 但这样新得到的堆显然不满足堆的性质，为此，要进行向下调整 同样以大根堆为例，在得到新的堆后，在新堆的根结点的儿子中，找一个值最大的结点，然后将他们交换，并重复该过程，直到底层为止 同理，当堆为小根堆时，找一个值最小的儿子结点，进行向下调整操作即可 向下调整操作的时间复杂度为 $O(\\log n)$ 1234567891011121314151617int heap[N]; //heap[1]为堆顶int size; //堆指针int down(int now) &#123; while (now * 2 &lt;= size &amp;&amp; heap[now*2] &gt; heap[now]) &#123; //当前结点值小于其子结点值时终止 int next = now *2; //当前结点的子结点 if (next &lt; size &amp;&amp; heap[next + 1] &lt; heap[next]) //比较左右孩子，指向较大者 next++; swap(heap[now], heap[next]); //交换元素 now = next; &#125;&#125;int del(int x) &#123; //删除操作 int res = heap[1]; //要删除的结点 heap[1] = heap[size--]; //尾结点提升到根结点 down(1); //从根结点1开始向下调整 return res;&#125; 【堆的建立】对于一个空的二叉堆，当从头开始建立时，若不考虑元素顺序，只需要一个个的将 $n$ 个元素进行插入操作，之后，从根开始，按 BFS 序进行向上调整，使得建立的二叉堆满足堆的性质 123456789int heap[N]; //heap[1]为堆顶int size; //堆指针void up(int now); //向上调整void buildHeap(int a[], int n) &#123; for (int i = 1; i &lt;= n; i++) //不考虑元素顺序插入n个元素 heap[++size] = a[i]; for (int i = 1; i &lt;= n; i++) //从根结点开始向上调整 up(i);&#125; 这样一来，对于第 $k$ 层的结点，向上调整的复杂度为 $O(k)$，而不是 $O(\\log n)$ 但以总时间复杂度来说，有： \\log 1+\\log 2 +...+\\log n=O(n\\log n)为此，可以换一种思路，即在对 $n$ 个元素插入后，从叶结点开始进行向下调整 123456789int heap[N]; //heap[1]为堆顶int size; //堆指针void down(int now); //向下调整void buildHeap(int a[], int n) &#123; for (int i = 1; i &lt;= n; i++) //不考虑元素顺序插入n个元素 heap[++size] = a[i]; for (int i = n; i &gt;= 1; i--) //从叶结点开始向下调整 down(i);&#125; 可以发现，叶结点无需调整，且结点向下调整的时间复杂度为 $O(\\log n-k)$ 因此，可以从序列约 $\\frac{n}{2}$ 的位置处开始调整，从而在不影响复杂度的情况下减少参数，以总时间复杂度来说，有： \\begin{align} & n\\log n-\\log 1-\\log 2-...-\\log n \\notag \\\\ \\leq & n\\log n-0\\times 2^0-1\\times2^1-...-(\\log n-1)\\times\\frac{n}{2} \\notag \\\\ =& n\\log n -(n-1)-(n-2)-(n-4)-...-(n-\\frac{n}{2}) \\notag \\\\ =& n\\log n- n\\log n+1+2+4+...+\\frac{n}{2} \\notag \\\\ =& n-1 \\notag \\\\ =& O(n) \\notag \\end{align}之所以能够以 $O(n)$ 的方式建堆，是因为堆的形式很弱，二叉堆并不是唯一的","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"堆","slug":"oi-acm/data-structure/heap","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/heap/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"堆","slug":"heap","permalink":"https://alex-mcavoy.github.io/tags/heap/"}],"author":"Alex_McAvoy"},{"title":"Linux 系统目录结构","slug":"09.Linux系统目录结构","date":"2018-06-14T07:26:00.000Z","updated":"2022-05-14T16:38:13.581Z","comments":true,"path":"linux/bfa11702.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/bfa11702.html","excerpt":"【概述】与 Windows 系统以存储介质为主目录为辅相反，Linux 是以树形目录结构的形式来构建系统，可将树形目录视为一个用户可操作系统的骨架 本质上，目录结构与操作系统内核都存储在磁盘上，但从逻辑上来说 Linux 的磁盘是挂载在目录上的，每一个目录不仅可使用本地磁盘分区的文件系统，还可使用网络上的文件系统","text":"【概述】与 Windows 系统以存储介质为主目录为辅相反，Linux 是以树形目录结构的形式来构建系统，可将树形目录视为一个用户可操作系统的骨架 本质上，目录结构与操作系统内核都存储在磁盘上，但从逻辑上来说 Linux 的磁盘是挂载在目录上的，每一个目录不仅可使用本地磁盘分区的文件系统，还可使用网络上的文件系统 【FSH 标准】概述利用 Linux 开发产品或 distribution 的个人、团队、公司太多，如果每个人都按自己的想法来配置文件放置的目录，那么会造成诸多管理上的困难，为解决这种问题，出现了 FHS 标准 FHS（Filesystem Hierarchy Standard）标准，文件系统层次结构标准，是多数 Linux 版本采用的文件组织形式，其主要目的是希望让用户可以了解到已安装软件通常放置在哪个目录下，因此希望独立软件开发商、OS 制作者、维护系统的用户等，都能遵循 FHS 标准 FHS 标准定义了系统中每个区域的用途、所需要的最小构成的文件和目录、给出了例外处理与矛盾处理等。简单来说，其规范了每个特定目录下应该要放置什么样的数据 交互形态FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四种交互作用的形态，如图： 可分享的：可以分享给其他系统挂载的使用目录，包括执行文件、用户邮件等 不可分享的：自己机器上运行的设备文件、与程序有关的 socket 文件等，仅与自身机器有关 不可变的：不会经常变动的数据，且跟随着 distribution 而不变动，例如函数库、文件说明文件等 可变的：经常改变的数据，例如登录文件、新闻组等 三个目录概述FHS 针对目录树架构，定义了三层目录下应该放置的数据： /：根(root)目录，与开机系统有关 /usr：与软件安装、执行有关 /var：与系统运作过程有关 根目录根目录是整个系统中最重要的目录，所有的目录都是由根目录衍生出来的，同时根目录与开机、还原、系统修复等操作有关 由于系统开机时要特定的开机软件、内核文件、开机所需程序、函数库等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行 因此，系统根目录不需要放置在非常大的分区内，因为越大的分区会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会 /user 目录/user 是 UNIX 软件资源(UNIX Software Resource)的缩写，其存放的是与软件安装、运行有关的数据，均是可分享与不可变动的 这个目录有点类似于 Windows 系统的 C:\\Windows\\ 和 C:\\Program files\\ 两目录的综合体，其在安装时会占用较大的硬盘容量 /var 目录/var 目录主要针对于常态性变动的文件，包括缓存、登录文件、某些软件运行产生的文件等 【目录树】在 Linux 中，所有文件与目录都是由根目录开始的，然后一个个分支下来，称这种配置方式为目录树（Directory Tree） 其主要特性有： 起始点为根目录 每个目录不只能使用本地端的文件系统，还可以使用网络端的文件系统 每个文件在目录树中的文件名（包含完整路径）是独一无二的 下面给出目录树的结构图","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"堆","slug":"data-structure/06.heap/01.堆","date":"2018-06-14T03:06:51.000Z","updated":"2021-09-02T13:59:03.097Z","comments":true,"path":"oi-acm/data-structure/heap/fab451a5.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/heap/fab451a5.html","excerpt":"【概述】堆（Heap），是一棵树，其每个结点都有一个值，且每个结点的值都大于等于或小于等于其父结点的值 当每个结点的值都大于等于其父结点的值时，称为大根堆；每个结点的值都小于等于其父结点的值时，称为小根堆","text":"【概述】堆（Heap），是一棵树，其每个结点都有一个值，且每个结点的值都大于等于或小于等于其父结点的值 当每个结点的值都大于等于其父结点的值时，称为大根堆；每个结点的值都小于等于其父结点的值时，称为小根堆 在 C++ 的 STL 中，优先队列 priority_queue 默认就是一个大根堆，在改写其比较算子 greater 后，可将其改为小根堆 一些功能强大的堆还支持可持久化，即对任意历史版本进行查询或操作，从而产生新的版本 【堆的分类】常用的堆有二叉堆、配对堆、左偏树、二项堆、斐波那契堆等 下面以这些堆的小根堆为例，给出其基本操作的时间复杂度比较 操作 二叉堆 配对堆 左偏树 二项堆 斐波那契堆 插入 $O(\\log n)$ $O(1)$ $O(\\log n)$ $O(1)$ $O(1)$ 查询最小值 $O(1)$ $O(1)$ $O(1)$ $O(\\log n)$ $O(1)$ 删除最小值 $O(\\log n)$ $O(\\log n)$ $O(\\log n)$ $O(\\log n)$ $O(\\log n)$ 合并 $O(n)$ $O(1)$ $O(\\log n)$ $O(\\log n)$ $O(1)$ 减小一个元素的值 $O(\\log n)$ $O(\\log n)$ $O(\\log n)$ $O(\\log n)$ $O(1)$ 是否可持久化 是 否 是 是 否 习惯上，不加限定提到堆时往往都指二叉堆","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"堆","slug":"oi-acm/data-structure/heap","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/heap/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"堆","slug":"heap","permalink":"https://alex-mcavoy.github.io/tags/heap/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件类型与扩展名","slug":"08.Linux文件类型与扩展名","date":"2018-06-13T14:38:00.000Z","updated":"2022-05-14T16:36:56.125Z","comments":true,"path":"linux/2eca33f9.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/2eca33f9.html","excerpt":"【文件类型】之前在 Linux 文件属性 中介绍了使用 ls 命令显示出文件属性的第一列代表了文件类型和文件权限，下面详细介绍一下文件的类型 目录文件(Directory)：代表一个目录，以 [d] 来标识","text":"【文件类型】之前在 Linux 文件属性 中介绍了使用 ls 命令显示出文件属性的第一列代表了文件类型和文件权限，下面详细介绍一下文件的类型 目录文件(Directory)：代表一个目录，以 [d] 来标识 普通文件(Regular File)：一般进行访问类型的文件，以 [-] 来标识 纯文本文件(ASCII)：内容为可直接读到的数据，是最多的一种文件类型，只要可以用来作为设置的文件都属于这种类型 二进制文件(Binary)：可执行文件 数据格式文件(Data)：某些程序运行过程时读取的某些特定格式的文件 连接文件(Link)：类似 Windows 中的快捷方式，以 [l] 来标识 设备与设备文件(Device)：与系统外设及存储相关的文件，通常集中在 /dev 目录下，其分为两种 块设备文件(Block)：是一些存储数据以提供系统随机访问的接口设备，可以随机地在硬盘的不同块读写，例如硬盘、软件等，以 [b] 来标识 字符设备文件(Character)：串行端口的接口设备，是一次性读取的，无法截断输出，例如键盘、鼠标等，以 [c] 来标识 套接字(Socket)：数据接口文件，用于在网络上的数据连接，通常位于 /var/run 目录下，以 [s] 来标识 管道(Pipe,FIFO)：用于解决多个程序同时访问一个文件所造成的错误问题，以 [p] 来标识 【文件扩展名】在 Linux 中，一个文件能不能被执行，只于它第一列的文件类型和文件权限来决定，只要权限中具有 x 的话，就能被执行，故而一个文件是否能被执行是与文件名无关的 但可以被执行和可以执行成功是不一样的，一个可执行文件能否执行成功，要看文件的内容。举例来说，一个权限为 -rwxrwxrwx 的 install.log 文件，其可以被执行，但其是一个文本文件，其内容没有可执行的数据 因此，在 Linux 中基本上是没有所谓的文件扩展名，但我们仍希望可以由扩展名来了解文件是什么东西，故而通常会以适当的扩展名来表示文件是什么种类的 常见的扩展名有： *.sh：脚本或批处理文件 *Z、*.tar、*.tar.gz、*.zip、*.tgz：打包的压缩文件 *.html、*.php：网页相关文件 *.jpg：JPEG 图像文件 *.png：PNG 图像文件 *.pdf：PDF 文档 *.txt：文本文件 *.log：日志文件 *.conf：程序配置文件 *.lock：程序锁定文件，用于检测某个程序在执行或者某个设备或者资源正在使用 *.rpm：RedHat 的软件包管理器文件，用于安装软件 【文件名限制】文件名限制由于 Linux 在字符界面下的一些命令操作关系，一般来说，在设置 Linux 下的文件名时，最好避免以下在命令行界面下有特殊含义的字符：*、?、&lt;、&gt;、;、&amp;、!、[、]、|、\\、&#39;、&quot;、(、)、{、} 同时，由于命令执行过程中，常会用到 -option 类的参数，因此也避免将文件名开头设置为 -、+ 此外，文件名开头为 . 时，代表这个文件为隐藏文件 文件名长度限制在 Linux 中，使用默认的 Ext2/Ext3 系统时，针对文件的文件名限制为： 单一文件或目录的最大容量为：255 个字符 包含完整路径名称及目录的完整文件名的最大容量为：4096 个字符 【路径的文件名与目录名】包含完整路径的文件名最长可达 4096 个字符，利用 / 可分辨文件名和路径名 在实际应用中，可以利用 basename 命令来取得文件名，利用 dirname 命令来取得目录名 实例：对于完整路径 /test/temp/test.txt，获得其文件名和目录名","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 文件属性","slug":"07.Linux文件属性","date":"2018-06-13T08:21:00.000Z","updated":"2022-06-03T10:34:06.401Z","comments":true,"path":"linux/fece1b69.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/fece1b69.html","excerpt":"【概述】在 Linux 系统中，不同的用户处于不同的地位，拥有不同的权限，为保护系统安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定 Linux 系统的每一个文件或目录都有访问权限，这些访问权限决定了哪些用户和组群能访问文件和能执行的操作","text":"【概述】在 Linux 系统中，不同的用户处于不同的地位，拥有不同的权限，为保护系统安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定 Linux 系统的每一个文件或目录都有访问权限，这些访问权限决定了哪些用户和组群能访问文件和能执行的操作 【文件属性】ls 命令使用 ls –l 命令可以显示文件的属性以及文件所属的用户和组，ls 是 list 的意思，用于显示文件的文件名和相关属性 如图，以第一行为例：drwxr-xr-x 2 root root 4096 6月 10 00:53 公共 其基本构成是：文件属性 链接数 所有者 所属用户组 最后修改时间 文件名 文件类型与权限使用 ls 命令列出的第 1 列是文件的类型与权限，其有 10 个字符，第一个字符代表了文件的类型，其后 9 个字符三个一组，分分别代表了文件所有者、文件所有者的同组用户、其他用户对该文件的权限 文件类型文件类型的具体代表字符有： 字符 类型 d 目录 - 普通文件 I 软链接，即链接文档（link file） b 块设备，装置文件中可供存储的接口设备（可随机存储装置） c 字符设备，装置文件中串行端口设备（一次性读取装置） s 网络套接字（socket） p 管道（piep） 文件权限文件类型其后的九个字符三个一组，均为 r、w、x 三个字符的组合 其中，r 代表可读（read）、w 代表可写（write）、x 代表可执行（execute），这三个权限的位置不会改变，若没有权限，仅会出现 - 符号 读权限，表示可以用一些命令来读取某个文件的内容；写权限，表示可以编辑和修改某个文件；执行权限，通常指可以运行的二进制程序文件或者脚本文件 以下图为例，从左至右用 0-9 表示 10 个字符，第 0 位确定文件类型，第 1-3 位确定属主权限拥有该文件的权限（该文件的所有者的权限），第 4-6 位确定属组权限拥有该文件的权限（所有者的同组用户），第 7-9 位确定其他用户拥有该文件的权限 需要说明的是，一个目录只有同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息 链接数使用 ls 命令列出的第 2 列是文件的链接数 链接数表示了有多少文件名连接到此节点(i-node)，每个文件都会将它的权限与属性记录到文件系统的 i-node 中 由于目录树是使用文件名来记录，因此每个文件名就会连接到一个 i-node，这个属性记录的就是有多少不同的文件名连接到相同的一个 i-node 号码 所有者与所属用户组使用 ls 命令列出的第 3 列是文件的所有者，第 4 列是文件所属用户组 在 Linux 系统中，每个文件都有一特定的所有者，也就是对该文件具有所有权的用户，同时，用户是按组分类的，一个用户属于一个或多个组，而文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户 所有者与所属用户组，标明了该文件具所有权的用户及该文件所属的用户组 文件大小使用 ls 命令列出的第 5 列是文件的大小 其是以 i-node 节点大小为单位来表示文件大小，其默认单位为字节（B） 可以给 ls 命令加上 -h 选项来更直观的查看文件的大小，即： ls -lh 同时，可以利用 -S 选项，按照文件大小升序排序显示，即：ls -lS。 修改日期使用 ls 命令列出的第 6 列是文件的创建日期或最近的修改日期 其内容分别为：月、日、时间，如果某个文件被修改的时间距离现在太久，那么时间部分会显示年份，反之，会显示具体的时间 如果想要显示完整的时间格式，可以利用 ls 命令的选项，即：ls -l --full-time，其包括年、月、日、时间 同时，可以利用 -t 选项，按照时间顺序升序显示，即：ls -lt 文件名使用 ls 命令列出的第 7 列是文件的文件名 需要注意的是，使用 ls -l 并不会列出隐藏文件，若想查看某目录下的隐藏文件，要加上 -a 选项，即：ls -al 隐藏文件的特点是文件名前多了一个 “.”，例如：.gconf 【文件属性的更改】在 Linux 中，复制行为会复制执行者的属性和权限，这就使得即使将某个文件给予某用户，但由于没有相应权限，其无法进行操作，因此就必须要修改文件的所有者与用户组，乃至于文件权限 chgrp 命令chgrp 命令用于更改文件属组，即改变文件所属的用户组，其语法为：chgrp [选项] 用户组名 文件名 其支持递归更改，即连同子目录下的所有文件、目录都进行更新，常用于更改某一目录内所有文件。 若想递归更改，加上 -R 选项即可 chown 命令chown 命令用于更改文件属主，即改变文件所有者，其语法为：chown [选项] 属主名 文件名 chown 命令更改文件属主的同时，也可以更改文件属组，其语法为：chown [选项] 属主名：属组名 文件名 同样的，若想递归更改，加上 -R 选项即可 chmod 命令Linux 文件的基本权限有九个，分别是 owner / group / others 三种身份各有自己的 read / write / execute 权限 chmod 命令用于更改文件权限，有两种方法，一种是用数字表示，一种是用字符表示 利用数字更改权限利用数字更改权限的语法为：chmod [选项] xyz 文件名或目录名 其中，xyz 为数字类型的权限属性 由于这九个权限是三个一组的，那么我们将每组的三个权限视为一个长度为 3 的二进制数，用 1、0 来表示权限是否存在，那么各权限的位权对照如下： r: 4 w: 2 x: 1 由于二进制数的特性，对于每种身份的三种权限，我们将其位权累加，即可得到一组唯一的权限对照，例如权限为 rwx 时，其分数为：4+2+1=7. 这样，对于三种身份的权限，我们只需要按次序将累加后的三个分数串接在一起即可，即数字类型的权限属性。 例如： 当权限为 [ -rwxrwxrwx ] 时，分数如下 123owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others = --- = 4+2+1 = 7 因此在设定权限变更时，该文件的权限数字为 777 利用字符更改九个权限分别是 user、group、others 三种身份的权限，那么可用 u、g、o 来代表三种身份的权限，此外，用 a 代表 all，即所有的身份 基于上述约定，利用字符更改权限的语法为：chmod 身份 符号 权限 文件名或目录名 其中，符号 有三种，分别是：+ 加入、- 除去、= 设定 其语法示意图如下： 如下图，给出了一个利用符号更改权限的实例 需要注意的是，使用 +、- 两个符号时，若没有指定到的选项，权限不会变动 【文件类型查看】当仅想要查看一个文件的类型时，使用 file 命令即可，该命令会告诉我们是 ASCII 的纯文本文件、二进制文件、数据文件、空文件等","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 关机与重启","slug":"06.Linux关机与重启","date":"2018-06-12T13:12:00.000Z","updated":"2022-06-03T10:28:07.107Z","comments":true,"path":"linux/5bb8281.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/5bb8281.html","excerpt":"【概述】Linux 系统的关机、重启是一个十分重要的系统操作，只有 root 用户才能进行 shutdown、reboot 等命令，这是因为，Linux 是一个多用户系统，在看不到的屏幕背后，可能有许多人同时利用主机进行工作 如果不正常关机，则可能会造成文件系统的损毁，所以在正常情况下，关机要注意以下几件事：","text":"【概述】Linux 系统的关机、重启是一个十分重要的系统操作，只有 root 用户才能进行 shutdown、reboot 等命令，这是因为，Linux 是一个多用户系统，在看不到的屏幕背后，可能有许多人同时利用主机进行工作 如果不正常关机，则可能会造成文件系统的损毁，所以在正常情况下，关机要注意以下几件事： 查看系统使用状态，以判断是否可以关机 who 命令：查看当前系统用户 netstat -a 命令：查看网络联机状态 ps -aux 命令：查看后台执行程序 通知在线用户关机的时刻：利用 shutdown -k 向所有用户发出警告 正确使用关机命令：sync、shutdown、reboot、halt、poweroff 【sync 指令】sync 命令被用于将数据同步写入磁盘 在默认情况下，某些已经加载到内存中的数据不会被直接写回硬盘，而是暂存在内存中，但万一系统因某些特殊情况造成不正常关机时，数据尚未被写入硬盘，就会造成数据的更新不正常 sync 命令会使得尚未被更新的数据写入硬盘中，因此该命令建议在系统关机或重启前多执行几次 1sync 需要说明的是，sync 命令可以被被一般用户使用，但一般用户所更新的硬盘数据只有自己的数据，root 用户可以更新整个系统的数据 此外，目前的 shutdown、reboot、halt、poweroff 等命令均在关机前执行了 sync，但多执行几次没有坏处 【shutdown 指令】shutdown 命令是最常用的关机命令，这个命令会通知系统内的各个进程，并且将通知关闭系统中的执行等级内的一些服务 其语法规则如下：shutdown [-t sec] [-arkhncfF] time [alarm] 参数： -t sec：过几秒后关机 -k：不是真正的关机，只是发送警告 -r：将系统服务停掉后重启 -h：将系统服务停掉后关机 -n：不经过 init 程序，直接以 shutdown 的功能来关机 -f：关机并开机后，强制略过 fsck 的磁盘检查 -F：系统重启后，强制进行 fsck 的磁盘检查 -c：取消当前在进行的 shutdown 命令 time：指定系统关机时间，若不加入，会自动跳到 runlevel-1，即单用户维护的登录情况 alarm：要发送的警告内容 下面给出几个含有时间参数的例子： 1234567891011# 立即关机shutdown -h now# 在今天的20:25关机，若在20:25之后执行该命令，会在隔天的20:25关机shutdown -h 20:25# 系统将在10分钟后关机，同时将'The system will reboot.'发送给所有在线用户shutdown -h +10 'The system will reboot.'# 系统将'The system will reboot.'发送给所有在线用户shutdown -k now 'The system will reboot.' 【reboot 指令】reboot 命令常用于重启计算机，若系统的 runlevel 为 0 或 6，那么会重新开机，否则，会以 shutdown -r 来进行取代 其具有多个参数，在终端中使用 man reboot 即可查看，此处不再赘述 在实际应用中，一般直接执行 reboot 命令即可 【halt 指令与 poweroff 指令】halt、poweroff 指令都可以完成关机和重启工作，但在实际应用中很少使用，一般利用 shutdown 和 reboot 即可完成工作 在默认情况下，halt 会先调用 shutdown，而 shutdown 会在最后调用 halt，其中 shutdown 可以依据目前已启动的服务来逐次关闭各服务后关机，halt 能在不理当前系统状况下直接进行硬件关机 对于 poweroff 来说，其会发送一个 ACPI 信号来通知系统关机 【init 指令】在 Linux 系统启动过程 中，介绍了 init 进程和 runlevel 值得注意的是， runlevel-0 相当于关机，runlevel-6 相当于重启 那么，可以使用 init 来指定 runlevel 从而实现关机与重启 12345# 关机init 0# 重启init 6","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 系统启动过程","slug":"05.Linux系统启动过程","date":"2018-06-12T08:31:00.000Z","updated":"2022-05-14T13:35:35.087Z","comments":true,"path":"linux/d0f31d63.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/d0f31d63.html","excerpt":"【概述】Linux 系统的启动过程一般分为 4 个阶段： BIOS 启动引导阶段 GRUB 启动引导阶段 内核阶段 1 号用户进程初始化阶段","text":"【概述】Linux 系统的启动过程一般分为 4 个阶段： BIOS 启动引导阶段 GRUB 启动引导阶段 内核阶段 1 号用户进程初始化阶段 这四个阶段具体过程细化如下图： 【BIOS 启动引导】当计算机打开电源启动后，首先进行的是 BIOS 开机自检，当设备检测通过后，根据在 BIOS 中设置的启动顺序搜索启动驱动器，并获取第一个启动设备的代号，读取第一个启动设备的 MBR 的引导加载程序的启动信息，从 MBR 中装载启动引导管理器 GRUB 并启动引导管理 MBR 是引导扇区的前 512 字节，由 BIOS 预加载在 ROM 中，其中 446 字节用于存储 Boot Loader 程序，64 字节用于存储分区表信息，最后 2 字节用于 MBR 的有效性检查 【GRUB 启动引导】大多数 Linux 发行版使用的引导加载程序有三种：GRUB、GRUB2、LILO，其中，GRUB2 是 CentOS 7 默认的引导加载程序 引导加载程序位于 /boot 目录下，用于将内核映像文件加载到内存中 【内核阶段】内核是 OS 的核心，是系统启动时加载的第一个程序，系统启动内核时，会从 initrd.img 将所有必需驱动模块加载到 Linux 系统中，并运行 1 号程序 initrd.img 是一种基于内存的文件系统，启动过程中，系统在访问真正的根文件系统时，会先访问 initrd 文件系统 【1号用户进程初始化阶段】init 进程1 号进程，在 CentOS7 之前被称为 init 进程，在 CentOS7 之后被称为 systemed 进程，其是 Linux 上运行的第一个进程（PID 为 1） 该进程是系统所有进程的起点，其会去读取 /etc/inittab 下的配置文件，以运行 Linux 中的守护进程（daemon） 注：守护进程类似于 Windows 中的服务（service），是需要开机启动的程序 运行级别不同的场合需要启动不同的程序，Linux 允许为不同的场合，分配不同的开机启动程序，这被称为运行级别（runlevel），即启动时根据运行级别，确定要运行的程序 Linux 系统有 7 个运行级别： runlevel-0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动 runlevel-1：单用户工作状态，root 权限用于系统维护，禁止远程登陆 runlevel-2：多用户状态（没有NFS） runlevel-3：完全的多用户状态（有NFS），登陆后进入控制台命令行模式 runlevel-4：系统未使用，保留 runlevel-5：X11 控制台，登陆后进入图形 GUI 模式 runlevel-6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动 系统初始化在 init 的配置文件中，存在这么一行：si::sysinit:/etc/rc.d/rc.sysinit 它调用执行了 /etc/rc.d/rc.sysinit ，而 rc.sysinit 是一个 bash shell 的脚本，主要用于完成系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本 它主要完成需要优先执行的任务，比如：激活交换分区、检查磁盘、加载硬件模块等 终端建立在 rc.sysinit 执行完毕后，会返回 init，此时基本系统环境已经设置好了，各种守护进程也已启动了，init 接下来会打开 6 个终端，以便用户登录系统 这 6 个终端窗口分别是 tty1~tty6，他们可以通过快捷键 Ctrl+Alt+F1~F6 来进行切换，默认登录的是第一个窗口，即 tty1 如果安装了图形界面，默认情况下是直接进入图形界面，此时可以通过快捷键 Ctrl+Alt+F1~F6 来进行切换进入其中一个命令窗口界面，当进入命令窗口界面后再返回图形界面只要通过快捷键 Ctrl+Alt+F7 即可返回 在 inittab 中通过以下命令定义了 6 个终端： 1234561:2345:respawn:/sbin/mingetty tty12:2345:respawn:/sbin/mingetty tty23:2345:respawn:/sbin/mingetty tty34:2345:respawn:/sbin/mingetty tty45:2345:respawn:/sbin/mingetty tty56:2345:respawn:/sbin/mingetty tty6 可以看出在 2、3、4、5 的运行级别中都将以 respawn 方式运行 mingetty 程序 该程序能打开终端、设置模式，同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在界面中会提示用户输入用户名，而用户输入的用户将作为参数传给 login 程序来验证用户的身份 用户登录系统对于运行级别为 5 的图形方式用户来说，登录是通过一个图形化的登录界面，登录成功后可以直接进入 KDE、Gnome 等窗口管理器 对于以文本方式登录的用户来说，当看到 mingetty 的登录界面时，就可以输入用户名和密码来登录系统 Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数，然后 login 会对用户名进行分析，如果不是 root 用户，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出 需要说明的是，以文本方式登录通常用于系统维护时防止非 root 用户登录，这使得只有在 /etc/securetty 中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 软件包管理","slug":"04.Linux软件包管理","date":"2018-06-11T10:39:00.000Z","updated":"2022-05-14T13:32:55.989Z","comments":true,"path":"linux/5fd53cd4.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/5fd53cd4.html","excerpt":"【概述】著名的 Linux 系统基本分为两大类： RedHat 系列：Redhat、Centos、Fedora 等 Debian 系列：Debian、Ubuntu、Kali 等","text":"【概述】著名的 Linux 系统基本分为两大类： RedHat 系列：Redhat、Centos、Fedora 等 Debian 系列：Debian、Ubuntu、Kali 等 两大系列，对软件的安装管理有所区别： Redhat 系列：安装软件包格式为 rpm 包，一般利用 rpm -参数 安装，所用的包管理工具为 yum Debian 系列：安装软件包格式为 deb 包，一般利用 dpkg -参数 安装，所用的包管理工具为 apt-get 在 Linux 系统中，当要安装软件时，一般用 yum 安装或 rpm 软件包管理。 除上述两种软件包外，还有源代码软件包、绿色免安装软件包等，他们的说明如下： 封装类型 说明 rpm 软件包 扩展名为 .rpm deb 软件包 扩展名为 .deb 源代码软件包 一般为 .tar.gz、.tar.bz2 等格式的压缩包，包含程序的原始代码 提供安装程序软件包 在压缩包内提供 install.sh、setup 等安装程序或以 .bin 格式的单个执行文件提供 绿色免安装软件包 在压缩包内提供已编译好的执行程序文件，解压后可直接使用 【Redhat 系列】RPM 软件包RPM 由 Red Hat 公司提出，其通过建立统一的数据库文件，详细的记录软件包安装、卸载等变化信息，且能够自动分析软件包依赖关系。 一般命名格式为： 软件名称.版本号.发布次数.硬件平台.扩展名例如：bash-3.1-16.1.i386.rpm，软件名称为 bash-3，版本号是 1-16，发型次数为 1，硬件平台为 i386，扩展名为 rpm 命令格式为：rpm [options] [package] 常见的选项有： -i：安装一个新的 rpm 软件包 -e：卸载指定的 rpm 软件包 -h：以 # 显示安装进度 -v：显示安装过程中的常用信息 –nodeps：安装、升级或卸载软件时，忽略依赖关系 常用的命令为：rpm -ivh *.rpm yum 软件包管理yum 是 Reahat 系列中的 Shell 前端软件包管理器，其基于 rpm 包管理，能够从指定的服务器自动下载 rpm 包并安装，可以处理依赖性关系，一次性安装所有依赖的软件包，无须繁琐地一次次下载、安装。 yum 提供了管理软件包的便捷方式，在配置软件源后，即可便捷地对软件包进行管理。 命令格式为：yum [options] [command] [package] 常见的命令有： 安装： yum install：全部安装 yum install package1：安装软件包 package1 yum install group1：安装程序组 group1 更新： yum check-update：检查可更新的程序 yum update：全部更新 yum update package1：更新软件包 package1 yum update group1：更新程序组 group1 查找与显示： yum info package1：显示软件包 package1 的信息 yum list：显示已安装和可安装的软件包 yum list package1：显示程序包 package1 的信息 yum groupinfo group1：显示程序组 group1 的信息 yum search string：根据关键字 string 查找软件包 删除程序： yum remove package1：删除程序 package1 yum groupremove group1：删除程序组 group1 yum deplist package1：查看软件 package1 的依赖情况 清除缓存： yum clean packages：清除缓存目录下的软件包 yum clean headers：清除缓存目录下的 headers yum clean oldheaders：清除缓存目录下旧的 headers 【Debian 系列】deb 软件包所有源自 Debian 的 Linux 发行版都使用 deb 格式，其与 rpm 十分相似。 在 Debian 系列中，对软件的安装、更新、移出时，需要使用 Debian 专门开发的套件管理系统 dpkg，其与 RPM 十分相似。 命令格式为：dpkg [options] [package] 常见的选项有： -i：安装一个新的 dep 软件包 -r：卸载指定的 dep 软件包 -I：显示 deb 包的信息 -s：显示已安装的软件信息 apt 管理工具APT 是 Debian 系列中的 Shell 前端软件包管理器，其基于 dpkg 包管理，类似于 yum apt 管理器包含多个以 apt- 开头的工具，如：apt-get、apt-cahe、apt-cdrom 等，其中最常用的就是 apt-get apt-get 是用于处理 apt 包的公用程序集，常可用它来在线安装、卸载、升级软件包等。 当执行安装操作时，apt-get 工具首先会在本地的软件源数据库中搜索关于要安装的软件的相关信息，并根据这些信息在相关的软件源镜像服务器上下载软件，进行安装。 使用 apt-get 需要定期从服务器上下载一个软件包列表，使用 apt-get update 命令来保持本地的软件包列表是最新的，这个表里会有软件依赖信息的记录 命令格式为：apt-get [options] [command] 常用的选项有： -y：自动回应是否安装软件包的选项 -f：修复损坏的依赖关系 -q：静默安装方式，指定多个 q 或 -q=# 来设置静默级别(#为数字) –reinstall：重新安装已安装但可能存在问题的软件包 常用的命令有： install：安装软件包 update：更新本地软件源列表 remove：移除已安装的软件包与有依赖关系的软件包 autoremove：移除之前被其他软件包依赖，但现在不再被使用的软件包","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 帮助命令","slug":"03.Linux帮助命令","date":"2018-06-09T07:05:00.000Z","updated":"2022-05-14T13:29:59.586Z","comments":true,"path":"linux/a6f0c50.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/a6f0c50.html","excerpt":"【概述】在 Linux 环境中，如果遇到困难，可以适用帮助命令来获取帮助 常见的帮助命令有：","text":"【概述】在 Linux 环境中，如果遇到困难，可以适用帮助命令来获取帮助 常见的帮助命令有： man 命令 help 命令 info 命令 【man 命令】概述man 命令，是 Manual pages 的缩写，它是 Linux 系统中在线软件文档的一种普遍的形式，其内容包括计算机程序（包括库和系统调用）、正式的标准和惯例，抽象的概念等 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，还有一些相关的描述，通过查看系统文档中的 man 还可以得到程序的更多相关信息和 Linux 的更多特性 man 命令通常用来获得某个命令的说明和使用方式的详细介绍 其使用格式为：man [命令名] 值得注意的是，可以使用 man 命令查看其本身的使用说明，即：man man man 手册的分区区段man 手册的内容很多，涉及了 Linux 使用过程中的方方面面，为了便于查找，man 手册被进行了分册（分区段）处理，手册通常被分为以下九个区段： 序号 内容 1 Standard commands （标准命令） 2 System calls （系统调用） 3 Library functions （库函数） 4 Special devices （设备说明） 5 File formats （文件格式） 6 Games and toys （游戏和娱乐） 7 Miscellaneous （杂项） 8 Administrative Commands （系统管理命令和守护进程） 9 other（其他，用来存放内核例行程序的文档） 如要查看相应区段的内容，就在 man 后面加上相应区段的数字即可，例如：若想要查看第二区段的内容，可以利用 man 2 ls 来实现 打开手册之后可以通过鼠标滚轮或上下键来进行上下翻看，查看完毕后按 q 退出当前页面 通常 man 手册中内容很多，不太容易找到想要的结果，可以在 man 中使用搜索：/ &lt;关键字&gt; 当查找完毕后，可以按 n 切换到下一个关键字所在处，shift+n 切换到上一个关键字所在处 man 手册页布局所有的手册页遵循一个常见的布局，一般包括以下部分内容： 手册名称与所在章节：如图中最上方的 LS（1），其中 LS 表示手册名称，（1）表示该手册位于第一章节 NAME（名称）：该命令或函数的名称，接着是一行简介 SYNOPSIS（概要）：对于命令，正式的描述它如何运行，以及需要什么样的命令行参数。对于函数，介绍函数所需的参数，以及哪个头文件包含该函数的定义 DESCRIPTION（说明）：命令或函数功能的文本描述 EXAMPLES（示例）：常用的一些示例 SEE ALSO（参见）：相关命令或函数的列表 除以上内容外，不同命令存在其它部分内容，但这些部分没有得到跨手册页的标准化 常见的例子有：OPTIONS（选项）、EXIT STATUS（退出状态）、ENVIRONMENT（环境）、BUGS（程序漏洞）、FILES（文件）、AUTHOR（作者）、REPORTING BUGS（已知漏洞）、HISTORY（历史）、COPYRIGHT（版权）等 【help 命令】help 命令是用于显示 shell 内建命令的简要帮助信息 通过 help [命令名] 即可得到相关内建命令的简要帮助信息，帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明 而对于外部命令来说，其都有一个参数 --help，通过这个参数，可以得到外部命令相应的帮助信息 当非常紧急只是忘记该用哪个参数的时候，help 这种显示简单扼要的信息就特别实用，若是不太紧急的时候就可以用 man 这种详细描述的查询方式 【info 命令】如果觉得 man 显示的信息都还不够，满足不了需求，那么可使用 info 命令来获取帮助。 该命令来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息 man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的 GNU 工具信息","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 终端与命令","slug":"02.Linux终端与命令","date":"2018-06-06T03:22:00.000Z","updated":"2022-06-03T10:25:41.456Z","comments":true,"path":"linux/28cb5a2f.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/28cb5a2f.html","excerpt":"【终端】概述终端（terminal），是一个提供了命令的输入输出环境，在 Linux 下使用组合键 Ctrl+Alt+T 打开的就是终端","text":"【终端】概述终端（terminal），是一个提供了命令的输入输出环境，在 Linux 下使用组合键 Ctrl+Alt+T 打开的就是终端 而 shell 是一个命令行解释器，是 Linux 内核的一个外壳，负责外界与 Linux 内核的交互 shell 接收用户或者其他应用程序的命令，然后将这些命令转化成内核能理解的语言并传给内核，内核执行命令完成后将结果返回给用户或者应用程序 因此，当打开一个 terminal 时，操作系统会将 terminal 和 shell 关联起来，当在 terminal 中输入命令后，shell 就负责解释命令 通用命令格式在 Linux 中，无论是命令名还是文件名，是区分大小写的，一个命令的各组成部分间用空格分隔，一个命令的输入由回车结束 命令的通用格式为：命令字 [选项] [参数] 选项用于调节命令的具体功能，其书写形式如下： 以 - 引导短格式选项，即单个字符 以 -- 引导长格式选项，即多个字符 多个短格式选项可以写在一起，用一个 - 引导 命令字前缀在终端中： @ 符号前，是当前登录的用户名 @ 符号后到 : 符号前，是计算机的主机名（hostname） : 符号后到 $ 符号前，是当前目录 $ 符号，是普通用户的命令提示符 # 符号，是 root 用户的命令提示符 输入与输出在 Linux 中，最重要的就是命令，这就包含了两个过程：输入与输出 输入，就是打开终端，然后按键盘输入，最后按回车 输出，如果是查看，会返回你想要的结果，比如返回文件的内容；如果是执行，执行成功会没有输出，执行失败会告诉你哪里错了 下面介绍几条初学者常用的命令： 打印命令：echo [输出内容] 创建空文件：touch [文件名] 删除文件：rm [文件名] 进入目录： cd [目录名] 查看当前目录： pwd 查看当前目录下的内容：ls 常用快捷键 按键 作用 Tab 可得到提示，用于补全命令、目录、命令参数 Ctrl+c 强行终止当前程序 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按任意键继续 Ctrl+k 删除从光标所在位置到行末 Ctrl+a 将光标移至行头 Ctrl+e 将光标移至行末 Alt+Backspace 向前删除一个单词 Shift+Pgup 将终端显示向上移动 Shift+Pgdn 将终端显示向下移动 通配符通配符是一种特殊语句，主要有星号 * 和问号 ?，用来对字符串进行模糊匹配 例如，在查找文件夹时，不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正字符 终端里面输入的通配符是由 Shell 处理的，不是由所涉及的命令语句处理的，它只会出现在命令的”参数值”里（它不能出现在命令名称里，命令不记得，那就用 Tab 补全） 当 Shell 在”参数值”中遇到了通配符时，Shell 会将其当作路径或文件名在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换（路径扩展），否则就将该通配符作为一个普通字符传递给”命令”，然后再由命令进行处理 总之，通配符实际上就是一种 Shell 实现的路径扩展功能。在通配符被处理后， Shell 会先完成该命令的重组，然后继续处理重组后的命令，直至执行该命令 Shell 常用通配符 字符 含义 * 匹配 $0$ 或多个字符 ？ 匹配任一字符 [list] 匹配 list 中的任意单一字符 [!list] 匹配除 list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 {string1,string2,…} 匹配 string1 或 string2 或更多其一字符串 {c1..c2} 匹配 c1-c2 中全部字符 例如：使用通配符一次创建多个名为 testX.txt 的文件，其中 X 从 1 到 5 【内建命令与外键命令】内建命令内建命令属于 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令（写在 bash 源码里 builtins 的 .def 中），由 shell 程序识别并在 shell 程序内部完成运行 shell 通常在 Linux 系统加载运行时，就被加载并驻留在系统内存中，且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快 常见内建命令有：history、cd、exit 等 外部命令外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存 外部命令虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的 外部命令是在 Bash 之外额外安装的，通常放在 /bin，/usr/bin，/sbin，/usr/sbin 等目录中 常见外部命令有：ls、vi 等 区分方法使用 type 命令即可来区分内建命令与外部命令 语法：type 要判断的命令名 当显示结果为：xxx is a shell builtin 时，说明 xxx 命令是内建命令 例如： 当显示结果为：xxx is /usr/bin/xxx 时，说明 xxx 命令是外部命令 例如： 当显示结果为：xxx is an alias for xxx —xx 时，说明 xxx 命令为 xxx —xx 命令的别名 例如：","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"Linux 概述","slug":"01.Linux概述","date":"2018-06-05T14:51:17.000Z","updated":"2022-05-14T13:24:06.176Z","comments":true,"path":"linux/f469c20f.html","link":"","permalink":"https://alex-mcavoy.github.io/linux/f469c20f.html","excerpt":"【概述】Windows 只是众多操作系统的一种，除了 Windows 系统外，常见的操作系统还有 Mac OS、Unix、Linux 等。 Unix 的历史可以追溯到 1969 年，比 Windows 还要久远，而 Linux 的发明与 Unix 系统有关","text":"【概述】Windows 只是众多操作系统的一种，除了 Windows 系统外，常见的操作系统还有 Mac OS、Unix、Linux 等。 Unix 的历史可以追溯到 1969 年，比 Windows 还要久远，而 Linux 的发明与 Unix 系统有关 Linux 是一个基于 Unix 的性能稳定的支持多任务、多线程的操作系统，其继承了 Unix 以网络为核心的设计思想，能运行 Unix 主要的工具软件、应用程序和网络协议 【Linux 的发展】Unix 系统Unix 是 1969 年美国贝尔实验室所创造的操作系统，其允许计算机同时处理多用户和程序，虽然价格昂贵，但性能、稳定性十分优越，常用于大型企业、航空公司、金融机构等 在 70 年代，Unix 用 C 语言重新编写，于 1973 年正式发布 Minix 系统Minix 系统是由荷兰阿姆斯特丹自由大学的 Andrew S. Tanenbaum(AST) 教授所开发的 其为了保持 Minix 的小型化，能让学生在一个学期内就能学完，而没有接纳全世界许多人对 Minix 的扩展要求 Minix 并不是一个优秀的操作系统，但其同时提供了用 C 语言和汇编语言写的系统源代码，这使得有抱负的程序员或 Hacker 能够阅读操作系统的源代码，而在当时，这种源代码是软件商一直小心地守护着的 GNU 计划GNU 计划，译为”革奴计划”，是由理查德·斯托曼在 1983 年公开发起的自由软件集体协作计划，其目标是创建一套完全自由的、能够兼容 Unix 的操作系统 GNU 为促进 GNU 计划与自由软件的发展，斯托曼撰写 GPL（通用公共许可证，GNU General Public License），其允许用户对支持 GPL 的自由软件任意复制、传递、修改以及再发布，而基于自由软件修改再次发布的软件，仍需遵守 GPL 在 GPL 之后，又有了 LGPL（宽通用公共许可证，Lesser General Public License），其相对于 GPL 较为宽松，允许不公开全部源代码，这为基于 Linux 平台开发商业软件提供了更多的空间 Linux 系统1991年，林纳斯·托瓦兹发表了 Linux 的内核，其是一套免费使用、允许自由传播的类 Unix 操作系统，能运行主要的工具软件、应用程序和网络协议 之后，经过诸多自愿对 Linux 进行修补的骇客，Linux 得到了极大的发展，直到今天，世界上 60% 终端设备采用 Linux 系统 【Linux 的版本】内核版本Linux 内核版本由 Linux 内核项目团体统一进行发布，自 1991 年推出第一个 Linux 正式的内核版本 1.0 后，在之后的发展中，Linux 内核版本的命名一直遵循以下规则： XX.YY.ZZ$XX$ 代表主版本号，$YY$ 代表次版本号，$ZZ$ 代表修订版本号，其中，当次版本号 $YY$ 为奇数时，代表开发版，当次版本号 $YY$ 为偶数时，代表稳定版 发行版任何软件公司和社团甚至是个人都可以将任意版本的 Linux 内核和自由软件打包成一个完整的 Linux 操作系统 而发行版的名称由厂商决定，例如： Red Hat Enterprise Linux 7：由 Red Hat 公司发布 Suse Linux 11：由 Novell 公司发布 Debian Linux 7.5：由Debian社区发布 【Linux 的组成】Linux 系统分为四个部分：内核、Shell、文件系统、应用程序 内核，是 Linux 的核心，具有很多最基本的功能，其主要模块分为存储管理、CPU 和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等 Shell，是一个命令解释器，也是系统的用户界面，提供了用户和内核进行交互操作的一种接口，其解释用户输入的命令并将其送入内核去执行，同时，Shell 具有普通编程语言的很多特点，也可作为编程语言，用其编写的 Shell 程序与其他应用程序具有同样的效果。 文件系统，文件存放在磁盘等存储设备上的组织方法。Linux 系统能支持多种目前流行的文件系统，如：ext3、ext4、XFS、FAT、VFAT、NTFS、ISO9660 等 应用程序，是 Linux 系统都有一套程序集，它包括文本编辑器、编程语言、X Window、办公软件和 Internet 工具等 【界面】桌面环境相较于 Windows 系统，Linux 本身是没有图形界面的 在 Linux 发行版上看到的图形界面实质上都是运行在 Linux 系统之上的软件，类似 Windows95 之前的 Windows 的图形界面只是运行在 DOS 环境的一套软件 而 Linux 上的这套软件以前是 XFree86，现在是 xorg（X.Org），这套软件是通过 X 窗口系统（X Window System，常被称为 X11 或 X）实现的，其本身只是工具包及架构协议，而 xorg 是 X 架构规范的一个实现体，即：它是实现了 X 协议规范的一个提供图形界面服务的服务器，就像实现了 http 协议提供 web 服务的 Apache 如果只有服务器则不能实现一个完整的桌面环境的，还需要一个客户端，我们称为 X Client，如目前最流行的实现客户端功能的桌面环境 KDE，GNOME，XFCE，LXDE 等 这也意味着在 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面 虚拟控制台终端（Terminal）也称终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入以及处理结果的输出等 Linux 系统为实现在图形窗口中完成用户输入和显示输出，提供了一个叫做终端模拟器的程序 终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登陆就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 $6$ 个虚拟终端，第一个终端默认是图形化用户界面，第二到六个虚拟终端是字符界面 在物理机系统上可以通过[Ctrl]+[Alt]+[F1]～[F6]进行切换终端 字符界面在安装图形界面后，Linux 系统默认进入的总是图形化界面，我们可以通过终端的 systemctl get-default 来查看计算机系统启动后要进入的默认目标 graphical.target 表示图形化界面，如果想默认进入图形界面，我们可以将 multi-user.target 设置为启动计算机系统后要进入的默认目标 即：systemctl set-default multi-user.target 同理，如果我们想默认进入图形界面，将 graphical.target 设置为启动计算机系统后要进入的默认目标即可","categories":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://alex-mcavoy.github.io/tags/linux/"}],"author":"Alex_McAvoy"},{"title":"哈希查找","slug":"search/06.hash-table/01.哈希表","date":"2018-05-14T11:20:23.000Z","updated":"2021-09-22T12:05:15.761Z","comments":true,"path":"oi-acm/search/hash-search/a6c955f5.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/search/hash-search/a6c955f5.html","excerpt":"【概述】查找最理想情况是：不经过任何比较，直接得出待查记录的存储位置 这就需要在记录的存储位置与其关键码之间建立一个确定的对应关系 $H$，使得每个关键码 $key$ 与唯一的存储位置 $H(key)$ 相对应","text":"【概述】查找最理想情况是：不经过任何比较，直接得出待查记录的存储位置 这就需要在记录的存储位置与其关键码之间建立一个确定的对应关系 $H$，使得每个关键码 $key$ 与唯一的存储位置 $H(key)$ 相对应 在查找时，根据这个确定关系找到给定值 $k$ 和映射 $H(k)$ ，若查找集合中存在这个记录，则必定在 $H(k)$ 的位置上，这种查找技术即哈希查找（Hash Search），又称散列查找 采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为哈希表（Hash Table），将关键码映射为哈希表中适当存储位置的函数称为哈希函数（Hash Function），所得的存储位置称为哈希地址（Hash Address） 具体来说，散列过程为： 存储记录时：通过散列函数计算记录的散列地址，并按散列地址存储该记录 查找记录时：通过散列函数计算记录的散列地址，并按散列地址访问该记录 综上，哈希查找所用的散列技术，既是一种存储方法，也是一种查找方法，但散列不是一种完整的存储技术，其只是通过记录的关键码定位该记录，难以完整地表达记录间的逻辑关系，因此，散列主要是面向哈希查找的存储结构 【限制及问题】由于哈希查找的特性要求关键码与地址一一对应，那么由此也存在一定的问题 哈希查找通过哈希函数建立了从记录的关键码集合到散列表的地址集合的一个映射，哈希函数的定义域是查找集合中全部记录的关键码，若哈希表中有 $m$ 个地址单元，则哈希函数的值域为 $[0,m-1]$ 最理想情况下，对任意给定的查找集合 $T$，若选定了某个理想的哈希函数 $H$ 及其相应的哈希表 $L$，则对 $T$ 中记录 $r_i$ 的关键码 $k_i$，$H(k_i)$ 就是记录 $r_i$ 在哈希表 $L$ 中的存储位置，这种情况下的散列称为完美散列 但在实际应用中，往往会出现两个不同的关键码 $k1≠k2$，有 $H(k1)=H(k2)$，即两个不同的记录需要存放在同一个存储位置中，这种现象称为冲突（collision），此时，$k1$ 与 $k2$ 相对于 $H$ 称为同义词（synonym） 若记录按照哈希函数计算出的地址加入哈希表时产生了冲突，那么就必须另找一个存储位置来存放，这就产生了如何处理冲突的问题，因此，采用哈希查找需要考虑的主要问题是： 哈希函数的设计：如何设计一简单、均匀、存储利用率高的哈希函数 冲突的处理：如何采用合适的处理冲突的方法来解决冲突 此外，由于哈希查找的特性，其不适用于范围查找，即不能查找最值、找到某一范围内的记录 【哈希函数】要求哈希查找一般用于处理关键码来自范围很大的记录，并将这些记录存储在一个有限的散列表中，因此哈希函数的设计是一个十分关键也是十分复杂的问题 一般来说，希望哈希函数能将记录以相同概率 “散列” 到哈希表的所有地址空间中，因此，设计哈希函数一般遵循以下基本原则： 计算简单：哈希函数不有很大的计算量，否则会降低查找效率 哈希地址分布均匀：函数值要尽量均匀散布在地址空间，从而保证存储空间的有效利用并减少冲突 以上两个方面在实际应用中是矛盾的，为了保证散列地址的均匀性好，哈希函数的计算就必然复杂；反之，如果哈希函数的计算比较简单，那么均匀性就较差 一般来说，哈希函数依赖于关键码的分布情况，而在实际应用中，事先并不知道关键码的分布情况，或者关键码高度汇集，因此在设计哈希函数时，要根据具体情况来选择一较为合理的方案 直接定址法直接定址法的哈希函数是关键码的线性函数，即： H(key)=a*key+b其优点是：单调、均匀、不会产生冲突，但需事先知道关键字的分布情况，适合查找表较小且连续的情况 例如：关键码集合为 $\\{10,30,50,70,80,90\\}$，选取的散列函数为 $H(key)=\\frac{1}{10}key$ 除留余数法除留余数法是最简单、最常用的哈希函数构造方法，且其不需要事先知道关键码的分布 其基本思想是：选择某个适当的正整数 $p$，以关键码除以 $p$ 的余数作为散列地址，即： H(key)=key \\:\\: mod \\:\\: p \\:\\:(p\\leq m)其中，$m$ 为哈希表表长 可以看出，这种方法的关键在于选取合适的 $p$，一般情况下，若哈希表表长为 $m$，通常选取小于或等于表长 $m$ 的最小素数 数字分析法数字分析法根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成哈希地址，其适合事先知道关键码的分布，且关键码中有若干位分布较均匀的情况 例如：关键码为 $8$ 位十进制数，哈希地址为 $2$ 位十进制数 平方取中法由于在一个数平方后，其中间的几位数分布较为均匀 因此，平方取中法就是对关键码平方后，按哈希表的大小，取中间若干位作为哈希地址，其常用于不知道关键码的分布且关键码的位数不是很大的情况。 例如：哈希地址为 $2$ 位，关键码为 $1234$，那么其哈希地址为： 折叠法折叠法是将关键字从左到右分割成位数相等的若干部分，最后一个部分位数不够可以短一些，然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址，通常采用以下两种叠加方法： 移位叠加：将各部分的最后一位对齐相加 间界叠加：从一端向另一端沿各部分分界来回折叠后，最后一位对齐相加 折叠法适用于关键码位数较多，且关键码每一位分布都不均匀的情况，其无需指定关键码的分布 例如：哈希地址为 $3$ 位，关键码为 $25346358705$，那么其哈希地址为： 【冲突处理方法】由于关键码的复杂性与随机性，很难有理想的哈希函数存在，如果某记录按哈希函数计算出的哈希地址在加入哈希表时发生冲突，就必须另外再寻找一个地址存放，因此需要有合适的处理冲突的方法 开放定址法开放定址法，就是由关键码得到的哈希地址一旦产生冲突，就去寻找下一个哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将记录存入，用开放定址法处理冲突得到的哈希表叫做闭哈希表 从冲突的下一个位置起，依次寻找空的哈希地址，即：对于键值 $key$，设 $H(key)=d$，闭哈希表长度为 $m$，则发生冲突时，下一哈希地址为： H_i=(H(key)+d_i)\\:\\:mod\\:\\:m用开放定址法处理冲突的方法十分简单，但在处理冲突的过程中，会出现非同义词间对同一个哈希地址争夺的现象，这种现象称为堆积 根据 $d_i$ 的不同，有以下几种方法： 1）线性探测法 当发生冲突时，下一哈希地址为 H_i=(H(key)+d_i)\\:\\:mod\\:\\:m(d_i=1,2,3,...,m-1)例如：关键码集合为 $\\{47, 7, 29, 11, 16, 92, 22, 8, 3\\}$，哈希表表长为 $11$，哈希函数为 $H(key)=key%11$，用线性探测法处理冲突，则有： 2）平方探测法 当发生冲突时，下一哈希地址为： H_i=(H(key)+d_i)\\:\\:mod\\:\\:m其中 $d_i=1^2,-1^2,2^2,-2^2,..,q^2,-q^2)$，且满足 $q\\leq \\sqrt m$ 例如：关键码集合为 $\\{47, 7, 29, 11, 16, 92, 22, 8, 3\\}$，散列表表长为 $11$，散列函数为 $H(key)=key \\:\\: mod \\:\\: 11$，用二次探测法处理冲突，则有 3）再探测法 当发生冲突时，下一哈希地址为 $H_i=Hash_2(key)$ 该方法使用两个哈希函数，当通过第一个哈希函数 $Hash_1(key)$ 得到的地址冲突时，再利用第二个哈希函数 $Hash_2(key)$ 计算该关键字的地址增量，即： H_i=(Hash_1(key)+i*Hash_2(key))\\:\\:mod\\:\\:m其中，$m$ 为表长，$i$ 是冲突的次数，初始为 $0$，初始探测位置 $H_0=H(key)\\:\\:mod\\:\\:m$ 值得注意的是，该方法最多经过 $m-1$ 次探测就会遍历表中所有位置，回到 $H_0$ 的位置 4）随机探测法 当发生冲突时，下一哈希地址为： H_i=(H(key)+d_i)mod\\:\\:m其中 $d_i$ 是一个随机数列 链地址法链地址法又称拉链法，其基本思想是：将所有哈希地址相同的记录存储在一个单链表（同义词子表）中，在哈希表中存储的是所有同义词子表的头指针 用链地址法处理冲突构造的哈希表叫做开哈希表，当 $n$ 个记录存储在长度为 $m$ 的开散列表中，其同义词子表的平均长度为 $\\frac{n}{m}$ 例如：关键码集合 $\\{47, 7, 29, 11, 16, 92, 22, 8, 3\\}$，散列函数为 $H(key)=key\\:\\:mod\\:\\:11$，用拉链法处理冲突，则有： 公共溢出区建立公共溢出区是在哈希表的基础上加了一个溢出表，其用于存储发生冲突的记录，使得哈希表包含两部分：基本表、溢出表，通常溢出表与基本表大小相同 在查找时，对给定值通过散列函数计算散列地址，先与基本表的相应单元进行比较，若相等，则查找成功；否则，再到溢出表中进行顺序查找。 例如：关键码集合 $\\{47, 7, 29, 11, 16, 92, 22, 8, 3\\}$，散列函数为 $H(key)=key\\:\\: mod \\:\\:11$，用公共溢出区法处理冲突，则有： 【性能分析】基本因素哈希查找中，处理冲突的方法不同，得到的哈希表不同，哈希表的查找性能也不同，由于冲突的存在，产生冲突后的查找仍然是给定值与关键码进行比较的过程，因此，对哈希查找效率的量度采用平均查找长度 在查找过程中，关键码的比较次数取决于产生冲突的概率，产生的冲突越多，查找效率就越低，而影响冲突产生的因素有： 散列函数是否均匀：直接影响冲突产生的概率，一般情况下，认为哈希函数是尽量均匀的，因此可以不考虑其对平均查找长度的影响 处理冲突的方法：就处理冲突的方法来看，他们的平均查找长度不同，容易看出，由于开放定址法处理冲突可能会产生堆积，从而会增加平均查找长度，而链地址法处理冲突不会产生堆积 装填因子记表中已填入的记录数为 $n$，表的长度为 $m$，则装填因子： α=\\frac{n}{m}装填因子 $α$ 标志着哈希表的装满程度，由于表长 $m$ 是定值，$α$ 与填入表中的记录个数 $n$ 成正比，因此，填入表中的记录越多，$α$ 就越大，产生的冲突可能性就越大 实际上，哈希表的平均查找长度只是装填因子 $α$ 的函数，只是不同处理冲突的方法具有不同的函数，常见的几种不同处理冲突方法的平均查找长度 $ASL$ 如下： 查找成功时 查找失败时 线性探测法 $\\frac{1}{2}(1+\\frac{1}{(1-α)^2})$ $\\frac{1}{2}(1+\\frac{1}{1-α^2})$ 平方探测法 $\\frac{1}{α}ln(1+α)$ $\\frac{1}{1-α}$ 链地址法 $1+\\frac{α}{2}$ $α+e^α$ 在等概率情况下，查找成功的平均查找长度公式为： ASL_{成功}=\\frac{1}{n}\\sum_{i=1}^nC_i其中 $n$ 为表中置入元素个数，$C_i$ 为置入每个元素时所需的比较次数 查找失败的平均查找长度公式为： ASL_{失败}=\\frac{1}{r}\\sum_{i=1}^rC_i其中 $r$ 为哈希函数取值个数，$C_i$ 函数取值为 $i$ 时确定查找不成功时的比较次数 【实现】下面给出链地址法的实现 12345678910111213141516171819202122232425262728293031323334353637const int SIZE = 1000000;const int M = 999997;struct HashTable &#123;struct Node &#123; int next; int value; int key;&#125; data[SIZE];int head[M], size;int f(int key) &#123; //哈希函数 return key % M; &#125;int get(int key) &#123; int p = head[f(key)]; while (p) &#123; if (data[p].key == key) return data[p].value; p = data[p].next; &#125; return -1;&#125;int modify(int key, int value) &#123; int p = head[f(key)]; while (p) &#123; if (data[p].key == key) return data[p].value = value; p = data[p].next; &#125;&#125;int add(int key, int value) &#123; if (get(key) != -1) return -1; data[++size] = (Node)&#123;head[f(key)], value, key&#125;; head[f(key)] = size; return value; &#125;&#125;;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"查找&搜索","slug":"oi-acm/search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/"},{"name":"哈希查找","slug":"oi-acm/search/hash-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/hash-search/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"},{"name":"哈希查找","slug":"hash-search","permalink":"https://alex-mcavoy.github.io/tags/hash-search/"}],"author":"Alex_McAvoy"},{"title":"倒排索引","slug":"data-structure/09.index-method/04.倒排索引","date":"2018-05-03T14:45:30.000Z","updated":"2021-09-22T12:50:34.712Z","comments":true,"path":"oi-acm/data-structure/index-method/ce1714.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/ce1714.html","excerpt":"【概述】倒排表是对次关键码的一种索引表，其索引项包括以下两个结构： 次关键码：要记录的表项 记录号表：存储具有相同次关键字的所有记录的记录号，并且有序排列","text":"【概述】倒排表是对次关键码的一种索引表，其索引项包括以下两个结构： 次关键码：要记录的表项 记录号表：存储具有相同次关键字的所有记录的记录号，并且有序排列 这种索引不是由记录来确定数据项，而是由数据项来确定记录的位置 【优缺点】倒排索引的优点在于查找记录的速度很快，有时不用读取记录即可得到结果，而且由于其并未对文件进行修改，使用和维护都比较简单 但由于倒排表中的记录号表长是不固定的，处理时极不方便，此外，倒排表中具同一关键码值的记录号都是有序序列，这在插入和删除时要进行一定的处理","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"斐波那契查找","slug":"search/02.binary-search/03.斐波那契查找","date":"2018-04-29T07:14:33.000Z","updated":"2021-09-22T12:33:32.159Z","comments":true,"path":"oi-acm/search/binary-search/785fbba3.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/search/binary-search/785fbba3.html","excerpt":"【概述】黄金分割又称黄金比例，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为 $1:0.618$ 或 $1.618:1$，黄金比例不仅在绘画、艺术上有着重要的审美价值，在工程上也具有极大的作用 在二分查找中，每次查找都是将查找表一分为二，无论数据是偏大还是偏小，很多时候都未必是最合适的做法","text":"【概述】黄金分割又称黄金比例，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为 $1:0.618$ 或 $1.618:1$，黄金比例不仅在绘画、艺术上有着重要的审美价值，在工程上也具有极大的作用 在二分查找中，每次查找都是将查找表一分为二，无论数据是偏大还是偏小，很多时候都未必是最合适的做法 斐波那契查找，是借助斐波那契数列从第三个数开始，前后两个数的比值越来越接近 $0.618$ 的特性，对二分查找进行了改进 &lt;img width=500 src=/images/oi-acm/search/02.binary-search/03-1.png” /&gt; 【基本思想】斐波那契查找中，首先根据查找表的长度 $n$ 来计算 $n$ 这个数，在斐波那契数列的位置 $k$，然后根据斐波那契数列中第 $k$ 个位置的元素 $F[k]$，来将查找表中不满的数值补全，最后再计算 $mid$，即： mid=left+F[k-1]-1之后，将 $a[mid]$ 与 $key$ 值进行比较，根据比较结果来调整查找区间： $key&lt;a[mid]$：查找记录小于当前查找点，最高下标 $right$ 调整到 $mid-1$ 处，斐波那契数列下标 $k$ 相应 $-1$ $key&gt;a[mid]$：查找记录大于当前查找点，最低下标 $left$ 调整到 $mid+1$ 处，斐波那契数列下标 $k$ 相应 $-2$ $key=a[mid]$：查找成功，此时与 $n$ 比较，来判断是查找到的数值还是补全的数值，若 $mid\\leq n$ 查找成功，反之，为补全的数值，返回 $n$ 【实现】1234567891011121314151617181920212223242526272829303132333435363738int F[N];void Fibonacci()&#123; //构造斐波那契数列 F[0] = 0; F[1] = 1; for (int i = 2; i &lt; N; i++) F[i] = F[i-1] + F[i-2];&#125;int fibonacciSearch (int a[], int n, int key) &#123; int low = 0; int high = n; Fibonacci();//构造斐波那契数列 int k = 0; while (n &gt; F[k]-1) //计算n位于斐波那契数列的位置 k++; for (int i = n; i &lt; F[k] - 1; i++) //将数组a扩展到F[k]-1的长度 a[i] = a[n]; while (low &lt;= high) &#123; int mid = low + F[k-1] - 1; if (key &lt; temp[mid]) &#123; //查找记录小于当前查找点 high = mid - 1; k--;//斐波那契数列下标-1 &#125; else if (key &gt; temp[mid]) &#123; //查找记录大于当前查找点 low = mid + 1; k -= 2; //斐波那契数列下标-2 &#125; else &#123; if (mid &lt;= n) //查找到的位置 return mid; else //扩展的数值 return n; &#125; &#125; return -1;//查找失败&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"查找&搜索","slug":"oi-acm/search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/"},{"name":"二分查找","slug":"oi-acm/search/binary-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/binary-search/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"},{"name":"二分查找","slug":"binary-search","permalink":"https://alex-mcavoy.github.io/tags/binary-search/"}],"author":"Alex_McAvoy"},{"title":"插值查找","slug":"search/02.binary-search/02.插值查找","date":"2018-04-29T07:03:00.000Z","updated":"2021-09-22T12:19:58.340Z","comments":true,"path":"oi-acm/search/binary-search/bb7c2db2.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/search/binary-search/bb7c2db2.html","excerpt":"【概述】以查字典为例，在英文字典中查 “apple” 时，下意识的会翻开前面的书页，当查 “zoo” 时，下意识的翻开一定是后面的书页，显然，此时还绝对不是从中间开始查起，而且有一定目的地从前或从后查找 同样的，以取值范围在 $1$ 到 $10000$ 间的从小到大均匀分布在数组中的 $100$ 个元素为例，若要查找元素 $5$，那么自然而然的会考虑从数组下标较小的开始查找","text":"【概述】以查字典为例，在英文字典中查 “apple” 时，下意识的会翻开前面的书页，当查 “zoo” 时，下意识的翻开一定是后面的书页，显然，此时还绝对不是从中间开始查起，而且有一定目的地从前或从后查找 同样的，以取值范围在 $1$ 到 $10000$ 间的从小到大均匀分布在数组中的 $100$ 个元素为例，若要查找元素 $5$，那么自然而然的会考虑从数组下标较小的开始查找 可以看出，对于二分查找这种查找方式，其并不是自适应的，因此，基于二分查找，就有了插值查找，其将查找点的选择改进为自适应选择，从而提高查找效率 简单来说，插值查找，就是根据要查找的关键字 $key$ 与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的查找点的计算公式 【查找点的计算】在二分查找中，查找点是中值，即： mid=\\frac{left+right}{2}经过简单变换，有： mid=left+\\frac{1}{2}*(right-left)而在插值查找中，对查找点的计算进行了一定的改进，即： mid=left+\\frac{key-a[left]}{a[right]-a[left]}*(right-left)即将 $\\frac{1}{2}$ 换为了能够自适应选择的插值点 \\frac{key-a[left]}{a[right]-a[left]}【时间复杂度】从时间复杂度的角度来说，插值查找的最坏时间复杂度与二分查找相同，均为： O(\\log_2 n)但对于表长较大，而关键字分布又比较均匀的查找表来说，其平均性能要比二分查找好的多 反之，若查找表中关键字分布非常不均匀，那么插值查找未必是很合适的选择 【实现】123456789int insertionSearch (int a[], int key, int left, int right) &#123; int mid = low + (key - a[left]) / (a[right] - a[left]) * (right - left); if (a[mid] == value) return mid; else if (a[mid] &gt; value) return insertionSearch(a, key, left, mid-1); else return insertionSearch(a, key, mid+1, right);&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"查找&搜索","slug":"oi-acm/search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/"},{"name":"二分查找","slug":"oi-acm/search/binary-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/binary-search/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"},{"name":"二分查找","slug":"binary-search","permalink":"https://alex-mcavoy.github.io/tags/binary-search/"}],"author":"Alex_McAvoy"},{"title":"分块索引","slug":"data-structure/09.index-method/03.分块索引","date":"2018-04-29T06:45:30.000Z","updated":"2021-09-22T12:06:42.073Z","comments":true,"path":"oi-acm/data-structure/index-method/e19882cf.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/e19882cf.html","excerpt":"【概述】分块索引，又称索引顺序查找，其吸取了顺序查找和二分查找的优点，属于线性索引结构，既适用于静态索引，又适用于动态索引 其基本思想是将查找表分为若干子块，这些子块之间满足分块有序这个要求，即这些块满足以下两个条件：","text":"【概述】分块索引，又称索引顺序查找，其吸取了顺序查找和二分查找的优点，属于线性索引结构，既适用于静态索引，又适用于动态索引 其基本思想是将查找表分为若干子块，这些子块之间满足分块有序这个要求，即这些块满足以下两个条件： 块间有序：后一块的所有记录的关键字要大于前一块的所有记录的关键字 块内无序：每一块的记录不要求有序 【结构】对于分块有序的数据集，将每块对应一个索引项，其结构分为以下三个部分： 最大关键码：存储每一块的最大关键字，以便在下一块中的最小关键字也能比这一块的最大关键字大 块长：存储块中记录个数 块首地址：指向块首数据元素的指针 【查找过程】在分块表中进行查找，整个过程分为两步： 在整个索引表中，通过顺序查找或二分查找，来确定待查记录所在的块 在确定的相应块中，采用顺序查找，查找待查关键字 如上图，关键码集合为 $\\{18,5,27,13,57,36,96,62,77\\}$，按照关键码值 $27,57,96$ 分为三个块，从而形成图中左边的索引表 假设查找待查元素为 $5$，那么会先在索引表中对元素 $5$ 进行查找，确定其所在的块是第一块，然后在第一块的四个元素 $18,5,27,13$ 中进行查找 【平均查找长度】分块索引的平均查找长度为索引查找和块内查找的平均长度之和 假设索引查找和块内查找的平均查找长度分别为 $L_I,L_S$，那么分块索引的平均查找长度为： ASL=L_I+L_S对于含有 $n$ 个记录的文件，假设将其分为 $m$ 个块，每块中有 $t$ 条记录，即： n=m*t在等概率的情况下，若在索引表和块内中均采用顺序查找，则平均查找长度为： \\begin{align} ASL &= L_I+L_S \\notag \\\\ &= \\frac{m+1}{2}+\\frac{t+1}{2} \\notag \\\\ &= \\frac{1}{2}(\\frac{n}{t}+1)+1 \\notag \\\\ &= \\frac{t^2+2t+n}{2t} \\notag \\end{align}可以发现，平均查找长度不仅取决于数据集的总记录数 $n$，还取决于每一个块中的记录条数 $t$ 最佳的情况就是分的块数 $m$ 与块中记录数相同，即：$n=mt=tt$，有：$t=\\sqrt n$，此时，平均查找长度取最小值： ASL=\\sqrt n +1若在索引表和块内中均采用顺序查找，则平均查找长度为： \\begin{align} ASL &= L_I+L_S \\notag \\\\ &= \\lceil \\log_2 (m+1) \\rceil + \\frac{t+1}{2} \\notag \\\\ \\end{align}【实现】假设分块长度为 $\\sqrt n$，那么分块的实现如下： 12345678910111213int block; //block为块的长度int sum; //sum为块的个数int a[N]; //存放数列元素int pos[N]; //tag为操作标记int tag[N]; //pos记录第i个元素在第几个块中void init(int n) &#123; //初始化 block = (int)sqrt(n); //块的长度 sum = n / block; //块数 if (n % block) sum++; for (int i = 1; i &lt;= n; i++) //第i个元素在第几块中 pos[i] = (i - 1) / block + 1;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"稠密索引","slug":"data-structure/09.index-method/02.稠密索引","date":"2018-04-25T06:45:30.000Z","updated":"2021-09-22T12:43:33.960Z","comments":true,"path":"oi-acm/data-structure/index-method/236c53cc.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/236c53cc.html","excerpt":"【概述】稠密索引常见于静态索引中，在线性索引里，若文件中的每个记录对应一个索引项，则这种索引称为稠密索引 在稠密索引中，无论文件是否按关键码有序，索引项总是按关键码有序进行排列","text":"【概述】稠密索引常见于静态索引中，在线性索引里，若文件中的每个记录对应一个索引项，则这种索引称为稠密索引 在稠密索引中，无论文件是否按关键码有序，索引项总是按关键码有序进行排列 【优缺点】只要内存空间允许，常常将稠密索引存储在内存中，从而提高查找速度 此外，在建立索引后，由于索引项有序，且每个索引项都包含了一个关键码以及指向该记录存储位置的指针，因此在对记录进行操作时，可以采用有序查找算法进行查找，也可以通过记录号进行随机访问，大大提高了效率 但相应的，如果文件中包含的记录过多，索引表本身可能会因为太大无法在内存中，这样在查找过程中可能需要多次访问磁盘，使得查找的性能降低","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"索引技术","slug":"data-structure/09.index-method/01.索引技术","date":"2018-04-23T07:39:13.000Z","updated":"2021-09-24T07:33:05.080Z","comments":true,"path":"oi-acm/data-structure/index-method/a9cf94d8.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/data-structure/index-method/a9cf94d8.html","excerpt":"【概述】在进行数据查找操作，当数据量不是很大时，一般的查找技术足以满足需求 但对于服务器来说，其是以大型数据库为中心的，并且其将大型数据库作为文件存放于外存中的，而当需要进行数据查找操作时，查找技术处理过于缓慢，为加快查找速度，设计出了索引这种结构","text":"【概述】在进行数据查找操作，当数据量不是很大时，一般的查找技术足以满足需求 但对于服务器来说，其是以大型数据库为中心的，并且其将大型数据库作为文件存放于外存中的，而当需要进行数据查找操作时，查找技术处理过于缓慢，为加快查找速度，设计出了索引这种结构 索引技术常应用于大型数据库与磁盘文件，通过索引可以实现对文件中记录的快速访问，对于一个文件来说，其可能拥有多个相关的索引，同时，每个索引往往只支持一个关键字 【基本概念】关于索引技术的基本概念如下： 文件：存储在外存上的数据的集合 记录：由若干数据项组成的数据元素，是文件进行存取的基本单位 数据项：数据记录中最基本的、不可分割的数据单位，是文件中可使用的最小单位 索引：将关键码与其对应的记录相关联的过程，隶属于某一文件 索引项：由关键码及关键码对应的记录在存取器中的位置等信息组成，是构成索引的基本单位 【索引的类型】按照索引的结构是否可以改变，索引可以分为以下两类： 静态索引：在文件创建时即生成索引结构，一旦生成就固定，只有当文件再组织时才发生改变 动态索引：在文件创建时即生成索引结构，当文件执行插入、删除等操作时，索引结构随之改变 按照索引项组织的结构，索引可分为以下三类： 线性索引：索引项组织为线性结构 树形索引：索引项组织为树形结构 多级索引：对于某些大型文件，其索引本身可能也很大，在这种情况下，可对索引再建一索引，从而构成多级索引结构 其中，线性索引是将索引项集合组织为线性结构，即索引表，其常见的形式有稠密索引、分块索引、倒排索引三种 进一步组，由于树结构每个结点可以存储一个元素，拥有多个孩子，那么在元素非常多的时候，就使得要么树的度非常大，要么树的高度非常大，这就使得在外存查找时，内存存取外存的次数非常多，严重影响了时间效率 为了提高时间效率，就要打破每一结点只能存储一个元素的限制，于是引入了多路查找树（Muitl-way Search Tree），其每一结点的孩子数可以多于两个，且每一结点可存储多个元素 而树形索引技术，就是将索引项组织为使用多路查找树的树形结构，其常见的形式有 2-3 树、2-3-4 树、B 树、B+树、B*树等","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"数据结构","slug":"oi-acm/data-structure","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/"},{"name":"索引技术","slug":"oi-acm/data-structure/index-method","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/data-structure/index-method/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"数据结构","slug":"data-structure","permalink":"https://alex-mcavoy.github.io/tags/data-structure/"},{"name":"索引技术","slug":"index-method","permalink":"https://alex-mcavoy.github.io/tags/index-method/"}],"author":"Alex_McAvoy"},{"title":"Hello World","slug":"daily/01.Hello World","date":"2018-04-22T10:29:00.000Z","updated":"2021-10-07T11:02:50.519Z","comments":true,"path":"essay/daily/4a17b156.html","link":"","permalink":"https://alex-mcavoy.github.io/essay/daily/4a17b156.html","excerpt":"无论什么时候，每当想起自己曾满怀激情、兴奋、惊奇与真诚等等情绪，在键盘上敲出的第一个程序——“Hello World”，就总是会充满一种不知名的情绪 记得很久很久以前对 G 说过，真正地程序员都是一群充满好奇心的为解决问题甚至不眠不休并以此为乐的疯子，他们之中有人简单纯粹内心火热，有人善于分享乐于助人，也有人沉默寡言不苟言笑，还有人孤僻冷漠难以相处，但他们无一不是理想主义者，从敲出 “Hello World” 的那一刻起，他们的最初梦想和最终目的，就是为了改变这个世界 从最开始接触计算机至今大约有 8、9 个年头了，儿时大多只是瞎捣鼓，真正开始接触编程后，又因为种种原因没有 Blog，最近决定建一个属于自己的 Blog","text":"无论什么时候，每当想起自己曾满怀激情、兴奋、惊奇与真诚等等情绪，在键盘上敲出的第一个程序——“Hello World”，就总是会充满一种不知名的情绪 记得很久很久以前对 G 说过，真正地程序员都是一群充满好奇心的为解决问题甚至不眠不休并以此为乐的疯子，他们之中有人简单纯粹内心火热，有人善于分享乐于助人，也有人沉默寡言不苟言笑，还有人孤僻冷漠难以相处，但他们无一不是理想主义者，从敲出 “Hello World” 的那一刻起，他们的最初梦想和最终目的，就是为了改变这个世界 从最开始接触计算机至今大约有 8、9 个年头了，儿时大多只是瞎捣鼓，真正开始接触编程后，又因为种种原因没有 Blog，最近决定建一个属于自己的 Blog 现在网络上有许多可以发表个人想法的平台，知乎，CSDN，简书，博客园等等，但还是决定建立一个属于自己 Blog，这是我自己的平台，可以自由地去发表个人想法与文章，不能担心内容是否迎合平台的读者 同时，一方面，作为自己的一个分享型知识记录，在忘记时可以回顾，当做笔记用，另一方面，我希望自己的经历或者知识，可以给别人带来一些启发与帮助 或许，还会在闲暇时刻记录一些生活的琐碎，仅此而已","categories":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/categories/essay/"},{"name":"Daily","slug":"essay/daily","permalink":"https://alex-mcavoy.github.io/categories/essay/daily/"}],"tags":[{"name":"随笔","slug":"essay","permalink":"https://alex-mcavoy.github.io/tags/essay/"},{"name":"Daily","slug":"daily","permalink":"https://alex-mcavoy.github.io/tags/daily/"}],"author":"Alex_McAvoy"},{"title":"计数排序","slug":"basic/02.sort/14.计数排序","date":"2018-04-17T14:44:38.000Z","updated":"2021-09-25T14:29:18.328Z","comments":true,"path":"oi-acm/basic/sort/cb625b07.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/cb625b07.html","excerpt":"【基本思想】计数排序是非比较类排序一种，其基本思想是：对于给定的输入序列中的每一个元素 $x$，确定该序列中值小于 $x$ 的元素的个数，一旦有了这个信息，就可以将 $x$ 直接存放到最终的输出序列的正确位置上 例如，如果输入序列中只有 $17$ 个元素的值小于 $x$ 的值，则 $x$ 可以直接存放在输出序列的第 $18$ 个位置上","text":"【基本思想】计数排序是非比较类排序一种，其基本思想是：对于给定的输入序列中的每一个元素 $x$，确定该序列中值小于 $x$ 的元素的个数，一旦有了这个信息，就可以将 $x$ 直接存放到最终的输出序列的正确位置上 例如，如果输入序列中只有 $17$ 个元素的值小于 $x$ 的值，则 $x$ 可以直接存放在输出序列的第 $18$ 个位置上 当然，如果有多个元素具有相同的值时，不能将这些元素放在输出序列的同一个位置上 计数排序的排序过程为： 统计数组中每个值为 $i$ 的元素出现的次数，存入数组 $C$ 的第 $i$ 项 求每个数出现次数的前缀和，即数组 $C$ 的前缀和 根据出现次数的前缀和，从右向左反向计算每个数的位置，即将每个元素 $i$ 放在新数组的第 $C[i]$项，同时，每放一个元素就将 $C[i]$减去 $1$ 【实例】以数列 $\\{0,2,5,3,7,9,10,3,7,6\\}$ 为例，演示计数排序的过程 【性能分析】计数排序适用于顺序存储结构，在计数累加过程中，并没有改变相同元素的相对位置，因此其是一种稳定排序算法 计数排序需要一个用来暂存输出序列的数组，其大小与输入序列大小相同，此外，还需要一个来暂存每个数出现次数的前缀和的数组，因此，其空间复杂度为： O(n)计数排序的时间复杂度大小与待排序数据的值域大小有关，假设值域大小为 $w$，那么时间复杂度为： O(n+w)【实现】1234567891011121314151617#define MAXNUM 20 //待排序数的最大个数#define MAX 100 //待排序数的最大值int res[MAXNUM];int temp[MAX+1];void countSort (int a[], int n) &#123; for (int i = 0; i &lt; n; i++) //统计i的次数 temp[a[i]]++; for (int i = 1; i &lt;= MAX; i++) //对所有的计数累加，统计数组a的前缀和与小于小于a数组值出现的个数 temp[i]+=temp[i-1]; for (int i = n - 1; i &gt;= 0; i--) &#123; //逆向遍历源数组，根据计数数组中对应的值填充到新数组中 res[temp[a[i]]-1] = a[i]; //temp[a[i]]表示数组a中包括a[i]和小于a[i]的总数 temp[a[i]]--; //如果数组a中有相同的数，a[i]的下标-1 &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"基数排序","slug":"basic/02.sort/13.基数排序","date":"2018-04-17T09:09:01.000Z","updated":"2021-09-25T14:19:04.558Z","comments":true,"path":"oi-acm/basic/sort/6367b42a.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/6367b42a.html","excerpt":"【基本思想】基数排序借助多关键字排序的思想，对单逻辑关键字进行排序，简单来说，其是基于关键字各位的大小进行排序 假设长度为 $n$ 的线性表中每个结点 $a_j$ 的关键字由 $d$ 元组 $(k_j^{d_-1},k_j^{d_-2},…,d_j^1,d_j^0)$ 组成，满足 $0\\leq k_j^i\\leq r-1$，其中 $k_j^{d-1}$ 为最主关键字，$k_j^0$ 为最次关键字，且 $0\\leq j &lt;n,0\\leq i\\leq d-1$","text":"【基本思想】基数排序借助多关键字排序的思想，对单逻辑关键字进行排序，简单来说，其是基于关键字各位的大小进行排序 假设长度为 $n$ 的线性表中每个结点 $a_j$ 的关键字由 $d$ 元组 $(k_j^{d_-1},k_j^{d_-2},…,d_j^1,d_j^0)$ 组成，满足 $0\\leq k_j^i\\leq r-1$，其中 $k_j^{d-1}$ 为最主关键字，$k_j^0$ 为最次关键字，且 $0\\leq j &lt;n,0\\leq i\\leq d-1$ 为实现多关键字排序，有两种方法： 最高位优先（MSD）：按关键字位权重递减，逐层划分为若干更小子序列，最后将所有子序列连接成有序序列 最低位优先（LSD）：按关键字位权重递增，逐层划分为若干更小子序列，最后将所有子序列连接成有序序列 以 $r$ 为基数的最低位优先基数排序为例，其实现过程为： 设置 $r$ 个辅助队列 $Q_0,Q_1,…,Q_{r-1}$ 对 $i=0,1,…,d-1$，依次进行分配和收集 分配：将 $Q_0,Q_1,…,Q_{r-1}$ 设为空队列，依次考察表中每个结点 $a_j$，若 $a_j$ 的关键字 $k_j^i=k$，则将 $a_j$ 放入队列 $Q_k$ 中 收集：将 $Q_0,Q_1,…,Q_{r-1}$ 中的结点依次首尾连接，得到新的结点序列，从而组成新的线性表 【实例】以 $\\{278,109,063,930,589,184,505,269,8,83\\}$ 为例 每个关键字均为 $1000$ 以下的正整数，基数 $r=10$，每个关键字由 $K^1K^2K^3$ 构成，分别代表百位、十位、个位，共需进行三趟分配、收集 第一趟：用最低子关键字 $K^3$ 进行，将所有最低子关键字相等的记录分配到同一队列，然后进行收集 第二趟：用次低子关键字 $K^2$ 进行，将所有次低子关键字相等的记录分配到同一队列，然后进行收集 第三趟：用最高子关键字 $K^1$ 进行，将所有最高子关键字相等的记录分配到同一队列，然后进行收集 至此，排序结束 【性能分析】基数排序适用于顺序存储、链式存储结构，由于队列先进先出的特性，分配与收集过程中并不会改变相同关键字的相对次序，因此其是一种稳定排序算法 对于链式存储结构来说，每一趟需要 $r$ 个队列，之后的排序会重复利用这些队列，因此其空间复杂度为： O(r)时间复杂度与序列初始状态无关，由于每一趟分配的时间复杂度为 $O(n)$，每一趟收集的时间复杂度为 $O(r)$，总共需要 $d$ 趟分配与收集，因此，总时间复杂度为： O(d(n+r))【实现】123456789101112131415161718192021222324252627#define RADIX 10 //基数为10,需要十个桶#define KEYNUM 10 //关键字位数，这里为整型位数int getDigitInPos(int num, int pos) &#123; //找到数字num的从第到高的第pos位数据 int temp = 1; for (int i = 0; i &lt; pos - 1; i++) temp *= 10; return (num / temp) % 10;&#125;void radixSort (int a[], int n) &#123; int *b[RADIX]; //分别为0~9基数的存放空间 for (int i = 0; i &lt; 10; i++) &#123; b[i] = (int *)malloc(sizeof(int)*(dataNum + 1)); b[i][0] = 0; //index为0处记录这组数据的个数 &#125; for (int pos = 1; pos &lt;= KEYNUM; pos++) &#123;//从个位开始入桶并出桶 for (int i = 0; i &lt; n; i++) &#123; //分配 int num = getDigitInPos(a[i], pos); int index = ++b[num][0]; b[num][index] = a[i]; &#125; for (int i = 0, j = 0; i &lt; RADIX; i++)&#123; //收集 for (int k = 1; k &lt;= radixArrays[i][0]; k++) a[j++] = b[i][k]; b[i][0] = 0;//出桶完毕，复位 &#125; &#125; &#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"桶排序","slug":"basic/02.sort/12.桶排序","date":"2018-04-17T07:04:43.000Z","updated":"2021-09-25T14:12:13.803Z","comments":true,"path":"oi-acm/basic/sort/9fe164cc.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/9fe164cc.html","excerpt":"【基本思想】桶排序，是非比较排序中最简单一种排序方法，适用于待排序数据值域较大但分布比较均匀的情况 其基本思想是：假设待排序记录的值都在 $0$ 到 $m-1$ 之间，那么就设置 $m$ 个桶，将值为 $i$ 的记录分配到第 $i$ 个桶中，然后再将各个桶中的数据依次收集起来","text":"【基本思想】桶排序，是非比较排序中最简单一种排序方法，适用于待排序数据值域较大但分布比较均匀的情况 其基本思想是：假设待排序记录的值都在 $0$ 到 $m-1$ 之间，那么就设置 $m$ 个桶，将值为 $i$ 的记录分配到第 $i$ 个桶中，然后再将各个桶中的数据依次收集起来 【实例】以数列 $\\{3,5,3,1,5,6,3,8\\}$ 为例，使用桶排序进行排序的示意图如下 【性能分析】桶排序适用于顺序存储、链式存储结构，由于相同元素存入同一个桶，因此其是一种不稳定排序算法 对于 $n$ 个数据，其数据范围为 $(0,m-1)$，那么显然需要 $m$ 个存储空间来作为桶，因此其空间复杂度与数据范围有关，即： O(m)在最好的情况下，每个桶中只有一个数据，那么最好时间复杂度为： O(n)假设 $C$ 为桶内排序所花费的时间，那么平均时间复杂度为： O(n+C)【实现】12345678910111213int bucket[m]; //m-1为数据的最大值void bucketSort(int a[], int n) &#123; for (int i = 0; i &lt; n; i++) //将数组a存入桶中 bucket[a[i]]++; int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; if (bucket[i] != 0) &#123; //桶不为空时 a[cnt++] = i; //收集数据 bucket[i]--; //桶中数据个数-1 &#125; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"逆序对问题","slug":"basic/02.sort/11.逆序对问题","date":"2018-03-29T14:04:43.000Z","updated":"2021-09-25T13:57:11.311Z","comments":true,"path":"oi-acm/basic/sort/d9d67e32.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/d9d67e32.html","excerpt":"【问题】设 $A$ 为一个有 $n$ 个数字的有序集，其中所有数字各不相同，如果存在整数 $i,j$，使得 $1\\leq i &lt; j \\leq n$ 且 $A[i]&gt;A[j]$，则 $\\{A[i],A[j]\\}$ 这个有序对称为 $A$ 的一个逆序对 例如：集合 $\\{3,1,4,5,2\\}$ 的逆序对有 $\\{3,1\\}$、$\\{3,2\\}$、$\\{4,2\\}$、$\\{5,2\\}$ 共 $4$ 个","text":"【问题】设 $A$ 为一个有 $n$ 个数字的有序集，其中所有数字各不相同，如果存在整数 $i,j$，使得 $1\\leq i &lt; j \\leq n$ 且 $A[i]&gt;A[j]$，则 $\\{A[i],A[j]\\}$ 这个有序对称为 $A$ 的一个逆序对 例如：集合 $\\{3,1,4,5,2\\}$ 的逆序对有 $\\{3,1\\}$、$\\{3,2\\}$、$\\{4,2\\}$、$\\{5,2\\}$ 共 $4$ 个 逆序对问题，即：对给定的数组序列，求其逆序对的数量 【分析】从定义上分析，逆序对就是数列中任意两个数满足大的在前小的在后的组合，如果将这些逆序对都调整为顺序，那么整个数列就变的有序 因而容易想到冒泡排序的机制正好是利用消除逆序来实现的，也就是说，交换相邻两个逆序数，最终实现整个序列有序，那么交换的次数即为逆序对的数量 由于冒泡排序本身效率不高，时间复杂度为 $O(n^2)$，对于 $n$ 较大的情况下不适用，一般选用归并排序来解决逆序对问题 【实现】123456789101112131415161718192021/*只需修改原有归并程序，当右边序列元素为较小值时，就统计其产生的逆序对数量，即可完成逆序对统计*/void mergeArray (int a[], int left, int mid, int right, int temp[], int ans) &#123; int i = left, j = mid + 1; int cnt = 0; //临时数组temp的指针 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; //比较左右两个子序列 if (a[i] &lt;= a[j]) //取a[i]与a[j]中的小者放入temp[k] temp[cnt++] = a[i++]; else &#123; temp[cnt++] = a[j++]; ans += mid - i + 1; //统计产生逆序对的数量 &#125; &#125; while (i &lt;= mid) //第一个子序列未处理完 temp[k++] = a[i++]; while (j &lt;= right) //第二个子序列未处理完 temp[k++] = a[j++]; for(int i = 0; i &lt; k; i++) //将数组temp中的值返回数组a a[left+i] = temp[i];&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"归并排序","slug":"basic/02.sort/10.归并排序","date":"2018-03-29T07:04:43.000Z","updated":"2021-09-25T13:56:51.401Z","comments":true,"path":"oi-acm/basic/sort/1599bffe.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/1599bffe.html","excerpt":"【基本思想】归并排序是分治策略的一个非常典型的应用，其基本思想是将 $n$ 个待排序的记录看成是 $n$ 个长度为 $1$ 的有序序列，然后两两进行归并，第一轮得到 $\\frac{n}{2}$ 个长度为 $2$ 的有序序列，第二轮得到 $\\frac{n}{4}$ 个长度为 $4$ 的有序序列，以此类推，直到得到一个长度为 $n$ 的有序序列 归并排序的核心是归并操作，即将两个已经排序的序列合并成一个序列的操作，其步骤如下：","text":"【基本思想】归并排序是分治策略的一个非常典型的应用，其基本思想是将 $n$ 个待排序的记录看成是 $n$ 个长度为 $1$ 的有序序列，然后两两进行归并，第一轮得到 $\\frac{n}{2}$ 个长度为 $2$ 的有序序列，第二轮得到 $\\frac{n}{4}$ 个长度为 $4$ 的有序序列，以此类推，直到得到一个长度为 $n$ 的有序序列 归并排序的核心是归并操作，即将两个已经排序的序列合并成一个序列的操作，其步骤如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤 3 直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 其宏观排序过程如下图 【实例】以数列 $\\{8,5,3,1,8,7,2,4\\}$ 为例，演示归并排序过程： 【性能分析】归并排序适用于顺序存储方式，由于归并过程并不会改变相同关键字的相对次序，因此其是一种稳定排序算法 在归并过程中，需要 $n$ 个辅助空间，因此其空间复杂度为： O(n)每趟归并的时间复杂度为 $O(n)$，需要进行 $\\left \\lceil log_2n\\rceil \\right.$ 趟归并，总时间复杂度为： O(nlog_2n)【实现】归并操作归并操作是核心操作，通过对归并操作的递归调用，即可完成归并排序 123456789101112131415161718void mergeArray (int a[], int left, int mid, int right, int temp[]) &#123; int i = left, j = mid + 1; int cnt = 0; //临时数组temp的指针 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; //比较左右两个子序列 if (a[i] &lt;= a[j]) //取a[i]与a[j]中的小者放入temp[k] temp[cnt++] = a[i++]; else temp[cnt++] = a[j++]; &#125; while (i &lt;= mid) //第一个子序列未处理完 temp[k++] = a[i++]; while (j &lt;= right) //第二个子序列未处理完 temp[k++] = a[j++]; for(int i = 0; i &lt; k; i++) //将数组temp中的值返回数组a a[left+i] = temp[i];&#125; 递归调用12345678void mergeSort (int a[], int left, int right, int temp[]) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort (a, left, mid, temp); //左边有序 mergeSort (a, mid+1, right, temp); //右边有序 mergeArray (a, left, mid, right, temp); //将两个有序数列合并 &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"快速排序","slug":"basic/02.sort/09.快速排序","date":"2018-03-21T07:04:43.000Z","updated":"2021-09-25T13:47:29.905Z","comments":true,"path":"oi-acm/basic/sort/ff8068c0.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/ff8068c0.html","excerpt":"【基本思想】快速排序对冒泡排序的一种改进，在冒泡排序中，记录的比较与移动是在相邻位置进行的，记录每次交换只能后移一个位置，因而总的比较次数与移动次数较多；而在快速排序中，记录的比较与移动是从两端向中间进行的，关键码较大的记录一次就能从前面移动到后面，关键码较小的记录一次就能从后面移动到前面，由于记录移动的距离较远，从而减少了总的比较次数与移动次数 快速排序利用了分治策略，其基本思想是：首先选一个轴值，作为比较的基准，将待排序记录划分为独立的两部分，左侧记录均小于等于轴值，右侧记录均大于等于轴值，然后分别对这两部分重复上述过程，直至序列有序","text":"【基本思想】快速排序对冒泡排序的一种改进，在冒泡排序中，记录的比较与移动是在相邻位置进行的，记录每次交换只能后移一个位置，因而总的比较次数与移动次数较多；而在快速排序中，记录的比较与移动是从两端向中间进行的，关键码较大的记录一次就能从前面移动到后面，关键码较小的记录一次就能从后面移动到前面，由于记录移动的距离较远，从而减少了总的比较次数与移动次数 快速排序利用了分治策略，其基本思想是：首先选一个轴值，作为比较的基准，将待排序记录划分为独立的两部分，左侧记录均小于等于轴值，右侧记录均大于等于轴值，然后分别对这两部分重复上述过程，直至序列有序 其宏观排序过程如下图 【算法步骤】显然，快速排序是一个递归的过程，其算法步骤为： 1）在待排序的 $n$ 个记录中任选一个记录作为轴值（通常选第 $1$个） 2）进行分区，设置两个指针 $i$、$j$，初值分别为 $left$、$right$ 指针 $j$ 以 $right$ 为起点，从后向前搜索第一个小于轴值的元素，将其交换到指针 $i$ 所指的元素 指针 $i$ 从 $left$ 为起点，从前向后搜索第一个大于轴值的元素，将其交换到指针 $j$ 所指的元素 当指针 $i=j$ 时，指针 $i$ 之前的元素均小于等于轴值，指针 $i$ 之后的元素均大于等于轴值 3）对左右两个分区递归的进行上述步骤，直到子序列大小为 $1$ 【实例】以数列 $\\{49,38,65,97,76,13,27,49\\}$ 为例，演示快速排序过程： 初始时，选取轴值为 $49$，第一次分区过程如下： 之后的每一趟，对左右分区递归的选取轴值，进行排序： 可以看出，快速排序的阶段性排序结果的特点是：第 $i$ 趟完成时，会有 $i$ 个以上的数出现在它最终将要出现的位置，即其左边的数都比他小，右边的数都比他大 【性能分析】快速排序仅适用于顺序存储结构，在划分算法中，若右端区间有两个关键字相同，且均小于轴值，则在交换到左区间后，它们的相对位置会发生变化，因此其是一种不稳定排序算法 由于快速排序是递归进行的，其需要借助一个递归工作栈来保存每层递归调用的信息，其容量与递归调用最大深度一致，最好情况时空间复杂度为 $O(log_2n)$，最坏情况时要进行 $n-1$ 次递归，空间复杂度为 $O(n)$，平均情况下空间复杂度为 $O(log_2n)$ 快速排序的时间复杂度与划分是否对称有关，最坏情况发生在两区域分别包含 $n-1$ 个元素和 $0$ 个元素时，此时这种最大程度的不对称若发生在每层递归上，即对应初始排序表基本有序或基本逆序时，时间复杂度为 $O(n^2)$ 为避免快速排序出现最坏的情况，一般是从序列的头尾和中间各选一个元素，然后再取这三个元素中的中值作为轴值，以避免最坏情况的发生 在理想的状态下，可能做到最平衡的划分，得到的两个子问题的大小都不可能大于 $\\frac{n}{2}$，在这种情况下，快速排序的最好时间复杂度与平均时间复杂度均为 $O(nlog_2n)$ 快速排序是所有内部排序算法中平均性能最优的排序算法 【实现】快速排序的关键在于划分操作，其性能也取决于划分操作的好坏，对于最基础的快速排序，每次总选择当前表中第一个元素作为轴值来对表进行划分，将表中比轴值小的元素向左移动，比轴值大的元素向右移动 12345678910111213int partitoin (int a[], int left, int right) &#123; int pivotKey = a[left]; //轴值 int i = left, j = right; //左右指针 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= pivotKey) //右侧扫描 j--; swap(a[i], a[j]); //比轴值小的交换到低端 while (i &lt; j &amp;&amp; a[i] &lt;= pivotKey) //左侧扫描 i++; swap(a[i],a[j]); //比轴值大的交换到高端 &#125; return i; //返回轴值所在位置&#125; 在每次划分操作结束后，得到轴值所在位置，之后对表的左右两端递归的进行快速排序即可 初始时，调用 quickSort(a, 1, n) 即可 1234567void quickSort (int a[], int left, int right) &#123; if (left &lt; right) &#123; int pivotKey = partitoin (a, left, right); //算出轴值并根据轴值进行分区 quickSort(a, left, pivotKey - 1); //左子表递归 quickSort(a, pivotKey + 1, right); //右子表递归 &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"鸡尾酒排序","slug":"basic/02.sort/08.鸡尾酒排序","date":"2018-03-18T06:53:01.000Z","updated":"2021-09-25T13:39:00.251Z","comments":true,"path":"oi-acm/basic/sort/877bdcb6.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/877bdcb6.html","excerpt":"【基本思想】鸡尾酒排序也称双向冒泡排序、定向冒泡排序，是原始冒泡排序的改进 双向冒泡排序与冒泡排序的不同在于其从低到高比较，然后再从高到低比较，如此循环往复，直到序列有序，而冒泡排序仅是从低到高的去比较序列中的每个元素","text":"【基本思想】鸡尾酒排序也称双向冒泡排序、定向冒泡排序，是原始冒泡排序的改进 双向冒泡排序与冒泡排序的不同在于其从低到高比较，然后再从高到低比较，如此循环往复，直到序列有序，而冒泡排序仅是从低到高的去比较序列中的每个元素 其实现借助两个指针来完成，一个作为头指针，负责从前向后扫描，一个作为尾指针，负责从后向前扫描，外层循环依靠指针控制数组左右边界，内层循环分别控制前后边界的排序 鸡尾酒排序的宏观排序过程如下图 【实例】以数列 $\\{6,5,3,1,8,7,2,4\\}$ 为例，演示双向冒泡排序过程： 可以发现，在第 $5$ 趟时，未发生交换，此时数列已经有序 与原始冒泡排序相比，有了一定的优化 【性能分析】鸡尾酒排序适用于顺序存储、链式存储结构，当 $i&gt;j$，且 $a[i]=a[j]$ 时，不会发生交换，因此其是一种稳定排序算法 鸡尾酒排序仅需常数个辅助空间，作为待插入记录的暂存单元，因此其空间复杂度为： O(1)鸡尾酒排序虽相较冒泡排序相比有了优化，但在数据量较少时优势并不明显，在较大数据量时相较原始冒泡排序有较大优势，其时间复杂度与冒泡排序相同，即： O(n^2)【实现】朴素实现123456789101112131415void cocktailSort (int a[], int n) &#123; int left = 1, right = n; while (left &lt; right) &#123; /*前半轮,将最大元素放到后面*/ for (int i = left; i &lt; right; i++) if(a[i] &gt; a[i+1]) swap(a[i], a[i+1]); right--; /*后半轮,将最小元素放到前面*/ for (int i = right; i &gt; left; i--) if(a[i-1] &gt; a[i]) swap(a[i], a[i-1]); left++; &#125;&#125; 判断优化123456789101112131415161718192021222324252627void cocktailSort (int a[], int n) &#123; int left = 1, right = n; while (left &lt; right) &#123; bool flag = false; //判断是否有交换 /*前半轮,将最大元素放到后面*/ for (int i = left; i &lt; right; i++) &#123; if(a[i] &gt; a[i+1]) &#123; swap(a[i], a[i+1]); flag = true; //有交换说明仍需排序 &#125; &#125; right--; if (!flag) //若本趟无交换，说明表已经有序，终止 break; /*后半轮,将最小元素放到前面*/ for (int i = right; i &gt; left; i--) &#123; if(a[i-1] &gt; a[i]) &#123; swap(a[i], a[i-1]); flag = true; //有交换说明仍需排序 &#125; &#125; left++; if (!flag) //若本趟无交换，说明表已经有序，终止 break; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"原始冒泡排序","slug":"basic/02.sort/07.原始冒泡排序","date":"2018-03-18T02:13:54.000Z","updated":"2021-09-25T13:34:27.754Z","comments":true,"path":"oi-acm/basic/sort/39ad9c4c.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/39ad9c4c.html","excerpt":"【基本思想】原始冒泡排序是交换排序中最简单的排序方法，其基本思想是：两两比较相邻记录的关键码，若反序则交换，直到没有反序为止 原始冒泡排序的具体的排序过程如下：","text":"【基本思想】原始冒泡排序是交换排序中最简单的排序方法，其基本思想是：两两比较相邻记录的关键码，若反序则交换，直到没有反序为止 原始冒泡排序的具体的排序过程如下： 1）将整个待排序的序列分为有序区和无序区，初始时有序区为空，无序区包含所有待排序记录 2）对无序区从前向后依次将相邻记录关键码进行比较，若反序则交换，从而使得关键码小的记录前移，关键码大的记录后移 3）重复执行步骤 2，直到无序区没有反序记录 需要注意的是，冒泡排序中产生的有序子序列一定是全局有序的，即有序子序列中的所有元素的关键字一定是小于或大于子序列中所有元素的关键字，每趟排序都会将一个元素放到其最终的位置上 原始冒泡排序的宏观排序过程如下图 【实例】以数列 $\\{6,5,3,1,8,7,2,4\\}$ 为例，演示原始冒泡排序过程： 由此，可列出每一趟的结果，可以发现，在第 $6$ 趟时，未发生交换，此时数列已经有序 因此，在冒泡排序中，当某一趟比较时未发生交换，说明表已经有序 【性能分析】冒泡排序适用于顺序存储、链式存储结构，由于当 $i&gt;j$，且 $a[i]=a[j]$ 时，不会发生交换，因此其是一种稳定排序算法 冒泡排序仅需常数个辅助空间，作为待插入记录的暂存单元，因此空间复杂度为： O(1)在最好情况下，待排序序列为正序，要进行 $n-1$ 趟排序，每趟仅比较 $1$ 次，共比较 $n-1$ 次，移动 $0$ 次，因此，最优时间复杂度为： O(n)在最坏情况下，待排序序列为逆序，要进行 $n-1$ 趟排序，第 $i$ 趟比较 $n-i$ 次，每次移动 $3$ 次来进行交换，那么总比较次数为 $\\frac{n(n+1)}{2}$，总移动次数为 $\\frac{3n(n-1)}{2}$，因此，最坏时间复杂度为： O(n^2)在平均情况下，待排序序列中各种可能排列的概率情况相同，在插入第 $i$ 个记录时平均要比较有序区中全部记录的一半，那么总的比较次数与移动次数均约为 $\\frac{n^2}{4}$，因此，平均时间复杂度为： O(n^2)【实现】朴素实现123456void bubbleSort (int a[], int n) &#123; for (int i = 1; i &lt;= n - 1; i++) //比较n-1趟 for (int j = 1; j &lt;= n - i; j++) //每趟交换n-i次 if(a[j] &gt; a[j+1]) swap(a[j], a[j+1]);&#125; 判断优化12345678910111213void bubbleSort (int a[], int n) &#123; for (int i = 1; i &lt;= n - 1; i++) &#123; //比较n-1趟 bool flag = false; //判断是否有交换 for (int j = 1; j &lt;= n - i; j++) &#123; //每趟交换n-i次 if (a[j] &gt; a[j+1]) &#123; swap(a[j], a[j+1]); flag = true; //有交换说明仍需排序 &#125; &#125; if (!flag) //若本趟无交换，说明表已经有序，终止 break; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"堆排序","slug":"basic/02.sort/06.堆排序","date":"2018-03-15T01:43:31.000Z","updated":"2021-09-25T13:34:51.634Z","comments":true,"path":"oi-acm/basic/sort/c2a5fdc5.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/c2a5fdc5.html","excerpt":"【基本思想】堆排序利用了堆这一数据结构来进行排序，其基本思想是：将待排序的记录构成堆，然后不断将堆顶元素移走，并将剩余的记录调整成堆，直到堆空 对于大根堆来说，其堆排序结果为降序序列，对于小根堆来说，其堆排序结果为升序序列","text":"【基本思想】堆排序利用了堆这一数据结构来进行排序，其基本思想是：将待排序的记录构成堆，然后不断将堆顶元素移走，并将剩余的记录调整成堆，直到堆空 对于大根堆来说，其堆排序结果为降序序列，对于小根堆来说，其堆排序结果为升序序列 堆排序主要需要解决两个操作： 1）根据初始数组去构造初始堆，构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大/小 2）每次输出堆顶元素，并将堆顶元素和堆尾元素交换，把剩下元素重新调整为堆 堆排序的宏观排序过程如下图 【堆的建立】无论是大顶堆还是小顶堆，在建立堆时，首先根据序列取构建一个完全二叉树，之后从最后一个节点起，不断交换元素，以保证所有的父结点都比它的孩子结点数值大/小 以序列 $\\{1, 3, 4, 5, 2, 6, 9, 7,8,0\\}$ 建立大顶堆过程为例： 【堆的调整】在建立堆后，进行堆排序，每次将堆顶元素输出，并将堆顶元素与堆尾元素互换，之后删除堆尾元素，此时不满足堆的性质，需要进行调整 以序列 $\\{1, 3, 4, 5, 2, 6, 9, 7,8,0\\}$ 利用大顶堆进行堆排序的过程为例： 【性能分析】堆排序适用于顺序存储、链式存储结构，在进行堆的调整时，可能会将后面的相同关键字的元素调整到前面，因此其是一种不稳定排序算法 堆排序仅需常数个辅助空间，作为待插入记录的暂存单元，因此其空间复杂度为： O(1)对于堆排序来说，其建堆的时间复杂度为 $O(n)$，之后有 $n-1$ 次向下调整操作，每次调整的时间复杂度为 $O(h)$，因此时间复杂度为： O(nlog_2n)【实现】以大根堆为例 1）堆的建立 对于 $n$ 个结点的完全二叉树，最后一个结点是第 $\\left \\lfloor \\frac{n}{2}\\rfloor \\right.$ 个结点的孩子 因此，建立堆时，仅需要调整第 $\\left \\lfloor \\frac{n}{2}\\rfloor \\right.$ 个结点为根的子树，之后依次向前对 $\\left \\lfloor \\frac{n}{2}\\rfloor \\right.-1$ ~ $1$ 为根的结点进行调整 1234void buildMaxHeap (int a[], int n) &#123; for (int i = n/2; i &gt; 0; i--) //调整a[2/n]到a[1] adjustHeap (a, i, n);&#125; 2）堆调整 1234567891011121314void adjustHeap (int a[], int k, int n) &#123; //调整以k为根的子树 int temp = a[k]; //暂存a[k] for (int i = 2*k; i &lt;= n; i = i*2) &#123; if (i &lt; n &amp;&amp; a[i] &lt; a[i+1]) //取关键字较大子结点的下标 i++; if(temp &gt;= a[i]) break; else &#123; a[k] = a[i]; //将a[i]调整到双亲结点上 k = i; //修改k值，以继续向下筛选 &#125; &#125; a[k] = temp; //被筛选结点放入最终位置&#125; 3）堆排序 1234567void heapSort (int a[], int n) &#123; buildMaxHeap(a, n); for (int i=n; i&gt;1; i--) &#123; swap (a[i], a[1]); //输出堆顶元素，并与堆底元素互换 adjustHeap(a, 1, i-1); //调整剩余i-1个元素 &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"二分查找","slug":"search/02.binary-search/01.二分查找","date":"2018-03-13T08:48:59.000Z","updated":"2021-09-13T15:00:39.000Z","comments":true,"path":"oi-acm/search/binary-search/e8eb0481.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/search/binary-search/e8eb0481.html","excerpt":"【概述】二分查找（Binary Search），又称折半查找，其仅适用于有序的顺序表或数组，不适用于链表 其算法的基本思想是：将给定关键字 key 与表中中间位置的元素对应的关键字进行比较，中间结点由此将查找表分为两个子表，若相等，则查找成功，若不相等，根据关键字 key 与该中间结点关键字的比较结果来确定下一步查找哪一个子表，这样递归进行，直到查找成功或查找结束发现表中没有这样的结点","text":"【概述】二分查找（Binary Search），又称折半查找，其仅适用于有序的顺序表或数组，不适用于链表 其算法的基本思想是：将给定关键字 key 与表中中间位置的元素对应的关键字进行比较，中间结点由此将查找表分为两个子表，若相等，则查找成功，若不相等，根据关键字 key 与该中间结点关键字的比较结果来确定下一步查找哪一个子表，这样递归进行，直到查找成功或查找结束发现表中没有这样的结点 【算法分析】 如上图所示，已知 $11$ 个元素的有序表 $\\{5,13,19,21,37,56,64,75,80,88,92\\}$，要查找值为 $21$ 的元素 用指针 low 指向表的下界，high 指向表的上界，mid 指向表的中间位置，有： mid=\\lfloor \\frac{low+high}{2} \\rfloor在第一次查找时，将中间位置元素 $56$ 与 key 值 $21$ 比较，由于 $21&lt;56$，说明若待查找元素存在，则必定在范围 $[low,mid-1]$ 内，于是： 指针 high 指向位置 $mid-1$，对应元素 $37$ 指针 low 指向不变，对应元素 $5$ 重新计算指针 mid，有 $mid=(1+5)/2=3$，对应元素 $19$ 在第二次查找时，将中间位置元素 $19$ 与 key 值 $21$ 比较，由于 $21&gt;19$，说明若待查找元素存在，则必定在范围 $[mid+1,high]$ 内，于是： 指针 low 指向位置 $mid+1$，对应元素 $21$ 指针 high 指向不变，对应元素 $37$ 重新计算指针 mid，有 $mid=(4+5)/2=4$，对应元素 $21$ 在第二次查找时，即可得出查找元素 $21$ 在表中存在 【二分查找判定树】二分查找的查找过程可用下图所示的二叉树来表示，其被称为二分查找判定树 二分查找判定树是一棵平衡二叉树，其中的每一个圆形结点代表一个记录，结点中的值为该记录的关键字值，被称为成功结点；每一个方形结点为树的叶结点，代表查找不成功的情况，被称为失败结点 同时，每个结点值均大于其左孩子结点值，均小于其右孩子结点值 若有序序列有 $n$ 个元素，那么对应的二分查找判定树有 $n$ 个成功结点和 $n+1$ 个失败叶结点 【平均查找长度】从判定树可以看出，查找成功时的查找长度，为从根结点到目的结点的路径上的结点数，查找不成功时的查找长度，为从根结点到对应失败结点的父结点的路径上的结点数 故而，用二分查找找到给定值的比较次数，最多不会超过树的高度 在查找元素等概率的情况下，二分查找查找成功的平均查找长度为： \\begin{align} ASL_{成功} &= \\sum_{i=1}^n p_il_i \\notag \\\\ &= \\frac{1}{n}(1*1+2*2+...+h*2^{h-1}) \\notag \\\\ &= \\frac{n+1}{n} \\log_2(n+1)-1 \\notag \\\\ &\\approx \\log_2(n+1)-1 \\end{align}其中，$l_i$ 为第 $i$ 层的成功结点数，$h$ 为树的高度，且元素个数为 $n$ 时，树高 $h=\\lceil \\log_2(n+1) \\rceil$ 易得二分查找的时间复杂度为：$O(\\log_2n)$ 在如上图所示的二分查找判定树中，在等概率情况下，有： \\left\\{ \\begin{array}{rl} ASL_{成功} &=& \\frac{1}{11}(1*1+2*2+3*4+4*4)=3 \\\\ ASL_{失败} &=& \\frac{1}{12}(3*4+4*8)=\\frac{11}{3} \\end{array} \\right.【实现】查找元素123456789101112131415int binarySearch (int key,int a[], int n) &#123; //在有序序列a中查找元素key的位置 int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; //设置中值 if (a[mid] == key) //查找到元素key return mid; else if (a[mid] &lt; key) //key在右边部分 left = mid + 1; //调整集合下界 else //key在左边部分 right = mid - 1; //调整集合上界 &#125; return -1; //若未找到key，返回-1&#125; 查找连续函数除在有序表中查找指定关键字外，二分查找还可以对连续单调函数进行查找 1234567891011121314151617#define EXP 1.0e-6bool cal(int x) &#123; //连续函数 //根据要求进行计算&#125;int binarySearch (double low, double high)&#123; //low为区间下界，high为区间上界 double left = low; //设置当前查找区间上界的初值 double right = high; //设置当前查找区间下界的初值 while (right - left &gt; EXP) &#123; //精度小于等于1E-6时停止 double mid = (right + left) / 2; //设置中值 if(cal(mid) &lt; x) //函数结果小于待查找的值 left = mid; //说明在右边部分，调整集合下界 else //函数结果大于待查找的值 right = mid; //说明在左边部分，调整集合上界 &#125; return mid;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"查找&搜索","slug":"oi-acm/search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/"},{"name":"二分查找","slug":"oi-acm/search/binary-search","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/search/binary-search/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"查找&搜索","slug":"search","permalink":"https://alex-mcavoy.github.io/tags/search/"},{"name":"二分查找","slug":"binary-search","permalink":"https://alex-mcavoy.github.io/tags/binary-search/"}],"author":"Alex_McAvoy"},{"title":"简单选择排序","slug":"basic/02.sort/05.简单选择排序","date":"2018-03-12T13:38:43.000Z","updated":"2021-09-25T13:15:41.414Z","comments":true,"path":"oi-acm/basic/sort/7c936fca.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/7c936fca.html","excerpt":"【基本思想】简单选择排序是选择类排序中简单的一种，其基本思想是：第 $i$ 趟排序在待排序列 $a[i]$~$a[n]$ 中选取关键码最小的记录，这样每一趟确定第 $i$ 个元素，$n-1$ 趟即可排序完成 简单选择排序的具体的排序过程如下：","text":"【基本思想】简单选择排序是选择类排序中简单的一种，其基本思想是：第 $i$ 趟排序在待排序列 $a[i]$~$a[n]$ 中选取关键码最小的记录，这样每一趟确定第 $i$ 个元素，$n-1$ 趟即可排序完成 简单选择排序的具体的排序过程如下： 1）将整个记录序列划分为有序区和无序区，初始时有序区为空，无序区含有待排序的所有记录 2）在第 $i$ 趟中，在无序区选择关键码最小的记录，将其与有序区中的第 $i$ 个元素交换，使得有序区扩展一个记录，同时无序区减少了一个记录 3）不断重复步骤 2），直到无序区剩下一个记录为止 简单选择排序的宏观排序过程如下 【实例】以数列 $\\{7,4,5,9,8,2,1\\}$ 为例，演示简单选择排序过程： 【性能分析】简单选择排序适用于顺序存储、链式存储方式，在第 $i$ 趟找到最小元素后，会与第 $i$ 个元素交换，这可能会导致第 $i$ 个元素与其含有相同关键字元素的相对位置发生改变，因此其是一种不稳定排序算法 简单选择排序在排序过程中，仅需常数个辅助空间，作为待插入记录的暂存单元，因此其空间复杂度为 O(1)由于每个元素移动次数不会超过 $3(n-1)$ 次，因此，在最好情况下，仅需要移动 $0$ 次，但元素间比较的次数与序列初始状态无关，始终为 $\\frac{n(n-1)}{2}$ 次，因此总时间复杂度始终为 O(n^2)【实现】12345678910void selectSort (int a[], int n) &#123; for (int i = 1; i &lt;= n - 1; i++) &#123; //n-1趟选择 int index = i; //当前有序区索引位置 for (int j = i + 1; j &lt;= n; j++) //在无序区选取最小的记录 if(a[index] &gt; a[j]) index = j; if(index != i) swap(a[i],a[index]); &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"希尔排序","slug":"basic/02.sort/04.希尔排序","date":"2018-02-14T14:17:42.000Z","updated":"2021-09-25T12:45:53.232Z","comments":true,"path":"oi-acm/basic/sort/1ac49179.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/1ac49179.html","excerpt":"【基本思想】对于直接插入排序，当待排序列为正序时，其时间复杂度可提高到 $O(n)$，故而其更适用于基本有序或数据量不大的排序表，针对这两点，对直接插入排序进行改进，即希尔排序 所谓基本有序，就是小的关键字基本在前，大的关键字基本在后，但基本有序的条件十分苛刻，难以达到，为了达到基本有序，采用跳跃分割策略，即将相距某个增量的记录组成一个子序列，这样保证子序列内分别进行直接插入排序得到的结果是基本有序而非局部有序","text":"【基本思想】对于直接插入排序，当待排序列为正序时，其时间复杂度可提高到 $O(n)$，故而其更适用于基本有序或数据量不大的排序表，针对这两点，对直接插入排序进行改进，即希尔排序 所谓基本有序，就是小的关键字基本在前，大的关键字基本在后，但基本有序的条件十分苛刻，难以达到，为了达到基本有序，采用跳跃分割策略，即将相距某个增量的记录组成一个子序列，这样保证子序列内分别进行直接插入排序得到的结果是基本有序而非局部有序 希尔排序的基本思想是：将整个待排序记录序列分割成若干个子序列，在子序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序 简单来说，希尔排序就是在直接插入排序的基础上，将直接插入排序中的 $1$ 全部改为增量 $d$ 【算法步骤】希尔排序的算法步骤如下： 1）从第一个元素开始，选择一个增量序列 $\\{d_1,d_2,..,d_k\\}$，该序列从 $d_1&lt;n$ 开始，严格递减，直到 $d_k=1$ 2）按增量序列个数 $k$，对序列进行 $k$ 趟直接插入排序 3）每趟排序，根据对应的增量 $d_i$，将待排序列分割成若干长度为 $m$ 的子序列，分别对各子表进行直接插入排序，仅增量因子为 $1$ 时，整个序列作为一个表来处理，表长度即为整个序列的长度 目前为止，尚未有一个最好的增量序列，一般取： d_1= \\left \\lfloor \\frac{n}{2} \\right \\rfloor, d_{i+1}=\\left \\lfloor \\frac{d_i}{2} \\right \\rfloor直到最后一个增量 $d_k=1$ 希尔排序的宏观过程如下图所示 【实例】下面以数列 $\\{80,30,60,40,20,10,50,70\\}$ 为例，演示希尔排序过程 数列中有 $8$ 个元素，即 $n=8$，那么有： 第一趟：取 $d_1=4$，分为 $4$ 组 第二趟：取 $d_2=2$，分为 $2$ 组 第三趟：取 $d_3=1$，分为 $1$ 组，排序完成 【性能分析】希尔排序适用于顺序存储方式，由于当相同关键字记录被划分到不同子表时，可能会改变相对次序，因此希尔排序是不稳定排序算法 在希尔排序过程中，需要常数个辅助空间，作为待插入记录的暂存单元，因此其空间复杂度为 O(1)希尔排序的时间复杂度依赖于增量序列的函数，这涉及到数学上尚未解决的难题 但当 $n$ 在某特定范围时，其时间复杂度约为 $O(n^{1.3})$，最坏情况下为 $O(n^2)$ 【实现】123456789101112void shellSort (int a[], int n) &#123; for (int d = n/2; d &gt;= 1; d = d/2) &#123; //增量 for (int i = d + 1; i &lt;= n; i++) &#123; //对每一组直接插入排序 if (a[i] &lt; a[i-d]) &#123; int temp = a[i]; //暂存a[i] for (int j = i - d; i &gt; 0 &amp;&amp; temp &lt; a[j]; j = j - d) //记录后移 a[j+d] = a[j]; a[j] = temp; //复制到插入位置 &#125; &#125; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"折半插入排序","slug":"basic/02.sort/03.折半插入排序","date":"2018-02-08T07:23:49.000Z","updated":"2021-09-25T12:05:42.433Z","comments":true,"path":"oi-acm/basic/sort/1dac4b0b.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/1dac4b0b.html","excerpt":"【基本思想】在直接插入排序中，每趟插入过程都进行了两项工作： 从有序子表中查找待插入元素应被插入位置 给插入位置腾出空间，将待插入元素复制到表中插入位置","text":"【基本思想】在直接插入排序中，每趟插入过程都进行了两项工作： 从有序子表中查找待插入元素应被插入位置 给插入位置腾出空间，将待插入元素复制到表中插入位置 可以看出，上述过程总是边比较边移动元素，针对这一过程，进行改进，即将比较与移动分离，先查找出元素的待插入位置，再统一的移动待插入位置后的所有元素 由于有序区是顺序表，因此可以采用折半查找来寻找插入位置 【性能分析】折半插入排序仅适用于顺序存储方式，是在直接插入排序的基础上进行的改进，其仍是一种稳定排序算法 在排序过程中，仅需一个辅助空间，作为待插入记录的暂存单元，因此空间复杂度为： O(1)由于折半查找的过程减少了元素的比较次数，该比较次数与待排序表的状态无关，仅与 $n$ 的大小有关，故而查找的时间复杂度为 $O(nlog_2n)$，但元素的移动次数没有改变，为 $O(n^2)$，因此，折半插入排序的时间复杂度仍为： O(n^2)虽然折半插入排序与直接插入排序的时间复杂度相同，但对于数据量不大的情况，折半插入排序往往能表现出较好的性能 【实现】12345678910111213141516void insertBinarySort(int a[], int n) &#123; for (int i=2; i &lt;= n; i++) &#123; //n-1趟比较，a[2]~a[n]依次插入 int temp = a[i]; //暂存a[i] int left = 1, right = i-1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (a[mid] &gt; temp) right = mid - 1; else left = mid +1; &#125; for (int j = i - 1; j &gt;= right + 1 ;j--) //记录后移 a[j+1] = a[j]; a[right+1] = temp; //复制到插入位置 &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"直接插入排序","slug":"basic/02.sort/02.直接插入排序","date":"2018-02-07T17:59:13.000Z","updated":"2021-09-25T12:04:06.380Z","comments":true,"path":"oi-acm/basic/sort/2b06d603.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/2b06d603.html","excerpt":"【基本思想】直接插入排序是最简单、最直观的插入类排序算法，其是一种稳定的排序方法，类似于玩扑克时整理手牌的过程 其排序过程为：","text":"【基本思想】直接插入排序是最简单、最直观的插入类排序算法，其是一种稳定的排序方法，类似于玩扑克时整理手牌的过程 其排序过程为： 1）将整个待排序的记录序列划分为有序区和无序区 2）初始时，有序区为待排序记录序列中的第一个记录，无序区包括所有剩余待排序的记录 3）每次将无序区的第一个记录插入到有序区的合适位置中，从而使无序区减少一个记录，有序区增加一个记录 4）重复执行步骤 3），直到无序区中没有记录 直接插入排序的宏观过程如下图所示 【实例】以数列 $\\{12,15,9,20,6,31,24\\}$ 为例，给出直接插入排序的每一趟的排序结果： 以数列 $\\{6,5,3,1,8,7,2,4\\}$ 为例，给出直接插入排序的排序过程： 【性能分析】直接排序适用于顺序存储、链式存储方式，每次插入的元素总是从前向后先比较再移动，不会出现两个相同元素相对位置发生变化的情况，是一稳定排序算法 在排序过程中，仅需一个辅助空间，作为待插入记录的暂存单元和插入过程中的哨兵，因此空间复杂度为 $O(1)$ 在最好情况下，待排序序列为正序，每趟排序只需与最后一个记录比较一次，移动两次记录，那么总比较次数为 $n-1$，总移动次数为 $2(n-1)$，因此，最优时间复杂度为 O(n)在最坏情况下，待排序序列为逆序，第 $i$ 趟插入时，第 $i$ 个记录必须与前面的 $i-1$ 个记录的关键码与哨兵比较，并且每比较一次就要做一次记录的移动，那么总比较次数为 $\\frac{n(n+1)}{2}$，总移动次数为 $\\sum\\limits_{i=2}^n(i+1)$，因此，最坏时间复杂度为 O(n^2)在平均情况下，待排序序列中各种可能排列的概率情况相同，在插入第 $i$ 个记录时平均要比较有序区中全部记录的一半，那么总的比较次数与移动次数均约为 $\\frac{n^2}{4}$，因此，平均时间复杂度为 O(n^2)【实现】12345678910void insertSort (int a[], int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; //n-1趟比较，a[2]~a[n]依次插入 if (a[i] &lt; a[i-1]) &#123; int temp = a[i]; //设置哨兵 for (int j = i - 1; temp &lt; a[j]; j--) //寻找插入位置 a[j+1] = a[j]; //记录后移 a[j+1] = temp; //复制到插入位置 &#125; &#125;&#125;","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"C++","slug":"cpp","permalink":"https://alex-mcavoy.github.io/tags/cpp/"},{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"},{"title":"排序简介","slug":"basic/02.sort/01.排序简介","date":"2018-02-04T03:23:53.000Z","updated":"2021-09-25T11:48:54.911Z","comments":true,"path":"oi-acm/basic/sort/8fc25bab.html","link":"","permalink":"https://alex-mcavoy.github.io/oi-acm/basic/sort/8fc25bab.html","excerpt":"排序，即重新排列表中的元素，使表中元素满足按关键字有序的过程 对于待排序表中的两个元素 $R_i$ 和 $R_j$，若排序前后 $R_i$ 和 $R_j$ 的相对位置不变，则称排序算法是稳定的，否则是不稳定的，稳定与不稳定是对算法性质的描述，若待排序表中的元素唯一，则选择排序算法时稳定与否无关紧要 在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：","text":"排序，即重新排列表中的元素，使表中元素满足按关键字有序的过程 对于待排序表中的两个元素 $R_i$ 和 $R_j$，若排序前后 $R_i$ 和 $R_j$ 的相对位置不变，则称排序算法是稳定的，否则是不稳定的，稳定与不稳定是对算法性质的描述，若待排序表中的元素唯一，则选择排序算法时稳定与否无关紧要 在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类： 内部排序：排序期间，元素全部存放在内存中 外部排序：排序期间，元素无法全部同时存在于内存中，在排序过程中根据要求不断地在内外存中移动 一般所说的排序，一般都是内部排序，分为五大类： 插入排序：每次将待排序记录按关键字大小插入到已排好的子序列中 选择排序：第 $i$ 趟在后面的 $n-i+1$ 个元素中选择关键字最小的元素作为有序区的第 $i$ 个元素 交换排序：根据序列中两元素关键字的比较结果来对换两记录在序列中的位置 归并排序：利用分治策略，两两进行归并，即将两个有序表组合为一个新的有序表 基数排序：基于关键字各位的大小进行排序 对于外部排序，通常采用归并排序法 内部排序算法的性能取决于时间复杂度与空间复杂度，时间复杂度取决于比较和移动的次数，按照时间复杂度，可以大体分为两类： 非线性时间比较类排序：时间复杂度 $O(nlog_2n)$ ~ $O(n^2)$ 线性时间非比较类排序：时间复杂度 $O(n)$，典型特点是以时间换空间 常见排序算法的比较如下：","categories":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/"},{"name":"算法基础","slug":"oi-acm/basic","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/"},{"name":"排序","slug":"oi-acm/basic/sort","permalink":"https://alex-mcavoy.github.io/categories/oi-acm/basic/sort/"}],"tags":[{"name":"OI&ACM","slug":"oi-acm","permalink":"https://alex-mcavoy.github.io/tags/oi-acm/"},{"name":"算法基础","slug":"basic","permalink":"https://alex-mcavoy.github.io/tags/basic/"},{"name":"排序","slug":"sort","permalink":"https://alex-mcavoy.github.io/tags/sort/"}],"author":"Alex_McAvoy"}]}